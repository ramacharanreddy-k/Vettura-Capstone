document_id,text,image_paths,pdf_paths,tables,metadata,cleaned_text,image_descriptions
f95dbeb26c41257522a18c8f6463c248,"Question:
I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file.
Answer:
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
  C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
  It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
If your device is not listed here, please check that you are using the latest version of CS+:    CS+
Suitable Products
RH850
Question:
I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file.
Answer:
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
  C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
  It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
If your device is not listed here, please check that you are using the latest version of CS+:    CS+
Suitable Products
RH850
I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file.
I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file.
I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file.
Answer:
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
  C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
  It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
If your device is not listed here, please check that you are using the latest version of CS+:    CS+
Suitable Products
RH850
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
  C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
  It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
If your device is not listed here, please check that you are using the latest version of CS+:    CS+
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
If your device is not listed here, please check that you are using the latest version of CS+:    CS+
If your device is not listed here, please check that you are using the latest version of CS+:
CS+
CS+
Suitable Products
RH850","['data/categories/rh850_family/rh850_general/f95dbeb26c41257522a18c8f6463c248/images/8e30aea5eface8fc259d997da34bfae4.png', 'data/categories/rh850_family/rh850_general/f95dbeb26c41257522a18c8f6463c248/images/b50f0e66167a52551bbe298e915639da.png']",[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850 find dvf file for CS+', 'url': 'https://en-support.renesas.com/knowledgeBase/21153486', 'last_updated': None, 'extracted_at': '2025-03-09T00:29:11.225703'}","Question I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file. Answer The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS You can find the dvf file in the install directory in the path shown like below. CProgram Files (x86)Renesas ElectronicsCSCCDeviceRH850Devicefile It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS Device Selection dialogue If your device is not listed here, please check that you are using the latest version of CS CS Suitable Products RH850 CProgram Files (x86)Renesas ElectronicsCSCCDeviceRH850Devicefile It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS Device Selection dialogue If your device is not listed here, please check that you are using the latest version of CS CS","['The image shows a computer window with the title ""Renesas Options"" at the top left. The window is divided into two sections: ""Property"" and ""Value"". The ""Property"" section lists various options, including ""Configuration"", ""Emulator"", ""CPU"", ""CPU Family"", ""DeviceFile"", ""Reset Type"", ""Stop CPU activities when stopped"", ""PinMasking"", ""RH850"", ""Debug Interface"", ""LPD Mode Debug Speed"", ""Oscillator Frequency"", ""PLL Multiplication Ratio"", and ""UnlockID"". The ""Value"" section displays the corresponding values for each option, including ""Renesas RH850"", ""RH850 dr7701024.dvi"", ""NORMAL"", ""LPD 4-Wire"", ""4000"", ""8000"", ""0"", and ""RL78"".\n\nAt the bottom of the window, there are two buttons: ""OK"" and ""Cancel"". The background of the window is light gray, with a darker gray border around the edges. Overall, the image appears to be a screenshot of a computer program or software interface, possibly related to microcontrollers or embedded systems.', 'The image shows a screenshot of a computer program, specifically a project creation window for a microcontroller. The window is titled ""Create Project"" and has several fields and options for configuring the project.\n\n*   **Microcontroller:** \n    *   The microcontroller field is pre-populated with ""RH850"".\n    *   There is a dropdown menu below the field with a list of available microcontrollers.\n    *   The selected microcontroller is highlighted in red.\n*   **Using microcontroller:**\n    *   This section lists the selected microcontroller and its properties.\n    *   The properties include the product name, internal ROM size, code flash, data flash, internal RAM, local RAM, cluster RAM, and additional information.\n    *   The properties are displayed in a table format.\n*   **Kind of project:**\n    *   This section allows the user to select the type of project they want to create.\n    *   The options are ""Application for Multi-core(CC-RH)"" and ""Project name"".\n    *   The selected option is highlighted in red.\n*   **Project name:**\n    *   This field allows the user to enter a name for their project.\n    *   The field is empty, indicating that no project name has been entered yet.\n*   **Place:**\n    *   This field allows the user to specify the location where they want to save their project.\n    *   The field is empty, indicating that no location has been specified yet.\n*   **Make the project folder:**\n    *   This checkbox allows the user to create a new folder for their project.\n    *   The checkbox is unchecked, indicating that the user has not chosen to create a new folder.\n*   **Pass the file composition of an existing project to the new project:**\n    *   This checkbox allows the user to copy the file composition of an existing project to the new project.\n    *   The checkbox is unchecked, indicating that the user has not chosen to copy the file composition.\n*   **Project to be passed:**\n    *   This field allows the user to select an existing project to copy its file composition from.\n    *   The field is empty, indicating that no project has been selected yet.\n*   **Copy composition files in the diverted project folder to a new project folder:**\n    *   This checkbox allows the user to copy the composition files from the diverted project folder to the new project folder.\n    *   The checkbox is unchecked, indicating that the user has not chosen to copy the composition files.\n\nOverall, the image shows a project creation window for a microcontroller, with various fields and options for configuring the project. The user can select the microcontroller, project type, project name, location, and other settings before creating the project.']"
85b897523834211bbbc3b0fe00a067a4,"Question:
I am using RH850 with CS+ IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM?
Answer:
Answer:
If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below.
  Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively.
    Prepare a separate routine for transfer that will lead to the following actions and include it in your program.
Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined _INITSCT_RH function provided by CC-RH)
Call the target routines from RAM.
In the process of building your program, run the optimizing linker with the following settings for such code.
As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated.
As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run.
    Sample Code:
#include <_h_c_lib.h>
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
    extern void my_ram_function(void);
  /* import sections to get start/end addresses */
extern char _Smysection_rom_text;
extern char _Emysection_rom_text;
extern char _Smysection_ram_text;
  /* define type for copy table entry. See doc --> _INITSCT_RH */
struct SectionTableEntry {
    void *rom_s;
    void *rom_e;
    void *ram_s;
};
      /* Initialize the array with our section addresses */
#define M 1
struct SectionTableEntry _C_DSEC[M] = {
    { (void *)&_Smysection_rom_text, (void *)&_Emysection_rom_text, (void *)&_Smysection_ram_text, }
};
    void main(void);
void main(void)
{
            /* copy function contents to RAM */
            _INITSCT_RH((void *)_C_DSEC, (void *)(_C_DSEC+M),(void *)0,(void *)0);
                        /* call RAM function */
            my_ram_function();
}

Suitable Products
RH850
Question:
I am using RH850 with CS+ IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM?
Answer:
Answer:
If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below.
  Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively.
    Prepare a separate routine for transfer that will lead to the following actions and include it in your program.
Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined _INITSCT_RH function provided by CC-RH)
Call the target routines from RAM.
In the process of building your program, run the optimizing linker with the following settings for such code.
As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated.
As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run.
    Sample Code:
#include <_h_c_lib.h>
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
    extern void my_ram_function(void);
  /* import sections to get start/end addresses */
extern char _Smysection_rom_text;
extern char _Emysection_rom_text;
extern char _Smysection_ram_text;
  /* define type for copy table entry. See doc --> _INITSCT_RH */
struct SectionTableEntry {
    void *rom_s;
    void *rom_e;
    void *ram_s;
};
      /* Initialize the array with our section addresses */
#define M 1
struct SectionTableEntry _C_DSEC[M] = {
    { (void *)&_Smysection_rom_text, (void *)&_Emysection_rom_text, (void *)&_Smysection_ram_text, }
};
    void main(void);
void main(void)
{
            /* copy function contents to RAM */
            _INITSCT_RH((void *)_C_DSEC, (void *)(_C_DSEC+M),(void *)0,(void *)0);
                        /* call RAM function */
            my_ram_function();
}

Suitable Products
RH850
I am using RH850 with CS+ IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM?
I am using RH850 with CS+ IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM?
I am using RH850 with CS+ IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM?
Answer:
Answer:
If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below.
  Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively.
    Prepare a separate routine for transfer that will lead to the following actions and include it in your program.
Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined _INITSCT_RH function provided by CC-RH)
Call the target routines from RAM.
In the process of building your program, run the optimizing linker with the following settings for such code.
As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated.
As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run.
    Sample Code:
#include <_h_c_lib.h>
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
    extern void my_ram_function(void);
  /* import sections to get start/end addresses */
extern char _Smysection_rom_text;
extern char _Emysection_rom_text;
extern char _Smysection_ram_text;
  /* define type for copy table entry. See doc --> _INITSCT_RH */
struct SectionTableEntry {
    void *rom_s;
    void *rom_e;
    void *ram_s;
};
      /* Initialize the array with our section addresses */
#define M 1
struct SectionTableEntry _C_DSEC[M] = {
    { (void *)&_Smysection_rom_text, (void *)&_Emysection_rom_text, (void *)&_Smysection_ram_text, }
};
    void main(void);
void main(void)
{
            /* copy function contents to RAM */
            _INITSCT_RH((void *)_C_DSEC, (void *)(_C_DSEC+M),(void *)0,(void *)0);
                        /* call RAM function */
            my_ram_function();
}

Suitable Products
RH850
Answer:
Answer:
If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below.
If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below.
Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively.
Prepare a separate routine for transfer that will lead to the following actions and include it in your program.
Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined _INITSCT_RH function provided by CC-RH)
Call the target routines from RAM.
In the process of building your program, run the optimizing linker with the following settings for such code.
As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated.
As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run.
    Sample Code:
#include <_h_c_lib.h>
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
    extern void my_ram_function(void);
  /* import sections to get start/end addresses */
extern char _Smysection_rom_text;
extern char _Emysection_rom_text;
extern char _Smysection_ram_text;
  /* define type for copy table entry. See doc --> _INITSCT_RH */
struct SectionTableEntry {
    void *rom_s;
    void *rom_e;
    void *ram_s;
};
      /* Initialize the array with our section addresses */
#define M 1
struct SectionTableEntry _C_DSEC[M] = {
    { (void *)&_Smysection_rom_text, (void *)&_Emysection_rom_text, (void *)&_Smysection_ram_text, }
};
    void main(void);
void main(void)
{
            /* copy function contents to RAM */
            _INITSCT_RH((void *)_C_DSEC, (void *)(_C_DSEC+M),(void *)0,(void *)0);
                        /* call RAM function */
            my_ram_function();
}
Prepare a separate routine for transfer that will lead to the following actions and include it in your program.
Copy the target routines from the ROM sections to the corresponding RAM sections.(
Code use pre-defined _INITSCT_RH function provided by CC-RH)
Call the target routines from RAM.
In the process of building your program, run the optimizing linker with the following settings for such code.
As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated.
As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run.
Sample Code:
Sample Code:
#include <_h_c_lib.h>
#include
<_h_c_lib.h>
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
extern void my_ram_function(void);
extern
void
my_ram_function(
void
);
/* import sections to get start/end addresses */
/* import sections to get start/end addresses */
extern char _Smysection_rom_text;
extern
char
_Smysection_rom_text;
extern char _Emysection_rom_text;
extern
char
_Emysection_rom_text;
extern char _Smysection_ram_text;
extern
char
_Smysection_ram_text;
/* define type for copy table entry. See doc --> _INITSCT_RH */
/* define type for copy table entry. See doc --> _INITSCT_RH */
struct SectionTableEntry {
struct
SectionTableEntry {
void *rom_s;
void
*
rom_s;
void *rom_e;
void
*
rom_e;
void *ram_s;
void
*
ram_s;
};
};
/* Initialize the array with our section addresses */
/* Initialize the array with our section addresses */
#define M 1
#define
M 1
struct SectionTableEntry _C_DSEC[M] = {
struct
SectionTableEntry _C_DSEC[M]
=
{
{ (void *)&_Smysection_rom_text, (void *)&_Emysection_rom_text, (void *)&_Smysection_ram_text, }
{ (
void
*
)
&
_Smysection_rom_text, (
void
*
)
&
_Emysection_rom_text, (
void
*
)
&
_Smysection_ram_text, }
};
};
void main(void);
void
main(
void
);
void main(void)
void
main(
void
)
{
{
/* copy function contents to RAM */
/* copy function contents to RAM */
_INITSCT_RH((void *)_C_DSEC, (void *)(_C_DSEC+M),(void *)0,(void *)0);
_INITSCT_RH((
void
*
)_C_DSEC, (
void
*
)(_C_DSEC
+
M),(
void
*
)0,(
void
*
)0);
/* call RAM function */
/* call RAM function */
my_ram_function();
my_ram_function();
}
}
Suitable Products
RH850","['data/categories/rh850_family/rh850_general/85b897523834211bbbc3b0fe00a067a4/images/198d45ba348f46df5f05c47eb602ca1e.png', 'data/categories/rh850_family/rh850_general/85b897523834211bbbc3b0fe00a067a4/images/b1a996cd92b432d64e4c1a7869df6e50.png']",[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850: CC-RH Execution of a routine from RAM', 'url': 'https://en-support.renesas.com/knowledgeBase/21476371', 'last_updated': None, 'extracted_at': '2025-03-09T00:28:39.925390'}","Question I am using RH850 with CS IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM? Answer If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below. Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively. Prepare a separate routine for transfer that will lead to the following actions and include it in your program. Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined INITSCTRH function provided by CC-RH) Call the target routines from RAM. In the process of building your program, run the optimizing linker with the following settings for such code. As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated. As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run. Sample Code include hclib.h / void INITSCTRH(void  datatblstart, void  datatblend, void  bsstblstart, void  bsstblend) / extern void myramfunction(void); / import sections to get start/end addresses / extern char Smysectionromtext; extern char Emysectionromtext; extern char Smysectionramtext; / define type for copy table entry. See doc -- INITSCTRH / struct SectionTableEntry  void roms; void rome; void rams; ; / Initialize the array with our section addresses / define M 1 struct SectionTableEntry CDSECM    (void )Smysectionromtext, (void )Emysectionromtext, (void )Smysectionramtext,  void main(void); void main(void)  / copy function contents to RAM / INITSCTRH((void )CDSEC, (void )(CDSECM),(void )0,(void )0); / call RAM function / myramfunction();  Suitable Products RH850 Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively. Prepare a separate routine for transfer that will lead to the following actions and include it in your program. Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined INITSCTRH function provided by CC-RH) Sample Code include hclib.h extern void myramfunction(void); extern void myramfunction( ); / import sections to get start/end addresses / char Smysectionromtext; Emysectionromtext; Smysectionramtext; / define type for copy table entry. See doc -- INITSCTRH / struct SectionTableEntry  void roms;  roms; void rome; rome; void rams; rams; / Initialize the array with our section addresses / define M 1 SectionTableEntry CDSECM   (void )Smysectionromtext, (void )Emysectionromtext, (void )Smysectionramtext,   ( )  Smysectionromtext, ( Emysectionromtext, ( Smysectionramtext,  void main(void); main( / copy function contents to RAM / INITSCTRH((void )CDSEC, (void )(CDSECM),(void )0,(void )0); INITSCTRH(( )CDSEC, ( )(CDSEC  M),( )0,( )0); / call RAM function / myramfunction();","['The image shows a screenshot of a computer program with a pop-up window. The main window is titled ""Section Settings"" and has a list of sections on the left side, including ""Address"", ""%ResetVectorPE1%"", ""0x00008000"", "".const"", "".INIT_DSEC.c..."", "".INIT_BSEC.c..."", "".text"", "".data"", "".mysection_ro..."", and "".data.R"". The right side of the window has a list of options, including ""Add..."", ""Modify..."", ""New Overlay..."", and ""Remove"".\n\nThe pop-up window is titled ""Modify Section"" and has a text box labeled ""Section name:"" with the text ""mysection_rom.text"" entered. There are also buttons labeled ""OK"" and ""Cancel"".\n\nThe background of the image is a light gray color.\n\nOverall, the image appears to be a screenshot of a computer program used for modifying sections of a file or program. The user is able to select a section from the list on the left and modify its properties using the options on the right. The pop-up window allows the user to enter a new name for the section and confirm their changes.', 'The image displays a screenshot of a computer program, specifically a code snippet in a programming language. The code is written in a text editor or an Integrated Development Environment (IDE), and it appears to be a simple program that maps a ROM (Read-Only Memory) to a RAM (Random Access Memory) section.\n\nHere are the details of the code:\n\n*   **ROM to RAM mapped section**: This is the title of the code snippet, which suggests that the program is designed to map a ROM section to a RAM section.\n*   **data=.data.R**: This line of code defines a variable named ""data"" and assigns it a value of "".data.R"". The "".data.R"" syntax is likely a reference to a specific memory location or address in the ROM.\n*   **mysection_rom.text = mysection_ram.text**: This line of code assigns the value of ""mysection_ram.text"" to the variable ""mysection_rom.text"". This suggests that the program is copying data from the RAM section to the ROM section.\n\nOverall, the code appears to be a simple program that maps a ROM section to a RAM section, allowing data to be transferred between the two. The program uses a variable named ""data"" to store the address of the ROM section, and then copies data from the RAM section to the ROM section using the ""mysection_rom.text"" and ""mysection_ram.text"" variables.\n\nThe code is written in a clear and concise manner, making it easy to understand and follow. The use of descriptive variable names and comments makes the code easy to read and maintain. Overall, the code is well-structured and effective in its purpose.']"
aef18c1527e32753e293578beff82f85,"Question:
How do I dump the RH850 whole IOR registers in the debug mode of CS+ IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers.
Answer:
In CS+, you have the option to export any window as either text or CSV.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
Suitable Products
RH850
Question:
How do I dump the RH850 whole IOR registers in the debug mode of CS+ IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers.
Answer:
In CS+, you have the option to export any window as either text or CSV.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
Suitable Products
RH850
How do I dump the RH850 whole IOR registers in the debug mode of CS+ IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers.
How do I dump the RH850 whole IOR registers in the debug mode of CS+ IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers.
How do I dump the RH850 whole IOR registers in the debug mode of CS+ IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers.
Answer:
In CS+, you have the option to export any window as either text or CSV.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
Suitable Products
RH850
In CS+, you have the option to export any window as either text or CSV.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
In CS+, you have the option to export any window as either text or CSV.
In CS+, you have the option to export any window as either text or CSV.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
Suitable Products
RH850",['data/categories/rh850_family/rh850_general/aef18c1527e32753e293578beff82f85/images/8a1c4d4b373a89027dc6bc425b274e02.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850 IOR dump in CS+', 'url': 'https://en-support.renesas.com/knowledgeBase/21671338', 'last_updated': None, 'extracted_at': '2025-03-09T00:28:45.063199'}","Question How do I dump the RH850 whole IOR registers in the debug mode of CS IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers. Answer In CS, you have the option to export any window as either text or CSV. For your specific needs, please open the IOR window(if not visible View-IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer. Suitable Products RH850","['The image shows a screenshot of a computer screen displaying a code editor with a red box highlighting a specific section of the code. The code editor is open on a Windows computer, and the red box is drawn around a portion of the code that appears to be a function or method definition.\n\nHere are the details of the image:\n\n*   **Code Editor:**\n    *   The code editor is open on a Windows computer.\n    *   The editor has a gray background with black text and white lines separating the code blocks.\n    *   The code is written in C# and includes comments and variable declarations.\n*   **Red Box:**\n    *   The red box is drawn around a portion of the code that appears to be a function or method definition.\n    *   The code inside the red box includes the function name, parameter list, and return type.\n    *   The code also includes comments and variable declarations.\n*   **Other Elements:**\n    *   The top-left corner of the screen shows the file path and name of the current file being edited.\n    *   The top-right corner of the screen shows the version number of the code editor.\n    *   The bottom-left corner of the screen shows the line numbers of the code.\n    *   The bottom-right corner of the screen shows the status bar, which displays information about the current file and the code editor.\n\nOverall, the image shows a screenshot of a code editor with a red box highlighting a specific section of the code. The code editor is open on a Windows computer, and the red box is drawn around a portion of the code that appears to be a function or method definition.']"
3cf13711a6bd31149acc5c5f5f248702,"Question:
We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause?
Answer:
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
  For the PG-FP6 the default option is to write those data and this needs to be changed.
  Suitable Products
RH850
Question:
We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause?
Answer:
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
  For the PG-FP6 the default option is to write those data and this needs to be changed.
  Suitable Products
RH850
We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause?
We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause?
We have a programming production line using the E1 programmer.
We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause?
Answer:
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
  For the PG-FP6 the default option is to write those data and this needs to be changed.
  Suitable Products
RH850
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
  For the PG-FP6 the default option is to write those data and this needs to be changed.
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
For the PG-FP6 the default option is to write those data and this needs to be changed.
For the PG-FP6 the default option is to write those data and this needs to be changed.
Suitable Products
RH850","['data/categories/rh850_family/rh850_general/3cf13711a6bd31149acc5c5f5f248702/images/09125fd2cf3a331544009492b477e5fc.png', 'data/categories/rh850_family/rh850_general/3cf13711a6bd31149acc5c5f5f248702/images/60d23586801f542a79f7e1a162290526.png']",[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850: Programmer change from E1 to PG-FP6', 'url': 'https://en-support.renesas.com/knowledgeBase/21490047', 'last_updated': None, 'extracted_at': '2025-03-09T00:28:30.258891'}",Question We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause? Answer One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot For the PG-FP6 the default option is to write those data and this needs to be changed. Suitable Products RH850 We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause? For the PG-FP6 the default option is to write those data and this needs to be changed. Suitable Products,"['The image shows a screenshot of the Renesas Flash Programmer V3.11.00 software, which is used to program and verify flash memory devices. The software has a gray background with black text and white boxes for inputting data.\n\n*   **Operation Settings**\n    *   The top-left corner of the window has a menu bar with the following options: File, Target Device, Help, Operation, Block Settings, Connect Settings, and Unique Code.\n    *   The ""Operation"" tab is selected, and it contains several sub-options, including Command, Erase Options, Program & Verify Options, Checksum Type, Fill with 0xFF, Code Flash / User Boot, and Data Flash.\n*   **Command**\n    *   The ""Command"" section has a checkbox for ""Erase"" and another for ""Program"". Both checkboxes are checked.\n*   **Erase Options**\n    *   The ""Erase Options"" section has a dropdown menu with the option ""Erase Selected Blocks"" selected.\n*   **Program & Verify Options**\n    *   The ""Program & Verify Options"" section has a dropdown menu with the option ""Erase Before Program"" selected.\n*   **Checksum Type**\n    *   The ""Checksum Type"" section has a dropdown menu with the option ""CRC-32 method"" selected.\n*   **Fill with 0xFF**\n    *   The ""Fill with 0xFF"" section has a checkbox for ""Code Flash / User Boot"" and another for ""Data Flash"". Both checkboxes are checked.\n*   **Error Settings**\n    *   The ""Error Settings"" section has a checkbox for ""Enable address check of program file"".\n*   **Loading Project**\n    *   At the bottom of the window, there is a text box that displays the loading project information, including the project name, version, and date.\n\nOverall, the image shows the Renesas Flash Programmer V3.11.00 software with various settings and options for programming and verifying flash memory devices. The software appears to be set up for erasing and programming a device with a CRC-32 checksum type and enabling address checks for the program file.', 'The image shows a screenshot of a computer program with a white background and black text. The program is titled ""Setup (C:\\Users\\a5050241\\Documents\\FP6\\Test_F1K\\Test_F1K.es6)"" and has several tabs at the top, including ""Program Files"", ""Operation Settings"", ""Block Settings"", ""Flash Options"", and ""Connect Settings"".\n\nThe ""Program Files"" tab is selected, and it contains several options, including:\n\n* ""Erase""\n* ""Program""\n* ""Verify""\n* ""Program Flash Options""\n* ""Verify Flash Options""\n* ""Checksum""\n\nThe ""Erase"" option is highlighted in yellow, indicating that it is the current selection. Below the ""Erase"" option, there are two checkboxes: ""Code Flash / User Boot"" and ""Data Flash"". The ""Code Flash / User Boot"" checkbox is checked, while the ""Data Flash"" checkbox is not.\n\nAt the bottom of the window, there are three buttons: ""Download to FP6"", ""Save"", and ""Cancel"". The ""Download to FP6"" button is highlighted in yellow, indicating that it is the current selection.\n\nOverall, the image appears to be a screenshot of a computer program used for programming or configuring a device. The highlighted options and buttons suggest that the user is in the process of erasing and programming the device.']"
0becf452098654551210915e6bf307b8,"Question:
I am using RH850 device with CS+. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup.
Answer:
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. 
  If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
  With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
    #pragma section r0_disp32 ""NO_INIT_TEST""
  int my_var;
  #pragma section default
  Additionally, sections should be defined on the Linker tab as below.
  Figure 1: Section Settings window
  NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
Suitable Products
RH850
Question:
I am using RH850 device with CS+. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup.
Answer:
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. 
  If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
  With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
    #pragma section r0_disp32 ""NO_INIT_TEST""
  int my_var;
  #pragma section default
  Additionally, sections should be defined on the Linker tab as below.
  Figure 1: Section Settings window
  NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
Suitable Products
RH850
I am using RH850 device with CS+. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup.
I am using RH850 device with CS+. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup.
I am using RH850 device with CS+.
Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup.
Answer:
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. 
  If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
  With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
    #pragma section r0_disp32 ""NO_INIT_TEST""
  int my_var;
  #pragma section default
  Additionally, sections should be defined on the Linker tab as below.
  Figure 1: Section Settings window
  NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
Suitable Products
RH850
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. 
  If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
  With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
    #pragma section r0_disp32 ""NO_INIT_TEST""
  int my_var;
  #pragma section default
  Additionally, sections should be defined on the Linker tab as below.
  Figure 1: Section Settings window
  NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified.
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified.
If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
#pragma section r0_disp32 ""NO_INIT_TEST""
#pragma section r0_disp32 ""NO_INIT_TEST""
int my_var;
int my_var;
#pragma section default
#pragma section default
Additionally, sections should be defined on the Linker tab as below.
Additionally, sections should be defined on the Linker tab as below.
Figure 1: Section Settings window
NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
Suitable Products
RH850",['data/categories/rh850_family/rh850_general/0becf452098654551210915e6bf307b8/images/b2e5fd14f6b5c407de10b99726bd360b.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850: Prevent variable from updating on software reset', 'url': 'https://en-support.renesas.com/knowledgeBase/21124767', 'last_updated': None, 'extracted_at': '2025-03-09T00:28:57.511121'}","Question I am using RH850 device with CS. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup. Answer To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used. With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference. pragma section r0disp32 ""NOINITTEST"" int myvar; pragma section default Additionally, sections should be defined on the Linker tab as below. Figure 1 Section Settings window NOINITTEST.data.R and NOINITTEST.bss are the sections inside retention RAM. Suitable Products RH850 I am using RH850 device with CS. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup. To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used. With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference. pragma section r0disp32 ""NOINITTEST"" int myvar; pragma section default Additionally, sections should be defined on the Linker tab as below. Figure 1 Section Settings window NOINITTEST.data.R and NOINITTEST.bss are the sections inside retention RAM.","['The image shows a screenshot of a computer program, specifically a settings window for a section. The window is titled ""Section Settings"" and has a list of options on the left side, including ""Address"", ""%ResetVectorPE1%"", ""0x00000200"", ""0x00008000"", ""0xFEDF8000"", and ""0xFEDF8000"". Each option has a corresponding value or setting next to it.\n\nOn the right side of the window, there are several buttons and options, including ""Add..."", ""Modify..."", ""New Overlay..."", ""Remove"", ""Up"", ""Down"", ""Import..."", and ""Export..."". The ""OK"" button is highlighted in blue, indicating that it is the default or currently selected option.\n\nThe background of the window is a light gray color, with a darker gray border around the edges. Overall, the image appears to be a screenshot of a computer program used for configuring settings related to a specific section or module.']"
dddff4ada4040ac8c679f99c156c51de,"Question:
Where can I find the BSDL and IBIS files for RH850 devices
Answer:
The BSDL and IBIS files for RH850 devices are now available on the website.
    Step 1: Go to the product landing page of the device family.
Figure 1: Product Landing page RH850/F1KM-S1
    Step 2: One the page click on the Design& Development section
Figure 2: Design & Development tab
    Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
Suitable Products
RH850
Question:
Where can I find the BSDL and IBIS files for RH850 devices
Answer:
The BSDL and IBIS files for RH850 devices are now available on the website.
    Step 1: Go to the product landing page of the device family.
Figure 1: Product Landing page RH850/F1KM-S1
    Step 2: One the page click on the Design& Development section
Figure 2: Design & Development tab
    Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
Suitable Products
RH850
Where can I find the BSDL and IBIS files for RH850 devices
Where can I find the BSDL and IBIS files for RH850 devices
Where can I find the BSDL and IBIS files for RH850 devices
Answer:
The BSDL and IBIS files for RH850 devices are now available on the website.
    Step 1: Go to the product landing page of the device family.
Figure 1: Product Landing page RH850/F1KM-S1
    Step 2: One the page click on the Design& Development section
Figure 2: Design & Development tab
    Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
Suitable Products
RH850
The BSDL and IBIS files for RH850 devices are now available on the website.
    Step 1: Go to the product landing page of the device family.
Figure 1: Product Landing page RH850/F1KM-S1
    Step 2: One the page click on the Design& Development section
Figure 2: Design & Development tab
    Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
The BSDL and IBIS files for RH850 devices are now available on the website.
The BSDL and IBIS files for RH850 devices are now available on the website.
Step 1: Go to the product landing page of the device family.
Step 1: Go to the product landing page of the device family.
Figure 1: Product Landing page RH850/F1KM-S1
Step 2: One the page click on the Design& Development section
Step 2: One the page click on the Design& Development section
Figure 2: Design & Development tab
Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
Suitable Products
RH850","['data/categories/rh850_family/rh850_general/dddff4ada4040ac8c679f99c156c51de/images/91891e9d00ffaaa483d7b98010f595ec.png', 'data/categories/rh850_family/rh850_general/dddff4ada4040ac8c679f99c156c51de/images/c39197eebde2e332712e54241889980d.png']",[],['|  |\n|  |\n| RH850 |'],"{'title': 'BSDL and IBIS files for RH850 devices', 'url': 'https://en-support.renesas.com/knowledgeBase/21124706', 'last_updated': None, 'extracted_at': '2025-03-09T00:29:04.718843'}","Question Where can I find the BSDL and IBIS files for RH850 devices Answer The BSDL and IBIS files for RH850 devices are now available on the website. Step 1 Go to the product landing page of the device family. Figure 1 Product Landing page RH850/F1KM-S1 Step 2 One the page click on the Design Development section Figure 2 Design  Development tab Step 3 Under the Modes tab, you can see both BSDL files and IBIS files. Suitable Products RH850 Step 1 Go to the product landing page of the device family. Step 2 One the page click on the Design Development section Step 3 Under the Modes tab, you can see both BSDL files and IBIS files.","['The image shows a screenshot of the Renesas website, which is a semiconductor company. The top of the page has a blue bar with the company\'s logo and navigation menu. Below that, there is a search bar and a shopping cart icon.\n\n*   **Header**\n    *   The header is blue and contains the company\'s logo and navigation menu.\n    *   The navigation menu includes links to various sections of the website, such as ""Products"", ""Applications"", ""Design Resources"", ""Sales & Support"", and ""About"".\n*   **Search Bar**\n    *   The search bar is located below the header and allows users to search for specific products or information on the website.\n    *   The search bar is white with a magnifying glass icon on the right side.\n*   **Shopping Cart Icon**\n    *   The shopping cart icon is located next to the search bar and allows users to view their shopping cart and checkout.\n    *   The shopping cart icon is a small icon of a shopping cart with a red circle around it.\n*   **Product Information**\n    *   Below the header and search bar, there is a section of the page that displays information about a specific product.\n    *   The product information includes a title, description, and images of the product.\n    *   The product information is displayed in a white box with a blue border.\n*   **Call-to-Action Buttons**\n    *   There are two call-to-action buttons on the page: ""Order Now"" and ""Download Datasheet"".\n    *   The ""Order Now"" button is yellow and allows users to place an order for the product.\n    *   The ""Download Datasheet"" button is blue and allows users to download a datasheet for the product.\n*   **Footer**\n    *   The footer is located at the bottom of the page and contains additional information about the company and its products.\n    *   The footer includes links to other pages on the website, as well as contact information and social media links.\n\nOverall, the image shows a screenshot of the Renesas website, which is a semiconductor company. The website has a clean and modern design, with a clear navigation menu and prominent call-to-action buttons. The product information section is well-organized and easy to read, making it simple for users to find the information they need.', 'The image shows a screenshot of a webpage with a white background and blue and black text. The page is titled ""Design & Development"" and has a navigation bar at the top with various tabs, including ""Overview,"" ""Documentation,"" ""Design & Development,"" ""Product Options,"" ""Support,"" ""Videos & Training,"" and ""Order Now."" \n\n*   **Title**\n    *   The title of the page is ""Design & Development.""\n*   **Navigation Bar**\n    *   The navigation bar has several tabs, including ""Overview,"" ""Documentation,"" ""Design & Development,"" ""Product Options,"" ""Support,"" ""Videos & Training,"" and ""Order Now.""\n*   **Content**\n    *   The main content of the page is a section titled ""ECAD Models"" with a brief description and a link to explore ECAD models.\n    *   Below this section, there is a table with two columns: ""Title"" and ""Date."" The table has three rows, each with a different title and date.\n    *   The first row has the title ""BSDL Files for RH850/F1KM-S1"" and the date ""Feb 6, 2019.""\n    *   The second row has the title ""IBIS Files for RH850/F1KM-S1"" and the date ""Jan 31, 2023.""\n    *   The third row has the title ""Model - BSDL"" and the date ""Feb 6, 2019.""\n    *   The fourth row has the title ""Model - IBIS"" and the date ""Jan 31, 2023.""\n*   **Footer**\n    *   The footer of the page has a link to ""Download Datasheet"" and a button to ""Order Now.""\n\nOverall, the page appears to be a product page for a design and development tool, with information about the product\'s features, specifications, and availability.']"
67f32524284fb38b192efcfaebf9a1e0,"Question:
We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue.
can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know.
Answer:
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
  If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
Suitable Products
RH850
Question:
We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue.
can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know.
Answer:
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
  If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
Suitable Products
RH850
We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue.
can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know.
We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue.
We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue.
can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know.
can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know.
Answer:
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
  If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
Suitable Products
RH850
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
  If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
If you have forgotten the security ID, you may try to use
Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
Suitable Products
RH850",['data/categories/rh850_family/rh850_general/67f32524284fb38b192efcfaebf9a1e0/images/3412fe575648e0769784f9cd4b7c261b.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850: GHS Code Flash security ID is not specified.', 'url': 'https://en-support.renesas.com/knowledgeBase/21153491', 'last_updated': None, 'extracted_at': '2025-03-09T00:29:14.713533'}","Question We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue. can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know. Answer The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs. If you have manually changed it before, you may have to use the new value. If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that. Suitable Products RH850 If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that. If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.","['The image shows a pop-up window with the title ""MULTI Debugger - MULTI v8.1.4"" at the top. The window has a white background and black text.\n\n*   **Title and Version**\n    *   The title is ""MULTI Debugger - MULTI v8.1.4"".\n    *   The version number is ""v8.1.4"".\n*   **Warning Message**\n    *   A yellow triangle with an exclamation mark inside it is displayed.\n    *   The message reads: ""850eserv2 Version: V2.063(x64) Release: Compiler v2022.1.4, Mon Mar 07 13:41:14 2022"".\n    *   Below the warning message, there is a paragraph of text that reads: ""Code Flash security ID-code is not specified. Please specify 64 digits ID-code with \'-cfapw\'. Connection: No remote connection established.""\n*   **Button**\n    *   There is a blue button at the bottom of the window with the text ""OK"" in it.\n\nThe image appears to be a pop-up window from a debugging tool, warning the user that the code flash security ID-code is not specified and requiring them to specify a 64-digit ID-code with the \'-cfapw\' option.']"
cd824a26233e5724b09e9622882ed837,"Question:
We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting.
Answer:
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
Figure 1: List of security settings data


In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable.
Suitable Products
RH850
Question:
We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting.
Answer:
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
Figure 1: List of security settings data


In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable.
Suitable Products
RH850
We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting.
We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting.
We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting.
Answer:
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
Figure 1: List of security settings data


In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable.
Suitable Products
RH850
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
Figure 1: List of security settings data


In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable.
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
Figure 1: List of security settings data
In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable.
Suitable Products
RH850",['data/categories/rh850_family/rh850_general/cd824a26233e5724b09e9622882ed837/images/5ea00ef8458b56aeed4d2a5dd6a66433.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850: Is Security Settings reversible?', 'url': 'https://en-support.renesas.com/knowledgeBase/21130250', 'last_updated': None, 'extracted_at': '2025-03-09T00:29:17.612966'}","Question We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting. Answer The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available. Figure 1 List of security settings data In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable. Suitable Products RH850","['The image presents a table with two columns and five rows, titled ""List of Security Setting Data."" The left column is labeled ""Security Functions"" and the right column is labeled ""Security Setting Data (16 Bytes)."" \n\nThe first row lists ""ID authentication enabled in serial programming mode"" and the corresponding security setting data as ""FFFF FFFF FFFF FFFF FFFF 1EFF FFFF."" The second row lists ""Serial programmer connection disabled"" and the corresponding security setting data as ""FFFF FFFF FFFF FFFF FFFF F7FF FFFF."" The third row lists ""Block erase command disabled"" and the corresponding security setting data as ""FFFF FFFF FFFF FFFF FFFF DFFF FFFF."" The fourth row lists ""Programming command disabled"" and the corresponding security setting data as ""FFFF FFFF FFFF FFFF FFFF BFFF FFFF."" The fifth row lists ""Read command disabled"" and the corresponding security setting data as ""FFFF FFFF FFFF FFFF FFFF 7FFF FFFF.""\n\nThe table provides a clear and organized comparison of security functions and their corresponding security setting data, allowing for easy reference and analysis.']"
621270c94bee070308c576d4b9bcc6b7,"Question:
What is the difference between R7F7010183AFP#KA4 and R7F7010183AFP#AA4? Are they interchangeable? What does the suffix mean?
Answer:
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The #xAx refers to Pb-free / Sn plating.
The #xx4 refers to silicon revision 4
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
Suitable Products
RH850
Question:
What is the difference between R7F7010183AFP#KA4 and R7F7010183AFP#AA4? Are they interchangeable? What does the suffix mean?
Answer:
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The #xAx refers to Pb-free / Sn plating.
The #xx4 refers to silicon revision 4
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
Suitable Products
RH850
What is the difference between R7F7010183AFP#KA4 and R7F7010183AFP#AA4? Are they interchangeable? What does the suffix mean?
What is the difference between R7F7010183AFP#KA4 and R7F7010183AFP#AA4? Are they interchangeable? What does the suffix mean?
What is the difference between
R7F7010183AFP#KA4 and R7F7010183AFP#AA4? Are they interchangeable?
What does the suffix mean?
Answer:
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The #xAx refers to Pb-free / Sn plating.
The #xx4 refers to silicon revision 4
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
Suitable Products
RH850
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The #xAx refers to Pb-free / Sn plating.
The #xx4 refers to silicon revision 4
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The #xAx refers to Pb-free / Sn plating.
The #xAx refers to Pb-free / Sn plating.
The #xx4 refers to silicon revision 4
The #xx4 refers to silicon revision 4
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
Suitable Products
RH850",['data/categories/rh850_family/rh850_general/621270c94bee070308c576d4b9bcc6b7/images/985a524ae5c63a1c1e3d50c28c145584.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850 part number suffix', 'url': 'https://en-support.renesas.com/knowledgeBase/21153494', 'last_updated': None, 'extracted_at': '2025-03-09T00:29:29.861265'}","Question What is the difference between R7F7010183AFPKA4 and R7F7010183AFPAA4? Are they interchangeable? What does the suffix mean? Answer The P/N suffix Axx refers to tray, Kxx is tape  reel. The xAx refers to Pb-free / Sn plating. The xx4 refers to silicon revision 4 The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery. Suitable Products RH850 What is the difference between R7F7010183AFPKA4 and R7F7010183AFPAA4? Are they interchangeable? What does the suffix mean?","['The image presents a table with the title ""#YJ1"" in the top-left corner, accompanied by a blue box containing white text. The table is divided into two columns: ""Material/Version"" and ""Packaging."" The ""Material/Version"" column lists various materials and versions, while the ""Packaging"" column provides corresponding packaging information.\n\n**Table Content:**\n\n*   **Material/Version**\n    *   #Axx\n    *   #Kxx\n    *   #Hxx\n    *   #x - x\n    *   #x - x\n    *   #Yxx\n    *   #YJx\n    *   #YKx\n    *   #YBx\n    *   #xxx\n*   **Packaging**\n    *   Tray\n    *   T&R QFP (top right, formerly -E3)\n    *   T&R BGA (top left, formerly -E2)\n    *   Pb free/ Sn plating\n    *   Pb free/\n    *   Sample Versions\n    *   Sample\n    *   WS = Working Sample\n    *   ES = Engineering Sample\n    *   CS = Commercial Sample\n    *   Product Version\n        *   x = 1, 2, 3, ...\n\nThe table appears to be a technical document or specification sheet, likely used in the electronics or semiconductor industry. It provides detailed information about different materials and versions, along with their corresponding packaging options. The use of abbreviations and technical terms suggests that the document is intended for an audience with a strong background in the field.']"
37f0da015a74510a0e8d600cb61be3b8,"Question:
Unable to connect the E2 to MCU RH850 U2A16 using Renesas Flash Programmer
I see the error (E3000105): The device is not responding when I am tryng connect the debugger using Renesas Flash Programmer.
And when I try with CS+ I found this error Set the SVR parameter (E0617024)
Answer:
Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device.
Suitable Products
RH850
Unable to connect the E2 to MCU RH850 U2A16 using Renesas Flash Programmer
I see the error (E3000105): The device is not responding when I am tryng connect the debugger using Renesas Flash Programmer.
And when I try with CS+ I found this error Set the SVR parameter (E0617024)
Unable to connect the E2 to MCU RH850 U2A16 using Renesas Flash Programmer
I see the error (E3000105): The device is not responding when I am tryng connect the debugger using Renesas Flash Programmer.
Unable to connect the E2 to MCU RH850 U2A16 using Renesas Flash Programmer
I see the error (E3000105): The device is not responding when I am tryng connect the debugger using Renesas Flash Programmer.
And when I try with CS+ I found this error Set the SVR parameter (E0617024)
And when I try with CS+ I found this error Set the SVR parameter (E0617024)
Answer:
Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device.
Suitable Products
RH850
Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device.
Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device.
Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device.
Suitable Products
RH850",['data/categories/rh850_family/rh850u2a/37f0da015a74510a0e8d600cb61be3b8/images/f273ab6a6e14ea080c010b8041f75572.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850 U2A SVR parameter error', 'url': 'https://en-support.renesas.com/knowledgeBase/21671339', 'last_updated': '2024-07-11', 'extracted_at': '2025-03-09T00:28:11.964430'}",Question Unable to connect the E2 to MCU RH850 U2A16 using Renesas Flash Programmer I see the error (E3000105) The device is not responding when I am tryng connect the debugger using Renesas Flash Programmer. And when I try with CS I found this error Set the SVR parameter (E0617024) Answer Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device. Suitable Products RH850,"['The image shows a screenshot of a computer program, specifically a development environment for microcontrollers. The program is open on a Windows computer, with the title ""SVR_test - C++ for CC - [Property]"" at the top.\n\n*   **Menu Bar**\n    *   The menu bar is located at the top of the window and contains various options such as ""File"", ""Edit"", ""View"", ""Project"", ""Build"", ""Debug"", ""Tool"", ""Window"", and ""Help"".\n*   **Toolbars**\n    *   There are several toolbars below the menu bar, including a ""Solution List"" toolbar, a ""Property"" toolbar, and a ""Connect Settings"" toolbar.\n    *   The ""Solution List"" toolbar has a dropdown menu with options such as ""Property"", ""RN485_Pie_Toggle map"", and ""Solution List"".\n    *   The ""Property"" toolbar has a dropdown menu with options such as ""Clock"", ""Connection with Emulator"", ""E2 Expansion Interface"", ""Flash"", ""OCD ID"", ""Customer ID"", ""Data Flash ID"", ""Device specific ID"", ""SVR Simulator"", ""Memory"", ""Map mode"", ""Work RAM start address"", and ""Security"".\n    *   The ""Connect Settings"" toolbar has a dropdown menu with options such as ""Debug Tool Settings"", ""Download File Settings"", and ""Hook Transaction Settings"".\n*   **Workspace**\n    *   The workspace is the main area of the window where the user can work on their project.\n    *   It contains a list of files and folders on the left side, and a code editor on the right side.\n    *   The code editor has a blue bar at the top with the text ""SVR_test - C++ for CC - [Property]"".\n    *   Below the blue bar, there is a list of files and folders, including ""boot0.asm"", ""boot1.asm"", ""boot2.asm"", ""boot3.asm"", ""SVR_test_App1_Subproject"", ""SVR_test_App2_Subproject"", ""SVR_test_App3_Subproject"", ""SVR_test_App4_Subproject"", ""SVR_test_App5_Subproject"", ""SVR_test_App6_Subproject"", ""SVR_test_App7_Subproject"", ""SVR_test_App8_Subproject"", ""SVR_test_App9_Subproject"", ""SVR_test_App10_Subproject"", ""SVR_test_App11_Subproject"", ""SVR_test_App12_Subproject"", ""SVR_test_App13_Subproject"", ""SVR_test_App14_Subproject"", ""SVR_test_App15_Subproject"", ""SVR_test_App16_Subproject"", ""SVR_test_App17_Subproject"", ""SVR_test_App18_Subproject"", ""SVR_test_App19_Subproject"", ""SVR_test_App20_Subproject"", ""SVR_test_App21_Subproject"", ""SVR_test_App22_Subproject"", ""SVR_test_App23_Subproject"", ""SVR_test_App24_Subproject"", ""SVR_test_App25_Subproject"", ""SVR_test_App26_Subproject"", ""SVR_test_App27_Subproject"", ""SVR_test_App28_Subproject"", ""SVR_test_App29_Subproject"", ""SVR_test_App30_Subproject"", ""SVR_test_App31_Subproject"", ""SVR_test_App32_Subproject"", ""SVR_test_App33_Subproject"", ""SVR_test_App34_Subproject"", ""SVR_test_App35_Subproject"", ""SVR_test_App36_Subproject"", ""SVR_test_App37_Subproject"", ""SVR_test_App38_Subproject"", ""SVR_test_App39_Subproject"", ""SVR_test_App40_Subproject"", ""SVR_test_App41_Subproject"", ""SVR_test_App42_Subproject"", ""SVR_test_App43_Subproject"", ""SVR_test_App44_Subproject"", ""SVR_test_App45_Subproject"", ""SVR_test_App46_Subproject"", ""SVR_test_App47_Subproject"", ""SVR_test_App48_Subproject"", ""SVR_test_App49_Subproject"", ""SVR_test_App50_Subproject"", ""SVR_test_App51_Subproject"", ""SVR_test_App52_Subproject"", ""SVR_test_App53_Subproject"", ""SVR_test_App54_Subproject"", ""SVR_test_App55_Subproject"", ""SVR_test_App56_Subproject"", ""SVR_test_App57_Subproject"", ""SVR_test_App58_Subproject"", ""SVR_test_App59_Subproject"", ""SVR_test_App60_Subproject"", ""SVR_test_App61_Subproject"", ""SVR_test_App62_Subproject"", ""SVR_test_App63_Subproject"", ""SVR_test_App64_Subproject"", ""SVR_test_App65_Subproject"", ""SVR_test_App66_Subproject"", ""SVR_test_App67_Subproject"", ""SVR_test_App68_Subproject"", ""SVR_test_App69_Subproject"", ""SVR_test_App70_Subproject"", ""SVR_test_App71_Subproject"", ""SVR_test_App72_Subproject"", ""SVR_test_App73_Subproject"", ""SVR_test_App74_Subproject"", ""SVR_test_App75_Subproject"", ""SVR_test_App76_Subproject"", ""SVR_test_App77_Subproject"", ""SVR_test_App78_Subproject"", ""SVR_test_App79_Subproject"", ""SVR_test_App80_Subproject"", ""SVR_test_App81_Subproject"", ""SVR_test_App82_Subproject"", ""SVR_test_App83_Subproject"", ""SVR_test_App84_Subproject"", ""SVR_test_App85_Subproject"", ""SVR_test_App86_Subproject"", ""SVR_test_App87_Subproject"", ""SVR_test_App88_Subproject"", ""SVR_test_App89_Subproject"", ""SVR_test_App90_Subproject"", ""SVR_test_App91_Subproject"", ""SVR_test_App92_Subproject"", ""SVR_test_App93_Subproject"", ""SVR_test_App94_Subproject"", ""SVR_test_App95_Subproject"", ""SVR_test_App96_Subproject"", ""SVR_test_App97_Subproject"", ""SVR_test_App98_Subproject"", ""SVR_test_App99_Subproject"", ""SVR_test_App100_Subproject"", ""SVR_test_App101_Subproject"", ""SVR_test_App102_Subproject"", ""SVR_test_App103_Subproject"", ""SVR_test_App104_Subproject"", ""SVR_test_App105_Subproject"", ""SVR_test_App106_Subproject"", ""SVR_test_App107_Subproject"", ""SVR_test_App108_Subproject"", ""SVR_test_App109_Subproject"", ""SVR_test_App110_Subproject"", ""SVR_test_App111_Subproject"", ""SVR_test_App112_Subproject"", ""SVR_test_App113_Subproject"", ""SVR_test_App114_Subproject"", ""SVR_test_App115_Subproject"", ""SVR_test_App116_Subproject"", ""SVR_test_App117_Subproject"", ""SVR_test_App118_Subproject"", ""SVR_test_App119_Subproject"", ""SVR_test_App120_Subproject"", ""SVR_test_App121_Subproject"", ""SVR_test_App122_Subproject"", ""SVR_test_App123_Subproject"", ""SVR_test_App124_Subproject"", ""SVR_test_App125_Subproject"", ""SVR_test_App126_Subproject"", ""SVR_test_App127_Subproject"", ""SVR_test_App128_Subproject"", ""SVR_test_App129_Subproject"", ""SVR_test_App130_Subproject"", ""SVR_test_App131_Subproject"", ""SVR_test_App132_Subproject"", ""SVR_test_App133_Subproject"", ""SVR_test_App134_Subproject"", ""SVR_test_App135_Subproject"", ""SVR_test_App136_Subproject"", ""SVR_test_App137_Subproject"", ""SVR_test_App138_Subproject"", ""SVR_test_App139_Subproject"", ""SVR_test_App140_Subproject"", ""SVR_test_App141_Subproject"", ""SVR_test_App142_Subproject"", ""SVR_test_App143_Subproject"", ""SVR_test_App144_Subproject"", ""SVR_test_App145_Subproject"", ""SVR_test_App146_Subproject"", ""SVR_test_App147_Subproject"", ""SVR_test_App148_Subproject"", ""SVR_test_App149_Subproject"", ""SVR_test_App150_Subproject"", ""SVR_test_App151_Subproject"", ""SVR_test_App152_Subproject"", ""SVR_test_App153_Subproject"", ""SVR_test_App154_Subproject"", ""SVR_test_App155_Subproject"", ""SVR_test_App156_Subproject"", ""SVR_test_App157_Subproject"", ""SVR_test_App158_Subproject"", ""SVR_test_App159_Subproject"", ""SVR_test_App160_Subproject"", ""SVR_test_App161_Subproject"", ""SVR_test_App162_Subproject"", ""SVR_test_App163_Subproject"", ""SVR_test_App164_Subproject"", ""SVR_test_App165_Subproject"", ""SVR_test_App166_Subproject"", ""SVR_test_App167_Subproject"", ""SVR_test_App168_Subproject"", ""SVR_test_App169_Subproject"", ""SVR_test_App170_Subproject"", ""SVR_test_App171_Subproject"", ""SVR_test_App172_Subproject"", ""SVR_test_App173_Subproject"", ""SVR_test_App174_Subproject"", ""SVR_test_App175_Subproject"", ""SVR_test_App176_Subproject"", ""SVR_test_App177_Subproject"", ""SVR_test_App178_Subproject"", ""SVR_test_App179_Subproject"", ""SVR_test_App180_Subproject"", ""SVR_test_App181_Subproject"", ""SVR_test_App182_Subproject"", ""SVR_test_App183_Subproject"", ""SVR_test_App184_Subproject"", ""SVR_test_App185_Subproject"", ""SVR_test_App186_Subproject"", ""SVR_test_App187_Subproject"", ""SVR_test_App188_Subproject"", ""SVR_test_App189_Subproject"", ""SVR_test_App190_Subproject"", ""SVR_test_App191_Subproject"", ""SVR_test_App192_Subproject"", ""SVR_test_App193_Subproject"", ""SVR_test_App194_Subproject"", ""SVR_test_App195_Subproject"", ""SVR_test_App196_Subproject"", ""SVR_test_App197_Subproject"", ""SVR_test_App198_Subproject"", ""SVR_test_App199_Subproject"", ""SVR_test_App200_Subproject"", ""SVR_test_App201_Subproject"", ""SVR_test_App202_Subproject"", ""SVR_test_App203_Subproject"", ""SVR_test_App204_Subproject"", ""SVR_test_App205_Subproject"", ""SVR_test_App206_Subproject"", ""SVR_test_App207_Subproject"", ""SVR_test_App208_Subproject"", ""SVR_test_App209_Subproject"", ""SVR_test_App210_Subproject"", ""SVR_test_App211_Subproject"", ""SVR_test_App212_Subproject"", ""SVR_test_App213_Subproject"", ""SVR_test_App214_Subproject"", ""SVR_test_App215_Subproject"", ""SVR_test_App216_Subproject"", ""SVR_test_App217_Subproject"", ""SVR_test_App218_Subproject"", ""SVR_test_App219_Subproject"", ""SVR_test_App220_Subproject"", ""SVR_test_App221_Subproject"", ""SVR_test_App222_Subproject"", ""SVR_test_App223_Subproject"", ""SVR_test_App224_Subproject"", ""SVR_test_App225_Subproject"", ""SVR_test_App226_Subproject"", ""SVR_test_App227_Subproject"", ""SVR_test_App228_Subproject"", ""SVR_test_App229_Subproject"", ""SVR_test_App230_Subproject"", ""SVR_test_App231_Subproject"", ""SVR_test_App232_Subproject"", ""SVR_test_App233_Subproject"", ""SVR_test_App234_Subproject"", ""SVR_test_App235_Subproject"", ""SVR_test_App236_Subproject"", ""SVR_test_App237_Subproject"", ""SVR_test_App238_Subproject"", ""SVR_test_App239_Subproject"", ""SVR_test_App240_Subproject"", ""SVR_test_App241_Subproject"", ""SVR_test_App242_Subproject"", ""SVR_test_App243_Subproject"", ""SVR_test_App244_Subproject"", ""SVR_test_App245_Subproject"", ""SVR_test_App246_Subproject"", ""SVR_test_App247_Subproject"", ""SVR_test_App248_Subproject"", ""SVR_test_App249_Subproject"", ""SVR_test_App250_Subproject"", ""SVR_test_App251_Subproject"", ""SVR_test_App252_Subproject"", ""SVR_test_App253_Subproject"", ""SVR_test_App254_Subproject"", ""SVR_test_App255_Subproject"", ""SVR_test_App256_Subproject"", ""SVR_test_App257_Subproject"", ""SVR_test_App258_Subproject"", ""SVR_test_App259_Subproject"", ""SVR_test_App260_Subproject"", ""SVR_test_App261_Subproject"", ""SVR_test_App262_Subproject"", ""SVR_test_App263_Subproject"", ""SVR_test_App264_Subproject"", ""SVR_test_App265_Subproject"", ""SVR_test_App266_Subproject"", ""SVR_test_App267_Subproject"", ""SVR_test_App268_Subproject"", ""SVR_test_App269_Subproject"", ""SVR_test_App270_Subproject"", ""SVR_test_App271_Subproject"", ""SVR_test_App272_Subproject"", ""SVR_test_App273_Subproject"", ""SVR_test_App274_Subproject"", ""SVR_test_App275_Subproject"", ""SVR_test_App276_Subproject"", ""SVR_test_App277_Subproject"", ""SVR_test_App278_Subproject"", ""SVR_test_App279_Subproject"", ""SVR_test_App280_Subproject"", ""SVR_test_App281_Subproject"", ""SVR_test_App282_Subproject"", ""SVR_test_App283_Subproject"", ""SVR_test_App284_Subproject"", ""SVR_test_App285_Subproject"", ""SVR_test_App286_Subproject"", ""SVR_test_App287_Subproject"", ""SVR_test_App288_Subproject"", ""SVR_test_App289_Subproject"", ""SVR_test_App290_Subproject"", ""SVR_test_App291_Subproject"", ""SVR_test_App292_Subproject"", ""SVR_test_App293_Subproject"", ""SVR_test_App294_Subproject"", ""SVR_test_App295_Subproject"", ""SVR_test_App296_Subproject"", ""SVR_test_App297_Subproject"", ""SVR_test_App298_Subproject"", ""SVR_test_App299_Subproject"", ""SVR_test_App300_Subproject"", ""SVR_test_App301_Subproject"", ""SVR_test_App302_Subproject"", ""SVR_test_App303_Subproject"", ""SVR_test_App304_Subproject"", ""SVR_test_App305_Subproject"", ""SVR_test_App306_Subproject"", ""SVR_test_App307_Subproject"", ""SVR_test_App308_Subproject"", ""SVR_test_App309_Subproject"", ""SVR_test_App310_Subproject"", ""SVR_test_App311_Subproject"", ""SVR_test_App312_Subproject"", ""SVR_test_App313_Subproject"", ""SVR_test_App314_Subproject"", ""SVR_test_App315_Subproject"", ""SVR_test_App316_Subproject"", ""SVR_test_App317_Subproject"", ""SVR_test_App318_Subproject"", ""SVR_test_App319_Subproject"", ""SVR_test_App320_Subproject"", ""SVR_test_App321_Subproject"", ""SVR_test_App322_Subproject"", ""SVR_test_App323_Subproject"", ""SVR_test_App324_Subproject"", ""SVR_test_App325_Subproject"", ""SVR_test_App326_Subproject"", ""SVR_test_App327_Subproject"", ""SVR_test_App328_Subproject"", ""SVR_test_App329_Subproject"", ""SVR_test_App330_Subproject"", ""SVR_test_App331_Subproject"", ""SVR_test_App332_Subproject"", ""SVR_test_App333_Subproject"", ""SVR_test_App334_Subproject"", ""SVR_test_App335_Subproject"", ""SVR_test_App336_Subproject"", ""SVR_test_App337_Subproject"", ""SVR_test_App338_Subproject"", ""SVR_test_App339_Subproject"", ""SVR_test_App340_Subproject"", ""SVR_test_App341_Subproject"", ""SVR_test_App342_Subproject"", ""SVR_test_App343_Subproject"", ""SVR_test_App344_Subproject"", ""SVR_test_App345_Subproject"", ""SVR_test_App346_Subproject"", ""SVR_test_App347_Subproject"", ""SVR_test_App348_Subproject"", ""SVR_test_App349_Subproject"", ""SVR_test_App350_Subproject"", ""SVR_test_App351_Subproject"", ""SVR_test_App352_Subproject"", ""SVR_test_App353_Subproject"", ""SVR_test_App354_Subproject"", ""SVR_test_App355_Subproject"", ""SVR_test_App356_Subproject"", ""SVR_test_App357_Subproject"", ""SVR_test_App358_Subproject"", ""SVR_test_App359_Subproject"", ""SVR_test_App360_Subproject"", ""SVR_test_App361_Subproject"", ""SVR_test_App362_Subproject"", ""SVR_test_App363_Subproject"", ""SVR_test_App364_Subproject"", ""SVR_test_App365_Subproject"", ""SVR_test_App366_Subproject"", ""SVR_test_App367_Subproject"", ""SVR_test_App368_Subproject"", ""SVR_test_App369_Subproject"", ""SVR_test_App370_Subproject"", ""SVR_test_App371_Subproject"", ""SVR_test_App372_Subproject"", ""SVR_test_App373_Subproject"", ""SVR_test_App374_Subproject"", ""SVR_test_App375_Subproject"", ""SVR_test_App376_Subproject"", ""SVR_test_App377_Subproject"", ""SVR_test_App378_Subproject"", ""SVR_test_App379_Subproject"", ""SVR_test_App380_Subproject"", ""SVR_test_App381_Subproject"", ""SVR_test_App382_Subproject"", ""SVR_test_App383_Subproject"", ""SVR_test_App384_Subproject"", ""SVR_test_App385_Subproject"", ""SVR_test_App386_Subproject"", ""SVR_test_App387_Subproject"", ""SVR_test_App388_Subproject"", ""SVR_test_App389_Subproject"", ""SVR_test_App390_Subproject"", ""SVR_test_App391_Subproject"", ""SVR_test_App392_Subproject"", ""SVR_test_App393_Subproject"", ""SVR_test_App394_Subproject"", ""SVR_test_App395_Subproject"", ""SVR_test_App396_Subproject"", ""SVR_test_App397_Subproject"", ""SVR_test_App398_Subproject"", ""SVR_test_App399_Subproject"", ""SVR_test_App400_Subproject"", ""SVR_test_App401_Subproject"", ""SVR_test_App402_Subproject"", ""SVR_test_App403_Subproject"", ""SVR_test_App404_Subproject"", ""SVR_test_App405_Subproject"", ""SVR_test_App406_Subproject"", ""SVR_test_App407_Subproject"", ""SVR_test_App408_Subproject"", ""SVR_test_App409_Subproject"", ""SVR_test_App410_Subproject"", ""SVR']"
6f6d3177d8b7687637ccd6111f8a6e45,"In some cases it is required inside the application to change the SCI_UART parameters runtime. Users can do this in FSP by declaring a new configuration structure variable, that will contain the new desired settings and then re-initialize UART with the new settings. This should be done of course after de-initializing the UART before.
In some cases it is required inside the application to change the SCI_UART parameters runtime. Users can do this in FSP by declaring a new configuration structure variable, that will contain the new desired settings and then re-initialize UART with the new settings. This should be done of course after de-initializing the UART before.
The code inside the application should look like this:
The code inside the application should look like this:
As example, a project developed in FSP 5.6.0 and EK-RA6M3 is attached in which the UART channel is changed runtime, by using only one UART instance in the application project.
As example, a project developed in FSP 5.6.0 and EK-RA6M3 is attached in which the UART channel is changed runtime, by using only one UART instance in the application project.
With the same way a new configuration structure is declared to hold the new configurations for SCI9. And inside the project as soon as UART instance is de-initialized for SCI0 by calling the close() API, the UART instance re-initializes by calling the open() API and passing now as second argument a pointer to the new configuration structure containing the new settings.
With the same way a new configuration structure is declared to hold the new configurations for SCI9. And inside the project as soon as UART instance is de-initialized for SCI0 by calling the close() API, the UART instance re-initializes by calling the open() API and passing now as second argument a pointer to the new configuration structure containing the new settings.
To change UART channel runtime and use only one instance it is also important to add in Interrupts Tab these events related with these interrupts, so that UART peripheral will work properly.
To change UART channel runtime and use only one instance it is also important to add in Interrupts Tab these events related with these interrupts, so that UART peripheral will work properly.
And the example is initially transmitting 10 test messages through UART SCI0 (Pins:TXD:P411,RXD:P410) and the rest of the messages are transmitted through UART SCI9 (Pins: TXD:P203, RXD:P202).
And the example is initially transmitting 10 test messages through UART SCI0 (Pins:TXD:P411,RXD:P410) and the rest of the messages are transmitted through UART SCI9 (Pins: TXD:P203, RXD:P202).
For further details check the project sci_uart_change_parameters_runtime.zip attached.
For further details check the project sci_uart_change_parameters_runtime.zip attached.
Suitable Products
Suitable Products
RA Family, FSP
RA Family, FSP","['data/categories/ra_family/rafsp_software/6f6d3177d8b7687637ccd6111f8a6e45/images/d4396d5c501a2cc392d19f63ead65e46.png', 'data/categories/ra_family/rafsp_software/6f6d3177d8b7687637ccd6111f8a6e45/images/f8674810b4b278e8c70e8208754d1f92.png']",[],[],"{'title': 'RA Family: How to change SCI_UART parameters runtime-FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/21690669', 'last_updated': None, 'extracted_at': '2025-03-08T23:16:28.204358'}","In some cases it is required inside the application to change the SCIUART parameters runtime. Users can do this in FSP by declaring a new configuration structure variable, that will contain the new desired settings and then re-initialize UART with the new settings. This should be done of course after de-initializing the UART before. The code inside the application should look like this As example, a project developed in FSP 5.6.0 and EK-RA6M3 is attached in which the UART channel is changed runtime, by using only one UART instance in the application project. With the same way a new configuration structure is declared to hold the new configurations for SCI9. And inside the project as soon as UART instance is de-initialized for SCI0 by calling the close() API, the UART instance re-initializes by calling the open() API and passing now as second argument a pointer to the new configuration structure containing the new settings. To change UART channel runtime and use only one instance it is also important to add in Interrupts Tab these events related with these interrupts, so that UART peripheral will work properly. And the example is initially transmitting 10 test messages through UART SCI0 (PinsTXDP411,RXDP410) and the rest of the messages are transmitted through UART SCI9 (Pins TXDP203, RXDP202). For further details check the project sciuartchangeparametersruntime.zip attached. Suitable Products RA Family, FSP","['The image shows a screenshot of a computer program with a white background and black text. The title at the top reads ""Interrupts Configuration"" in bold black font.\n\nBelow the title, there are two sections: ""User Events"" and ""Allocations"". The ""User Events"" section has a red box around it, highlighting the following events:\n\n* SCI9 RXI (Receive data full)\n* SCI9 TXI (Transmit data empty)\n* SCI9 TEI (Transmit end)\n* SCI9 ERI (Receive error)\n\nThe ""Allocations"" section lists the following interrupts:\n\n* SCI0 RXI (Receive data full)\n* SCI0 TXI (Transmit data empty)\n* SCI0 TEI (Transmit end)\n* SCI0 ERI (Receive error)\n* SCI9 RXI (Receive data full)\n* SCI9 TXI (Transmit data empty)\n* SCI9 TEI (Transmit end)\n* SCI9 ERI (Receive error)\n\nAt the bottom of the page, there is a menu bar with options such as ""Summary"", ""BSP"", ""Clocks"", ""Pins"", ""Interrupts"", ""Event Links"", ""Stacks"", and ""Components"".\n\nIn the top-right corner, there is a green circle with a white checkmark inside it, indicating that the ""New User Event"" button has been clicked. The background of the image is white, with a gray border around the edges. Overall, the image appears to be a screenshot of a computer program used for configuring interrupts in a microcontroller or other embedded system.', 'The image shows a screenshot of a computer program, likely a code editor or IDE (Integrated Development Environment), with a list of lines of code in the center of the screen. The code is written in a programming language, possibly C# or Java, and appears to be a simple program that transmits messages.\n\nHere are the details of the image:\n\n*   **Code Editor/IDE:**\n    *   The program is running on a Windows operating system, as indicated by the title bar at the top of the window.\n    *   The code editor/IDE has a gray background and a white text box in the center of the screen.\n    *   The text box contains a list of lines of code, each with a different color and font size.\n*   **Code:**\n    *   The code is written in a programming language, possibly C# or Java.\n    *   The code appears to be a simple program that transmits messages.\n    *   Each line of code has a different color and font size, indicating different types of code, such as comments, variables, and functions.\n*   **Menu Bar:**\n    *   The menu bar at the top of the window has several options, including ""File"", ""Edit"", ""View"", ""Debug"", and ""Help"".\n    *   The ""File"" menu has options for opening and saving files, as well as creating new projects.\n    *   The ""Edit"" menu has options for cutting, copying, and pasting text, as well as finding and replacing text.\n    *   The ""View"" menu has options for changing the font size and style, as well as toggling the display of line numbers and syntax highlighting.\n    *   The ""Debug"" menu has options for running the program, debugging the program, and viewing the program\'s output.\n    *   The ""Help"" menu has options for accessing the program\'s documentation and contacting support.\n*   **Status Bar:**\n    *   The status bar at the bottom of the window displays information about the program\'s current state, such as the number of lines of code, the number of errors, and the current line number.\n    *   The status bar also displays the name of the current file and the path to the file.\n\nOverall, the image shows a screenshot of a computer program, likely a code editor or IDE, with a list of lines of code in the center of the screen. The code appears to be a simple program that transmits messages, and the program has several menus and options for editing, debugging, and viewing the code.']"
f756c4e1bf322ed1671fe4c62478b884,"Question:
On customized boards and on newer versions of FSP, where external clock source for sub-clock is not setup the project gets stuck on FSP_HARDWARE_REGISTER_WAIT(R_RTC->RCR2_b.RESET, 0);
Answer:
Set the 'Subclock Populated' value to 'Not populated’ on BSP settings on FSP configurator.
  Suitable Products
RA Family
On customized boards and on newer versions of FSP, where external clock source for sub-clock is not setup the project gets stuck on FSP_HARDWARE_REGISTER_WAIT(R_RTC->RCR2_b.RESET, 0);
On customized boards and on newer versions of FSP, where external clock source for sub-clock is not setup the project gets stuck on FSP_HARDWARE_REGISTER_WAIT(R_RTC->RCR2_b.RESET, 0);
On customized boards and on newer versions of FSP, where external clock source for sub-clock is not setup the project gets stuck on FSP_HARDWARE_REGISTER_WAIT(R_RTC->RCR2_b.RESET, 0);
Answer:
Set the 'Subclock Populated' value to 'Not populated’ on BSP settings on FSP configurator.
  Suitable Products
RA Family
Set the 'Subclock Populated' value to 'Not populated’ on BSP settings on FSP configurator.
Set the 'Subclock Populated' value to 'Not populated’ on BSP settings on FSP configurator.
Set the 'Subclock Populated' value to 'Not populated’ on BSP settings on FSP configurator.
Suitable Products
RA Family
日本語 中文
日本語
中文",['data/categories/ra_family/rafsp_software/f756c4e1bf322ed1671fe4c62478b884/images/58bc226fe0c51f5efb99e339049be97b.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'SubClock configuration during FSP for customized boards for RA Family', 'url': 'https://en-support.renesas.com/knowledgeBase/21094268', 'last_updated': '2023-12-10', 'extracted_at': '2025-03-08T23:17:07.705393'}","Question On customized boards and on newer versions of FSP, where external clock source for sub-clock is not setup the project gets stuck on FSPHARDWAREREGISTERWAIT(RRTC-RCR2b.RESET, 0); Answer Set the 'Subclock Populated' value to 'Not populated on BSP settings on FSP configurator. Suitable Products RA Family Suitable Products    ","[""The image shows a screenshot of a computer program's settings menu, with a list of options and their corresponding values. The menu is organized into sections, each with its own set of options and values.\n\n*   **Property**\n    *   part_number: R7FA6E10F2CFP\n    *   rom_size_bytes: 1048576\n    *   ram_size_bytes: 262144\n    *   data_flash_size_bytes: 8192\n    *   package_style: QFP\n    *   package_pins: 100\n*   **RAGE1 series**\n    *   RAGE1 Family: 6\n*   **RAGE1 Family**\n    *   Security: OFSO register settings\n    *   OFS1 register settings: Block Protection Settings (E)\n    *   Permanent Block Protection: Clocks\n    *   Startup C-Cache Line Size: 32 Bytes\n    *   Dual Bank Mode: Disabled\n    *   Main Oscillator Wait Time: 8163 cycles\n*   **RA Common**\n    *   Main stack size (bytes): 0x400\n    *   Heap size (bytes): 0\n    *   MCU Vcc (mV): 3300\n    *   Parameter checking: Disabled\n    *   Assert Failures: Return FSP_ERR_ASSERTION\n    *   Error Log: No Error Log\n    *   Clock Registers not Reset: Disabled\n    *   Main Oscillator Populated: Not Populated\n    *   PFS Protect: Enabled\n    *   C Runtime Initialization: Enabled\n    *   Early BSP Initialization: Disabled\n    *   Main Oscillator Clock Source: Crystal or Resonator\n*   **Subclock Populated**\n    *   Subclock Drive (Drive capa: Standard/Normal mode\n    *   Subclock Stabilization Time: 1000\n\nThe image shows a comprehensive list of settings for a computer program, including properties, security settings, and performance settings. The settings are organized into sections, making it easy to navigate and find the desired option.""]"
0b8504a5b9dc96d02b4177eb55cef291,"During debug it is sometimes useful to capture a time delay between two different debug events. Measuring the delay between two breakpoints, for example, can help identify processing bottlenecks. In e2 studio you can use the DWT report to see the delay in time as well as in clock cycles.
The DWT report needs to know the CPU frequency, so this needs to be set in the debug configuration.
Make sure this frequency reflects the operating frequency of the MCU during debug.
Once this is set, simply use the DWT report, shown at information ribbon at the bottom of the e2 studio window.
Suitable Products
e2 studio
e2 studio
e2 studio","['data/categories/ra_family/rafsp_software/0b8504a5b9dc96d02b4177eb55cef291/images/1ee8a36e62fdc2ca001e67e138bb6d26.png', 'data/categories/ra_family/rafsp_software/0b8504a5b9dc96d02b4177eb55cef291/images/2c3fb4bb7d153b86cae83cba754ac1a2.png']",[],['|  |\n|  |\n| e2 studio |'],"{'title': 'RA Family: Measure Time Interval Between Debug Events in e2 studio', 'url': 'https://en-support.renesas.com/knowledgeBase/19575558', 'last_updated': None, 'extracted_at': '2025-03-08T23:16:07.690627'}","During debug it is sometimes useful to capture a time delay between two different debug events. Measuring the delay between two breakpoints, for example, can help identify processing bottlenecks. In e2 studio you can use the DWT report to see the delay in time as well as in clock cycles. The DWT report needs to know the CPU frequency, so this needs to be set in the debug configuration. Make sure this frequency reflects the operating frequency of the MCU during debug. Once this is set, simply use the DWT report, shown at information ribbon at the bottom of the e2 studio window. Suitable Products e2 studio","['The image shows a screenshot of a computer program\'s settings menu, with the ""Debug hardware"" tab selected. The menu is organized into sections, each with its own set of options and sub-options.\n\n*   **IO**\n    *   Use Default IO Filename: Yes\n    *   IO Filename: $(support area.loc)\n*   **General Debug**\n    *   Reset After Reload: Yes\n*   **Memory**\n    *   Endian: Little Endian\n*   **Break**\n    *   Use Flash Breakpoints: Yes\n    *   Allow Simulation: No\n*   **Flash**\n    *   Flash Bus Type: Flash Memory Type\n    *   WorkRam Start: WorkRam End\n    *   Use CFI-Flash: No\n    *   CFI Start: 0x0\n    *   CFI End: 0x0\n*   **Semihosting**\n    *   Semihosting breakpoint address: \n*   **RTOS**\n    *   RTOS Integration in Debug View: Yes\n    *   RTOS Debugging - Large Number of Threads: No\n*   **Time Measurement**\n    *   Run Break Time Measurement: Yes\n    *   Count Every Core Cycle: Yes\n*   **Operating Frequency [MHz]**\n    *   48.000\n\nThe image shows a computer program\'s settings menu, with the ""Debug hardware"" tab selected. The menu is organized into sections, each with its own set of options and sub-options. The user can adjust various settings, such as the IO filename, general debug settings, memory settings, break settings, flash settings, semihosting settings, RTOS settings, time measurement settings, and operating frequency. The image provides a clear and concise overview of the available settings and their current values.', 'The image shows a screenshot of a computer program, likely a web browser or software application. The screenshot is divided into several sections, each with its own set of information and controls.\n\n*   **Top-left corner:**\n    *   A gray box with white text that reads ""Suspended"".\n    *   A yellow arrow pointing to the right, indicating that the program is currently suspended or paused.\n*   **Center of the screen:**\n    *   A large, light blue rectangle with black text that reads ""89478.48 ms"".\n    *   A small, circular icon with a clock face inside it, indicating the time elapsed since the program was last active.\n*   **Right side of the screen:**\n    *   A green icon with a dollar sign ($) inside it, indicating the amount of money or resources being used by the program.\n    *   A numerical value ""4294967295"" displayed next to the icon, which appears to be a large number representing the amount of money or resources being used.\n*   **Bottom of the screen:**\n    *   A row of icons and buttons, including a clock, a gear, and a question mark, which may represent different functions or settings within the program.\n\nOverall, the image suggests that the program is currently suspended or paused, and is displaying information about the time elapsed since it was last active, as well as the amount of money or resources being used. The icons and buttons at the bottom of the screen may represent different functions or settings within the program.']"
1a335228fcd63ba0f4b90bdb286989ba,"Question:
How to change the settings in FreeRTOSConfig.h ?
Answer:
The FreeRTOS settings defined in FreeRTOSConfig.h can be changed in the thread properties as shown below. If you would like to add any additional macros to the FreeRTOSConfig.h file then add them to a new file and add that file to the ""Custom FreeRTOSConfig.h"" parameter in the configurator.
  Suitable Products
RA/FSP
How to change the settings in FreeRTOSConfig.h ?
How to change the settings in FreeRTOSConfig.h ?
Answer:
The FreeRTOS settings defined in FreeRTOSConfig.h can be changed in the thread properties as shown below. If you would like to add any additional macros to the FreeRTOSConfig.h file then add them to a new file and add that file to the ""Custom FreeRTOSConfig.h"" parameter in the configurator.
  Suitable Products
RA/FSP
The FreeRTOS settings defined in FreeRTOSConfig.h can be changed in the thread properties as shown below. If you would like to add any additional macros to the FreeRTOSConfig.h file then add them to a new file and add that file to the ""Custom FreeRTOSConfig.h"" parameter in the configurator.
The FreeRTOS settings defined in FreeRTOSConfig.h can be changed in the thread properties as shown below. If you would like to add any additional macros to the FreeRTOSConfig.h file then add them to a new file and add that file to the ""Custom FreeRTOSConfig.h"" parameter in the configurator.
Suitable Products
RA/FSP",['data/categories/ra_family/ra_hardware/1a335228fcd63ba0f4b90bdb286989ba/images/e8ec4e0b15b0412b79cd4a38091dbb77.png'],[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'RA Family: How to change the settings in FreeRTOSConfig.h ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21177411', 'last_updated': None, 'extracted_at': '2025-03-08T23:14:14.612953'}","Question How to change the settings in FreeRTOSConfig.h ? Answer The FreeRTOS settings defined in FreeRTOSConfig.h can be changed in the thread properties as shown below. If you would like to add any additional macros to the FreeRTOSConfig.h file then add them to a new file and add that file to the ""Custom FreeRTOSConfig.h"" parameter in the configurator. Suitable Products RA/FSP Suitable Products","['The image shows a screenshot of a computer program\'s settings menu, with the ""New Thread"" option selected. The menu is organized into sections, including ""Property"", ""Value"", and ""Settings"". The ""Property"" section lists various options, such as ""Custom FreeRTOSConfig.h"", ""Use Preemption"", ""Use Port Optimised Task Selection"", ""Use Tickless Idle"", ""CPU Clock Hz"", ""Tick Rate Hz"", ""Max Priorities"", ""Minimal Stack Size"", ""Max Task Name Len"", ""Use 16-bit Ticks"", ""Idle Should Yield"", ""Use Task Notifications"", ""Use Mutexes"", ""Use Recursive Mutexes"", ""Use Counting Semaphores"", ""Queue Registry Size"", ""Use Queue Sets"", ""Use Time Slicing"", ""Use Newlib Reentrant"", ""Enable Backward Compatibility"", ""Num Thread Local Storage Pointers"", ""Stack Depth Type"", ""Message Buffer Length Type"", ""Library Max Syscall Interrupt Priority"", ""Assert"", and ""Include Application Defined Privileged Functions"". The ""Value"" section lists the corresponding values for each option, such as ""my_FreeRTOSConfig.h"", ""Enabled"", ""Disabled"", ""Disabled"", ""SystemCoreClock"", ""1000"", ""5"", ""128"", ""16"", ""Disabled"", ""Enabled"", ""Enabled"", ""Disabled"", ""Disabled"", ""Enabled"", ""10"", ""Disabled"", ""Disabled"", ""Disabled"", ""5"", ""uint32_t"", ""size_t"", ""Priority 1"", ""assert(x)"", and ""Disabled"". The ""Settings"" section includes options such as ""Hooks"", ""Stats"", ""Memory Allocation"", ""Timers"", ""Optional Functions"", ""RA"", and ""Logging"". The background of the image is a light gray color, with a darker gray border around the edges. Overall, the image appears to be a screenshot of a computer program\'s settings menu, with various options and values listed in a clear and organized manner.']"
1a278ce457f18fabab435b5c64477aab,"How to handle the MD pin, when using E2 or E2 Lite emulators on a custom RA2 board?
The RA2 devices use a Cortex-M23 core and they do not support DLM transitions or Trustzone. So, there is no need to connect the MD pin to SWCLK/TCK/MD in order to be able to drive it to low to change the device lifecycle state or set the TrustZone Boundaries.
Also the MD pin is by default pulled-up, since the initial value of PFS register for P201 is 0x00000010 which means that PCR bit is set to 1.
And there is no need to add also an external pull-up resistor.
In case you want to place the MCU to SCI boot mode (the MD pin needs to be driven low) the recommended circuit for MD pin is:
Open-circuit: MD pin (P201) is high level and the MCU is in Single-chip mode (for debugging).
Short-Circuit: MD pin (P201) is low level and MCU will enter SCI boot mode after reset state (#RES pin released).
Resources:
RA2E1 Group User's Manual: Hardware
RA2L1 Group User's Manual: Hardware
RA2E2 Group User's Manual: Hardware
RA2A1 Group User's Manual: Hardware
RA2E3 Group User's Manual: Hardware
RA2A2 Group User's Manual: Hardware
E2 Emulator, E2 Emulator Lite Additional Document for User’s Manual (Notes on Connection of RA Devices)
Suitable Products
RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2
RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2","['data/categories/ra_family/ra_hardware/1a278ce457f18fabab435b5c64477aab/images/660acab83bb2e3e7b33dbf64ae4daa1c.png', 'data/categories/ra_family/ra_hardware/1a278ce457f18fabab435b5c64477aab/images/d42c2b1ec85e8abccf4dda62110b7c83.png', 'data/categories/ra_family/ra_hardware/1a278ce457f18fabab435b5c64477aab/images/65700b0b2b0d955c40e99cea7a5bea94.png']",[],[],"{'title': 'How to handle the MD pin, when using E2 or E2 Lite emulators on a custom RA2 board?', 'url': 'https://en-support.renesas.com/knowledgeBase/21671697', 'last_updated': None, 'extracted_at': '2025-03-08T23:14:03.238606'}","How to handle the MD pin, when using E2 or E2 Lite emulators on a custom RA2 board? The RA2 devices use a Cortex-M23 core and they do not support DLM transitions or Trustzone. So, there is no need to connect the MD pin to SWCLK/TCK/MD in order to be able to drive it to low to change the device lifecycle state or set the TrustZone Boundaries. Also the MD pin is by default pulled-up, since the initial value of PFS register for P201 is 0x00000010 which means that PCR bit is set to 1. And there is no need to add also an external pull-up resistor. In case you want to place the MCU to SCI boot mode (the MD pin needs to be driven low) the recommended circuit for MD pin is Open-circuit MD pin (P201) is high level and the MCU is in Single-chip mode (for debugging). Short-Circuit MD pin (P201) is low level and MCU will enter SCI boot mode after reset state (RES pin released). Resources RA2E1 Group User's Manual Hardware RA2L1 Group User's Manual Hardware RA2E2 Group User's Manual Hardware RA2A1 Group User's Manual Hardware RA2E3 Group User's Manual Hardware RA2A2 Group User's Manual Hardware E2 Emulator, E2 Emulator Lite Additional Document for Users Manual (Notes on Connection of RA Devices) Suitable Products RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2","['The image shows a table with a title that reads ""PmnPFS/PmnPFS_HA/PmnPFS_BY: Port mn Pin Function Select Register (m = 0 to 8, n = 00 to 15)"". The table has several columns and rows, with the first row containing column headers. The columns are labeled as follows:\n\n* Bit\n* Symbol\n* Function\n\nThe table appears to be a technical document or datasheet for a microcontroller or other electronic component, and it provides information about the pin functions of the device. The table is likely used by engineers or technicians to design and develop circuits that use this component.\n\nThe table is divided into two main sections: the top section shows the base address and offset address of the register, while the bottom section shows the bit position, symbol, and function of each pin. The bit position column shows the binary value of each pin, ranging from 0 to 31. The symbol column shows the name of each pin, such as ""PODR"" or ""PDR"". The function column describes the purpose of each pin, such as ""Port Output Data"" or ""Pull-up Control"".\n\nOverall, the table provides a detailed and organized overview of the pin functions of the device, making it easier for users to understand and work with the component.', 'The image presents a technical diagram, specifically a circuit diagram, which is a visual representation of an electrical circuit. The diagram is accompanied by a caption that provides additional information about the circuit.\n\n**Circuit Diagram:**\n\n*   The diagram consists of several components, including:\n    *   A 1.5 kΩ resistor\n    *   An open circuit labeled ""Single-chip mode (on-chip debugging)""\n    *   A short circuit labeled ""SCI or USB boot mode""\n    *   An MCU (Microcontroller Unit)\n    *   An MD (Microcontroller Debugger)\n\n**Caption:**\n\n*   The caption reads: ""Figure 2.9 Other than RA6M4, RA6M5, RA6E1, RA4M2, RA4M3, RA4E1, and RA6T2""\n\n**Summary:**\n\nIn summary, the image displays a technical diagram of a circuit, which includes various components such as resistors, open and short circuits, an MCU, and an MD. The caption provides additional context about the circuit, specifically mentioning the types of microcontrollers that are not included in this particular diagram.', 'The image depicts a flowchart illustrating the mode-setting pin level and operating mode. The flowchart consists of three main sections: ""Single-chip mode,"" ""Reset,"" and ""SCI boot mode."" Each section is represented by an oval shape, with arrows connecting them to indicate the flow of the process.\n\n**Single-chip mode**\n\n*   MD = 1 and release RES pin\n*   Release POR\n\n**Reset**\n\n*   RES pin or POR occurs\n*   MD = 0 and release RES pin\n\n**SCI boot mode**\n\n*   SCI boot mode\n\nThe flowchart shows that when the mode-setting pin level is set to 1, the system enters single-chip mode. If the reset pin or power-on reset (POR) occurs, the system resets and enters SCI boot mode. If the mode-setting pin level is set to 0, the system also enters SCI boot mode.\n\nOverall, the flowchart provides a clear and concise overview of the mode-setting pin level and operating mode, making it easy to understand and follow the process.']"
2bed78d04899c936b6e2e1aa93932a2b,"Question:
CPU Performance Difference when C-/S-caches are on/off
Answer:
For Renesas Cortex-M33 RA6M4 and RA6M5 MCUs, there are system level caches for both instruction cache and data cache, which help to improve instruction and data fetch speed. The data cache is named S-Cache in the Renesas RA6M4/RA6M5 MCU Hardware User’s Manual, and it’s on the MCU’s system bus. The instruction cache is named C-Cache, and it’s on the code bus. The Cache detail specifications, which includes Capacity, Way, Line Size, Write Way, Cache Support Area, etc., can be found through the Renesas RA6M4/RA6M5 MCU Hardware User’s Manual Table 14.9. Basically, this article briefly showcases how the RA6M4 or RA6M5 CPU performance is influenced based on different combinations of C-cache, and S-cache configuration. The relevant information about benchmark testing conditions as well as the result comparison is described below.
The environment of Benchmark testing:
MCU and the runtime environment initialization (SystemInit) is based on FSPv5.0.0
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize More)
System Clock configuration: ICLK=200MHz
Board: EK-RA6M4
The first method of CPU performance measurement:
A simple For loop with accumulation operation
Toggling GPIO before and after the calculation


The CPU process time measurement from output level change:
Config Option S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 820us
2 Disable Enable Enable 1.47ms
3 Disable Disable*1 Enable 2.46ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
According to the above result, enabling the S-Cache can significantly improve MCU performance because the measured operation basically focuses on the SRAM write access. When the S-Cache is enabled, the access cycle of SRAM write is reduced from 2 cycles to 1 cycle. Especially if the system clock ICLK is configured to 100MHz or less, accessing SRAM is always 0 wait state. At such condition, enabling the S-Cache to reduce the required cycle of SRAM write access can obviously improve the performance.
The second method of CPU performance measurement:
Fixed point iteration method for locating the real roots of an equation within a specified iteration cycle
Toggling GPIO before and after the calculation

The CPU process time measurement from output level change:
  S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 3.125ms
2 Disable Enable Enable 3.81ms
3 Disable Disable*1 Enable 6.97ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
For this measured operation, enabling the C-Cache, which reduces the required access cycle of instruction fetch, can significantly improve the MCU performance. When the C-cache is enabled and the cacheable access is from CPU, the read access is one cycle if C-cache is hit. For the C-Cache is missed while C-Cache operation is enabled, or C-cache is disabled, the read access is three cycles.
Reference Attachments:
Example project on EK-RA6M4 for above benchmark testing (below)
Example project on EK-RA6M5 for above benchmark testing (below)
Suitable Products
RA6M4, RA6M5
CPU Performance Difference when C-/S-caches are on/off
CPU Performance Difference when C-/S-caches are on/off
Answer:
For Renesas Cortex-M33 RA6M4 and RA6M5 MCUs, there are system level caches for both instruction cache and data cache, which help to improve instruction and data fetch speed. The data cache is named S-Cache in the Renesas RA6M4/RA6M5 MCU Hardware User’s Manual, and it’s on the MCU’s system bus. The instruction cache is named C-Cache, and it’s on the code bus. The Cache detail specifications, which includes Capacity, Way, Line Size, Write Way, Cache Support Area, etc., can be found through the Renesas RA6M4/RA6M5 MCU Hardware User’s Manual Table 14.9. Basically, this article briefly showcases how the RA6M4 or RA6M5 CPU performance is influenced based on different combinations of C-cache, and S-cache configuration. The relevant information about benchmark testing conditions as well as the result comparison is described below.
The environment of Benchmark testing:
MCU and the runtime environment initialization (SystemInit) is based on FSPv5.0.0
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize More)
System Clock configuration: ICLK=200MHz
Board: EK-RA6M4
The first method of CPU performance measurement:
A simple For loop with accumulation operation
Toggling GPIO before and after the calculation


The CPU process time measurement from output level change:
Config Option S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 820us
2 Disable Enable Enable 1.47ms
3 Disable Disable*1 Enable 2.46ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
According to the above result, enabling the S-Cache can significantly improve MCU performance because the measured operation basically focuses on the SRAM write access. When the S-Cache is enabled, the access cycle of SRAM write is reduced from 2 cycles to 1 cycle. Especially if the system clock ICLK is configured to 100MHz or less, accessing SRAM is always 0 wait state. At such condition, enabling the S-Cache to reduce the required cycle of SRAM write access can obviously improve the performance.
The second method of CPU performance measurement:
Fixed point iteration method for locating the real roots of an equation within a specified iteration cycle
Toggling GPIO before and after the calculation

The CPU process time measurement from output level change:
  S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 3.125ms
2 Disable Enable Enable 3.81ms
3 Disable Disable*1 Enable 6.97ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
For this measured operation, enabling the C-Cache, which reduces the required access cycle of instruction fetch, can significantly improve the MCU performance. When the C-cache is enabled and the cacheable access is from CPU, the read access is one cycle if C-cache is hit. For the C-Cache is missed while C-Cache operation is enabled, or C-cache is disabled, the read access is three cycles.
Reference Attachments:
Example project on EK-RA6M4 for above benchmark testing (below)
Example project on EK-RA6M5 for above benchmark testing (below)
Suitable Products
RA6M4, RA6M5
For Renesas Cortex-M33 RA6M4 and RA6M5 MCUs, there are system level caches for both instruction cache and data cache, which help to improve instruction and data fetch speed. The data cache is named S-Cache in the Renesas RA6M4/RA6M5 MCU Hardware User’s Manual, and it’s on the MCU’s system bus. The instruction cache is named C-Cache, and it’s on the code bus. The Cache detail specifications, which includes Capacity, Way, Line Size, Write Way, Cache Support Area, etc., can be found through the Renesas RA6M4/RA6M5 MCU Hardware User’s Manual Table 14.9. Basically, this article briefly showcases how the RA6M4 or RA6M5 CPU performance is influenced based on different combinations of C-cache, and S-cache configuration. The relevant information about benchmark testing conditions as well as the result comparison is described below.
The environment of Benchmark testing:
MCU and the runtime environment initialization (SystemInit) is based on FSPv5.0.0
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize More)
System Clock configuration: ICLK=200MHz
Board: EK-RA6M4
The first method of CPU performance measurement:
A simple For loop with accumulation operation
Toggling GPIO before and after the calculation


The CPU process time measurement from output level change:
Config Option S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 820us
2 Disable Enable Enable 1.47ms
3 Disable Disable*1 Enable 2.46ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
According to the above result, enabling the S-Cache can significantly improve MCU performance because the measured operation basically focuses on the SRAM write access. When the S-Cache is enabled, the access cycle of SRAM write is reduced from 2 cycles to 1 cycle. Especially if the system clock ICLK is configured to 100MHz or less, accessing SRAM is always 0 wait state. At such condition, enabling the S-Cache to reduce the required cycle of SRAM write access can obviously improve the performance.
The second method of CPU performance measurement:
Fixed point iteration method for locating the real roots of an equation within a specified iteration cycle
Toggling GPIO before and after the calculation

The CPU process time measurement from output level change:
  S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 3.125ms
2 Disable Enable Enable 3.81ms
3 Disable Disable*1 Enable 6.97ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
For this measured operation, enabling the C-Cache, which reduces the required access cycle of instruction fetch, can significantly improve the MCU performance. When the C-cache is enabled and the cacheable access is from CPU, the read access is one cycle if C-cache is hit. For the C-Cache is missed while C-Cache operation is enabled, or C-cache is disabled, the read access is three cycles.
Reference Attachments:
Example project on EK-RA6M4 for above benchmark testing (below)
Example project on EK-RA6M5 for above benchmark testing (below)
For Renesas Cortex-M33 RA6M4 and RA6M5 MCUs, there are system level caches for both instruction cache and data cache, which help to improve instruction and data fetch speed. The data cache is named S-Cache in the Renesas RA6M4/RA6M5 MCU Hardware User’s Manual, and it’s on the MCU’s system bus. The instruction cache is named C-Cache, and it’s on the code bus. The Cache detail specifications, which includes Capacity, Way, Line Size, Write Way, Cache Support Area, etc., can be found through the Renesas RA6M4/RA6M5 MCU Hardware User’s Manual Table 14.9. Basically, this article briefly showcases how the RA6M4 or RA6M5 CPU performance is influenced based on different combinations of C-cache, and S-cache configuration. The relevant information about benchmark testing conditions as well as the result comparison is described below.
The environment of Benchmark testing:
The first method of CPU performance measurement:
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
According to the above result, enabling the S-Cache can significantly improve MCU performance because the measured operation basically focuses on the SRAM write access. When the S-Cache is enabled, the access cycle of SRAM write is reduced from 2 cycles to 1 cycle. Especially if the system clock ICLK is configured to 100MHz or less, accessing SRAM is always 0 wait state. At such condition, enabling the S-Cache to reduce the required cycle of SRAM write access can obviously improve the performance.
The second method of CPU performance measurement:
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
For this measured operation, enabling the C-Cache, which reduces the required access cycle of instruction fetch, can significantly improve the MCU performance. When the C-cache is enabled and the cacheable access is from CPU, the read access is one cycle if C-cache is hit. For the C-Cache is missed while C-Cache operation is enabled, or C-cache is disabled, the read access is three cycles.
Reference Attachments:
Suitable Products
RA6M4, RA6M5","['data/categories/ra_family/ra_hardware/2bed78d04899c936b6e2e1aa93932a2b/images/ccc102eeb158ae50086aaf6f534cdff2.png', 'data/categories/ra_family/ra_hardware/2bed78d04899c936b6e2e1aa93932a2b/images/7c8e9f9013a637dafa927d9060c959ca.png', 'data/categories/ra_family/ra_hardware/2bed78d04899c936b6e2e1aa93932a2b/images/53b450079879257082d5f3e6107402c6.jpg']",[],"['|  |\n|  |\n| Config Option | S-Cache control | C-Cache control | F-Cache control | Process time |\n| 1 | Enable*1 | Enable | Enable | 820us |\n| 2 | Disable | Enable | Enable | 1.47ms |\n| 3 | Disable | Disable*1 | Enable | 2.46ms |', '|  |\n|  |\n|  | S-Cache control | C-Cache control | F-Cache control | Process time |\n| 1 | Enable*1 | Enable | Enable | 3.125ms |\n| 2 | Disable | Enable | Enable | 3.81ms |\n| 3 | Disable | Disable*1 | Enable | 6.97ms |', '|  |\n|  |\n| RA6M4, RA6M5 |']","{'title': 'RA6M4/RA6M5: CPU Performance Difference when C-/S-caches are on/off', 'url': 'https://en-support.renesas.com/knowledgeBase/21177407', 'last_updated': None, 'extracted_at': '2025-03-08T23:14:18.098153'}","Question CPU Performance Difference when C-/S-caches are on/off Answer For Renesas Cortex-M33 RA6M4 and RA6M5 MCUs, there are system level caches for both instruction cache and data cache, which help to improve instruction and data fetch speed. The data cache is named S-Cache in the Renesas RA6M4/RA6M5 MCU Hardware Users Manual, and its on the MCUs system bus. The instruction cache is named C-Cache, and its on the code bus. The Cache detail specifications, which includes Capacity, Way, Line Size, Write Way, Cache Support Area, etc., can be found through the Renesas RA6M4/RA6M5 MCU Hardware Users Manual Table 14.9. Basically, this article briefly showcases how the RA6M4 or RA6M5 CPU performance is influenced based on different combinations of C-cache, and S-cache configuration. The relevant information about benchmark testing conditions as well as the result comparison is described below. The environment of Benchmark testing MCU and the runtime environment initialization (SystemInit) is based on FSPv5.0.0 Compiler GCC10.3.1 Compiler Optimization Level O2 (Optimize More) System Clock configuration ICLK200MHz Board EK-RA6M4 The first method of CPU performance measurement A simple For loop with accumulation operation Toggling GPIO before and after the calculation The CPU process time measurement from output level change Config Option S-Cache control C-Cache control F-Cache control Process time 1 Enable1 Enable Enable 820us 2 Disable Enable Enable 1.47ms 3 Disable Disable1 Enable 2.46ms Note1 Change at the beginning of the application. Others are default setting after FSP SystemInit. According to the above result, enabling the S-Cache can significantly improve MCU performance because the measured operation basically focuses on the SRAM write access. When the S-Cache is enabled, the access cycle of SRAM write is reduced from 2 cycles to 1 cycle. Especially if the system clock ICLK is configured to 100MHz or less, accessing SRAM is always 0 wait state. At such condition, enabling the S-Cache to reduce the required cycle of SRAM write access can obviously improve the performance. The second method of CPU performance measurement Fixed point iteration method for locating the real roots of an equation within a specified iteration cycle S-Cache control C-Cache control F-Cache control Process time 1 Enable1 Enable Enable 3.125ms 2 Disable Enable Enable 3.81ms 3 Disable Disable1 Enable 6.97ms For this measured operation, enabling the C-Cache, which reduces the required access cycle of instruction fetch, can significantly improve the MCU performance. When the C-cache is enabled and the cacheable access is from CPU, the read access is one cycle if C-cache is hit. For the C-Cache is missed while C-Cache operation is enabled, or C-cache is disabled, the read access is three cycles. Reference Attachments Example project on EK-RA6M4 for above benchmark testing (below) Example project on EK-RA6M5 for above benchmark testing (below) Suitable Products RA6M4, RA6M5","['The image displays a code snippet in C# that measures the execution time of a specific block of code. The code is written in a monospaced font and is colored in various shades of green, blue, and red.\n\nThe code begins with the line `R_BSP_PinWrite((bsp_io_port_pin_t) pin, BSP_IO_LEVEL_HIGH);`, which sets the pin to a high level. This is followed by a for loop that iterates from 0 to 0x7FFF, incrementing by 1 each time. Inside the loop, the code calls the `test_cnt++` function, which increments a counter variable.\n\nAfter the loop, the code calls `R_BSP_PinWrite((bsp_io_port_pin_t) pin, BSP_IO_LEVEL_LOW);`, which sets the pin to a low level. Finally, the code prints the value of the counter variable using the `Console.WriteLine` function.\n\nThe code is likely used to measure the execution time of the loop, as the pin is set to high before the loop starts and set to low after the loop ends. The counter variable is incremented inside the loop, and its value is printed at the end. This allows the programmer to measure the number of iterations performed during the execution of the loop.\n\nOverall, the code provides a simple way to measure the execution time of a block of code and can be useful for debugging and optimization purposes.', ""The image presents a code snippet in C++ that calculates the root of a cubic equation using the Newton-Raphson method. The code is written in a clear and concise manner, with comments explaining each step of the process.\n\nHere is a detailed breakdown of the code:\n\n*   The first line defines a function `R_BSP_PinWrite` that takes two arguments: `bsp_io_port_pin_t` and `BSP_IO_LEVEL_HIGH`. This function is used to write a value to a specific pin on a microcontroller.\n*   The second line defines a variable `e` and initializes it to 100.0. This variable represents the error tolerance for the Newton-Raphson method.\n*   The third line defines a variable `x[0]` and initializes it to 1.0. This variable represents the initial guess for the root of the equation.\n*   The fourth line defines a variable `j` and initializes it to 0. This variable is used as an index to iterate through the array `x`.\n*   The fifth line defines a while loop that continues until the error tolerance `e` is less than a certain threshold (in this case, 0.0000001).\n*   Inside the while loop, the code calculates the derivative of the function at the current point `x[j]` using the formula `f'(x[j]) = (float)f(x[j])`.\n*   The code then calculates the new estimate for the root using the formula `x[j+1] = x[j] - f(x[j]) / f'(x[j])`.\n*   The code also updates the error tolerance `e` using the formula `e = x[j+1] - x[j]`.\n*   The code repeats this process until the error tolerance `e` is less than the threshold.\n*   Finally, the code prints the final value of `x[j]` as the root of the equation.\n\nOverall, the code provides a clear and efficient implementation of the Newton-Raphson method for finding the root of a cubic equation.""]"
c4c4ce18c55c3d890ac5327a7d635d14,"Answer:
The RA6T2 General PWM Timer (GPT) supports Complementary the PWM mode, which can generate a three-phase PWM waveform with dead time and ensure the linearity in the vicinity of duty 0% and 100%. Therefore, this article takes Complementary PWM mode 3 (transfer at both crests and troughs) as an example to illustrate how to enable this operating mode based upon the FSP General PWM Timer Driver* (r_gpt).
*As Complementary PWM operating mode is not generally supported by other RA MCU General PWM Timer (GPT) peripheral, the configuration of FSP General PWM Timer Driver (r_gpt) does not support it as default.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output:
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.
  Step 1: Create a Renesas RA C/C++ Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective.
From the toolbar of e2studio, select File > New > RA C/C++ Project > Renesas RA
Flat (Non-TrustZone) Project is selected
RTOS selection is No RTOS.
Bare Metal (Minimal) is selected.
Step 2: In the Stacks option of FSP configuration window, first we add “Three-Phase PWM module (r_gpt_three_phase) in the HAL/Common Stacks. The Three-Phase PWM module can be found under the Timer category.
New Stack > Timers > Three-Phase PWM (r_gpt_three_phase)
  Step 3: After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers.
Select one of the r_gpt modules and configure “Pin Output Support” property to Enabled with Extra Features
Step 4: Configure Three-Phase PWM module (r_gpt_three_phase) with the settings below. The default value of other properties is kept.
General > Period: 10
General > Period Unit: Kilohertz
General > GPT U-Channel: 4
General > GPT V-Channel: 5
General > GPT W-Channel: 6
Extra Features > Dead Time > Dead Time Count Up (Raw Counts): 240
In complementary PWM mode, the GTDVD register is invalid and the GTDVU register is used as the dead time value during both up-counting and down-counting. Therefore, we only need to configure Dead Time Count Up (Raw Counts).
  Step 5: Configure the g_timer1, which is used for U signal output, with the setting below through FSP configuration.
Interrupts > Callback: gpt_u_callback
Interrupts > Overflow/Crest Interrupt Priority: Priority 1
Interrupts > Underflow/Trough Interrupt Priority: Priority 1
Because the GPT callback channel is set to U channel, we should register a user callback function to the U channel GPT. In addition, we will use Complementary PWM mode 3 to transfer the data count at both crest and trough sections, so both Crest Interrupt and Trough Interrupt are enabled.
  Step 6: Assign the required MCU Pins for running this example
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT
GTCPPO4: PB10 (used as PWM Synchronous Output Pin)
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT4
GTIOC4A: PB04
GTIOC4B: PB05
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT5
GTIOC5A: PB06
GTIOC5B: PB07
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT6
GTIOC6A: PB08
GTIOC6B: PB09
  Step 7: Add the below initialization function, which enables Complementary PWM mode 3 usage, in the hal_entry.c.
static fsp_err_t gpt_complementary_pwm_mode_3_init (void)
{
    fsp_err_t err = FSP_SUCCESS;
    /* Initializes the module. */
    err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);
    /* Handle any errors. This function should be defined by the user. */
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    R_GPT4->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT5->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT6->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    /*
     * GTBER: General PWM Timer Buffer Enable
     * - BD0: GTCCR Buffer Operation
     * - BD1: GTPR Buffer Operation
     * - BD2: GTADTRA/GTADTRB Buffer Operation
     * - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)
     */
    R_GPT4->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT4->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT4->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT5->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT5->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT5->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT6->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT6->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT6->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT4->GTPDBR = 6000;
    R_GPT5->GTPDBR = 6000;
    R_GPT6->GTPDBR = 6000;
    /*
     * GTIOR : General PWM Timer I/O Control Register
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b
     * GTIOA = 0x09
     *  - Initial output is Low (Active level is High),
     *  - High output in up count compare match
     *  - Low output in down count compare match
     * GTIOB = 0x06
     *  - Initial output is Low (Active level is High),
     *  - Low output in up count compare match
     *  - High output in down count compare match
     */
    R_GPT4->GTIOR_b.GTIOA = 0x09;
    R_GPT5->GTIOR_b.GTIOA = 0x09;
    R_GPT6->GTIOR_b.GTIOA = 0x09;
    R_GPT4->GTIOR_b.GTIOB = 0x06;
    R_GPT5->GTIOR_b.GTIOB = 0x06;
    R_GPT6->GTIOR_b.GTIOB = 0x06;
    /*PSYE: PWM Synchronous output Enable:
     * Enable GTCPPOT4 output */
    R_GPT4->GTIOR_b.PSYE = 1;
    /*
     * GTBER2: General PWM Timer Buffer Enable 2
     * - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4
     * - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select
     * - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select
     */
    R_GPT4->GTBER2_b.CP3DB = 0;
    R_GPT4->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.CP3DB = 0;
    R_GPT5->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.CP3DB = 0;
    R_GPT6->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    /* Start the timer. */
    err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    return FSP_SUCCESS;
}
  Step 8: Add the below code, which includes the implementation of gpt_u_callback, in the hal_entry.c
static volatile int direction = 1; // 1 for incrementing, -1 for decrementing
static volatile int u2_count_u = 0U;
static void rm_motor_driver_set_uvw_duty_test (void)
{
    u2_count_u += direction;
    // Check if the counter needs to change direction
    if (u2_count_u == 6240) {
        direction = -1; // Switch to decrementing
    } else if (u2_count_u == 0) {
        direction = 1; // Switch to incrementing
    }
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
}
  #define DEBUG_OUTPUT_PD00_ENABLE 1
void gpt_u_callback(timer_callback_args_t *p_args)
{
    /* TODO: add your own code here */
    if(p_args->event == TIMER_EVENT_CREST)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_LOW);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
      if(p_args->event == TIMER_EVENT_TROUGH)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_HIGH);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
}
  Step 9: Add below code in the beginning of hal_entry.c
enum e_gpt_three_phase_prv_gtccr
{
    GPT_THREE_PHASE_PRV_GTCCRA = 0U,
    GPT_THREE_PHASE_PRV_GTCCRB,
    GPT_THREE_PHASE_PRV_GTCCRC,
    GPT_THREE_PHASE_PRV_GTCCRE,
    GPT_THREE_PHASE_PRV_GTCCRD,
    GPT_THREE_PHASE_PRV_GTCCRF
};
static fsp_err_t gpt_complementary_pwm_mode_3_init (void);
  Step 10: In the hal_entry(), make a call to gpt_complementary_pwm_mode_3_init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTn_OVF and GPTn_UDF interrupts.
GPTn_OVF: In complementary PWM mode, these interrupts request are enabled at crests (GTCNT counter value of master channel changes from GTPR register to GTPR register value minus 1)
GPTn_UDF: In complementary PWM mode, these interrupt requests are enabled at troughs (GTCNT counter value of master channel changes from 0 to 1)
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t err = FSP_SUCCESS;
    /* Complementary PWM mode Setting */
    err = gpt_complementary_pwm_mode_3_init();
    assert(err == FSP_SUCCESS);
    while(1)
    {
    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}
  Step 11: Do a quick measurement to verify whether the result matches our target operation.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output: 
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.


    Suitable Products
RA6T2
Answer:
The RA6T2 General PWM Timer (GPT) supports Complementary the PWM mode, which can generate a three-phase PWM waveform with dead time and ensure the linearity in the vicinity of duty 0% and 100%. Therefore, this article takes Complementary PWM mode 3 (transfer at both crests and troughs) as an example to illustrate how to enable this operating mode based upon the FSP General PWM Timer Driver* (r_gpt).
*As Complementary PWM operating mode is not generally supported by other RA MCU General PWM Timer (GPT) peripheral, the configuration of FSP General PWM Timer Driver (r_gpt) does not support it as default.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output:
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.
  Step 1: Create a Renesas RA C/C++ Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective.
From the toolbar of e2studio, select File > New > RA C/C++ Project > Renesas RA
Flat (Non-TrustZone) Project is selected
RTOS selection is No RTOS.
Bare Metal (Minimal) is selected.
Step 2: In the Stacks option of FSP configuration window, first we add “Three-Phase PWM module (r_gpt_three_phase) in the HAL/Common Stacks. The Three-Phase PWM module can be found under the Timer category.
New Stack > Timers > Three-Phase PWM (r_gpt_three_phase)
  Step 3: After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers.
Select one of the r_gpt modules and configure “Pin Output Support” property to Enabled with Extra Features
Step 4: Configure Three-Phase PWM module (r_gpt_three_phase) with the settings below. The default value of other properties is kept.
General > Period: 10
General > Period Unit: Kilohertz
General > GPT U-Channel: 4
General > GPT V-Channel: 5
General > GPT W-Channel: 6
Extra Features > Dead Time > Dead Time Count Up (Raw Counts): 240
In complementary PWM mode, the GTDVD register is invalid and the GTDVU register is used as the dead time value during both up-counting and down-counting. Therefore, we only need to configure Dead Time Count Up (Raw Counts).
  Step 5: Configure the g_timer1, which is used for U signal output, with the setting below through FSP configuration.
Interrupts > Callback: gpt_u_callback
Interrupts > Overflow/Crest Interrupt Priority: Priority 1
Interrupts > Underflow/Trough Interrupt Priority: Priority 1
Because the GPT callback channel is set to U channel, we should register a user callback function to the U channel GPT. In addition, we will use Complementary PWM mode 3 to transfer the data count at both crest and trough sections, so both Crest Interrupt and Trough Interrupt are enabled.
  Step 6: Assign the required MCU Pins for running this example
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT
GTCPPO4: PB10 (used as PWM Synchronous Output Pin)
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT4
GTIOC4A: PB04
GTIOC4B: PB05
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT5
GTIOC5A: PB06
GTIOC5B: PB07
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT6
GTIOC6A: PB08
GTIOC6B: PB09
  Step 7: Add the below initialization function, which enables Complementary PWM mode 3 usage, in the hal_entry.c.
static fsp_err_t gpt_complementary_pwm_mode_3_init (void)
{
    fsp_err_t err = FSP_SUCCESS;
    /* Initializes the module. */
    err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);
    /* Handle any errors. This function should be defined by the user. */
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    R_GPT4->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT5->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT6->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    /*
     * GTBER: General PWM Timer Buffer Enable
     * - BD0: GTCCR Buffer Operation
     * - BD1: GTPR Buffer Operation
     * - BD2: GTADTRA/GTADTRB Buffer Operation
     * - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)
     */
    R_GPT4->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT4->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT4->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT5->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT5->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT5->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT6->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT6->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT6->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT4->GTPDBR = 6000;
    R_GPT5->GTPDBR = 6000;
    R_GPT6->GTPDBR = 6000;
    /*
     * GTIOR : General PWM Timer I/O Control Register
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b
     * GTIOA = 0x09
     *  - Initial output is Low (Active level is High),
     *  - High output in up count compare match
     *  - Low output in down count compare match
     * GTIOB = 0x06
     *  - Initial output is Low (Active level is High),
     *  - Low output in up count compare match
     *  - High output in down count compare match
     */
    R_GPT4->GTIOR_b.GTIOA = 0x09;
    R_GPT5->GTIOR_b.GTIOA = 0x09;
    R_GPT6->GTIOR_b.GTIOA = 0x09;
    R_GPT4->GTIOR_b.GTIOB = 0x06;
    R_GPT5->GTIOR_b.GTIOB = 0x06;
    R_GPT6->GTIOR_b.GTIOB = 0x06;
    /*PSYE: PWM Synchronous output Enable:
     * Enable GTCPPOT4 output */
    R_GPT4->GTIOR_b.PSYE = 1;
    /*
     * GTBER2: General PWM Timer Buffer Enable 2
     * - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4
     * - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select
     * - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select
     */
    R_GPT4->GTBER2_b.CP3DB = 0;
    R_GPT4->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.CP3DB = 0;
    R_GPT5->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.CP3DB = 0;
    R_GPT6->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    /* Start the timer. */
    err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    return FSP_SUCCESS;
}
  Step 8: Add the below code, which includes the implementation of gpt_u_callback, in the hal_entry.c
static volatile int direction = 1; // 1 for incrementing, -1 for decrementing
static volatile int u2_count_u = 0U;
static void rm_motor_driver_set_uvw_duty_test (void)
{
    u2_count_u += direction;
    // Check if the counter needs to change direction
    if (u2_count_u == 6240) {
        direction = -1; // Switch to decrementing
    } else if (u2_count_u == 0) {
        direction = 1; // Switch to incrementing
    }
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
}
  #define DEBUG_OUTPUT_PD00_ENABLE 1
void gpt_u_callback(timer_callback_args_t *p_args)
{
    /* TODO: add your own code here */
    if(p_args->event == TIMER_EVENT_CREST)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_LOW);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
      if(p_args->event == TIMER_EVENT_TROUGH)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_HIGH);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
}
  Step 9: Add below code in the beginning of hal_entry.c
enum e_gpt_three_phase_prv_gtccr
{
    GPT_THREE_PHASE_PRV_GTCCRA = 0U,
    GPT_THREE_PHASE_PRV_GTCCRB,
    GPT_THREE_PHASE_PRV_GTCCRC,
    GPT_THREE_PHASE_PRV_GTCCRE,
    GPT_THREE_PHASE_PRV_GTCCRD,
    GPT_THREE_PHASE_PRV_GTCCRF
};
static fsp_err_t gpt_complementary_pwm_mode_3_init (void);
  Step 10: In the hal_entry(), make a call to gpt_complementary_pwm_mode_3_init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTn_OVF and GPTn_UDF interrupts.
GPTn_OVF: In complementary PWM mode, these interrupts request are enabled at crests (GTCNT counter value of master channel changes from GTPR register to GTPR register value minus 1)
GPTn_UDF: In complementary PWM mode, these interrupt requests are enabled at troughs (GTCNT counter value of master channel changes from 0 to 1)
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t err = FSP_SUCCESS;
    /* Complementary PWM mode Setting */
    err = gpt_complementary_pwm_mode_3_init();
    assert(err == FSP_SUCCESS);
    while(1)
    {
    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}
  Step 11: Do a quick measurement to verify whether the result matches our target operation.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output: 
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.


    Suitable Products
RA6T2
The RA6T2 General PWM Timer (GPT) supports Complementary the PWM mode, which can generate a three-phase PWM waveform with dead time and ensure the linearity in the vicinity of duty 0% and 100%. Therefore, this article takes Complementary PWM mode 3 (transfer at both crests and troughs) as an example to illustrate how to enable this operating mode based upon the FSP General PWM Timer Driver* (r_gpt).
*As Complementary PWM operating mode is not generally supported by other RA MCU General PWM Timer (GPT) peripheral, the configuration of FSP General PWM Timer Driver (r_gpt) does not support it as default.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output:
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.
  Step 1: Create a Renesas RA C/C++ Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective.
From the toolbar of e2studio, select File > New > RA C/C++ Project > Renesas RA
Flat (Non-TrustZone) Project is selected
RTOS selection is No RTOS.
Bare Metal (Minimal) is selected.
Step 2: In the Stacks option of FSP configuration window, first we add “Three-Phase PWM module (r_gpt_three_phase) in the HAL/Common Stacks. The Three-Phase PWM module can be found under the Timer category.
New Stack > Timers > Three-Phase PWM (r_gpt_three_phase)
  Step 3: After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers.
Select one of the r_gpt modules and configure “Pin Output Support” property to Enabled with Extra Features
Step 4: Configure Three-Phase PWM module (r_gpt_three_phase) with the settings below. The default value of other properties is kept.
General > Period: 10
General > Period Unit: Kilohertz
General > GPT U-Channel: 4
General > GPT V-Channel: 5
General > GPT W-Channel: 6
Extra Features > Dead Time > Dead Time Count Up (Raw Counts): 240
In complementary PWM mode, the GTDVD register is invalid and the GTDVU register is used as the dead time value during both up-counting and down-counting. Therefore, we only need to configure Dead Time Count Up (Raw Counts).
  Step 5: Configure the g_timer1, which is used for U signal output, with the setting below through FSP configuration.
Interrupts > Callback: gpt_u_callback
Interrupts > Overflow/Crest Interrupt Priority: Priority 1
Interrupts > Underflow/Trough Interrupt Priority: Priority 1
Because the GPT callback channel is set to U channel, we should register a user callback function to the U channel GPT. In addition, we will use Complementary PWM mode 3 to transfer the data count at both crest and trough sections, so both Crest Interrupt and Trough Interrupt are enabled.
  Step 6: Assign the required MCU Pins for running this example
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT
GTCPPO4: PB10 (used as PWM Synchronous Output Pin)
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT4
GTIOC4A: PB04
GTIOC4B: PB05
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT5
GTIOC5A: PB06
GTIOC5B: PB07
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT6
GTIOC6A: PB08
GTIOC6B: PB09
  Step 7: Add the below initialization function, which enables Complementary PWM mode 3 usage, in the hal_entry.c.
static fsp_err_t gpt_complementary_pwm_mode_3_init (void)
{
    fsp_err_t err = FSP_SUCCESS;
    /* Initializes the module. */
    err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);
    /* Handle any errors. This function should be defined by the user. */
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    R_GPT4->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT5->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT6->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    /*
     * GTBER: General PWM Timer Buffer Enable
     * - BD0: GTCCR Buffer Operation
     * - BD1: GTPR Buffer Operation
     * - BD2: GTADTRA/GTADTRB Buffer Operation
     * - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)
     */
    R_GPT4->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT4->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT4->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT5->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT5->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT5->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT6->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT6->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT6->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT4->GTPDBR = 6000;
    R_GPT5->GTPDBR = 6000;
    R_GPT6->GTPDBR = 6000;
    /*
     * GTIOR : General PWM Timer I/O Control Register
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b
     * GTIOA = 0x09
     *  - Initial output is Low (Active level is High),
     *  - High output in up count compare match
     *  - Low output in down count compare match
     * GTIOB = 0x06
     *  - Initial output is Low (Active level is High),
     *  - Low output in up count compare match
     *  - High output in down count compare match
     */
    R_GPT4->GTIOR_b.GTIOA = 0x09;
    R_GPT5->GTIOR_b.GTIOA = 0x09;
    R_GPT6->GTIOR_b.GTIOA = 0x09;
    R_GPT4->GTIOR_b.GTIOB = 0x06;
    R_GPT5->GTIOR_b.GTIOB = 0x06;
    R_GPT6->GTIOR_b.GTIOB = 0x06;
    /*PSYE: PWM Synchronous output Enable:
     * Enable GTCPPOT4 output */
    R_GPT4->GTIOR_b.PSYE = 1;
    /*
     * GTBER2: General PWM Timer Buffer Enable 2
     * - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4
     * - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select
     * - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select
     */
    R_GPT4->GTBER2_b.CP3DB = 0;
    R_GPT4->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.CP3DB = 0;
    R_GPT5->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.CP3DB = 0;
    R_GPT6->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    /* Start the timer. */
    err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    return FSP_SUCCESS;
}
  Step 8: Add the below code, which includes the implementation of gpt_u_callback, in the hal_entry.c
static volatile int direction = 1; // 1 for incrementing, -1 for decrementing
static volatile int u2_count_u = 0U;
static void rm_motor_driver_set_uvw_duty_test (void)
{
    u2_count_u += direction;
    // Check if the counter needs to change direction
    if (u2_count_u == 6240) {
        direction = -1; // Switch to decrementing
    } else if (u2_count_u == 0) {
        direction = 1; // Switch to incrementing
    }
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
}
  #define DEBUG_OUTPUT_PD00_ENABLE 1
void gpt_u_callback(timer_callback_args_t *p_args)
{
    /* TODO: add your own code here */
    if(p_args->event == TIMER_EVENT_CREST)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_LOW);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
      if(p_args->event == TIMER_EVENT_TROUGH)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_HIGH);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
}
  Step 9: Add below code in the beginning of hal_entry.c
enum e_gpt_three_phase_prv_gtccr
{
    GPT_THREE_PHASE_PRV_GTCCRA = 0U,
    GPT_THREE_PHASE_PRV_GTCCRB,
    GPT_THREE_PHASE_PRV_GTCCRC,
    GPT_THREE_PHASE_PRV_GTCCRE,
    GPT_THREE_PHASE_PRV_GTCCRD,
    GPT_THREE_PHASE_PRV_GTCCRF
};
static fsp_err_t gpt_complementary_pwm_mode_3_init (void);
  Step 10: In the hal_entry(), make a call to gpt_complementary_pwm_mode_3_init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTn_OVF and GPTn_UDF interrupts.
GPTn_OVF: In complementary PWM mode, these interrupts request are enabled at crests (GTCNT counter value of master channel changes from GTPR register to GTPR register value minus 1)
GPTn_UDF: In complementary PWM mode, these interrupt requests are enabled at troughs (GTCNT counter value of master channel changes from 0 to 1)
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t err = FSP_SUCCESS;
    /* Complementary PWM mode Setting */
    err = gpt_complementary_pwm_mode_3_init();
    assert(err == FSP_SUCCESS);
    while(1)
    {
    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}
  Step 11: Do a quick measurement to verify whether the result matches our target operation.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output: 
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.
The RA6T2 General PWM Timer (GPT) supports Complementary the PWM mode, which can generate a three-phase PWM waveform with dead time and ensure the linearity in the vicinity of duty 0% and 100%. Therefore, this article takes Complementary PWM mode 3 (transfer at both crests and troughs) as an example to illustrate how to enable this operating mode based upon the FSP General PWM Timer Driver* (r_gpt).
*As Complementary PWM operating mode is not generally supported by other RA MCU General PWM Timer (GPT) peripheral, the configuration of FSP General PWM Timer Driver (r_gpt) does not support it as default.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
Step 1: Create a Renesas RA C/C++ Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective.
Step 2: In the Stacks option of FSP configuration window, first we add “Three-Phase PWM module (r_gpt_three_phase) in the HAL/Common Stacks. The Three-Phase PWM module can be found under the Timer category.
Step 3: After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers.
Step 4: Configure Three-Phase PWM module (r_gpt_three_phase) with the settings below. The default value of other properties is kept.
Step 5: Configure the g_timer1, which is used for U signal output, with the setting below through FSP configuration.
Because the GPT callback channel is set to U channel, we should register a user callback function to the U channel GPT. In addition, we will use Complementary PWM mode 3 to transfer the data count at both crest and trough sections, so both Crest Interrupt and Trough Interrupt are enabled.
Step 6: Assign the required MCU Pins for running this example
Step 7: Add the below initialization function, which enables Complementary PWM mode 3 usage, in the hal_entry.c.
static fsp_err_t gpt_complementary_pwm_mode_3_init (void)
static
fsp_err_t
gpt_complementary_pwm_mode_3_init (
void
)
{
{
fsp_err_t err = FSP_SUCCESS;
fsp_err_t
err =
FSP_SUCCESS
;
/* Initializes the module. */
/* Initializes the module. */
err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);
err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);
/* Handle any errors. This function should be defined by the user. */
/* Handle any errors. This function should be defined by the user. */
if(FSP_SUCCESS != err)
if
(
FSP_SUCCESS
!= err)
{
{
return err;
return
err;
}
}
R_GPT4->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
R_GPT4->GTCR_b.MD = 0x0E;
//Complementary PWM mode 3(transfer at crest and trough)
R_GPT5->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
R_GPT5->GTCR_b.MD = 0x0E;
//Complementary PWM mode 3(transfer at crest and trough)
R_GPT6->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
R_GPT6->GTCR_b.MD = 0x0E;
//Complementary PWM mode 3(transfer at crest and trough)
/*
/*
* GTBER: General PWM Timer Buffer Enable
* GTBER: General PWM Timer Buffer Enable
* - BD0: GTCCR Buffer Operation
* - BD0: GTCCR Buffer Operation
* - BD1: GTPR Buffer Operation
* - BD1: GTPR Buffer Operation
* - BD2: GTADTRA/GTADTRB Buffer Operation
* - BD2: GTADTRA/GTADTRB Buffer Operation
* - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)
* - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)
*/
*/
R_GPT4->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
R_GPT4->GTBER_b.BD0 = 0;
//GTCCCR Buffer operation is enabled
R_GPT4->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
R_GPT4->GTBER_b.BD1 = 0;
//GTPR Buffer operation is enabled
R_GPT4->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
R_GPT4->GTBER_b.BD2 = 1;
//GTADTRA/GTADTRB Buffer operation is disabled
R_GPT5->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
R_GPT5->GTBER_b.BD0 = 0;
//GTCCCR Buffer operation is enabled
R_GPT5->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
R_GPT5->GTBER_b.BD1 = 0;
//GTPR Buffer operation is enabled
R_GPT5->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
R_GPT5->GTBER_b.BD2 = 1;
//GTADTRA/GTADTRB Buffer operation is disabled
R_GPT6->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
R_GPT6->GTBER_b.BD0 = 0;
//GTCCCR Buffer operation is enabled
R_GPT6->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
R_GPT6->GTBER_b.BD1 = 0;
//GTPR Buffer operation is enabled
R_GPT6->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
R_GPT6->GTBER_b.BD2 = 1;
//GTADTRA/GTADTRB Buffer operation is disabled
R_GPT4->GTPDBR = 6000;
R_GPT4->GTPDBR = 6000;
R_GPT5->GTPDBR = 6000;
R_GPT5->GTPDBR = 6000;
R_GPT6->GTPDBR = 6000;
R_GPT6->GTPDBR = 6000;
/*
/*
* GTIOR : General PWM Timer I/O Control Register
* GTIOR : General PWM Timer I/O Control Register
* - In complementary PWM mode,
* - In complementary PWM mode,
* the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b
* the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b
* - In complementary PWM mode,
* - In complementary PWM mode,
* the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b
* the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b
* GTIOA = 0x09
* GTIOA = 0x09
*  - Initial output is Low (Active level is High),
*  - Initial output is Low (Active level is High),
*  - High output in up count compare match
*  - High output in up count compare match
*  - Low output in down count compare match
*  - Low output in down count compare match
* GTIOB = 0x06
* GTIOB = 0x06
*  - Initial output is Low (Active level is High),
*  - Initial output is Low (Active level is High),
*  - Low output in up count compare match
*  - Low output in up count compare match
*  - High output in down count compare match
*  - High output in down count compare match
*/
*/
R_GPT4->GTIOR_b.GTIOA = 0x09;
R_GPT4->GTIOR_b.GTIOA = 0x09;
R_GPT5->GTIOR_b.GTIOA = 0x09;
R_GPT5->GTIOR_b.GTIOA = 0x09;
R_GPT6->GTIOR_b.GTIOA = 0x09;
R_GPT6->GTIOR_b.GTIOA = 0x09;
R_GPT4->GTIOR_b.GTIOB = 0x06;
R_GPT4->GTIOR_b.GTIOB = 0x06;
R_GPT5->GTIOR_b.GTIOB = 0x06;
R_GPT5->GTIOR_b.GTIOB = 0x06;
R_GPT6->GTIOR_b.GTIOB = 0x06;
R_GPT6->GTIOR_b.GTIOB = 0x06;
/*PSYE: PWM Synchronous output Enable:
/*PSYE: PWM Synchronous output Enable:
* Enable GTCPPOT4 output */
* Enable GTCPPOT4 output */
R_GPT4->GTIOR_b.PSYE = 1;
R_GPT4->GTIOR_b.PSYE = 1;
/*
/*
* GTBER2: General PWM Timer Buffer Enable 2
* GTBER2: General PWM Timer Buffer Enable 2
* - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4
* - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4
* - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select
* - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select
* - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select
* - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select
*/
*/
R_GPT4->GTBER2_b.CP3DB = 0;
R_GPT4->GTBER2_b.CP3DB = 0;
R_GPT4->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT4->GTBER2_b.OLTTA = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT4->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT4->GTBER2_b.OLTTB = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT5->GTBER2_b.CP3DB = 0;
R_GPT5->GTBER2_b.CP3DB = 0;
R_GPT5->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT5->GTBER2_b.OLTTA = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT5->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT5->GTBER2_b.OLTTB = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT6->GTBER2_b.CP3DB = 0;
R_GPT6->GTBER2_b.CP3DB = 0;
R_GPT6->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT6->GTBER2_b.OLTTA = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT6->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT6->GTBER2_b.OLTTB = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
/* Start the timer. */
/* Start the timer. */
err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);
err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);
if(FSP_SUCCESS != err)
if
(
FSP_SUCCESS
!= err)
{
{
return err;
return
err;
}
}
return FSP_SUCCESS;
return
FSP_SUCCESS
;
}
}
Step 8: Add the below code, which includes the implementation of gpt_u_callback, in the hal_entry.c
static volatile int direction = 1; // 1 for incrementing, -1 for decrementing
static
volatile
int
direction = 1;
// 1 for incrementing, -1 for decrementing
static volatile int u2_count_u = 0U;
static
volatile
int
u2_count_u = 0U;
static void rm_motor_driver_set_uvw_duty_test (void)
static
void
rm_motor_driver_set_uvw_duty_test (
void
)
{
{
u2_count_u += direction;
u2_count_u += direction;
// Check if the counter needs to change direction
// Check if the counter needs to change direction
if (u2_count_u == 6240) {
if
(u2_count_u == 6240) {
direction = -1; // Switch to decrementing
direction = -1;
// Switch to decrementing
} else if (u2_count_u == 0) {
}
else
if
(u2_count_u == 0) {
direction = 1; // Switch to incrementing
direction = 1;
// Switch to incrementing
}
}
R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (
uint32_t
) u2_count_u;
R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (
uint32_t
) u2_count_u;
R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (
uint32_t
) u2_count_u;
}
}
#define DEBUG_OUTPUT_PD00_ENABLE 1
#define
DEBUG_OUTPUT_PD00_ENABLE 1
void gpt_u_callback(timer_callback_args_t *p_args)
void
gpt_u_callback(timer_callback_args_t *p_args)
{
{
/* TODO: add your own code here */
/*
TODO
: add your own code here */
if(p_args->event == TIMER_EVENT_CREST)
if
(p_args->event ==
TIMER_EVENT_CREST
)
{
{
#if DEBUG_OUTPUT_PD00_ENABLE
#if
DEBUG_OUTPUT_PD00_ENABLE
R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_LOW);
R_IOPORT_PinWrite(&g_ioport_ctrl,
BSP_IO_PORT_13_PIN_00
,
BSP_IO_LEVEL_LOW
);
#endif
#endif
rm_motor_driver_set_uvw_duty_test();
rm_motor_driver_set_uvw_duty_test();
}
}
if(p_args->event == TIMER_EVENT_TROUGH)
if
(p_args->event == TIMER_EVENT_TROUGH)
{
{
#if DEBUG_OUTPUT_PD00_ENABLE
#if
DEBUG_OUTPUT_PD00_ENABLE
R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_HIGH);
R_IOPORT_PinWrite(&g_ioport_ctrl,
BSP_IO_PORT_13_PIN_00
,
BSP_IO_LEVEL_HIGH
);
#endif
#endif
rm_motor_driver_set_uvw_duty_test();
rm_motor_driver_set_uvw_duty_test();
}
}
}
}
Step 9: Add below code in the beginning of hal_entry.c
enum e_gpt_three_phase_prv_gtccr
enum
e_gpt_three_phase_prv_gtccr
{
{
GPT_THREE_PHASE_PRV_GTCCRA = 0U,
GPT_THREE_PHASE_PRV_GTCCRA
= 0U,
GPT_THREE_PHASE_PRV_GTCCRB,
GPT_THREE_PHASE_PRV_GTCCRB
,
GPT_THREE_PHASE_PRV_GTCCRC,
GPT_THREE_PHASE_PRV_GTCCRC
,
GPT_THREE_PHASE_PRV_GTCCRE,
GPT_THREE_PHASE_PRV_GTCCRE
,
GPT_THREE_PHASE_PRV_GTCCRD,
GPT_THREE_PHASE_PRV_GTCCRD
,
GPT_THREE_PHASE_PRV_GTCCRF
GPT_THREE_PHASE_PRV_GTCCRF
};
};
static fsp_err_t gpt_complementary_pwm_mode_3_init (void);
static
fsp_err_t
gpt_complementary_pwm_mode_3_init (
void
);
Step 10: In the hal_entry(), make a call to gpt_complementary_pwm_mode_3_init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTn_OVF and GPTn_UDF interrupts.
void hal_entry(void)
void
hal_entry(
void
)
{
{
/* TODO: add your own code here */
/*
TODO
: add your own code here */
fsp_err_t err = FSP_SUCCESS;
fsp_err_t
err =
FSP_SUCCESS
;
/* Complementary PWM mode Setting */
/* Complementary PWM mode Setting */
err = gpt_complementary_pwm_mode_3_init();
err = gpt_complementary_pwm_mode_3_init();
assert(err == FSP_SUCCESS);
assert(err ==
FSP_SUCCESS
);
while(1)
while
(1)
{
{
}
}
#if BSP_TZ_SECURE_BUILD
#if
BSP_TZ_SECURE_BUILD
/* Enter non-secure code */
/* Enter non-secure code */
R_BSP_NonSecureEnter();
R_BSP_NonSecureEnter();
#endif
#endif
}
}
Step 11: Do a quick measurement to verify whether the result matches our target operation.
Suitable Products
RA6T2","['data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/8d54988bfaffb52d1eddba1d0966c5da.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/91131772c15fae3c52b624c1180f8cdb.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/7142db3f1eca213dc6ec553a147d9f32.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/4701650b9a6d81bdbf2ab018ac8d3d0c.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/692c5949cc97b5bf687b61a145e6e57b.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/07128eeadeb01b85cc9f21099690e4cf.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/73daa6998081e489038f9b2a0ac2d0e3.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/055d1d942bcb2900ddc624bea814c44c.png']",[],"['|  |\n|  |\n| The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.\nPWM Frequency: 10kHz\nDeadtime period: 2us (GTDVU=240, PCLKD=120MHz)\nGTIOA output:\nInitial output level is Low, and active level is High\nOutput level is High in up count compare match, and it becomes Low in down count compare match.\nGTIOB: Initial output level is Low\nInitial output level is Low, and active level is High.\nOutput level is Low in up count compare match, and it becomes High in down count compare match. |', '|  |\n|  |\n| In complementary PWM mode, the GTDVD register is invalid and the GTDVU register is used as the dead time value during both up-counting and down-counting. Therefore, we only need to configure Dead Time Count Up (Raw Counts). |', '|  |\n|  |\n| static fsp_err_t gpt_complementary_pwm_mode_3_init (void)\n{\n    fsp_err_t err = FSP_SUCCESS;\n    /* Initializes the module. */\n    err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);\n    /* Handle any errors. This function should be defined by the user. */\n    if(FSP_SUCCESS != err)\n    {\n        return err;\n    }\n    R_GPT4->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)\n    R_GPT5->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)\n    R_GPT6->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)\n    /*\n     * GTBER: General PWM Timer Buffer Enable\n     * - BD0: GTCCR Buffer Operation\n     * - BD1: GTPR Buffer Operation\n     * - BD2: GTADTRA/GTADTRB Buffer Operation\n     * - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)\n     */\n    R_GPT4->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled\n    R_GPT4->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled\n    R_GPT4->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled\n    R_GPT5->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled\n    R_GPT5->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled\n    R_GPT5->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled\n    R_GPT6->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled\n    R_GPT6->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled\n    R_GPT6->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled\n    R_GPT4->GTPDBR = 6000;\n    R_GPT5->GTPDBR = 6000;\n    R_GPT6->GTPDBR = 6000;\n    /*\n     * GTIOR : General PWM Timer I/O Control Register\n     * - In complementary PWM mode,\n     * the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b\n     * - In complementary PWM mode,\n     * the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b\n     * GTIOA = 0x09\n     *  - Initial output is Low (Active level is High),\n     *  - High output in up count compare match\n     *  - Low output in down count compare match\n     * GTIOB = 0x06\n     *  - Initial output is Low (Active level is High),\n     *  - Low output in up count compare match\n     *  - High output in down count compare match\n     */\n    R_GPT4->GTIOR_b.GTIOA = 0x09;\n    R_GPT5->GTIOR_b.GTIOA = 0x09;\n    R_GPT6->GTIOR_b.GTIOA = 0x09;\n    R_GPT4->GTIOR_b.GTIOB = 0x06;\n    R_GPT5->GTIOR_b.GTIOB = 0x06;\n    R_GPT6->GTIOR_b.GTIOB = 0x06;\n    /*PSYE: PWM Synchronous output Enable:\n     * Enable GTCPPOT4 output */\n    R_GPT4->GTIOR_b.PSYE = 1;\n    /*\n     * GTBER2: General PWM Timer Buffer Enable 2\n     * - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4\n     * - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select\n     * - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select\n     */\n    R_GPT4->GTBER2_b.CP3DB = 0;\n    R_GPT4->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT4->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT5->GTBER2_b.CP3DB = 0;\n    R_GPT5->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT5->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT6->GTBER2_b.CP3DB = 0;\n    R_GPT6->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT6->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;\n    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;\n    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;\n    /* Start the timer. */\n    err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);\n    if(FSP_SUCCESS != err)\n    {\n        return err;\n    }\n    return FSP_SUCCESS;\n} |', '|  |\n|  |\n| static volatile int direction = 1; // 1 for incrementing, -1 for decrementing\nstatic volatile int u2_count_u = 0U;\nstatic void rm_motor_driver_set_uvw_duty_test (void)\n{\n    u2_count_u += direction;\n    // Check if the counter needs to change direction\n    if (u2_count_u == 6240) {\n        direction = -1; // Switch to decrementing\n    } else if (u2_count_u == 0) {\n        direction = 1; // Switch to incrementing\n    }\n    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;\n    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;\n    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;\n}\n  #define DEBUG_OUTPUT_PD00_ENABLE 1\nvoid gpt_u_callback(timer_callback_args_t *p_args)\n{\n    /* TODO: add your own code here */\n    if(p_args->event == TIMER_EVENT_CREST)\n    {\n#if DEBUG_OUTPUT_PD00_ENABLE\n        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_LOW);\n#endif\n        rm_motor_driver_set_uvw_duty_test();\n    }\n      if(p_args->event == TIMER_EVENT_TROUGH)\n    {\n#if DEBUG_OUTPUT_PD00_ENABLE\n        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_HIGH);\n#endif\n        rm_motor_driver_set_uvw_duty_test();\n    }\n} |', '|  |\n|  |\n| enum e_gpt_three_phase_prv_gtccr\n{\n    GPT_THREE_PHASE_PRV_GTCCRA = 0U,\n    GPT_THREE_PHASE_PRV_GTCCRB,\n    GPT_THREE_PHASE_PRV_GTCCRC,\n    GPT_THREE_PHASE_PRV_GTCCRE,\n    GPT_THREE_PHASE_PRV_GTCCRD,\n    GPT_THREE_PHASE_PRV_GTCCRF\n};\nstatic fsp_err_t gpt_complementary_pwm_mode_3_init (void); |', '|  |\n|  |\n| void hal_entry(void)\n{\n    /* TODO: add your own code here */\n    fsp_err_t err = FSP_SUCCESS;\n    /* Complementary PWM mode Setting */\n    err = gpt_complementary_pwm_mode_3_init();\n    assert(err == FSP_SUCCESS);\n    while(1)\n    {\n    }\n#if BSP_TZ_SECURE_BUILD\n    /* Enter non-secure code */\n    R_BSP_NonSecureEnter();\n#endif\n} |', '|  |\n|  |\n| The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.\nPWM Frequency: 10kHz\nDeadtime period: 2us (GTDVU=240, PCLKD=120MHz)\nGTIOA output: \nInitial output level is Low, and active level is High\nOutput level is High in up count compare match, and it becomes Low in down count compare match.\nGTIOB: Initial output level is Low\nInitial output level is Low, and active level is High.\nOutput level is Low in up count compare match, and it becomes High in down count compare match. |', '|  |\n|  |\n| RA6T2 |']","{'title': 'RA6T2: How to use the GPT Complementary PWM mode', 'url': 'https://en-support.renesas.com/knowledgeBase/21745546', 'last_updated': '2024-07-01', 'extracted_at': '2025-03-08T23:13:56.988643'}","Answer The RA6T2 General PWM Timer (GPT) supports Complementary the PWM mode, which can generate a three-phase PWM waveform with dead time and ensure the linearity in the vicinity of duty 0 and 100. Therefore, this article takes Complementary PWM mode 3 (transfer at both crests and troughs) as an example to illustrate how to enable this operating mode based upon the FSP General PWM Timer Driver (rgpt). As Complementary PWM operating mode is not generally supported by other RA MCU General PWM Timer (GPT) peripheral, the configuration of FSP General PWM Timer Driver (rgpt) does not support it as default. The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions. PWM Frequency 10kHz Deadtime period 2us (GTDVU240, PCLKD120MHz) GTIOA output Initial output level is Low, and active level is High Output level is High in up count compare match, and it becomes Low in down count compare match. GTIOB Initial output level is Low Initial output level is Low, and active level is High. Output level is Low in up count compare match, and it becomes High in down count compare match. Step 1 Create a Renesas RA C/C Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective. From the toolbar of e2studio, select File  New  RA C/C Project  Renesas RA Flat (Non-TrustZone) Project is selected RTOS selection is No RTOS. Bare Metal (Minimal) is selected. Step 2 In the Stacks option of FSP configuration window, first we add Three-Phase PWM module (rgptthreephase) in the HAL/Common Stacks. The Three-Phase PWM module can be found under the Timer category. New Stack  Timers  Three-Phase PWM (rgptthreephase) Step 3 After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers. Select one of the rgpt modules and configure Pin Output Support property to Enabled with Extra Features Step 4 Configure Three-Phase PWM module (rgptthreephase) with the settings below. The default value of other properties is kept. General  Period 10 General  Period Unit Kilohertz General  GPT U-Channel 4 General  GPT V-Channel 5 General  GPT W-Channel 6 Extra Features  Dead Time  Dead Time Count Up (Raw Counts) 240 In complementary PWM mode, the GTDVD register is invalid and the GTDVU register is used as the dead time value during both up-counting and down-counting. Therefore, we only need to configure Dead Time Count Up (Raw Counts). Step 5 Configure the gtimer1, which is used for U signal output, with the setting below through FSP configuration. Interrupts  Callback gptucallback Interrupts  Overflow/Crest Interrupt Priority Priority 1 Interrupts  Underflow/Trough Interrupt Priority Priority 1 Because the GPT callback channel is set to U channel, we should register a user callback function to the U channel GPT. In addition, we will use Complementary PWM mode 3 to transfer the data count at both crest and trough sections, so both Crest Interrupt and Trough Interrupt are enabled. Step 6 Assign the required MCU Pins for running this example FSP Configuration  Pins  Peripherals  TimersGPT  GPT GTCPPO4 PB10 (used as PWM Synchronous Output Pin) FSP Configuration  Pins  Peripherals  TimersGPT  GPT4 GTIOC4A PB04 GTIOC4B PB05 FSP Configuration  Pins  Peripherals  TimersGPT  GPT5 GTIOC5A PB06 GTIOC5B PB07 FSP Configuration  Pins  Peripherals  TimersGPT  GPT6 GTIOC6A PB08 GTIOC6B PB09 Step 7 Add the below initialization function, which enables Complementary PWM mode 3 usage, in the halentry.c. static fsperrt gptcomplementarypwmmode3init (void)  fsperrt err  FSPSUCCESS; / Initializes the module. / err  RGPTTHREEPHASEOpen(gthreephase0ctrl, gthreephase0cfg); / Handle any errors. This function should be defined by the user. / if(FSPSUCCESS ! err)  return err;  RGPT4-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT5-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT6-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) /  GTBER General PWM Timer Buffer Enable  - BD0 GTCCR Buffer Operation  - BD1 GTPR Buffer Operation  - BD2 GTADTRA/GTADTRB Buffer Operation  - BD3 GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode) / RGPT4-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT4-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT4-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT5-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT5-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT5-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT6-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT6-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT6-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT4-GTPDBR  6000; RGPT5-GTPDBR  6000; RGPT6-GTPDBR  6000;  GTIOR  General PWM Timer I/O Control Register  - In complementary PWM mode,  the only values that can be set in the GTIOA40 bits are 01001b, and 10110b  the only values that can be set in the GTIOB40 bits are 00110b, and 11001b  GTIOA  0x09  - Initial output is Low (Active level is High),  - High output in up count compare match  - Low output in down count compare match  GTIOB  0x06  - Low output in up count compare match  - High output in down count compare match RGPT4-GTIORb.GTIOA  0x09; RGPT5-GTIORb.GTIOA  0x09; RGPT6-GTIORb.GTIOA  0x09; RGPT4-GTIORb.GTIOB  0x06; RGPT5-GTIORb.GTIOB  0x06; RGPT6-GTIORb.GTIOB  0x06; /PSYE PWM Synchronous output Enable  Enable GTCPPOT4 output / RGPT4-GTIORb.PSYE  1;  GTBER2 General PWM Timer Buffer Enable 2  - CP3DB0  Disable double buffer function in complementary PWM mode 3, 4  - OLTTA GTIOCnA Output Level Buffer Transfer Timing Select  - OLTTB GTIOCnB Output Level Buffer Transfer Timing Select RGPT4-GTBER2b.CP3DB  0; RGPT4-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT4-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT5-GTBER2b.CP3DB  0; RGPT5-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT5-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT6-GTBER2b.CP3DB  0; RGPT6-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT6-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT4-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; RGPT5-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; RGPT6-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; / Start the timer. / err  RGPTTHREEPHASEStart(gthreephase0ctrl); return FSPSUCCESS;  Step 8 Add the below code, which includes the implementation of gptucallback, in the halentry.c static volatile int direction  1; // 1 for incrementing, -1 for decrementing static volatile int u2countu  0U; static void rmmotordriversetuvwdutytest (void) u2countu  direction; // Check if the counter needs to change direction if (u2countu  6240)  direction  -1; // Switch to decrementing  else if (u2countu  0)  direction  1; // Switch to incrementing RGPT4-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; RGPT5-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; RGPT6-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; define DEBUGOUTPUTPD00ENABLE 1 void gptucallback(timercallbackargst pargs) / TODO add your own code here / if(pargs-event  TIMEREVENTCREST) if DEBUGOUTPUTPD00ENABLE RIOPORTPinWrite(gioportctrl, BSPIOPORT13PIN00, BSPIOLEVELLOW); endif rmmotordriversetuvwdutytest(); if(pargs-event  TIMEREVENTTROUGH) RIOPORTPinWrite(gioportctrl, BSPIOPORT13PIN00, BSPIOLEVELHIGH); Step 9 Add below code in the beginning of halentry.c enum egptthreephaseprvgtccr GPTTHREEPHASEPRVGTCCRA  0U, GPTTHREEPHASEPRVGTCCRB, GPTTHREEPHASEPRVGTCCRC, GPTTHREEPHASEPRVGTCCRE, GPTTHREEPHASEPRVGTCCRD, GPTTHREEPHASEPRVGTCCRF ; static fsperrt gptcomplementarypwmmode3init (void); Step 10 In the halentry(), make a call to gptcomplementarypwmmode3init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTnOVF and GPTnUDF interrupts. GPTnOVF In complementary PWM mode, these interrupts request are enabled at crests (GTCNT counter value of master channel changes from GTPR register to GTPR register value minus 1) GPTnUDF In complementary PWM mode, these interrupt requests are enabled at troughs (GTCNT counter value of master channel changes from 0 to 1) void halentry(void) / Complementary PWM mode Setting / err  gptcomplementarypwmmode3init(); assert(err  FSPSUCCESS); while(1) if BSPTZSECUREBUILD / Enter non-secure code / RBSPNonSecureEnter(); Step 11 Do a quick measurement to verify whether the result matches our target operation. GTIOA output Suitable Products RA6T2 Step 1 Create a Renesas RA C/C Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective. Step 3 After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers. Step 5 Configure the gtimer1, which is used for U signal output, with the setting below through FSP configuration. Step 6 Assign the required MCU Pins for running this example Step 7 Add the below initialization function, which enables Complementary PWM mode 3 usage, in the halentry.c. static fsperrt gptcomplementarypwmmode3init ( void ) fsperrt err  FSPSUCCESS; err  FSPSUCCESS ; / Initializes the module. / err  RGPTTHREEPHASEOpen(gthreephase0ctrl, gthreephase0cfg); / Handle any errors. This function should be defined by the user. / if(FSPSUCCESS ! err) if ( ! err) return err; return err; RGPT4-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT4-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT5-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT5-GTCRb.MD  0x0E; RGPT6-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT6-GTCRb.MD  0x0E; /  GTBER General PWM Timer Buffer Enable  - BD0 GTCCR Buffer Operation  - BD1 GTPR Buffer Operation  - BD2 GTADTRA/GTADTRB Buffer Operation  - BD3 GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode) / RGPT4-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT4-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT4-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT4-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT4-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT4-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT5-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT5-GTBERb.BD0  0; RGPT5-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT5-GTBERb.BD1  0; RGPT5-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT5-GTBERb.BD2  1; RGPT6-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT6-GTBERb.BD0  0; RGPT6-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT6-GTBERb.BD1  0; RGPT6-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT6-GTBERb.BD2  1; RGPT4-GTPDBR  6000; RGPT5-GTPDBR  6000; RGPT6-GTPDBR  6000;  GTIOR  General PWM Timer I/O Control Register  - In complementary PWM mode,  the only values that can be set in the GTIOA40 bits are 01001b, and 10110b  the only values that can be set in the GTIOB40 bits are 00110b, and 11001b  GTIOA  0x09  - Initial output is Low (Active level is High),  - High output in up count compare match  - Low output in down count compare match  GTIOB  0x06  - Low output in up count compare match  - High output in down count compare match RGPT4-GTIORb.GTIOA  0x09; RGPT5-GTIORb.GTIOA  0x09; RGPT6-GTIORb.GTIOA  0x09; RGPT4-GTIORb.GTIOB  0x06; RGPT5-GTIORb.GTIOB  0x06; RGPT6-GTIORb.GTIOB  0x06; /PSYE PWM Synchronous output Enable  Enable GTCPPOT4 output / RGPT4-GTIORb.PSYE  1;  GTBER2 General PWM Timer Buffer Enable 2  - CP3DB0  Disable double buffer function in complementary PWM mode 3, 4  - OLTTA GTIOCnA Output Level Buffer Transfer Timing Select  - OLTTB GTIOCnB Output Level Buffer Transfer Timing Select RGPT4-GTBER2b.CP3DB  0; RGPT4-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT4-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT4-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT4-GTBER2b.OLTTB  3; RGPT5-GTBER2b.CP3DB  0; RGPT5-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT5-GTBER2b.OLTTA  3; RGPT5-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT5-GTBER2b.OLTTB  3; RGPT6-GTBER2b.CP3DB  0; RGPT6-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT6-GTBER2b.OLTTA  3; RGPT6-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT6-GTBER2b.OLTTB  3; RGPT4-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; RGPT5-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; RGPT6-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; / Start the timer. / err  RGPTTHREEPHASEStart(gthreephase0ctrl); return FSPSUCCESS; Step 8 Add the below code, which includes the implementation of gptucallback, in the halentry.c volatile int direction  1; // 1 for incrementing, -1 for decrementing u2countu  0U; rmmotordriversetuvwdutytest ( u2countu  direction; // Check if the counter needs to change direction if (u2countu  6240)  (u2countu  6240)  direction  -1; // Switch to decrementing direction  -1; // Switch to decrementing  else if (u2countu  0)  else (u2countu  0)  direction  1; // Switch to incrementing // Switch to incrementing RGPT4-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; RGPT4-GTCCRGPTTHREEPHASEPRVGTCCRD  ( uint32t ) u2countu; RGPT5-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; RGPT5-GTCCRGPTTHREEPHASEPRVGTCCRD  ( RGPT6-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; RGPT6-GTCCRGPTTHREEPHASEPRVGTCCRD  ( define DEBUGOUTPUTPD00ENABLE 1 define DEBUGOUTPUTPD00ENABLE 1 gptucallback(timercallbackargst pargs) / TODO add your own code here / TODO  add your own code here / if(pargs-event  TIMEREVENTCREST) (pargs-event  TIMEREVENTCREST if DEBUGOUTPUTPD00ENABLE RIOPORTPinWrite(gioportctrl, BSPIOPORT13PIN00, BSPIOLEVELLOW); RIOPORTPinWrite(gioportctrl, BSPIOPORT13PIN00 , BSPIOLEVELLOW ); rmmotordriversetuvwdutytest(); if(pargs-event  TIMEREVENTTROUGH) (pargs-event  TIMEREVENTTROUGH) RIOPORTPinWrite(gioportctrl, BSPIOPORT13PIN00, BSPIOLEVELHIGH); BSPIOLEVELHIGH Step 9 Add below code in the beginning of halentry.c enum egptthreephaseprvgtccr GPTTHREEPHASEPRVGTCCRA  0U, GPTTHREEPHASEPRVGTCCRA  0U, GPTTHREEPHASEPRVGTCCRB, GPTTHREEPHASEPRVGTCCRB GPTTHREEPHASEPRVGTCCRC, GPTTHREEPHASEPRVGTCCRC GPTTHREEPHASEPRVGTCCRE, GPTTHREEPHASEPRVGTCCRE GPTTHREEPHASEPRVGTCCRD, GPTTHREEPHASEPRVGTCCRD GPTTHREEPHASEPRVGTCCRF Step 10 In the halentry(), make a call to gptcomplementarypwmmode3init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTnOVF and GPTnUDF interrupts. halentry( / Complementary PWM mode Setting / err  gptcomplementarypwmmode3init(); assert(err  FSPSUCCESS); assert(err  while(1) while (1) BSPTZSECUREBUILD / Enter non-secure code / RBSPNonSecureEnter(); Step 11 Do a quick measurement to verify whether the result matches our target operation. Suitable Products","['The image shows a screenshot of a computer program with a window titled ""Stacks Configuration"" and a sub-window titled ""Threads"". The main window has a gray background with black text, while the sub-window has a white background with red text. The main window contains a list of threads, each represented by a small icon and a brief description. The sub-window displays a flowchart with various boxes and arrows, indicating the relationships between the threads.\n\nThe flowchart appears to be a visual representation of the program\'s architecture, showing how the different threads interact with each other. The boxes represent different components or functions within the program, while the arrows indicate the flow of data or control between them.\n\nOverall, the image suggests that the program is designed to manage and coordinate multiple threads or processes, and the flowchart provides a clear visual representation of how these threads interact with each other.', 'The image presents a flowchart illustrating the process of generating PWM (Pulse Width Modulation) signals. The chart is divided into three main sections, each representing a different stage in the PWM generation process.\n\n*   **Three-Phase PWM (r_gpt_three_phase)**\n    *   This section represents the initial stage of the PWM generation process.\n    *   It is labeled as ""Three-Phase PWM (r_gpt_three_phase)"" and is depicted in a light gray color.\n    *   The section contains a single input, which is represented by a blue circle with an ""i"" inside.\n    *   The input is connected to the next stage of the process, which is represented by a red rectangle.\n*   **g_timer0 Timer, General PWM (r_gpt)**\n    *   This section represents the second stage of the PWM generation process.\n    *   It is labeled as ""g_timer0 Timer, General PWM (r_gpt)"" and is depicted in a dark gray color.\n    *   The section contains a single output, which is represented by a blue circle with an ""i"" inside.\n    *   The output is connected to the next stage of the process, which is represented by a white rectangle.\n*   **g_timer2 Timer, General PWM (r_gpt)**\n    *   This section represents the third and final stage of the PWM generation process.\n    *   It is labeled as ""g_timer2 Timer, General PWM (r_gpt)"" and is depicted in a white color.\n    *   The section contains a single output, which is represented by a blue circle with an ""i"" inside.\n    *   The output is not connected to any further stages of the process.\n\nIn summary, the flowchart illustrates the process of generating PWM signals, starting with the Three-Phase PWM stage and progressing through the g_timer0 Timer and g_timer2 Timer stages. Each stage is represented by a distinct color and contains a single input or output, which is connected to the next stage in the process.', 'The image shows a screenshot of a computer program with a settings menu open. The title at the top of the window reads ""g_timer0 Timer, General PWM (r_gpt)"" in black text.\n\n*   **Settings Menu**\n    *   The settings menu is open, displaying various options.\n    *   The options are listed in a table format, with columns for ""Property"", ""Value"", and ""API Info"".\n    *   The ""Property"" column lists different settings, such as ""Common"", ""Parameter Checking"", ""Pin Output Support"", and ""Write Protect Enable"".\n    *   The ""Value"" column shows the current value of each setting, which is mostly blank except for ""Pin Output Support"", which is set to ""Enabled with Extra Features"".\n    *   The ""API Info"" column provides additional information about each setting, including a brief description and any relevant API calls.\n*   **Pin Output Support**\n    *   The ""Pin Output Support"" setting is highlighted in red, indicating that it is currently enabled.\n    *   The value of this setting is ""Enabled with Extra Features"", suggesting that it allows for additional functionality beyond basic pin output support.\n*   **Other Settings**\n    *   The other settings in the menu are not highlighted, but they appear to be related to the timer and PWM functionality of the program.\n    *   Some of these settings, such as ""Parameter Checking"" and ""Write Protect Enable"", may be important for ensuring the correct operation of the timer and PWM functions.\n\nOverall, the image suggests that the program is a timer and PWM control system, and the settings menu allows users to customize its behavior and functionality. The highlighted ""Pin Output Support"" setting indicates that this feature is currently enabled, and the other settings in the menu provide additional options for configuring the program\'s behavior.', 'The image shows a screenshot of a computer program\'s settings menu, with the title ""g_timer1 Timer, General PWM (r_gpt)"" at the top. The menu is organized into sections, including ""Property"", ""API Info"", and ""Pins"". The ""Property"" section has several sub-options, such as ""Common"", ""Parameter Checking"", ""Pin Output Support"", and ""Write Protect Enable"". The ""API Info"" section lists various API-related information, including ""Module g_timer1 Timer, General PWM (r_gpt)"", ""General"", ""Output"", ""Input"", and ""Interrupts"". The ""Pins"" section displays a list of pins, including ""GTIOCAA"" and ""GTIOC4B"".\n\nThe background of the image is a light gray color, with a darker gray border around the edges. The overall design of the menu is clean and organized, making it easy to navigate and understand the various settings and options available.', 'The image shows a screenshot of a computer program with a white background and black text. The program is titled ""Select Pin Configuration"" and has several sections, including ""Pin Selection,"" ""Pin Configuration,"" and ""Module name: GPT."" \n\n*   **Pin Selection**\n    *   This section has a list of pins on the left side, with checkboxes next to each pin.\n    *   The pins are listed in a table format, with columns for ""Type filter text,"" ""Name,"" ""Value,"" ""Lock,"" and ""Link.""\n    *   Some of the pins have a green checkmark next to them, indicating that they are selected.\n*   **Pin Configuration**\n    *   This section has a table with columns for ""Name,"" ""Value,"" ""Lock,"" and ""Link.""\n    *   The table is empty, except for a few rows that have been filled in.\n    *   The rows that have been filled in have a green checkmark next to them, indicating that they are selected.\n*   **Module name: GPT**\n    *   This section has a single row with a green checkmark next to it.\n    *   The row has a column for ""Module name"" and a column for ""GPT.""\n    *   The ""Module name"" column is empty, but the ""GPT"" column has a value of ""GPT.""\n\nOverall, the image appears to be a screenshot of a computer program used for configuring pins on a microcontroller or other electronic device. The program allows users to select specific pins and configure their values, locks, and links.', 'The image shows a screenshot of a computer program with a white background and black text. The program is titled ""Select Pin Configuration"" and has a menu bar at the top with options such as ""Export to CSV file,"" ""Configure Pin Driver Warnings,"" and ""Manage configurations...""\n\nBelow the menu bar, there are two main sections: ""Pin Selection"" and ""Pin Configuration."" The ""Pin Selection"" section has a list of pins on the left side, with checkboxes next to each one. The ""Pin Configuration"" section has a table with columns for ""Name,"" ""Value,"" ""Lock,"" and ""Link."" There are several rows in the table, each representing a different pin configuration.\n\nIn the top-right corner of the window, there is a checkbox labeled ""Generate data: g_bsp_pin_cfg."" Below this, there is a text box where you can enter a name for the pin configuration.\n\nOverall, the image appears to be a screenshot of a computer program used for configuring pins on a microcontroller or other electronic device. The program allows users to select which pins to use, configure their values, and generate data for the selected pins.', 'The image presents a waveform graph with a black background, featuring a grid pattern of white lines. The graph is divided into two sections: the top section displays a waveform with a blue, yellow, and red line, while the bottom section provides additional information in a table format.\n\n**Top Section: Waveform Graph**\n\n*   The waveform graph is titled ""GTCPP04(PB10) : PWM Synchronous output"" in black text at the top.\n*   The graph features a blue, yellow, and red line, each representing a different signal or channel.\n*   The x-axis is labeled with time values, ranging from -7.6 μs to 20.0 μs, with increments of 2.0 μs.\n*   The y-axis is labeled with voltage values, ranging from -1.980 V to 1.52 V, with increments of 0.16 V.\n\n**Bottom Section: Table**\n\n*   The table is titled ""Timebase"" and provides additional information about the waveform graph.\n*   The table includes columns for ""Trigger"", ""Stop"", ""Edge"", and ""Positive"", each containing specific values or settings.\n*   The table also includes a row labeled ""X1="" with values ""-44.40 μs"" and ""X2="" with values ""55.55 μs"".\n*   A red box highlights the value ""1/ΔX="" with a value of ""10.005 kHz"".\n\n**Overall**\n\n*   The image appears to be a technical diagram or graph used to analyze and understand the behavior of a PWM (Pulse Width Modulation) synchronous output signal.\n*   The waveform graph and table provide detailed information about the signal\'s characteristics, such as its amplitude, frequency, and timing.\n*   The image may be used in the context of electronics, engineering, or scientific research to study and optimize the performance of PWM systems.', 'The image presents a waveform display, showcasing the output of a PWM (Pulse Width Modulation) synchronous signal. The waveform is displayed on a black background with a grid pattern, featuring a white header at the top that reads ""GTCPP04(PB10) : PWM Synchronous output"" in black text. Below the header, three colored bars are visible, each representing a different channel: blue for GTIOC4A(PB04), yellow for GTIOC4B(PB05), and red for GTIOC4(PB04).\n\nThe waveform itself is composed of multiple lines, each representing a different channel. The blue line, corresponding to GTIOC4A(PB04), exhibits a square wave pattern with a frequency of approximately 500 kHz. The yellow line, representing GTIOC4B(PB05), displays a similar square wave pattern but with a slightly lower frequency, around 400 kHz. The red line, associated with GTIOC4(PB04), shows a more complex waveform with a mix of square and triangular patterns.\n\nAt the bottom of the image, a table provides additional information about the waveform. The table includes columns for the channel name, voltage, and time, as well as a section for trigger settings. The trigger settings are set to 20.0 μs/div, with a stop time of 1.52 V and a positive offset of 1.0 kΩ. The timebase is set to -7.6 μs, and the X1 and X2 settings are -44.40 μs and -42.40 μs, respectively.\n\nOverall, the image effectively conveys the characteristics of the PWM synchronous signal, including its frequency, amplitude, and waveform shape. The inclusion of the table at the bottom provides further context and allows for a more detailed analysis of the signal.']"
6018623afd9089cd0f48a5d1b4c5b122,"Question:
Even though a CAN/CAN-FD communication application is implemented on RA Family MCU, test signal output cannot be confirmed from the MCU pin.
Answer:
To connect the RA Family MCU to the CAN physical bus, an external CAN bus transceiver is required. If the CAN bus transceiver is not connected (e.g., the state when the receive pin is open), the MCU may not output a CAN transmit signal. Please check the setup of evaluation board used.
Some RA Family evaluation kits (e.g., the EK-RA6M5) already mounted a CAN bus transceiver on the board, so users can start evaluation without additional components consideration.
Note: Few development kits are shipped with cutting the line between MCU pins and the CAN bus transceiver by a solder jumper. Please refer to the User's Manual of evaluation kit for details on how to use it.
  Suitable Products
RA Family
Even though a CAN/CAN-FD communication application is implemented on RA Family MCU, test signal output cannot be confirmed from the MCU pin.
Even though a CAN/CAN-FD communication application is implemented on RA Family MCU, test signal output cannot be confirmed from the MCU pin.
Answer:
To connect the RA Family MCU to the CAN physical bus, an external CAN bus transceiver is required. If the CAN bus transceiver is not connected (e.g., the state when the receive pin is open), the MCU may not output a CAN transmit signal. Please check the setup of evaluation board used.
Some RA Family evaluation kits (e.g., the EK-RA6M5) already mounted a CAN bus transceiver on the board, so users can start evaluation without additional components consideration.
Note: Few development kits are shipped with cutting the line between MCU pins and the CAN bus transceiver by a solder jumper. Please refer to the User's Manual of evaluation kit for details on how to use it.
  Suitable Products
RA Family
To connect the RA Family MCU to the CAN physical bus, an external CAN bus transceiver is required. If the CAN bus transceiver is not connected (e.g., the state when the receive pin is open), the MCU may not output a CAN transmit signal. Please check the setup of evaluation board used.
Some RA Family evaluation kits (e.g., the EK-RA6M5) already mounted a CAN bus transceiver on the board, so users can start evaluation without additional components consideration.
Note: Few development kits are shipped with cutting the line between MCU pins and the CAN bus transceiver by a solder jumper. Please refer to the User's Manual of evaluation kit for details on how to use it.
To connect the RA Family MCU to the CAN physical bus, an external CAN bus transceiver is required. If the CAN bus transceiver is not connected (e.g., the state when the receive pin is open), the MCU may not output a CAN transmit signal. Please check the setup of evaluation board used.
Some RA Family evaluation kits (e.g., the EK-RA6M5) already mounted a CAN bus transceiver on the board, so users can start evaluation without additional components consideration.
Note: Few development kits are shipped with cutting the line between MCU pins and the CAN bus transceiver by a solder jumper. Please refer to the User's Manual of evaluation kit for details on how to use it.
Suitable Products
RA Family
日本語
日本語",['data/categories/ra_family/ra_hardware/6018623afd9089cd0f48a5d1b4c5b122/images/d7f674b9591098f0ebd829b5f42f6e2f.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: CAN / CAN-FD signal output not observed', 'url': 'https://en-support.renesas.com/knowledgeBase/21727827', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:59.647580'}","Question Even though a CAN/CAN-FD communication application is implemented on RA Family MCU, test signal output cannot be confirmed from the MCU pin. Answer To connect the RA Family MCU to the CAN physical bus, an external CAN bus transceiver is required. If the CAN bus transceiver is not connected (e.g., the state when the receive pin is open), the MCU may not output a CAN transmit signal. Please check the setup of evaluation board used. Some RA Family evaluation kits (e.g., the EK-RA6M5) already mounted a CAN bus transceiver on the board, so users can start evaluation without additional components consideration. Note Few development kits are shipped with cutting the line between MCU pins and the CAN bus transceiver by a solder jumper. Please refer to the User's Manual of evaluation kit for details on how to use it. Suitable Products RA Family Suitable Products ","[""The image presents a detailed schematic diagram of the CAN FD (Controller Area Network Flexible Data-Rate) system, specifically the EK-RA6M5 v1 version. The diagram is divided into three main sections: the left side, the center, and the right side.\n\n**Left Side:**\n\n*   **Connect to MCU pins:** This section is labeled with red text and features a series of lines and symbols that represent the connections between the CAN FD system and the microcontroller unit (MCU) pins.\n*   **Jumper_Solder_Bridge:** This section is also labeled with red text and shows a jumper solder bridge, which is used to connect or disconnect specific pins on the MCU.\n\n**Center:**\n\n*   **CAN Transceiver:** This section is labeled with red text and features a detailed diagram of the CAN transceiver, which is responsible for transmitting and receiving data on the CAN bus.\n*   **TJA1042T3:** This section is labeled with red text and shows the TJA1042T3 chip, which is a CAN transceiver IC.\n*   **VIO:** This section is labeled with red text and shows the VIO (Voltage Input) pin, which is used to supply power to the CAN transceiver.\n*   **STB:** This section is labeled with red text and shows the STB (Standby) pin, which is used to put the CAN transceiver into standby mode.\n*   **RXD:** This section is labeled with red text and shows the RXD (Receive Data) pin, which is used to receive data from the CAN bus.\n*   **TXD:** This section is labeled with red text and shows the TXD (Transmit Data) pin, which is used to transmit data to the CAN bus.\n*   **CANH:** This section is labeled with red text and shows the CANH (CAN High) pin, which is used to transmit data on the CAN bus.\n*   **CANL:** This section is labeled with red text and shows the CANL (CAN Low) pin, which is used to transmit data on the CAN bus.\n*   **GND:** This section is labeled with red text and shows the GND (Ground) pin, which is used to connect the CAN transceiver to ground.\n\n**Right Side:**\n\n*   **Connect to CAN bus:** This section is labeled with red text and features a series of lines and symbols that represent the connections between the CAN FD system and the CAN bus.\n*   **J33:** This section is labeled with red text and shows the J33 connector, which is used to connect the CAN FD system to the CAN bus.\n\nIn summary, the image provides a detailed schematic diagram of the CAN FD system, highlighting the connections between the MCU pins, the CAN transceiver, and the CAN bus. The diagram also shows the various pins and components of the CAN transceiver, including the VIO, STB, RXD, TXD, CANH, CANL, and GND pins. Overall, the image provides a clear and concise visual representation of the CAN FD system's architecture and functionality.""]"
f66b80baf9e191ca337d2ca1466fc28f,"For the applications such as the Internet of Things or product version management, reading the information of an MCU is a common task for developers. This topic describes how to read the Unique ID, Part Number, and Mask Version information on Renesas RA Family microcontrollers.
We can obtain information using the content stored in the following three addresses, which are located as shown below:
project RA2E1/RA2E2/RA2L1 RA2A1/RA4M1/RA4W1/RA6M1/RA6M2/RA6M3/RA6T1 RA4M2/RA4M3/RA6M4/RA6M5/RA6T2/RA4E1/ RA6E1
Unique ID (16bytes) 0x0100_1C00 FMIFRT+14h (0x407F_B1B0) 0x0100_8190
Part number (16bytes) 0x0100_1C10 FMIFRT+24h (0x407F_B1C0) 0x0100_80F0
Mask version (1byte) 0x0100_1C20 FMIFRT+44h (0x407F_B1E0) 0x0100_81B0
FMIFRT* No Yes No
Note: The address of the FMIFRT register is 0x407F_B19C.
About FMIFRT registers
FMIRT register is built into RA2A1, RA4M1, RA4W1, RA6M1, RA6M2, RA6M3, and RA6T1.
FMIFRT is a read-only register that stores the base addresses of the Unique ID register, Part Number register, and MCU Version register.
FMIFRT should be read in 32-bit units.
The address of the FMIFRT register is 0x407F_B19C.
The following steps describe how to read out the Unique ID, Part Number, and Mask Version through the program code, using the RA2L1 as an example.
(1) Unique ID register address and readout method
The 128-bit Unique ID can be read directly through the FSP API ""R_BSP_UniqueIdGet"".
Refer to the following command:
const bsp_unique_id_t* unique_id = R_BSP_UniqueIdGet();
(2) Part Number register address and readout method
There is no API in FSP to read Part Numbers, so the following code is required.
First, define the address of the Part Number register and store the struct of the Part Number array.
#define BSP_FEATURE_BSP_PART_NUMBER_POINTER (0x01001C10U)
typedef struct st_bsp_part_number
{
    union
    {
        uint32_t part_number_words[4];
        uint8_t  part_number_bytes[16];
    };
} bsp_part_number_t;
Then execute the following command in the user code to read out the Part Number.
const bsp_part_number_t* part_number = BSP_FEATURE_BSP_PART_NUMBER_POINTER;
(3) MCU Version register address and readout method
There is no API to read the MCU version in the FSP, so the following code is required.
First, define the address of the MCU Version register:
#define BSP_FEATURE_BSP_MASK_REVISION_POINTER (0x01001C20U)
Then run the following command in the user code to read out the MCU Version.
const uint8_t* mask_version = BSP_FEATURE_BSP_MASK_REVISION_POINTER;
The following results are read out in the debug state (RA2L1 is used as an example):
The product model is written in ASCII code, and the RA2L1 is used as an example to illustrate the following.
Address : 0x0100_1C0F  <->  0x0100_1C00
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
Address : 0x0100_1C1F  <->  0x0100_1C10
（Part number : R7FA2L1AB2DFP case）
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
P
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x50
Address : 0x0100_1C1F  <->  0x0100_1C10
（Part number : R7FA2L1AB2DFM case）
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
M
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x4D
Address : 0x0100_1C2F  <->  0x0100_1C20
~
~
~
~
~
~
~
~
~
~
~
~
0xFF
0xFF
0xFF
0x01

Suitable Products
RA
For the applications such as the Internet of Things or product version management, reading the information of an MCU is a common task for developers. This topic describes how to read the Unique ID, Part Number, and Mask Version information on Renesas RA Family microcontrollers.
We can obtain information using the content stored in the following three addresses, which are located as shown below:
project RA2E1/RA2E2/RA2L1 RA2A1/RA4M1/RA4W1/RA6M1/RA6M2/RA6M3/RA6T1 RA4M2/RA4M3/RA6M4/RA6M5/RA6T2/RA4E1/ RA6E1
Unique ID (16bytes) 0x0100_1C00 FMIFRT+14h (0x407F_B1B0) 0x0100_8190
Part number (16bytes) 0x0100_1C10 FMIFRT+24h (0x407F_B1C0) 0x0100_80F0
Mask version (1byte) 0x0100_1C20 FMIFRT+44h (0x407F_B1E0) 0x0100_81B0
FMIFRT* No Yes No
Note: The address of the FMIFRT register is 0x407F_B19C.
About FMIFRT registers
FMIRT register is built into RA2A1, RA4M1, RA4W1, RA6M1, RA6M2, RA6M3, and RA6T1.
FMIFRT is a read-only register that stores the base addresses of the Unique ID register, Part Number register, and MCU Version register.
FMIFRT should be read in 32-bit units.
The address of the FMIFRT register is 0x407F_B19C.
The following steps describe how to read out the Unique ID, Part Number, and Mask Version through the program code, using the RA2L1 as an example.
(1) Unique ID register address and readout method
The 128-bit Unique ID can be read directly through the FSP API ""R_BSP_UniqueIdGet"".
Refer to the following command:
const bsp_unique_id_t* unique_id = R_BSP_UniqueIdGet();
(2) Part Number register address and readout method
There is no API in FSP to read Part Numbers, so the following code is required.
First, define the address of the Part Number register and store the struct of the Part Number array.
#define BSP_FEATURE_BSP_PART_NUMBER_POINTER (0x01001C10U)
typedef struct st_bsp_part_number
{
    union
    {
        uint32_t part_number_words[4];
        uint8_t  part_number_bytes[16];
    };
} bsp_part_number_t;
Then execute the following command in the user code to read out the Part Number.
const bsp_part_number_t* part_number = BSP_FEATURE_BSP_PART_NUMBER_POINTER;
(3) MCU Version register address and readout method
There is no API to read the MCU version in the FSP, so the following code is required.
First, define the address of the MCU Version register:
#define BSP_FEATURE_BSP_MASK_REVISION_POINTER (0x01001C20U)
Then run the following command in the user code to read out the MCU Version.
const uint8_t* mask_version = BSP_FEATURE_BSP_MASK_REVISION_POINTER;
The following results are read out in the debug state (RA2L1 is used as an example):
The product model is written in ASCII code, and the RA2L1 is used as an example to illustrate the following.
Address : 0x0100_1C0F  <->  0x0100_1C00
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
Address : 0x0100_1C1F  <->  0x0100_1C10
（Part number : R7FA2L1AB2DFP case）
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
P
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x50
Address : 0x0100_1C1F  <->  0x0100_1C10
（Part number : R7FA2L1AB2DFM case）
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
M
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x4D
Address : 0x0100_1C2F  <->  0x0100_1C20
~
~
~
~
~
~
~
~
~
~
~
~
0xFF
0xFF
0xFF
0x01

Suitable Products
RA
For the applications such as the Internet of Things or product version management, reading the information of an MCU is a common task for developers. This topic describes how to read the Unique ID, Part Number, and Mask Version information on Renesas RA Family microcontrollers.
We can obtain information using the content stored in the following three addresses, which are located as shown below:
project RA2E1/RA2E2/RA2L1 RA2A1/RA4M1/RA4W1/RA6M1/RA6M2/RA6M3/RA6T1 RA4M2/RA4M3/RA6M4/RA6M5/RA6T2/RA4E1/ RA6E1
Unique ID (16bytes) 0x0100_1C00 FMIFRT+14h (0x407F_B1B0) 0x0100_8190
Part number (16bytes) 0x0100_1C10 FMIFRT+24h (0x407F_B1C0) 0x0100_80F0
Mask version (1byte) 0x0100_1C20 FMIFRT+44h (0x407F_B1E0) 0x0100_81B0
FMIFRT* No Yes No
Note: The address of the FMIFRT register is 0x407F_B19C.
About FMIFRT registers
FMIRT register is built into RA2A1, RA4M1, RA4W1, RA6M1, RA6M2, RA6M3, and RA6T1.
FMIFRT is a read-only register that stores the base addresses of the Unique ID register, Part Number register, and MCU Version register.
FMIFRT should be read in 32-bit units.
The address of the FMIFRT register is 0x407F_B19C.
The following steps describe how to read out the Unique ID, Part Number, and Mask Version through the program code, using the RA2L1 as an example.
(1) Unique ID register address and readout method
The 128-bit Unique ID can be read directly through the FSP API ""R_BSP_UniqueIdGet"".
Refer to the following command:
const bsp_unique_id_t* unique_id = R_BSP_UniqueIdGet();
(2) Part Number register address and readout method
There is no API in FSP to read Part Numbers, so the following code is required.
First, define the address of the Part Number register and store the struct of the Part Number array.
#define BSP_FEATURE_BSP_PART_NUMBER_POINTER (0x01001C10U)
typedef struct st_bsp_part_number
{
    union
    {
        uint32_t part_number_words[4];
        uint8_t  part_number_bytes[16];
    };
} bsp_part_number_t;
Then execute the following command in the user code to read out the Part Number.
const bsp_part_number_t* part_number = BSP_FEATURE_BSP_PART_NUMBER_POINTER;
(3) MCU Version register address and readout method
There is no API to read the MCU version in the FSP, so the following code is required.
First, define the address of the MCU Version register:
#define BSP_FEATURE_BSP_MASK_REVISION_POINTER (0x01001C20U)
Then run the following command in the user code to read out the MCU Version.
const uint8_t* mask_version = BSP_FEATURE_BSP_MASK_REVISION_POINTER;
The following results are read out in the debug state (RA2L1 is used as an example):
The product model is written in ASCII code, and the RA2L1 is used as an example to illustrate the following.
Address : 0x0100_1C0F  <->  0x0100_1C00
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
Address : 0x0100_1C1F  <->  0x0100_1C10
（Part number : R7FA2L1AB2DFP case）
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
P
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x50
Address : 0x0100_1C1F  <->  0x0100_1C10
（Part number : R7FA2L1AB2DFM case）
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
M
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x4D
Address : 0x0100_1C2F  <->  0x0100_1C20
~
~
~
~
~
~
~
~
~
~
~
~
0xFF
0xFF
0xFF
0x01
For the applications such as the Internet of Things or product version management, reading the information of an MCU is a common task for developers. This topic describes how to read the Unique ID, Part Number, and Mask Version information on Renesas RA Family microcontrollers.
We can obtain information using the content stored in the following three addresses, which are located as shown below:
Note: The address of the FMIFRT register is 0x407F_B19C.
About FMIFRT registers
The following steps describe how to read out the Unique ID, Part Number, and Mask Version through the program code, using the RA2L1 as an example.
(1) Unique ID register address and readout method
The 128-bit Unique ID can be read directly through the FSP API ""R_BSP_UniqueIdGet"".
Refer to the following command:
const bsp_unique_id_t* unique_id = R_BSP_UniqueIdGet();
const bsp_unique_id_t* unique_id = R_BSP_UniqueIdGet();
(2) Part Number register address and readout method
There is no API in FSP to read Part Numbers, so the following code is required.
First, define the address of the Part Number register and store the struct of the Part Number array.
#define BSP_FEATURE_BSP_PART_NUMBER_POINTER (0x01001C10U)
typedef struct st_bsp_part_number
{
    union
    {
        uint32_t part_number_words[4];
        uint8_t  part_number_bytes[16];
    };
} bsp_part_number_t;
Then execute the following command in the user code to read out the Part Number.
const bsp_part_number_t* part_number = BSP_FEATURE_BSP_PART_NUMBER_POINTER;
const bsp_part_number_t* part_number = BSP_FEATURE_BSP_PART_NUMBER_POINTER;
(3) MCU Version register address and readout method
There is no API to read the MCU version in the FSP, so the following code is required.
First, define the address of the MCU Version register:
#define BSP_FEATURE_BSP_MASK_REVISION_POINTER (0x01001C20U)
Then run the following command in the user code to read out the MCU Version.
const uint8_t* mask_version = BSP_FEATURE_BSP_MASK_REVISION_POINTER;
const uint8_t* mask_version = BSP_FEATURE_BSP_MASK_REVISION_POINTER;
The following results are read out in the debug state (RA2L1 is used as an example):
The product model is written in ASCII code, and the RA2L1 is used as an example to illustrate the following.
Address : 0x0100_1C0F  <->  0x0100_1C00
Address : 0x0100_1C0F  <->  0x0100_1C00
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
Address : 0x0100_1C1F  <->  0x0100_1C10
（Part number : R7FA2L1AB2DFP case）
Address : 0x0100_1C1F  <->  0x0100_1C10
（
Part number : R7FA2L1AB2DFP case
）
space
space
space
space
space
space
R
R
7
7
F
F
A
A
2
2
L
L
1
1
A
A
B
B
2
2
D
D
F
F
P
P
0x20
0x20
0x20
0x20
0x20
0x20
0x52
0x52
0x37
0x37
0x46
0x46
0x41
0x41
0x32
0x32
0x4C
0x4C
0x31
0x31
0x41
0x41
0x42
0x42
0x32
0x32
0x44
0x44
0x46
0x46
0x50
0x50
Address : 0x0100_1C1F  <->  0x0100_1C10
（Part number : R7FA2L1AB2DFM case）
Address : 0x0100_1C1F  <->  0x0100_1C10
（
Part number : R7FA2L1AB2DFM case
）
space
space
space
space
space
space
R
R
7
7
F
F
A
A
2
2
L
L
1
1
A
A
B
B
2
2
D
D
F
F
M
M
0x20
0x20
0x20
0x20
0x20
0x20
0x52
0x52
0x37
0x37
0x46
0x46
0x41
0x41
0x32
0x32
0x4C
0x4C
0x31
0x31
0x41
0x41
0x42
0x42
0x32
0x32
0x44
0x44
0x46
0x46
0x4D
0x4D
Address : 0x0100_1C2F  <->  0x0100_1C20
Address : 0x0100_1C2F  <->  0x0100_1C20
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0x01
0x01
Suitable Products
RA","['data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/022ea4391fdab4bfe20bacbaab096253.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/537533407aa4c811e0635ddb92055094.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/84f145e865ab8df4d545bc49d0a26588.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/b9e58503fbcc3997ec396a27d5e84610.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/7b90d83182253db54f83b490d14dd3ed.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/d30a4927e87e9142b7a058b6912818aa.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/9d3953580a05769fbbff05450164a87c.png']",[],"['|  |\n|  |\n| project | RA2E1/RA2E2/RA2L1 | RA2A1/RA4M1/RA4W1/RA6M1/RA6M2/RA6M3/RA6T1 | RA4M2/RA4M3/RA6M4/RA6M5/RA6T2/RA4E1/ RA6E1 |\n| Unique ID (16bytes) | 0x0100_1C00 | FMIFRT+14h (0x407F_B1B0) | 0x0100_8190 |\n| Part number (16bytes) | 0x0100_1C10 | FMIFRT+24h (0x407F_B1C0) | 0x0100_80F0 |\n| Mask version (1byte) | 0x0100_1C20 | FMIFRT+44h (0x407F_B1E0) | 0x0100_81B0 |\n| FMIFRT* | No | Yes | No |', '|  |\n|  |\n| Address : 0x0100_1C0F  <->  0x0100_1C00 |\n| xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx |\n| Address : 0x0100_1C1F  <->  0x0100_1C10\n（Part number : R7FA2L1AB2DFP case） |\n| space | space | space | R | 7 | F | A | 2 | L | 1 | A | B | 2 | D | F | P |\n| 0x20 | 0x20 | 0x20 | 0x52 | 0x37 | 0x46 | 0x41 | 0x32 | 0x4C | 0x31 | 0x41 | 0x42 | 0x32 | 0x44 | 0x46 | 0x50 |\n| Address : 0x0100_1C1F  <->  0x0100_1C10\n（Part number : R7FA2L1AB2DFM case） |\n| space | space | space | R | 7 | F | A | 2 | L | 1 | A | B | 2 | D | F | M |\n| 0x20 | 0x20 | 0x20 | 0x52 | 0x37 | 0x46 | 0x41 | 0x32 | 0x4C | 0x31 | 0x41 | 0x42 | 0x32 | 0x44 | 0x46 | 0x4D |\n| Address : 0x0100_1C2F  <->  0x0100_1C20 |\n| ~ | ~ | ~ | ~ | ~ | ~ | ~ | ~ | ~ | ~ | ~ | ~ | 0xFF | 0xFF | 0xFF | 0x01 |', '|  |\n|  |\n| RA |']","{'title': 'About how RA MCU reads Unique ID and Device Part Number', 'url': 'https://en-support.renesas.com/knowledgeBase/21397541', 'last_updated': None, 'extracted_at': '2025-03-08T23:14:12.060291'}","For the applications such as the Internet of Things or product version management, reading the information of an MCU is a common task for developers. This topic describes how to read the Unique ID, Part Number, and Mask Version information on Renesas RA Family microcontrollers. We can obtain information using the content stored in the following three addresses, which are located as shown below project RA2E1/RA2E2/RA2L1 RA2A1/RA4M1/RA4W1/RA6M1/RA6M2/RA6M3/RA6T1 RA4M2/RA4M3/RA6M4/RA6M5/RA6T2/RA4E1/ RA6E1 Unique ID (16bytes) 0x01001C00 FMIFRT14h (0x407FB1B0) 0x01008190 Part number (16bytes) 0x01001C10 FMIFRT24h (0x407FB1C0) 0x010080F0 Mask version (1byte) 0x01001C20 FMIFRT44h (0x407FB1E0) 0x010081B0 FMIFRT No Yes No Note The address of the FMIFRT register is 0x407FB19C. About FMIFRT registers FMIRT register is built into RA2A1, RA4M1, RA4W1, RA6M1, RA6M2, RA6M3, and RA6T1. FMIFRT is a read-only register that stores the base addresses of the Unique ID register, Part Number register, and MCU Version register. FMIFRT should be read in 32-bit units. The address of the FMIFRT register is 0x407FB19C. The following steps describe how to read out the Unique ID, Part Number, and Mask Version through the program code, using the RA2L1 as an example. (1) Unique ID register address and readout method The 128-bit Unique ID can be read directly through the FSP API ""RBSPUniqueIdGet"". Refer to the following command const bspuniqueidt uniqueid  RBSPUniqueIdGet(); (2) Part Number register address and readout method There is no API in FSP to read Part Numbers, so the following code is required. First, define the address of the Part Number register and store the struct of the Part Number array. define BSPFEATUREBSPPARTNUMBERPOINTER (0x01001C10U) typedef struct stbsppartnumber  union  uint32t partnumberwords4; uint8t partnumberbytes16; ;  bsppartnumbert; Then execute the following command in the user code to read out the Part Number. const bsppartnumbert partnumber  BSPFEATUREBSPPARTNUMBERPOINTER; (3) MCU Version register address and readout method There is no API to read the MCU version in the FSP, so the following code is required. First, define the address of the MCU Version register define BSPFEATUREBSPMASKREVISIONPOINTER (0x01001C20U) Then run the following command in the user code to read out the MCU Version. const uint8t maskversion  BSPFEATUREBSPMASKREVISIONPOINTER; The following results are read out in the debug state (RA2L1 is used as an example) The product model is written in ASCII code, and the RA2L1 is used as an example to illustrate the following. Address  0x01001C0F - 0x01001C00 xx Address  0x01001C1F - 0x01001C10 Part number  R7FA2L1AB2DFP case space R 7 F A 2 L 1 B D P 0x20 0x52 0x37 0x46 0x41 0x32 0x4C 0x31 0x42 0x44 0x50 Part number  R7FA2L1AB2DFM case M 0x4D Address  0x01001C2F - 0x01001C20  0xFF 0x01 Suitable Products RA  Part number  R7FA2L1AB2DFP case  Part number  R7FA2L1AB2DFM case","['The image displays a screenshot of a technical document, specifically a ""Factory MCU Information Flash Root Table (FMIFRT)"" for a microcontroller unit (MCU). The document is presented in a clear and organized format, with a focus on providing detailed information about the MCU\'s flash memory.\n\n**Header Section**\n\n*   **Title**: The title of the document is prominently displayed at the top, reading ""Factory MCU Information Flash Root Table (FMIFRT)"" in blue text.\n*   **Address(es)**: Below the title, the address(es) of the document are listed, which appear to be hexadecimal values.\n*   **Bit**: The bit column is located on the left side of the table, with values ranging from 0 to 31.\n\n**Table Section**\n\n*   **Description**: The description column is situated below the bit column, providing a brief explanation of each bit\'s function.\n*   **R/W**: The R/W column is located on the right side of the table, indicating whether each bit is read-only (R) or read/write (W).\n\n**Content**\n\n*   The table contains 32 rows, each representing a different bit in the MCU\'s flash memory.\n*   Each row includes the bit number, description, and R/W status.\n*   The descriptions provide information about the purpose of each bit, such as ""Base address of Unique ID"" or ""Part Numbering register"".\n\n**Footer Section**\n\n*   **Bit**: The footer section repeats the bit column, providing a summary of the bit values.\n*   **Description**: The description column is also repeated in the footer, summarizing the descriptions of each bit.\n*   **R/W**: The R/W column is repeated in the footer, summarizing the R/W status of each bit.\n\n**Additional Information**\n\n*   At the bottom of the page, there is a note that states: ""The FMIFRT is a read-only register that stores a base address of the Unique ID register, Part Numbering register and MCU Version register. The FMIFRT should be read in 32-bit units. The base address of RA6M1 MCU is 0x01007000.""\n*   The note provides additional context about the FMIFRT and its purpose.\n\nOverall, the image provides a detailed and organized overview of the Factory MCU Information Flash Root Table (FMIFRT) for a microcontroller unit (MCU). The table and descriptions provide a clear understanding of the MCU\'s flash memory and its various components.', 'The image displays a technical diagram for a Unique ID Register (UIDRn) in a microcontroller unit (MCU). The diagram is divided into several sections, each with its own set of information.\n\n*   **Address:** The address of the UIDRn is 0x0100_1C00 + n * 4, where n is the register number.\n*   **Bit position:** The bit position of the UIDRn is 31.\n*   **Bit field:** The bit field of the UIDRn is UID[31:0], which represents a 32-bit value.\n*   **Value after reset:** The value after reset is Unique value for each chip.\n*   **Bit:** The bit is 31:0, which represents a 32-bit value.\n*   **Symbol:** The symbol is UID[31:0], which represents a 32-bit value.\n*   **Function:** The function is Unique ID, which represents a unique identifier for each chip.\n*   **R/W:** The R/W field indicates that the register is read-only, meaning it can only be read and not written to.\n*   **R:** The R field indicates that the register is readable, meaning its value can be read.\n\nThe UIDRn is a read-only register that stores a 16-byte ID code (unique ID) for identifying the individual MCU. The UIDRn register should be read in 32-bit units.', 'The image displays a screenshot of a computer program, specifically a part numbering register (PNRn) register. The title at the top reads ""PNRn : Part Numbering Register n (n = 0 to 3)"".\n\n*   **Address**: The address is displayed as ""0x0100_1C10 + n × 4"", indicating that the register is located at a specific memory address.\n*   **Bit position**: The bit position is shown as ""31"", which means that the register occupies a single bit in the memory address.\n*   **Bit field**: The bit field is labeled as ""PNR[31:0]"", indicating that the register contains a 32-bit value.\n*   **Value after reset**: The value after reset is listed as ""Unique value for each chip"", suggesting that each chip has a unique identifier stored in this register.\n*   **Bit**: The bit is labeled as ""31:0"", indicating that it is a 32-bit register.\n*   **Symbol**: The symbol is listed as ""PNR[31:0]"", which is the same as the bit field label.\n*   **Function**: The function is described as ""Part Number"", indicating that the register stores a unique identifier for each chip.\n*   **R/W**: The R/W column is empty, suggesting that the register is read-only.\n*   **R**: The R column is filled with an ""R"", indicating that the register can be read.\n\nIn summary, the image shows a part numbering register (PNRn) register that stores a unique identifier for each chip. The register is located at a specific memory address, occupies a single bit, and contains a 32-bit value. The value after reset is unique for each chip, and the register can be read but not written to.', 'The image displays a screenshot of a computer screen with a text box containing information about an MCUVER: MCU Version Register.\n\n**Title**\nThe title at the top of the image reads ""35.3.29 MCUVER : MCU Version Register"" in black text.\n\n**Text Box**\nBelow the title, there is a text box with the following information:\n\n*   **Address:** 0x0100_1C20\n*   **Bit position:** 7 6 5 4 3 2 1 0\n*   **Bit field:** MCUVE[7:0]\n*   **Value after reset:** Value depend on the chip\n\n**Table**\nBelow the text box, there is a table with the following columns:\n\n*   **Bit**\n*   **Symbol**\n*   **Function**\n*   **R/W**\n\nThe table contains the following data:\n\n| Bit | Symbol | Function | R/W |\n| --- | --- | --- | --- |\n| 7:0 | MCUVE[7:0] | MCU Version | R |\n\n**Description**\nAt the bottom of the image, there is a description that reads: ""The MCUVER is a read-only register that stores a MCU version. The MCUVER register should be read in 8-bit units. The higher the value, the newer MCU version.""\n\n**Background**\nThe background of the image is white.', 'The image shows a table with a list of unique identifiers (UIDs) and their corresponding values. The table has two columns: ""unique_id"" and ""const bsp_unique_id_t *"". The ""unique_id"" column contains a list of UIDs, while the ""const bsp_unique_id_t *"" column contains the corresponding values for each UID.\n\nThe UIDs are listed in the following order:\n\n* unique_id_words\n* unique_id_words[0]\n* unique_id_words[1]\n* unique_id_words[2]\n* unique_id_words[3]\n* unique_id_bytes\n* unique_id_bytes[16]\n\nThe corresponding values for each UID are:\n\n* unique_id_words: 0x1001c00\n* unique_id_words[0]: 0x370a220a (Hex)\n* unique_id_words[1]: 0x37383030 (Hex)\n* unique_id_words[2]: 0x4b3339 (Hex)\n* unique_id_words[3]: 0x4b57286f (Hex)\n* unique_id_bytes: 0x1001c00\n* unique_id_bytes[16]: 0x16\n\nThe table appears to be a list of unique identifiers and their corresponding values, possibly used in a programming context. The use of hexadecimal values suggests that the data may be related to computer programming or coding.', 'The image presents a table of data, likely from a programming or coding context, with a header row and multiple rows of data. The header row is labeled ""part_number"" and contains three columns: ""const bsp_part_number_t *"", ""0x1001c10"", and ""0x1001c10"". The first column lists various part numbers, while the second and third columns contain hexadecimal values.\n\nThe table appears to be a list of part numbers and their corresponding hexadecimal values. The part numbers are listed in the first column, and the hexadecimal values are listed in the second and third columns. The table does not provide any additional information or context about the part numbers or their meanings.\n\nOverall, the image suggests that the table is used to store and organize data related to part numbers and their corresponding hexadecimal values. The table may be used in a programming or coding context to reference or manipulate the data.', 'The image displays a code snippet in a programming language, likely C or C++. The code is written in a text editor or IDE (Integrated Development Environment) and is presented in a monospaced font.\n\nThe code snippet consists of two lines:\n\n*   `mask_version = *mask_version`\n*   `const uint8_t * const uint8_t`\n\nThe first line assigns the value of the variable `mask_version` to itself, effectively doing nothing. The second line declares a pointer to a constant unsigned 8-bit integer (`const uint8_t *`) and assigns it the value `1`.\n\nThe code is written in a simple and straightforward style, with clear indentation and spacing. The use of `const` keywords indicates that the variables are intended to be read-only, and the use of pointers suggests that the code is working with memory addresses.\n\nOverall, the code appears to be a simple example of how to work with pointers and constants in a programming language. It does not seem to be part of a larger program or project, but rather a standalone demonstration of these concepts.']"
5561a6e66e0edc7cbca9ffd52dd4046a,"Is it possible to set the TrustZone boundaries runtime?
In general for most RA MCUs, that are using a Cortex-M33 core the TrustZone boundaries cannot be changed in the firmware. And the MCUs need to be placed in either SCI or USB boot mode. However for the new E-devices like RA4E2 and RA6E2 the Trustzone boundaries can be set runtime by writing to the following registers:
Resources:
RA4E2 Group User's Manual: Hardware
RA6E2 Group User's Manual: Hardware
Suitable Products
RA4E2,RA6E2
RA4E2,RA6E2",['data/categories/ra_family/ra4__ra6_series_with_cortex-m33_core/5561a6e66e0edc7cbca9ffd52dd4046a/images/cf217399d110bbb321daa81472775099.png'],[],[],"{'title': 'RA4E2, RA6E2: Is it possible to set the TrustZone boundaries runtime?', 'url': 'https://en-support.renesas.com/knowledgeBase/21671949', 'last_updated': None, 'extracted_at': '2025-03-08T23:30:48.616301'}","Is it possible to set the TrustZone boundaries runtime? In general for most RA MCUs, that are using a Cortex-M33 core the TrustZone boundaries cannot be changed in the firmware. And the MCUs need to be placed in either SCI or USB boot mode. However for the new E-devices like RA4E2 and RA6E2 the Trustzone boundaries can be set runtime by writing to the following registers Resources RA4E2 Group User's Manual Hardware RA6E2 Group User's Manual Hardware Suitable Products RA4E2,RA6E2","['The image displays a page from a technical document, specifically page 1802 of 1896, dated July 31, 2024. The title at the top reads ""44.2.2 Memory Security Attribution"" in black text. Below the title, a paragraph explains that the code flash, data flash, and SRAM are divided into Secure (S), Non-secure (NS), and Non-secure callable (NSC) regions.\n\nThe main content of the page is a list of memory security attributes, which are set in the following registers:\n\n*   Code Flash Security Attribution Register A (CFSAMONA)\n*   Code Flash Security Attribution Register B (CFSAMONB)\n*   Data Flash Security Attribution Register (DFSAMON)\n*   SRAM Security Attribution Register A (SSAMONA)\n*   SRAM Security Attribution Register B (SSAMONB)\n\nThe text is written in black, with some words highlighted in blue. The background of the page is white, and there is a blue line at the bottom with the text ""Renesas"" in the center. The page number and date are displayed in the bottom-left corner, while the page count is shown in the bottom-right corner. Overall, the image appears to be a technical document related to memory security attribution in microcontrollers.']"
09ec298bc3147151544a700b17aace92,"The RA2 Series have available the SCI boot mode. The SCI boot mode is a state where the on-chip flash memory routine (SCI boot program), stored in the boot area within the MCU is used. In this mode the host sends some commands to do some basic operations like programming, erasing the flash memory (code and data flash) etc.
To put the MCU on this state you need to drive the MD pin (P201) to low level. For example, on EK-RA2L1 you need to close jumper J16.
The MCU will enter the boot mode only when the MD pin is held low on release from reset state.
To use the SCI boot mode SCI channel 9 must be used (SCI9).  Below you can find the pins used to communicate with the device in boot mode through 2-Wire UART interface to make basic operations.
To program the flash memory with Renesas Flash Programmer you need to use a USB to UART bridge and make the connections described below:
TXD (USB to UART bridge) ->RXD9 (P110)
RXD (USB to UART bridge) -> TXD9 (P109)
In Renesas Flash Programmer create a new project and set the Communication Settings as shown below:
And then you can select your image file to program the MCU, while being in boot mode through RFP with a USB to UART bridge only used.
You can download Renesas Flash Programmer and it's User's Manual from here:
https://www.renesas.com/en/software-tool/renesas-flash-programmer-programming-gui
Suitable Products
RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2
RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2","['data/categories/ra_family/ra2_series_with_cortex-m23_core/09ec298bc3147151544a700b17aace92/images/9804d5dcd04187b7ab818a6f3e807918.png', 'data/categories/ra_family/ra2_series_with_cortex-m23_core/09ec298bc3147151544a700b17aace92/images/53bb3b2b44b3ab27ef73c24b8648e414.png', 'data/categories/ra_family/ra2_series_with_cortex-m23_core/09ec298bc3147151544a700b17aace92/images/10b688a0258a8c93958b783457d9c8d8.png', 'data/categories/ra_family/ra2_series_with_cortex-m23_core/09ec298bc3147151544a700b17aace92/images/a916005241c85fa3432720a0d82a0fba.png', 'data/categories/ra_family/ra2_series_with_cortex-m23_core/09ec298bc3147151544a700b17aace92/images/9903db08771cb3575f6a776b316255ae.png']",[],[],"{'title': 'Using SCI Boot with RA2 and RFP.', 'url': 'https://en-support.renesas.com/knowledgeBase/21676626', 'last_updated': None, 'extracted_at': '2025-03-08T23:31:57.397554'}","The RA2 Series have available the SCI boot mode. The SCI boot mode is a state where the on-chip flash memory routine (SCI boot program), stored in the boot area within the MCU is used. In this mode the host sends some commands to do some basic operations like programming, erasing the flash memory (code and data flash) etc. To put the MCU on this state you need to drive the MD pin (P201) to low level. For example, on EK-RA2L1 you need to close jumper J16. The MCU will enter the boot mode only when the MD pin is held low on release from reset state. To use the SCI boot mode SCI channel 9 must be used (SCI9). Below you can find the pins used to communicate with the device in boot mode through 2-Wire UART interface to make basic operations. To program the flash memory with Renesas Flash Programmer you need to use a USB to UART bridge and make the connections described below TXD (USB to UART bridge) -RXD9 (P110) RXD (USB to UART bridge) - TXD9 (P109) In Renesas Flash Programmer create a new project and set the Communication Settings as shown below And then you can select your image file to program the MCU, while being in boot mode through RFP with a USB to UART bridge only used. You can download Renesas Flash Programmer and it's User's Manual from here https//www.renesas.com/en/software-tool/renesas-flash-programmer-programming-gui Suitable Products RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2","['The image depicts a flowchart illustrating the mode-setting pin level and operating mode. The flowchart consists of three main sections: ""Single-chip mode,"" ""SCI boot mode,"" and ""Reset."" Each section has two sub-sections, with arrows connecting them to indicate the flow of operations.\n\n**Single-chip mode**\n\n*   MD = 1 and release RES pin\n*   Release POR\n\n**SCI boot mode**\n\n*   MD = 0 and release RES pin\n\n**Reset**\n\n*   RES pin or POR occurs\n*   RES pin or POR occurs\n\nThe flowchart shows that when the MD pin is set to 1 and the RES pin is released, the system enters single-chip mode. If the MD pin is set to 0 and the RES pin is released, the system enters SCI boot mode. If the RES pin or POR occurs, the system resets.\n\nOverall, the flowchart provides a clear and concise overview of the mode-setting pin level and operating mode, making it easy to understand and follow the system\'s behavior.', 'The image presents a table with the title ""I/O pins of flash memory-related modules"" and is labeled as ""Table 37.18."" The table consists of four columns: ""Pin name,"" ""I/O,"" ""Applicable modes,"" and ""Function."" The table contains three rows, each representing a different pin:\n\n*   **MD**: This pin is used for input and is applicable in SCI boot mode (serial programming mode). Its function is to select the operating mode.\n*   **P110/RX09**: This pin is used for input and is applicable in SCI boot mode. Its function is to receive data through the SCI.\n*   **P109/TXD9**: This pin is used for output and is applicable for host communication, to transmit data through the SCI.\n\nThe table provides a clear and concise overview of the I/O pins of flash memory-related modules, including their names, input/output functions, applicable modes, and functions.', 'The image shows a screenshot of a computer program, specifically a project creation interface. The title at the top reads ""Create New Project"" in black text.\n\nBelow the title are several sections with labels and input fields. The first section is labeled ""Project Information"" and contains fields for entering the project name, microcontroller, and project folder. The second section is labeled ""Communication"" and has two fields: ""Tool"" and ""Interface"". The ""Tool"" field is set to ""COM port"", and the ""Interface"" field is set to ""2 wire UART"".\n\nAt the bottom of the window are buttons labeled ""Connect"" and ""Cancel"". The background of the window is light gray, and the text and buttons are black.\n\nOverall, the image appears to be a screenshot of a software tool used for creating and managing projects related to microcontrollers and communication protocols.', 'The image shows a screenshot of the Renesas Flash Programmer V3.15.00 software, which is used to program and erase flash memory devices. The software is open on a computer screen, with various menus and options available for configuring the programmer.\n\n*   **Project Information**\n    *   Current Project: SCI_Boot_RA2L1.rpj\n    *   Microcontroller: RA\n*   **Program Files**\n    *   CRC-32: D4BB13BB\n    *   Add/Remove Files...\n*   **Command**\n    *   Erase >> Program >> Verify\n*   **Start**\n    *   A button to start the programming process\n*   **Connecting to the target device**\n    *   Setting the target device\n    *   Setting the target device\n    *   Query the device information.\n    *   Signature: RA\n    *   Device: RA\n    *   Boot Firmware Version: V1.0\n    *   Device Code: 06\n    *   Code Flash 1 (Address: 0x00000000, Size: 256 K, Erase Size: 2 K)\n    *   Data Flash 1 (Address: 0x40100000, Size: 8 K, Erase Size: 1 K)\n    *   Config Area 1 (Address: 0x01010010, Size: 36, Erase Size: 0)\n*   **Disconnecting the tool**\n    *   Operation completed.\n\nOverall, the image shows a user-friendly interface for programming and erasing flash memory devices using the Renesas Flash Programmer V3.15.00 software. The software provides various options for configuring the programmer, including setting the target device, querying device information, and disconnecting the tool.', 'The image shows a screenshot of a computer program with a white background and black text. The text is in a monospaced font and is divided into sections by lines of dashes.\n\n*   **Erasing the selected blocks**\n    *   Code Flash: 0x00000000 - 0x0003FFFF\n    *   Data Flash: 0x40100000 - 0x40101FFF\n    *   size: 256 K\n    *   size: 8 K\n*   **Writing data to the target device**\n    *   Code Flash: 0x00000000 - 0x00000E63\n    *   Config Area: 0x01010018 - 0x01010033\n    *   size: 3.6 K\n    *   size: 28\n*   **Verifying data**\n    *   Code Flash: 0x00000000 - 0x00000E63\n    *   Config Area: 0x01010018 - 0x01010033\n    *   size: 3.6 K\n    *   size: 28\n*   **Disconnecting the tool**\n    *   Operation completed.\n\nThe image appears to be a screenshot of a computer program used for programming or debugging microcontrollers. The program is displaying information about the erasure and writing of data to the target device, as well as the verification of the data. The program also indicates that the operation has been completed.']"
313b8db3b3234df44b7220c593992b46,"Question:
How to generate a complementary/push-pull PWM signal
Answer:
The GPT (general purpose timer – r_gpt) module can be used to generate complementary/push-pull PWM signals.
The below reference example configuration generates two complementary PWM signals with a 10Khz frequency-
GPT mode and frequency:


Pin state configuration:


The timer output pins generate two complementary PWM signal waveforms of 10Khz as shown below:


Suitable Products
RA Family
How to generate a complementary/push-pull PWM signal
How to generate a complementary/push-pull PWM signal
Answer:
The GPT (general purpose timer – r_gpt) module can be used to generate complementary/push-pull PWM signals.
The below reference example configuration generates two complementary PWM signals with a 10Khz frequency-
GPT mode and frequency:


Pin state configuration:


The timer output pins generate two complementary PWM signal waveforms of 10Khz as shown below:


Suitable Products
RA Family
The GPT (general purpose timer – r_gpt) module can be used to generate complementary/push-pull PWM signals.
The below reference example configuration generates two complementary PWM signals with a 10Khz frequency-
GPT mode and frequency:


Pin state configuration:


The timer output pins generate two complementary PWM signal waveforms of 10Khz as shown below:
The GPT (general purpose timer – r_gpt) module can be used to generate complementary/push-pull PWM signals.
The below reference example configuration generates two complementary PWM signals with a 10Khz frequency-
GPT mode and frequency:
Pin state configuration:
The timer output pins generate two complementary PWM signal waveforms of 10Khz as shown below:
Suitable Products
RA Family","['data/categories/ra_family/timer/313b8db3b3234df44b7220c593992b46/images/7477eea50361ae67d2bcadddead125f1.png', 'data/categories/ra_family/timer/313b8db3b3234df44b7220c593992b46/images/f199977cc2d2e4201f97b19da6005402.png', 'data/categories/ra_family/timer/313b8db3b3234df44b7220c593992b46/images/de6adabfc9961d3aed9d336b477b9927.png']",[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: How to generate a complementary/push-pull PWM signal', 'url': 'https://en-support.renesas.com/knowledgeBase/21056466', 'last_updated': None, 'extracted_at': '2025-03-08T23:40:02.135823'}",Question How to generate a complementary/push-pull PWM signal Answer The GPT (general purpose timer  rgpt) module can be used to generate complementary/push-pull PWM signals. The below reference example configuration generates two complementary PWM signals with a 10Khz frequency- GPT mode and frequency Pin state configuration The timer output pins generate two complementary PWM signal waveforms of 10Khz as shown below Suitable Products RA Family,"['The image shows a table with a red border around it, containing information about a module. The table has two columns: ""Name"" and ""Channel"". The ""Name"" column contains the text ""g_timer0"", and the ""Channel"" column contains the number ""0"". Below the table, there are three lines of text that read ""Mode"", ""Period"", and ""Period Unit"". The ""Mode"" line contains the text ""PWM"", the ""Period"" line contains the number ""10"", and the ""Period Unit"" line contains the text ""Kilohertz"".\n\nThe background of the image is white, with a grid pattern of thin gray lines. The overall appearance suggests that this is a screenshot of a computer program or software interface, possibly related to electronics or engineering.', 'The image shows a screenshot of a computer program with a list of settings. The title at the top reads ""g_timer0 Timer, General PWM (r_gpt)"" in black text. Below the title, there are two columns: ""Property"" and ""Value"". The ""Property"" column lists various settings, such as ""Parameter Checking"", ""Pin Output Support"", ""Module g_timer0 Timer, General PWM (_r_gpt)"", ""Output"", ""Custom Waveform"", and ""GTIOA"". The ""Value"" column shows the corresponding values for each setting, including ""Default (BSP)"", ""Enabled"", ""PCLKD"", ""General"", ""GTIOA"", ""Pin Level Low"", ""Pin Level High"", ""Pin Level Low"", ""Pin Level High"", ""Disabled"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level Low"",', 'The image presents a screenshot of a computer program, likely a simulation or modeling tool, featuring a timeline with various events and data points. The timeline is divided into sections, each representing a different time period, and includes several key elements:\n\n*   **Timeline**: The timeline is the central element of the image, spanning from 2023-08-17 17:26:08.120 to 2023-08-17 17:26:08.130. It is divided into sections, each representing a different time period.\n*   **Events**: The timeline includes several events, represented by small boxes or markers, which are scattered throughout the timeline. These events may represent specific actions, milestones, or data points.\n*   **Data Points**: The timeline also includes several data points, represented by small numbers or values, which are scattered throughout the timeline. These data points may represent measurements, readings, or other types of data.\n*   **Labels**: The timeline includes several labels, which provide additional information about the events and data points. These labels may include text, such as ""Stop"" or ""Sample"", or symbols, such as arrows or icons.\n*   **Color Scheme**: The timeline features a color scheme, with different colors used to represent different types of events or data points. For example, red may be used to represent stop events, while green may be used to represent sample events.\n*   **Background**: The background of the image is a light gray color, which provides a clean and neutral backdrop for the timeline and its various elements.\n\nOverall, the image appears to be a screenshot of a computer program, likely a simulation or modeling tool, that is used to visualize and analyze data over time. The timeline and its various elements provide a clear and concise way to represent complex data and events, making it easier to understand and interpret the information.']"
e4fe5104cb37e3b6e337a10b84dbd4ea,"Question:
   Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU?
  Answer:
Yes, by writing 0xFF to GTCLR register the waveform outputs will start immediatetely from zero.
    For example, for channel 0 of GPT0 timer the necessary code will be R_GPT0->GTCLR = 0xFFFFFFFF.
  Also, there is a second way, using the R_GPT_Reset() API.
    Suitable Products
RA FAMILY
Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU?
Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU?
Answer:
Yes, by writing 0xFF to GTCLR register the waveform outputs will start immediatetely from zero.
    For example, for channel 0 of GPT0 timer the necessary code will be R_GPT0->GTCLR = 0xFFFFFFFF.
  Also, there is a second way, using the R_GPT_Reset() API.
    Suitable Products
RA FAMILY
Yes, by writing 0xFF to GTCLR register the waveform outputs will start immediatetely from zero.
    For example, for channel 0 of GPT0 timer the necessary code will be R_GPT0->GTCLR = 0xFFFFFFFF.
  Also, there is a second way, using the R_GPT_Reset() API.
Yes, by writing 0xFF to GTCLR register the waveform outputs will start immediatetely from zero.
For example, for channel 0 of GPT0 timer the necessary code will be R_GPT0->GTCLR = 0xFFFFFFFF.
Also, there is a second way, using the R_GPT_Reset() API.
Suitable Products
RA FAMILY
日本語 中文
日本語
中文","['data/categories/ra_family/timer/e4fe5104cb37e3b6e337a10b84dbd4ea/images/5b49a7fc4db0fde5bfdc3a87e72e1a12.png', 'data/categories/ra_family/timer/e4fe5104cb37e3b6e337a10b84dbd4ea/images/7b448d286912028ab03ce94455162442.png', 'data/categories/ra_family/timer/e4fe5104cb37e3b6e337a10b84dbd4ea/images/50abb2634a01c2e47b401e3c8eb847ff.png']",[],['|  |\n|  |\n| RA FAMILY |'],"{'title': 'Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU?', 'url': 'https://en-support.renesas.com/knowledgeBase/21095654', 'last_updated': None, 'extracted_at': '2025-03-08T23:40:08.482425'}","Question Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU? Answer Yes, by writing 0xFF to GTCLR register the waveform outputs will start immediatetely from zero. For example, for channel 0 of GPT0 timer the necessary code will be RGPT0-GTCLR  0xFFFFFFFF. Also, there is a second way, using the RGPTReset() API. Suitable Products RA FAMILY Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU? Answer For example, for channel 0 of GPT0 timer the necessary code will be RGPT0-GTCLR  0xFFFFFFFF. Also, there is a second way, using the RGPTReset() API. Suitable Products    ","['The image presents a technical document focused on PWM (Pulse Width Modulation) output operation, specifically highlighting the synchronization of PWM outputs. The document is divided into two main sections: a brief introduction and a detailed example.\n\n**Introduction**\n\n*   The introduction provides an overview of the GPT (General Purpose Timer) and its ability to output 20 phases of linked PWM waveforms for a maximum of 10 channels by multiple GPTs.\n*   It explains that Figure 22.61 illustrates an example in which four channels perform synchronized operation in saw-wave PWM mode and eight phases of PWM waveforms are output.\n*   The GTIOCA is set so that it outputs low as the initial value, high at a GTCCRA compare match, and low at the cycle end.\n*   The GTIOCB is set so that it outputs low as the initial value, high at a GTCCRB compare match, and low at the cycle end.\n\n**Example of Synchronized PWM Output**\n\n*   The example is presented in a table format, with each row representing a different phase of the PWM waveform.\n*   The columns represent the different channels (GPT320, GPT321, GPT322, and GPT323) and their corresponding outputs (GTIOCOA, GTIOCOB, GTIOC1A, GTIOC1B, GTIOC2A, GTIOC2B, GTIOC3A, and GTIOC3B).\n*   The table shows the output values for each channel at each phase of the PWM waveform.\n*   The outputs are represented by a series of 1s and 0s, indicating whether the output is high (1) or low (0) at each phase.\n\n**Summary**\n\nIn summary, the image provides a technical document that explains the synchronization of PWM outputs using the GPT. The document includes an introduction that explains the capabilities of the GPT and the example of synchronized PWM output, which is presented in a table format. The example shows the output values for each channel at each phase of the PWM waveform, providing a clear understanding of how the GPT can be used to synchronize PWM outputs.', 'The image displays a screenshot of a computer program, specifically a text-based interface for a General Purpose Timer (GPT) software clear register. The title at the top reads ""GTCLR : General PWM Timer Software Clear Register"" in black text.\n\nBelow the title, there are several lines of code and text that appear to be a header or footer for the program. The main content of the image is a table with four columns and five rows. The columns are labeled ""Bit"", ""Symbol"", ""Function"", and ""R/W"". The rows contain various bits of information related to the GPT software clear register, including the bit position, symbol, function, and read/write status.\n\nAt the bottom of the image, there is a note that explains the purpose of the GTCLR register and how it is used to clear the GTCNT counter operation for each channel n, where n = 0 to 9.\n\nOverall, the image appears to be a technical document or user manual for a specific piece of hardware or software related to timing and counting. It provides detailed information about the GTCLR register and its functions, which would be useful for engineers, programmers, or other technical professionals working with this type of technology.', 'The image shows a screenshot of a computer program with a gray background and black text. The program is titled ""R_GPT_Reset()"" and has a gray bar at the top with the title in blue text. Below the title, there is a section of code in blue text that reads ""fsp.err | R_GPT_Reset ( timer_ctrl | *const p_ctrl )"". \n\nBelow the code section, there is a note in black text that reads ""Resets the counter value to 0. Implements timer_api::reset."" Below the note, there is a section of text that reads ""This function also updates to the new period if no counter overflow has occurred since the last call to R_GPT_PeriodSet()"". \n\nBelow this section, there is a section of text that reads ""Return values"" in bold black text. Below this, there are three lines of text that read ""FSP_SUCCESS"", ""FSP_ERR_ASSERTION p_ctrl was NULL"", and ""FSP_ERR_NOT_OPEN The instance is not opened"". \n\nThe background of the image is a solid gray color. Overall, the image appears to be a screenshot of a computer program with a gray background and black text.']"
d7990364595fa35ac98b1796d83f6efe,"Issue:
After calling the FreeRTOS_IPInit API and setting  the static IP of the device and the initial MAC address. You call the FreeRTOS_UpdateMACAddress API to set the new MAC address.
Even though you can see the new MAC address being assigned to the device with the initial static IP address you have set. You are not able to ping  with the new MAC address set.
Answer:
The issue is the fact that even though the MAC address has been updated after the FreeRTOS_UpdateMACAddress API call. The hardware is still listening on the old MAC address. To solve this problem, you should also update the MAC address for the ethernet peripheral. You should set the new MAC address into the configuration structure of the ethernet instance in your code.
If you navigate the common_data.c file under the ra_gen directory, you will see that there is a configuration structure for the ethernet peripheral holding inside the MAC address set for the device:
As you can see the MAC address in this structure, is set depending on the value of g_ether0_mac_address table also declared on the same file:
This variable holds the contents of  the setting for the MAC address users set on r_ether stack properties in Stacks Tab:
To change the MAC address for the ethernet peripheral you should declare again the table g_ether0_mac_address as extern in the file you want to make the changes. Update its contents with the new physical address and then de-initialize the ethernet peripheral and re-initialize it with the new MAC adress now set:
As soon as this change is done, the device keeping the initial static IP address can ping also with the new MAC address set, other devices in the same network:
Source:  https://community.renesas.com/mcu-mpu/ra/f/forum/33669/change-mac-address-in-ra6m5-microcontroller-during-runtime-after-freertos_ipinit-api-call/119993#119993
Suitable Products
Suitable Products
Suitable Products","['data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/6dd0b9e10ee506b3e5712b384ac87248.png', 'data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/954307efcdf1a4fa24ebb52469297296.png', 'data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/0a2cc705763f0b9aae79a98e4fed7cc5.png', 'data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/6690044c1e3654fd9851452e93047ab9.png', 'data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/033336ffcd445a485d7a35357b32ba62.png', 'data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/c8d2aef5311a6b13988b0123e44de9d3.png']",[],['|  |\n|  |\n| RA / FSP |'],"{'title': 'RA Family: How to change the MAC address of the device runtime using FreeRTOS+TCP', 'url': 'https://en-support.renesas.com/knowledgeBase/21297051', 'last_updated': None, 'extracted_at': '2025-03-08T23:35:16.886376'}","Issue After calling the FreeRTOSIPInit API and setting the static IP of the device and the initial MAC address. You call the FreeRTOSUpdateMACAddress API to set the new MAC address. Even though you can see the new MAC address being assigned to the device with the initial static IP address you have set. You are not able to ping with the new MAC address set. Answer The issue is the fact that even though the MAC address has been updated after the FreeRTOSUpdateMACAddress API call. The hardware is still listening on the old MAC address. To solve this problem, you should also update the MAC address for the ethernet peripheral. You should set the new MAC address into the configuration structure of the ethernet instance in your code. If you navigate the commondata.c file under the ragen directory, you will see that there is a configuration structure for the ethernet peripheral holding inside the MAC address set for the device As you can see the MAC address in this structure, is set depending on the value of gether0macaddress table also declared on the same file This variable holds the contents of the setting for the MAC address users set on rether stack properties in Stacks Tab To change the MAC address for the ethernet peripheral you should declare again the table gether0macaddress as extern in the file you want to make the changes. Update its contents with the new physical address and then de-initialize the ethernet peripheral and re-initialize it with the new MAC adress now set As soon as this change is done, the device keeping the initial static IP address can ping also with the new MAC address set, other devices in the same network Source https//community.renesas.com/mcu-mpu/ra/f/forum/33669/change-mac-address-in-ra6m5-microcontroller-during-runtime-after-freertosipinit-api-call/119993119993 Suitable Products","['The image shows a screenshot of a Windows Explorer window displaying a folder containing various files and subfolders. The folder is titled ""Project Explorer"" and has a red box around it, indicating that it is the current directory being explored.\n\nThe folder contains several files and subfolders, including:\n\n*   ""ethernet_RA6M4_modified""\n*   ""Binaries""\n*   ""Includes""\n*   ""ra""\n*   ""ra_gen""\n*   ""common_data.h""\n*   ""hal_data.c""\n*   ""hal_data.h""\n*   ""main.c""\n*   ""new_thread0.c""\n*   ""new_thread0.h""\n*   ""pin_data.c""\n*   ""vector_data.c""\n*   ""vector_data.h""\n*   ""src""\n*   ""Debug""\n*   ""ra_cfg""\n*   ""script""\n*   ""configuration.xml""\n*   ""ethernet_RA6M4_modified Debug_Flat.jlink""\n*   ""ethernet_RA6M4_modified Debug_Flat.launch""\n*   ""JLinkLog.log""\n*   ""ra_cfg.txt""\n*   ""Developer Assistance""\n\nThe background of the image is a light gray color, which provides good contrast with the darker text and icons. Overall, the image appears to be a screenshot of a Windows Explorer window, likely taken by someone who is working on a project and needs to navigate through the files and subfolders in the ""Project Explorer"" folder.', 'The image shows a screenshot of a code editor with a large block of code in the center. The code is written in C# and appears to be a part of a larger program.\n\n*   The code is written in a monospaced font and is displayed in a gray background.\n*   The code is divided into several sections, each with its own set of variables and functions.\n*   The code includes several comments, which are denoted by the ""//"" symbol.\n*   The code also includes several error messages, which are displayed in red text.\n*   The code is surrounded by a gray border, which helps to distinguish it from the rest of the image.\n*   In the top-left corner of the image, there is a small icon that looks like a gear. This icon is likely used to open a menu or settings panel.\n*   In the top-right corner of the image, there is a small icon that looks like a square with an arrow pointing up. This icon is likely used to minimize or maximize the window.\n*   The background of the image is a light gray color, which provides a clean and neutral backdrop for the code.\n\nOverall, the image appears to be a screenshot of a code editor, possibly Visual Studio or another IDE. The code is well-organized and easy to read, with clear comments and error messages. The gray background and border help to make the code stand out, and the icons in the corners provide quick access to common functions.', 'The image shows a screenshot of a code editor with a large block of code in the center. The code is written in C# and appears to be a part of a larger program.\n\n*   The code is written in a monospaced font and is colored in shades of blue, green, and red.\n*   The code is divided into several sections, each with its own set of variables and functions.\n*   The code includes comments and whitespace to make it easier to read and understand.\n*   The code is likely part of a larger program that is used for a specific purpose, such as data analysis or machine learning.\n\nOverall, the image provides a detailed view of the code and its structure, allowing the viewer to understand how it works and what it does.', 'The image shows a screenshot of a computer program, specifically the ""Stacks Configuration"" window in the FreeRTOS operating system. The window is divided into several sections, each with its own set of options and settings.\n\n*   **Threads**\n    *   This section lists the available threads in the system, along with their current status (e.g., ""New Thread"" or ""Remove"").\n    *   There are several threads listed, including ""g_ioport I/O Port (r_ioport)"", ""FreeRTOS Port (rm_freertos_port)"", and ""FreeRTOS+ TCP"".\n    *   Each thread has a checkbox next to it, allowing the user to select or deselect it.\n*   **Objects**\n    *   This section lists the available objects in the system, along with their current status (e.g., ""New Object"" or ""Remove"").\n    *   There are several objects listed, including ""g_ethernet0 Ethernet (r_ethernet)"", ""g_ethernet_phy0 Ethernet (r_ethernet_phy)"", and ""FreeRTOS Buffer Allocation 2"".\n    *   Each object has a checkbox next to it, allowing the user to select or deselect it.\n*   **Settings**\n    *   This section allows the user to configure various settings for the system.\n    *   There are several options available, including ""Parameter Checking"", ""ETO_LINKSTA Pin Status Flag"", ""Link Signal Change Flag"", and ""Module g_ethernet (r_ethernet)"".\n    *   Each option has a dropdown menu or text box where the user can enter their desired settings.\n*   **API Info**\n    *   This section provides information about the API being used by the system.\n    *   There are several fields listed, including ""Common"", ""Parameter Checking"", ""ETO_LINKSTA Pin Status Flag"", ""Link Signal Change Flag"", and ""Module g_ethernet (r_ethernet)"".\n    *   Each field has a value associated with it, which can be edited by the user.\n\nOverall, the image shows a complex system with many different components and settings. The user can configure various aspects of the system, including threads, objects, and settings, using the options provided in the window.', 'The image shows a screenshot of a computer screen displaying a code editor with a red box highlighting a specific section of code. The code is written in C# and appears to be related to network programming, specifically Ethernet and MAC addresses.\n\nHere are the details of the image:\n\n* **Code Editor**\n\t+ The code editor is open on a Windows desktop.\n\t+ The editor is called ""Visual Studio Code"" and has a light theme.\n\t+ The code is displayed in a large text box with a scrollbar on the right side.\n* **Highlighted Code**\n\t+ The highlighted code is in a red box and is located in the middle of the text box.\n\t+ The code is a C# method that appears to be updating an Ethernet instance with a new MAC address.\n\t+ The code includes several lines of comments and variable declarations.\n* **Code Structure**\n\t+ The code is organized into several sections, including a header section with comments and variable declarations.\n\t+ The main body of the code is divided into several blocks, each with its own set of comments and variable declarations.\n\t+ The code uses a consistent naming convention and indentation style.\n* **Other Elements**\n\t+ There are several other elements on the screen, including a menu bar at the top with options for file, edit, source, refactor, navigate, search, project, run, renaissas AI, window, and help.\n\t+ There is also a status bar at the bottom of the screen with information about the current file and line number.\n\nOverall, the image suggests that the user is working on a project related to network programming and is using Visual Studio Code to write and edit their code. The highlighted code appears to be a critical part of the project, and the user may be trying to troubleshoot an issue or optimize the code for performance.', 'The image shows a screenshot of a terminal window displaying network information. The terminal window is open on a computer, and the text in the window is black on a white background. The text is a series of lines of code, with each line representing a different command or piece of information.\n\nThe first line of code reads ""Network is up"" and is followed by several lines of IP and MAC addresses. The next line of code reads ""Ping from IP address 192.168.1.42 to 192.168.1.238 results: packets sent: 8, packets received: 7, packets lost: 0"". This line indicates that a ping command was sent from the IP address 192.168.1.42 to the IP address 192.168.1.238, and the results of the ping are displayed.\n\nThe next line of code reads ""Button S1 pressed to change the MAC Address"" and is followed by another line of code that reads ""IP address: 192.168.1.42"". This line indicates that a button labeled S1 was pressed to change the MAC address of the device, and the new IP address is displayed.\n\nThe final line of code reads ""MAC address: 00-22-33-44-55-66"" and is followed by another line of code that reads ""Ping from IP address 192.168.1.42 to 192.168.1.238 results: packets sent: 10, packets received: 9, packets lost: 0"". This line indicates that another ping command was sent from the IP address 192.168.1.42 to the IP address 192.168.1.238, and the results of the ping are displayed.\n\nOverall, the image shows a series of network commands and their results, including pings and changes to the MAC address. The commands are displayed in a terminal window, and the results are shown in a clear and concise format.']"
5e2f6446153730f385081f39a48c4a47,"Overview:
Some RA MCUs requires special placement of Code/RAM for proper operation. One example is RAM allocation in the RA6M4 when an ethernet peripheral is used.  The EDMAC peripheral is designed for non-secure operation, so RAM buffer allocated to it needs to be placed in non-secure RAM.
This RAM assignment is accomplished by adding instructions in linker script to move the location counter for .ns_buffer (non-secure buffer) towards the end of RAM, as illustrated below.
Normally RAM is allocation from the start of RAM location.
For an MCU with CMSE (Cortex Microcomputer Security Extension, aka TrustZone), the secure and NSC regions are allocated first.  The remainder are assigned to non-secure.  For a flat project (MCU with CMSE) the ethernet buffers are allocated from the top of RAM while the rest of RAM are allocated from the start of RAM.
When RAM use exceeds the available RAM, the linker will prompt with an error message, of the form “‘RAM’ region overflowed by xyz bytes”.
In the case of a flat project with ethernet, a different error message is seen, of the form ““../arm-none-eabi/bin/ld.exe:fsp.ld:622 cannot move location counter backwards (from 20036d70 to 2002c900)”
Check your RAM assignments and reduce them where possible.  If further RAM reduction is not possible, please consider another MCU with larger RAM.
Some RA MCUs requires special placement of Code/RAM for proper operation. One example is RAM allocation in the RA6M4 when an ethernet peripheral is used.  The EDMAC peripheral is designed for non-secure operation, so RAM buffer allocated to it needs to be placed in non-secure RAM.
This RAM assignment is accomplished by adding instructions in linker script to move the location counter for .ns_buffer (non-secure buffer) towards the end of RAM, as illustrated below.
Normally RAM is allocation from the start of RAM location.
For an MCU with CMSE (Cortex Microcomputer Security Extension, aka TrustZone), the secure and NSC regions are allocated first.  The remainder are assigned to non-secure.  For a flat project (MCU with CMSE) the ethernet buffers are allocated from the top of RAM while the rest of RAM are allocated from the start of RAM.
When RAM use exceeds the available RAM, the linker will prompt with an error message, of the form “‘RAM’ region overflowed by xyz bytes”.
In the case of a flat project with ethernet, a different error message is seen, of the form ““../arm-none-eabi/bin/ld.exe:fsp.ld:622 cannot move location counter backwards (from 20036d70 to 2002c900)”
Check your RAM assignments and reduce them where possible.  If further RAM reduction is not possible, please consider another MCU with larger RAM.
Some RA MCUs requires special placement of Code/RAM for proper operation. One example is RAM allocation in the RA6M4 when an ethernet peripheral is used.  The EDMAC peripheral is designed for non-secure operation, so RAM buffer allocated to it needs to be placed in non-secure RAM.
This RAM assignment is accomplished by adding instructions in linker script to move the location counter for .ns_buffer (non-secure buffer) towards the end of RAM, as illustrated below.
Normally RAM is allocation from the start of RAM location.
For an MCU with CMSE (Cortex Microcomputer Security Extension, aka TrustZone), the secure and NSC regions are allocated first.  The remainder are assigned to non-secure.  For a flat project (MCU with CMSE) the ethernet buffers are allocated from the top of RAM while the rest of RAM are allocated from the start of RAM.
When RAM use exceeds the available RAM, the linker will prompt with an error message, of the form “‘RAM’ region overflowed by xyz bytes”.
In the case of a flat project with ethernet, a different error message is seen, of the form ““../arm-none-eabi/bin/ld.exe:fsp.ld:622 cannot move location counter backwards (from 20036d70 to 2002c900)”
Check your RAM assignments and reduce them where possible.  If further RAM reduction is not possible, please consider another MCU with larger RAM.
Suitable Products
RA6M4, RA6M5
Suitable Products
Suitable Products
RA6M4, RA6M5","['data/categories/ra_family/rafsp_knowledge_base/5e2f6446153730f385081f39a48c4a47/images/791cc8e036aa3ca0b04e3736e2721aa8.png', 'data/categories/ra_family/rafsp_knowledge_base/5e2f6446153730f385081f39a48c4a47/images/eca247e8a98c19dfef25af357547c8a2.png', 'data/categories/ra_family/rafsp_knowledge_base/5e2f6446153730f385081f39a48c4a47/images/58c1c1c42c9aaeda3959031ccf69d354.png']",[],"['|  |\n|  |\n| RA6M4, RA6M5 |']","{'title': 'RA Family: How can I resolve the linker error message “cannot move location counter backwards” when using the GCC toolchain', 'url': 'https://en-support.renesas.com/knowledgeBase/21618620', 'last_updated': '2024-04-10', 'extracted_at': '2025-03-08T23:23:25.772226'}","Overview Some RA MCUs requires special placement of Code/RAM for proper operation. One example is RAM allocation in the RA6M4 when an ethernet peripheral is used. The EDMAC peripheral is designed for non-secure operation, so RAM buffer allocated to it needs to be placed in non-secure RAM. This RAM assignment is accomplished by adding instructions in linker script to move the location counter for .nsbuffer (non-secure buffer) towards the end of RAM, as illustrated below. Normally RAM is allocation from the start of RAM location. For an MCU with CMSE (Cortex Microcomputer Security Extension, aka TrustZone), the secure and NSC regions are allocated first. The remainder are assigned to non-secure. For a flat project (MCU with CMSE) the ethernet buffers are allocated from the top of RAM while the rest of RAM are allocated from the start of RAM. When RAM use exceeds the available RAM, the linker will prompt with an error message, of the form RAM region overflowed by xyz bytes. In the case of a flat project with ethernet, a different error message is seen, of the form ../arm-none-eabi/bin/ld.exefsp.ld622 cannot move location counter backwards (from 20036d70 to 2002c900) Check your RAM assignments and reduce them where possible. If further RAM reduction is not possible, please consider another MCU with larger RAM. Suitable Products RA6M4, RA6M5","[""The image displays a code snippet in C programming language, specifically focusing on Ethernet buffer allocation and management. The code is written in a monospaced font, with comments and variable names clearly visible.\n\n**Code Structure:**\n\n*   The code begins with a comment explaining that non-secure buffers must be in non-secure RAM.\n*   It then defines a function `ns_buffer` that takes no arguments and returns a pointer to a buffer.\n*   The function allocates a 32-byte boundary to help with the placement of Ethernet buffers.\n*   It uses the `RESERVE_NS_RAM` macro to reserve memory for the buffer.\n*   The code also includes a comment indicating that the EDMAC is a non-secure bus master and can only access non-secure RAM.\n\n**Key Points:**\n\n*   The code is written in C and focuses on Ethernet buffer allocation and management.\n*   It uses non-secure buffers in non-secure RAM.\n*   The `ns_buffer` function allocates a 32-byte boundary to help with Ethernet buffer placement.\n*   The code includes comments explaining the purpose of the code and the EDMAC's capabilities.\n\n**Conclusion:**\n\nThe image displays a code snippet in C programming language that focuses on Ethernet buffer allocation and management. The code is well-structured and includes clear comments explaining its purpose and functionality."", 'The image presents a comparison of three types of memory allocation: non-CMSE, CMSE, and CMSE flat project. The diagram illustrates the allocation of memory for different types of buffers, including Ethernet buffers, NSC secure buffers, and non-secure buffers.\n\n*   **Non-CMSE**\n    *   Top of RAM\n    *   RAM start: 0x20000000\n    *   Allocation for Ethernet buffer: green\n    *   Allocation for NSC secure buffer: blue\n    *   Allocation for non-secure buffer: yellow\n*   **CMSE**\n    *   Allocation for Ethernet buffer: green\n    *   Allocation for NSC secure buffer: blue\n    *   Allocation for non-secure buffer: yellow\n*   **CMSE flat project**\n    *   Allocation for Ethernet buffer: green\n    *   Allocation for NSC secure buffer: blue\n    *   Allocation for non-secure buffer: yellow\n\nThe image highlights the differences in memory allocation between the three types of memory allocation. The non-CMSE allocation has a larger allocation for Ethernet buffers, while the CMSE and CMSE flat project allocations have smaller allocations for Ethernet buffers. The CMSE and CMSE flat project allocations also have larger allocations for NSC secure buffers compared to the non-CMSE allocation. Overall, the image provides a clear visual representation of the differences in memory allocation between the three types of memory allocation.', ""The image presents a technical diagram illustrating the process of memory allocation and deallocation in a computer system. The diagram is divided into two main sections: the left side, which represents the top of the RAM, and the right side, which represents the CMSE flat project.\n\n**Left Side: Top of RAM**\n\n*   **RAM Start**: The starting point of the RAM, marked as 0x20000000.\n*   **Non-CMSE**: A section of the RAM that is not part of the CMSE flat project.\n*   **Ethernet Buffers**: A specific area within the non-CMSE section, allocated for Ethernet buffers.\n*   **All Other RAM**: The remaining portion of the RAM, not allocated for Ethernet buffers or the CMSE flat project.\n\n**Right Side: CMSE Flat Project**\n\n*   **Non-Secure**: A section of the CMSE flat project that is not secure.\n*   **Secure**: A section of the CMSE flat project that is secure.\n*   **Ethernet Buffers**: The same area allocated for Ethernet buffers on the left side, now part of the CMSE flat project.\n\n**Additional Information**\n\n*   **ARM-None-eabi/bin/ld.exe**: A command-line tool used for linking and loading object files into executable files.\n*   **NetX_ftp_client_ek_ra6m3_ep.elf section**: A specific section within the NetX_ftp_client_ek_ra6m3_ep.elf file, which is part of the CMSE flat project.\n*   **Stack_Dummy**: A placeholder or dummy variable used in the stack allocation process.\n*   **Region 'RAM' overflowed by 35432 bytes**: An error message indicating that the RAM region has overflowed by 35432 bytes.\n\nIn summary, the diagram illustrates the allocation and deallocation of memory in a computer system, specifically highlighting the CMSE flat project and its relationship with the top of the RAM. The diagram also provides additional information about the tools and files used in the process.""]"
5af388624ed4857aafaf1a5bb0fb4b74,"Introduction
It can be convenient to store information in a QSPI memory instead of using up valuable MCU memory. Graphics user interfaces, can often require significant amount of memory, so storing GUI data in QSPI memory can be advantageous. This article describes several important considerations and techniques useful when locating AppWizard generated data into QSPI memory.
QSPI Memory Organization in FSP
Before you begin to add data to QSPI memory. It is important to understand where the QSPI is located within an FSP project.
1. To view the memory organization, open the linker file fsp.ld included in script folder.
2. Click on “Memory” tab at the bottom of the editor area to populate the window:
3. The exact value of QSPI_FLASH_START and QSPI_FLASH_LENGTH can be found in memory_regions.ld , which is generated in Debug folder.
Place AppWizard resources into QSPI flash.
To locate data in QSPI memory, we need to edit the section of the QSPI Flash memory in the linker script. Follow along with the below steps to see how it is done.
1.Open with text editor the linker script fsp.ld.
2. Figure out where the AppWizard resources are located.
3. Edit the “.qspi_flash” section as shown below:
4. Also, it is necessary to initialize properly the QSPI memory in your project for more details check the example project provided.
5.Don’t forget to perform Clean Project and then Build Project.
Placing Individual Symbols to QSPI.
To place data in the .qspi_flash section to flash it during programming, define them using the macro BSP_PLACE_IN_SECTION().
An example project for placing AppWizard resources on EK-RA6M3G is provided below.
Suitable Products
Suitable Products
Suitable Products","['data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/fb3e009774676c930ea3b4c84395c057.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/324824be9296e86d546bce0fafdfeb13.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/bcf69ff1a24a382309b605a0278017e0.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/f2fdf06faae57f90ae6d8372abaf2797.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/881916b6ed2401b59304e4784a9ea615.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/8f759893cb50c6480354847b9d7a4bdc.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/a260d5805dccf892842e88c5ade86a8e.png']",[],"['|  |\n|  |\n| RA,FSP,e2studio, RA6M3G |']","{'title': 'RA Family: Storing AppWizard Resources in QSPI memory.', 'url': 'https://en-support.renesas.com/knowledgeBase/21104534', 'last_updated': None, 'extracted_at': '2025-03-08T23:19:33.853589'}","Introduction It can be convenient to store information in a QSPI memory instead of using up valuable MCU memory. Graphics user interfaces, can often require significant amount of memory, so storing GUI data in QSPI memory can be advantageous. This article describes several important considerations and techniques useful when locating AppWizard generated data into QSPI memory. QSPI Memory Organization in FSP Before you begin to add data to QSPI memory. It is important to understand where the QSPI is located within an FSP project. 1. To view the memory organization, open the linker file fsp.ld included in script folder. 2. Click on Memory tab at the bottom of the editor area to populate the window 3. The exact value of QSPIFLASHSTART and QSPIFLASHLENGTH can be found in memoryregions.ld , which is generated in Debug folder. Place AppWizard resources into QSPI flash. To locate data in QSPI memory, we need to edit the section of the QSPI Flash memory in the linker script. Follow along with the below steps to see how it is done. 1.Open with text editor the linker script fsp.ld. 2. Figure out where the AppWizard resources are located. 3. Edit the .qspiflash section as shown below 4. Also, it is necessary to initialize properly the QSPI memory in your project for more details check the example project provided. 5.Dont forget to perform Clean Project and then Build Project. Placing Individual Symbols to QSPI. To place data in the .qspiflash section to flash it during programming, define them using the macro BSPPLACEINSECTION(). An example project for placing AppWizard resources on EK-RA6M3G is provided below. Suitable Products","['The image shows a screenshot of a computer screen displaying a file explorer window. The window is titled ""Project Explorer"" and has a list of files and folders on the left side, with a search bar at the top. The files and folders are organized in a hierarchical structure, with subfolders and sub-subfolders.\n\nThe main points of the image are:\n\n*   **File Explorer Window**\n    *   The window is titled ""Project Explorer"" and has a list of files and folders on the left side.\n    *   The window has a search bar at the top.\n*   **List of Files and Folders**\n    *   The list includes various files and folders, such as ""Graphics_App_EK_RA6M3G_Debug"", ""AppWizard"", ""ra"", ""ra_gen"", ""src"", ""Debug"", ""ra_cfg"", ""script"", ""fsp.ld"", ""configuration.xml"", ""Graphics_App_EK_RA6M3G_Debug.Jlink"", ""Graphics_App_EK_RA6M3G_Debug.launch"", ""JLinkLog.log"", ""R7FA6M3AH3CFC.pincfg"", ""ra_cfg.txt"", ""RA6M3G-EK.pincfg"", and ""Developer Assistance"".\n    *   The files and folders are organized in a hierarchical structure, with subfolders and sub-subfolders.\n*   **Search Bar**\n    *   The search bar is located at the top of the window.\n    *   It allows users to search for specific files or folders within the project explorer.\n\nOverall, the image shows a typical file explorer window with a list of files and folders, organized in a hierarchical structure. The search bar at the top allows users to quickly find specific files or folders within the project explorer.', 'The image shows a screenshot of a computer program with a list of memory regions. The title at the top of the window reads ""Memory Regions"" in black text, and below that is a list of defined memory regions. Each region has a name, start address, length, and other details. The list includes regions such as ""FLASH"", ""RAM"", ""DATA_FLASH"", and ""OSPI_FLASH"". The background of the window is white, and there are several buttons and menus along the top and bottom of the window. The overall appearance suggests that this is a technical or programming-related application.', 'The image shows a screenshot of a code editor with a highlighted line of code. The code is written in C++ and appears to be a memory region file.\n\n*   The code is written in a monospaced font and is displayed in a light gray background.\n*   The highlighted line of code is in a red box and reads: `OSPI_FLASH_START = 0x60000000; OSPI_FLASH_LENGTH = 0x40000000;`\n*   The code is organized into sections, with each section having a unique identifier (e.g., ""RAM_START"", ""FLASH_LENGTH"", etc.).\n*   The code includes various constants and variables, such as `RAM_START`, `FLASH_LENGTH`, `DATA_FLASH_START`, `OPTION_SETTING_START`, `OPTION_SETTING_S_START`, `OPTION_SETTING_S_LENGTH`, `ID_CODE_START`, `ID_CODE_LENGTH`, `SDRAM_START`, and `SDRAM_LENGTH`.\n*   The code also includes several lines of comments, which are denoted by the `//` symbol.\n\nOverall, the image suggests that the code is used to define memory regions for a specific device or system. The highlighted line of code appears to be defining the start and length of the OSPI flash memory region.', 'The image shows a screenshot of a computer screen displaying a code editor with a menu open. The code editor is open to a file named ""Graphics_App_EK_RA6M3G"" and contains a list of lines of code. The menu is open, showing options such as ""Open With"", ""Text Editor"", and ""System Editor"". The background of the image is a light gray color.\n\nThe image appears to be a screenshot of a computer screen displaying a code editor with a menu open, likely used for programming or coding purposes.', 'The image shows a screenshot of a computer screen displaying a file explorer window with a list of files and folders. The file explorer window is open on a Windows computer, and it appears to be displaying a directory tree for a project called ""Graphics_App_EK_RA6M3G"".\n\nThe top-left corner of the window has a menu bar with options such as ""File"", ""Edit"", ""View"", and ""Help"". Below the menu bar is a toolbar with icons for common actions like ""New Folder"", ""Delete"", and ""Refresh"".\n\nThe main content area of the window displays a list of files and folders in a hierarchical structure. The list is organized into folders and subfolders, with each item represented by an icon and a text label. Some of the folders and files have additional icons or labels next to them, indicating their type or status.\n\nThe background of the window is a light gray color, and the text and icons are displayed in a dark gray or black color. Overall, the image suggests that the user is working on a project involving graphics and is using the file explorer to manage files and folders related to that project.', 'The image shows a screenshot of a computer screen displaying a project explorer window. The window is open on a Windows operating system, as indicated by the title bar and the file menu.\n\n*   **Project Explorer Window**\n    *   The window is titled ""Project Explorer"" and has a white background with black text.\n    *   It contains a list of files and folders on the left side, with a tree-like structure.\n    *   The right side of the window has a menu bar with various options, including ""New"", ""Go Into"", ""Open in New Window"", ""Show In"", ""Copy"", ""Paste"", ""Delete"", ""Source"", ""Move..."", ""Rename..."", ""Import..."", ""Export..."", and ""Renessas FSP Export"".\n    *   There are also several buttons at the bottom of the window, including ""Build Project"", ""Clean Project"", ""Full Build Of Selected Projects"", ""Refresh"", ""Close Project"", and ""Close Unrelated Project"".\n*   **File Menu**\n    *   The file menu is located at the top of the window and has several options, including ""New"", ""Go Into"", ""Open in New Window"", ""Show In"", ""Copy"", ""Paste"", ""Delete"", ""Source"", ""Move..."", ""Rename..."", ""Import..."", ""Export..."", and ""Renessas FSP Export"".\n    *   The file menu is used to perform various actions on the files and folders in the project explorer window.\n*   **Build Project Button**\n    *   The ""Build Project"" button is located at the bottom of the window and is used to build the current project.\n    *   When clicked, this button will start the build process and display the results in the output window.\n*   **Clean Project Button**\n    *   The ""Clean Project"" button is also located at the bottom of the window and is used to clean the current project.\n    *   When clicked, this button will remove any temporary files or objects from the project and prepare it for a new build.\n*   **Full Build Of Selected Projects Button**\n    *   The ""Full Build Of Selected Projects"" button is located at the bottom of the window and is used to build all the selected projects.\n    *   When clicked, this button will start the build process for all the selected projects and display the results in the output window.\n*   **Refresh Button**\n    *   The ""Refresh"" button is located at the bottom of the window and is used to refresh the project explorer window.\n    *   When clicked, this button will update the list of files and folders in the project explorer window.\n*   **Close Project Button**\n    *   The ""Close Project"" button is located at the bottom of the window and is used to close the current project.\n    *   When clicked, this button will close the project explorer window and remove the project from memory.\n*   **Close Unrelated Project Button**\n    *   The ""Close Unrelated Project"" button is located at the bottom of the window and is used to close any unrelated projects.\n    *   When clicked, this button will close any projects that are not currently being used.\n\nIn summary, the image shows a project explorer window with various buttons and menus for managing projects. The buttons allow users to build, clean, and close projects, while the menus provide options for performing various actions on the files and folders in the project explorer window.', 'The image shows a screenshot of a code editor with a highlighted section of code. The code is written in C# and appears to be part of a larger program.\n\n*   The code is written in a monospaced font and is displayed in a gray background.\n*   The code is organized into sections, with each section separated by a blank line.\n*   The highlighted section of code is enclosed in a red rectangle and contains a single line of code that reads: `const uint8_t g_src[1024] BSP_PLACE_IN_SECTION("".qspi_flash"") = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";`\n*   The code is likely part of a program that is designed to work with a specific hardware platform, given the use of the `BSP_PLACE_IN_SECTION` macro and the mention of a ""qspi_flash"" section.\n*   The code may be used to store data in a non-volatile memory location, such as a flash memory chip.\n*   The use of the `const` keyword suggests that the data stored in the array is intended to be read-only.\n\nOverall, the code appears to be part of a larger program that is designed to work with a specific hardware platform and is intended to store data in a non-volatile memory location.']"
1048b8716f42024df89ed0789dd3d804,"Answer:
When the DRW Engine Support is Enabled, there must be enough heap memory (set by Heap size in the FSP Configurator BSP tab properties) to match the value set for MAX DRW Operations.  This is because the DRW Engine prepares a display list, which is a collection of rendering operations, and performs the drawing process, but this display list is placed in the heap area of memory.
The FSP User's Manual contains notes on MAX DRW Operations settings.
Max DRW Operations
Specifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance.
  Suitable Products
RA Family
Answer:
When the DRW Engine Support is Enabled, there must be enough heap memory (set by Heap size in the FSP Configurator BSP tab properties) to match the value set for MAX DRW Operations.  This is because the DRW Engine prepares a display list, which is a collection of rendering operations, and performs the drawing process, but this display list is placed in the heap area of memory.
The FSP User's Manual contains notes on MAX DRW Operations settings.
Max DRW Operations
Specifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance.
  Suitable Products
RA Family
When the DRW Engine Support is Enabled, there must be enough heap memory (set by Heap size in the FSP Configurator BSP tab properties) to match the value set for MAX DRW Operations.  This is because the DRW Engine prepares a display list, which is a collection of rendering operations, and performs the drawing process, but this display list is placed in the heap area of memory.
The FSP User's Manual contains notes on MAX DRW Operations settings.
Max DRW Operations
Specifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance.
When the DRW Engine Support is Enabled, there must be enough heap memory (set by Heap size in the FSP Configurator BSP tab properties) to match the value set for MAX DRW Operations.  This is because the DRW Engine prepares a display list, which is a collection of rendering operations, and performs the drawing process, but this display list is placed in the heap area of memory.
The FSP User's Manual contains notes on MAX DRW Operations settings.
Max DRW Operations
Specifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance.
Suitable Products
RA Family
日本語
日本語","['data/categories/ra_family/rafsp_knowledge_base/1048b8716f42024df89ed0789dd3d804/images/46ca31726f2b9b5b7cf090fd7e0bc8dc.png', 'data/categories/ra_family/rafsp_knowledge_base/1048b8716f42024df89ed0789dd3d804/images/43746fbb15022b5f8c3ef73a044b91bc.png']",[],"['|  |\n|  |\n| Max DRW Operations\nSpecifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance. |', '|  |\n|  |\n| RA Family |']","{'title': 'RA Family: Graphics drawing process using GUIX does not work properly', 'url': 'https://en-support.renesas.com/knowledgeBase/21652596', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:18.835137'}","Answer When the DRW Engine Support is Enabled, there must be enough heap memory (set by Heap size in the FSP Configurator BSP tab properties) to match the value set for MAX DRW Operations. This is because the DRW Engine prepares a display list, which is a collection of rendering operations, and performs the drawing process, but this display list is placed in the heap area of memory. The FSP User's Manual contains notes on MAX DRW Operations settings. Max DRW Operations Specifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance. Suitable Products RA Family Suitable Products ","['The image shows a screenshot of the Azure RTOS GUIX settings page, with the ""Max DRW Operations"" setting highlighted in red. \n\n*   The top-left corner has a gray box with the word ""Properties"" in it.\n*   Below that is a white box with the title ""Azure RTOS GUIX"" in black text.\n*   To the right of the title is a dropdown menu with the word ""Settings"" in it.\n*   Below the dropdown menu is a list of settings, including ""Common"", ""Hardware Acceleration"", ""JPEG Codec Support"", ""DRW Engine Support"", ""Max DRW Operations"", ""Internal Thread"", ""System Timer (ms)"", ""Multithread Support"", ""UTF8 Support"", ""Event Queue Size"", and ""Enable GX_WIDGET User Data"".\n*   The ""Max DRW Operations"" setting is highlighted in red, indicating that it is the current focus of the user.\n*   The value of the ""Max DRW Operations"" setting is 85.\n\nOverall, the image appears to be a screenshot of a settings page for an Azure RTOS GUIX application, with the user currently focused on the ""Max DRW Operations"" setting.', 'The image shows a screenshot of a computer window with a list of settings. The window is titled ""EK-RA6M3"" and has a gray background with black text. The list of settings is organized into categories, with each category having a title and a list of sub-settings below it.\n\nThe categories are:\n\n*   Property\n*   RA Common\n*   Main stack size (bytes)\n*   Heap size (bytes)\n*   MCU Vcc (mV)\n*   Parameter checking\n*   Assert Failures\n*   Error Log\n\nEach sub-setting has a checkbox next to it, indicating whether it is enabled or disabled. The checkboxes are grayed out, suggesting that they are not currently being used.\n\nThe background of the window is a light gray color, with a darker gray border around the edges. The overall design of the window is clean and simple, with clear headings and concise descriptions for each setting.\n\nOverall, the image appears to be a screenshot of a computer program or application that allows users to configure various settings for their system. The settings listed in the image suggest that the program is related to embedded systems or microcontrollers, given the mention of ""MCU Vcc"" and ""Parameter checking"".']"
11e79377143e719f1f29cc5244404567,"Question:
How to Debug Code from a Specified Address in Renesas RA MCUs - IAR
Answer:
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use IAR as an example.
1. Linker script file (code writing phase).
To modify the linker script, take the memory_regions.icf file as an example, FLASH_START the basic offset address is 0 by default when the code is compiled, and the target offset address of the application is changed to the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000 as seen below.
  2. Debug Configuration Settings (Code Debugging Phase)
Modify the settings in Debugger > Extra Options, as shown in the following figure.
  As shown in the following figure, when you jump to the main() function, the address is at 0x4fd0.
Suitable Products
RA
How to Debug Code from a Specified Address in Renesas RA MCUs - IAR
How to Debug Code from a Specified Address in Renesas RA MCUs - IAR
Answer:
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use IAR as an example.
1. Linker script file (code writing phase).
To modify the linker script, take the memory_regions.icf file as an example, FLASH_START the basic offset address is 0 by default when the code is compiled, and the target offset address of the application is changed to the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000 as seen below.
  2. Debug Configuration Settings (Code Debugging Phase)
Modify the settings in Debugger > Extra Options, as shown in the following figure.
  As shown in the following figure, when you jump to the main() function, the address is at 0x4fd0.
Suitable Products
RA
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use IAR as an example.
1. Linker script file (code writing phase).
To modify the linker script, take the memory_regions.icf file as an example, FLASH_START the basic offset address is 0 by default when the code is compiled, and the target offset address of the application is changed to the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000 as seen below.
2. Debug Configuration Settings (Code Debugging Phase)
Modify the settings in Debugger > Extra Options, as shown in the following figure.
As shown in the following figure, when you jump to the main() function, the address is at 0x4fd0.
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/11e79377143e719f1f29cc5244404567/images/aee31b448c849f7ddcdc961107b1dd14.png', 'data/categories/ra_family/rafsp_knowledge_base/11e79377143e719f1f29cc5244404567/images/67d9357bdfeafe8862b601fb5bf4dbb3.png', 'data/categories/ra_family/rafsp_knowledge_base/11e79377143e719f1f29cc5244404567/images/ec735d80928f030183d99de0543afc5e.png', 'data/categories/ra_family/rafsp_knowledge_base/11e79377143e719f1f29cc5244404567/images/69c1817e6079ab977ab23c6744653497.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'How to Debug Code from a Specified Address in Renesas RA MCUs - IAR', 'url': 'https://en-support.renesas.com/knowledgeBase/21172751', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:57.998604'}","Question How to Debug Code from a Specified Address in Renesas RA MCUs - IAR Answer For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged. To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use IAR as an example. 1. Linker script file (code writing phase). To modify the linker script, take the memoryregions.icf file as an example, FLASHSTART the basic offset address is 0 by default when the code is compiled, and the target offset address of the application is changed to the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000 as seen below. 2. Debug Configuration Settings (Code Debugging Phase) Modify the settings in Debugger  Extra Options, as shown in the following figure. As shown in the following figure, when you jump to the main() function, the address is at 0x4fd0. Suitable Products RA 2. Debug Configuration Settings (Code Debugging Phase) As shown in the following figure, when you jump to the main() function, the address is at 0x4fd0.","['The image shows a screenshot of a code editor with a grey background and black text. The code is written in C++ and appears to be a memory region file generator. The code defines several memory regions, including RAM, FLASH, DATA, and OPTION_SETTING, with their respective sizes and settings.\n\nThe code also includes a comment at the top that reads ""/* generated memory regions file - do not edit */"", indicating that this code was automatically generated and should not be modified by hand.\n\nOverall, the image suggests that the code is being used to generate a memory map for a microcontroller or other embedded system, and that the memory regions are being defined with specific sizes and settings to optimize performance and resource usage.', 'The image shows a screenshot of a computer program displaying a list of hexadecimal codes. The list is organized into columns, with each column representing a different section of the code. The codes are displayed in a variety of colors, including red, green, blue, and yellow.\n\nThe top-left corner of the image has a small window with a blue and orange border, containing the text ""tra2el_app_0x4000.srec"". This suggests that the program is displaying a file or data in a specific format.\n\nThe background of the image is a light gray color, which provides good contrast with the colorful hexadecimal codes. Overall, the image appears to be a technical screenshot, possibly from a debugging or programming environment.', 'The image shows a screenshot of a computer program with a window open, displaying a list of options for a node. The window is titled ""Options for node \'ra2e1_app_0x4000\'"". \n\n*   The window has a list of options on the left side, including:\n    *   General Options\n    *   Static Analysis\n    *   Runtime Checking\n    *   C/C++ Compiler\n    *   Assembler\n    *   Output Converter\n    *   Custom Build\n    *   Build Actions\n    *   Linker\n    *   Simulator\n    *   CADL\n    *   CMSIS DAP\n    *   GDB Server\n    *   I-Jet\n    *   J-Link/J-Trace\n    *   TI Stelaris\n    *   Nu-Link\n    *   PE micro\n    *   ST-LINK\n    *   Third-Party Driver\n    *   TI MSP-FET\n    *   TI XDS-FET\n*   The main part of the window has a checkbox labeled ""Use command line options"" and a text box below it where you can enter a command line option.\n*   The background of the window is light gray, and the text is black.\n\nOverall, the image appears to be a screenshot of a computer program used for debugging or testing purposes.', 'The image shows a screenshot of a computer program, likely a code editor or IDE (Integrated Development Environment), with a code snippet and a disassembly view. The code snippet is written in C++ and appears to be a simple program that prints ""Hello, World!"" to the console. The disassembly view shows the machine code generated by the compiler for this program.\n\nHere are the details of the image:\n\n*   **Code Snippet:**\n    *   The code snippet is written in C++ and is located on the left side of the image.\n    *   It consists of a single function called `main()` that prints ""Hello, World!"" to the console using the `printf()` function.\n    *   The code is well-formatted and easy to read, with clear indentation and spacing.\n*   **Disassembly View:**\n    *   The disassembly view is located on the right side of the image and shows the machine code generated by the compiler for the `main()` function.\n    *   The disassembly view is displayed in a table format, with each row representing a single instruction.\n    *   The instructions are listed in hexadecimal format, with the opcode and operands displayed separately.\n    *   The disassembly view also includes some additional information, such as the memory address of each instruction and the size of each instruction.\n*   **Toolbar:**\n    *   The toolbar is located at the top of the image and contains various buttons and menus for editing and debugging the code.\n    *   The toolbar includes buttons for compiling, running, and debugging the code, as well as menus for selecting the programming language and setting up the build environment.\n*   **Status Bar:**\n    *   The status bar is located at the bottom of the image and displays information about the current state of the code.\n    *   The status bar shows the current line number, the number of errors or warnings, and the current file being edited.\n\nOverall, the image shows a typical code editor or IDE with a code snippet and a disassembly view. The code snippet is well-formatted and easy to read, and the disassembly view provides detailed information about the machine code generated by the compiler. The toolbar and status bar provide additional functionality for editing and debugging the code.']"
2be83d1dbe128835e4d96b9d4c726fc1,"The GCC compiler can generate .elf, .srec or .bin files.  Typically .elf file are used for debugging whereas .srec/.bin files are sent to the flash programmer for downloading to MCUs.  The advantage of using .bin over .srec file is that .bin files are  smaller, and can be further manipulated (calculating checksum, inserting additional information) before being downloaded.  Unlike an .srec file, address information is not included in a .bin file.  Instead, the .bin image is programmed continuously from a start location (typically 0x00000000) to the last location as specified in the linker script. The last location could be an option setting area. E.g., for RA6M4, code flash 0x00000000-0x000FFFFF while the option settings occupied 0x0100A100~0x0100A2FF.
    Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x0~0x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area.  If these areas are programmed, the chip could be damaged!
If a “.bin” file must be used, please check the target location and the size of the file generated.  If necessary, please omit the option setting area. This can be done by adding “(NOLOAD)” to the linker script, fsp.ld.
  .id_code (NOLOAD):
  .option_setting_ofs (NOLOAD):
{
} > OPTION_SETTING_OFS = 0xFF
  .option_setting_sas (NOLOAD):
{
} > OPTION_SETTING_SAS = 0xFF
  .option_setting_ns (NOLOAD):
{
} > OPTION_SETTING = 0xFF
  .option_setting_s (NOLOAD):
{
} > OPTION_SETTING_S = 0xFF
  Suitable Products
RA and FSP
The GCC compiler can generate .elf, .srec or .bin files.  Typically .elf file are used for debugging whereas .srec/.bin files are sent to the flash programmer for downloading to MCUs.  The advantage of using .bin over .srec file is that .bin files are  smaller, and can be further manipulated (calculating checksum, inserting additional information) before being downloaded.  Unlike an .srec file, address information is not included in a .bin file.  Instead, the .bin image is programmed continuously from a start location (typically 0x00000000) to the last location as specified in the linker script. The last location could be an option setting area. E.g., for RA6M4, code flash 0x00000000-0x000FFFFF while the option settings occupied 0x0100A100~0x0100A2FF.
    Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x0~0x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area.  If these areas are programmed, the chip could be damaged!
If a “.bin” file must be used, please check the target location and the size of the file generated.  If necessary, please omit the option setting area. This can be done by adding “(NOLOAD)” to the linker script, fsp.ld.
  .id_code (NOLOAD):
  .option_setting_ofs (NOLOAD):
{
} > OPTION_SETTING_OFS = 0xFF
  .option_setting_sas (NOLOAD):
{
} > OPTION_SETTING_SAS = 0xFF
  .option_setting_ns (NOLOAD):
{
} > OPTION_SETTING = 0xFF
  .option_setting_s (NOLOAD):
{
} > OPTION_SETTING_S = 0xFF
  Suitable Products
RA and FSP
The GCC compiler can generate .elf, .srec or .bin files.  Typically .elf file are used for debugging whereas .srec/.bin files are sent to the flash programmer for downloading to MCUs.  The advantage of using .bin over .srec file is that .bin files are  smaller, and can be further manipulated (calculating checksum, inserting additional information) before being downloaded.  Unlike an .srec file, address information is not included in a .bin file.  Instead, the .bin image is programmed continuously from a start location (typically 0x00000000) to the last location as specified in the linker script. The last location could be an option setting area. E.g., for RA6M4, code flash 0x00000000-0x000FFFFF while the option settings occupied 0x0100A100~0x0100A2FF.
    Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x0~0x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area.  If these areas are programmed, the chip could be damaged!
If a “.bin” file must be used, please check the target location and the size of the file generated.  If necessary, please omit the option setting area. This can be done by adding “(NOLOAD)” to the linker script, fsp.ld.
  .id_code (NOLOAD):
  .option_setting_ofs (NOLOAD):
{
} > OPTION_SETTING_OFS = 0xFF
  .option_setting_sas (NOLOAD):
{
} > OPTION_SETTING_SAS = 0xFF
  .option_setting_ns (NOLOAD):
{
} > OPTION_SETTING = 0xFF
  .option_setting_s (NOLOAD):
{
} > OPTION_SETTING_S = 0xFF
  Suitable Products
The GCC compiler can generate .elf, .srec or .bin files.  Typically .elf file are used for debugging whereas .srec/.bin files are sent to the flash programmer for downloading to MCUs.  The advantage of using .bin over .srec file is that .bin files are  smaller, and can be further manipulated (calculating checksum, inserting additional information) before being downloaded.  Unlike an .srec file, address information is not included in a .bin file.  Instead, the .bin image is programmed continuously from a start location (typically 0x00000000) to the last location as specified in the linker script. The last location could be an option setting area. E.g., for RA6M4, code flash 0x00000000-0x000FFFFF while the option settings occupied 0x0100A100~0x0100A2FF.
Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x0~0x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area.  If these areas are programmed, the chip could be damaged!
If a “.bin” file must be used, please check the target location and the size of the file generated.  If necessary, please omit the option setting area. This can be done by adding “(NOLOAD)” to the linker script, fsp.ld.
.id_code (NOLOAD):
.id_code (NOLOAD):
(NOLOAD)
.option_setting_ofs (NOLOAD):
.option_setting_ofs (NOLOAD):
(NOLOAD)
{
{
} > OPTION_SETTING_OFS = 0xFF
} > OPTION_SETTING_OFS = 0xFF
.option_setting_sas (NOLOAD):
.option_setting_sas (NOLOAD):
(NOLOAD)
{
{
} > OPTION_SETTING_SAS = 0xFF
} > OPTION_SETTING_SAS = 0xFF
.option_setting_ns (NOLOAD):
.option_setting_ns (NOLOAD):
(NOLOAD)
{
{
} > OPTION_SETTING = 0xFF
} > OPTION_SETTING = 0xFF
.option_setting_s (NOLOAD):
.option_setting_s (NOLOAD):
(NOLOAD)
{
{
} > OPTION_SETTING_S = 0xFF
} > OPTION_SETTING_S = 0xFF
Suitable Products
RA and FSP
RA and FSP",['data/categories/ra_family/rafsp_knowledge_base/2be83d1dbe128835e4d96b9d4c726fc1/images/f140d228c0d295615d775f682961231e.png'],[],"['|  |\n|  |\n| .id_code (NOLOAD):\n  .option_setting_ofs (NOLOAD):\n{\n} > OPTION_SETTING_OFS = 0xFF\n  .option_setting_sas (NOLOAD):\n{\n} > OPTION_SETTING_SAS = 0xFF\n  .option_setting_ns (NOLOAD):\n{\n} > OPTION_SETTING = 0xFF\n  .option_setting_s (NOLOAD):\n{\n} > OPTION_SETTING_S = 0xFF |', '|  |\n|  |\n| RA and FSP |']","{'title': 'Caution when programming a bin file with FSP and RA Family', 'url': 'https://en-support.renesas.com/knowledgeBase/21073658', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:20.000888'}","The GCC compiler can generate .elf, .srec or .bin files. Typically .elf file are used for debugging whereas .srec/.bin files are sent to the flash programmer for downloading to MCUs. The advantage of using .bin over .srec file is that .bin files are smaller, and can be further manipulated (calculating checksum, inserting additional information) before being downloaded. Unlike an .srec file, address information is not included in a .bin file. Instead, the .bin image is programmed continuously from a start location (typically 0x00000000) to the last location as specified in the linker script. The last location could be an option setting area. E.g., for RA6M4, code flash 0x00000000-0x000FFFFF while the option settings occupied 0x0100A1000x0100A2FF. Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x00x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area. If these areas are programmed, the chip could be damaged! If a .bin file must be used, please check the target location and the size of the file generated. If necessary, please omit the option setting area. This can be done by adding (NOLOAD) to the linker script, fsp.ld. .idcode (NOLOAD) .optionsettingofs (NOLOAD)    OPTIONSETTINGOFS  0xFF .optionsettingsas (NOLOAD)   OPTIONSETTINGSAS  0xFF .optionsettingns (NOLOAD)   OPTIONSETTING  0xFF .optionsettings (NOLOAD)   OPTIONSETTINGS  0xFF Suitable Products RA and FSP Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x00x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area. If these areas are programmed, the chip could be damaged! .idcode (NOLOAD) (NOLOAD) .optionsettingofs (NOLOAD) .optionsettingsas (NOLOAD) .optionsettingns (NOLOAD) .optionsettings (NOLOAD) Suitable Products","['The image displays a table with a list of memory addresses and their corresponding reserved areas. The table is divided into two columns, with the left column listing the memory addresses in hexadecimal format, and the right column indicating whether each address is reserved or not.\n\nThe table includes the following information:\n\n*   **Memory Addresses:** The left column lists various memory addresses, including 0x2800_0400, 0x2800_0000, 0x2004_0000, 0x2000_0000, 0x0800_2000, 0x0800_0000, 0x0100_A300, 0x0100_A100, 0x0100_81B4, 0x0100_80F0, 0x0028_0000, and 0x0000_0000.\n*   **Reserved Areas:** The right column indicates whether each memory address is reserved or not. The reserved areas are marked with an asterisk (*) and include:\n    *   Standby SRAM\n    *   SRAM0\n    *   On-chip flash (data flash)\n    *   On-chip flash (option-setting memory)\n    *   On-chip flash (Factory Flash)\n    *   On-chip flash (code flash) (read only)\n\nAt the bottom of the image, there is a note that reads: ""Note 1. Do not access reserved areas."" This suggests that the memory addresses listed in the table are protected and should not be accessed by the user.\n\nOverall, the image provides a clear and concise overview of the memory addresses and their corresponding reserved areas, making it easy to understand the memory layout of the device.']"
ba4a792be062013a3461af816b82a367,"Question:
How do I configure SPI to implement the following waveform in the manual on RA6M4?
Answer:
To achieve the waveform shown in the figure, the SPI Burst Transfer needs to be used. The specific configuration method is:
Before the last transmission, update SPCMD_b[0].SSLKP from 1 to 0. One transmission represents the number of data bits specified by the bits [11:8]-SPB[3:0] (SPI Data Length Setting) of the register SPCMDm.
Please update the SPI-related API as follows (add the content between #if 1 and #endif). The r_spi_transmit function is located in the ra\fsp\src\r_spi\r_spi.c file.
static void r_spi_transmit (spi_instance_ctrl_t * p_ctrl)
{   
    uint32_t tx_count = p_ctrl->tx_count;   
    if (tx_count == p_ctrl->count)   
    {       
        return;   
    }
#if 1   // added for burst transmit
    if (tx_count == p_ctrl->count-1)   
    {       
        p_ctrl->p_regs->SPCMD_b[0].SSLKP = 0;   
    }
#endif
  Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers.
Suitable Products
RA Family
How do I configure SPI to implement the following waveform in the manual on RA6M4?
How do I configure SPI to implement the following waveform in the manual on RA6M4?
Answer:
To achieve the waveform shown in the figure, the SPI Burst Transfer needs to be used. The specific configuration method is:
Before the last transmission, update SPCMD_b[0].SSLKP from 1 to 0. One transmission represents the number of data bits specified by the bits [11:8]-SPB[3:0] (SPI Data Length Setting) of the register SPCMDm.
Please update the SPI-related API as follows (add the content between #if 1 and #endif). The r_spi_transmit function is located in the ra\fsp\src\r_spi\r_spi.c file.
static void r_spi_transmit (spi_instance_ctrl_t * p_ctrl)
{   
    uint32_t tx_count = p_ctrl->tx_count;   
    if (tx_count == p_ctrl->count)   
    {       
        return;   
    }
#if 1   // added for burst transmit
    if (tx_count == p_ctrl->count-1)   
    {       
        p_ctrl->p_regs->SPCMD_b[0].SSLKP = 0;   
    }
#endif
  Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers.
Suitable Products
RA Family
To achieve the waveform shown in the figure, the SPI Burst Transfer needs to be used. The specific configuration method is:
Before the last transmission, update SPCMD_b[0].SSLKP from 1 to 0. One transmission represents the number of data bits specified by the bits [11:8]-SPB[3:0] (SPI Data Length Setting) of the register SPCMDm.
Please update the SPI-related API as follows (add the content between #if 1 and #endif). The r_spi_transmit function is located in the ra\fsp\src\r_spi\r_spi.c file.
static void r_spi_transmit (spi_instance_ctrl_t * p_ctrl)
{   
    uint32_t tx_count = p_ctrl->tx_count;   
    if (tx_count == p_ctrl->count)   
    {       
        return;   
    }
#if 1   // added for burst transmit
    if (tx_count == p_ctrl->count-1)   
    {       
        p_ctrl->p_regs->SPCMD_b[0].SSLKP = 0;   
    }
#endif
  Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers.
To achieve the waveform shown in the figure, the SPI Burst Transfer needs to be used. The specific configuration method is:
Before the last transmission, update SPCMD_b[0].SSLKP from 1 to 0. One transmission represents the number of data bits specified by the bits [11:8]-SPB[3:0] (SPI Data Length Setting) of the register SPCMDm.
Please update the SPI-related API as follows (add the content between #if 1 and #endif). The r_spi_transmit function is located in the ra\fsp\src\r_spi\r_spi.c file.
static void r_spi_transmit (spi_instance_ctrl_t * p_ctrl)
static
void r_spi_transmit (spi_instance_ctrl_t * p_ctrl)
{
{
uint32_t tx_count = p_ctrl->tx_count;
uint32_t tx_count = p_ctrl->tx_count;
if (tx_count == p_ctrl->count)
if
(tx_count == p_ctrl->count)
{
{
return;
return
;
}
}
#if 1   // added for burst transmit
#
if
1
// added for burst transmit
if (tx_count == p_ctrl->count-1)
if
(tx_count == p_ctrl->count-1)
{
{
p_ctrl->p_regs->SPCMD_b[0].SSLKP = 0;
p_ctrl->p_regs->SPCMD_b[0].SSLKP = 0;
}
}
#endif
#endif
Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers.
Suitable Products
RA Family
Chinese
Chinese",['data/categories/ra_family/rafsp_knowledge_base/ba4a792be062013a3461af816b82a367/images/f684a0552db7123b81872006f18af8dd.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: How to use SPI Burst Mode?', 'url': 'https://en-support.renesas.com/knowledgeBase/21789661', 'last_updated': '2025-04-02', 'extracted_at': '2025-03-08T23:22:27.544396'}","Question How do I configure SPI to implement the following waveform in the manual on RA6M4? Answer To achieve the waveform shown in the figure, the SPI Burst Transfer needs to be used. The specific configuration method is Before the last transmission, update SPCMDb0.SSLKP from 1 to 0. One transmission represents the number of data bits specified by the bits 118-SPB30 (SPI Data Length Setting) of the register SPCMDm. Please update the SPI-related API as follows (add the content between if 1 and endif). The rspitransmit function is located in the rafspsrcrspirspi.c file. static void rspitransmit (spiinstancectrlt  pctrl)  uint32t txcount  pctrl-txcount; if (txcount  pctrl-count)  return;  if 1 // added for burst transmit if (txcount  pctrl-count-1) pctrl-pregs-SPCMDb0.SSLKP  0; endif Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers. Suitable Products RA Family static void rspitransmit (spiinstancectrlt  pctrl)  uint32t txcount  pctrl-txcount; if (txcount  pctrl-count) if (txcount  pctrl-count) return; return ;   1 // added for burst transmit if (txcount  pctrl-count-1) (txcount  pctrl-count-1) pctrl-pregs-SPCMDb0.SSLKP  0; Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers. Chinese","['The image presents a technical diagram illustrating the process of burst transfer operation using the SSLKP bit (BFDS = 1). The diagram is divided into two sections: the top section displays the RSPCK signal, while the bottom section shows the SSL signal.\n\n**RSPCK Signal:**\n\n*   The RSPCK signal is represented by a series of pulses, with each pulse indicating a specific event or action.\n*   The pulses are labeled with numbers (1) to (6), which correspond to different stages of the burst transfer operation.\n*   The RSPCK signal is used to control the transfer of data between the transmitter and receiver.\n\n**SSL Signal:**\n\n*   The SSL signal is represented by a series of bits, with each bit indicating a specific value or state.\n*   The bits are labeled with numbers (1) to (6), which correspond to the same stages as the RSPCK signal.\n*   The SSL signal is used to transmit data from the transmitter to the receiver.\n\n**Burst Transfer Operation:**\n\n*   The burst transfer operation is initiated when the RSPCK signal is set to a specific value (e.g., 1).\n*   The transmitter sends a burst of data to the receiver, which is indicated by the SSL signal.\n*   The receiver acknowledges the receipt of the data by sending an acknowledgement signal back to the transmitter.\n*   The transmitter then sends another burst of data, and the process repeats until the transmission is complete.\n\n**Key Points:**\n\n*   The RSPCK signal controls the transfer of data between the transmitter and receiver.\n*   The SSL signal transmits data from the transmitter to the receiver.\n*   The burst transfer operation involves the transmission of multiple bursts of data, with each burst being acknowledged by the receiver before the next one is sent.\n\nOverall, the diagram provides a clear illustration of the burst transfer operation using the SSLKP bit (BFDS = 1), highlighting the key signals and stages involved in the process.']"
b0371bfed4fabbb7167d3e2634308e2c,"To use the disassembly view you must first enable the assembly listing, using the project tool settings property, as seen in the below screen shot.
Start a debug session and the assembly file is generated in the project directory src folder, as illustrated below.
Suitable Products
Suitable Products
RA/FSP","['data/categories/ra_family/rafsp_knowledge_base/b0371bfed4fabbb7167d3e2634308e2c/images/3142b1db2834630102b01914d442691d.png', 'data/categories/ra_family/rafsp_knowledge_base/b0371bfed4fabbb7167d3e2634308e2c/images/a7ca923cb8ca79da973a822b2a942f28.png']",[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'Disassembly View for RA MCUs in FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/20078475', 'last_updated': None, 'extracted_at': '2025-03-08T23:18:19.597238'}","To use the disassembly view you must first enable the assembly listing, using the project tool settings property, as seen in the below screen shot. Start a debug session and the assembly file is generated in the project directory src folder, as illustrated below. Suitable Products RA/FSP","['The image shows a screenshot of a computer program with a menu bar at the top and a list of options on the left side. The menu bar has several tabs, including ""Tool Settings,"" ""Toolchain,"" ""Build Steps,"" ""Build Artifact,"" ""Binary Parsers,"" and ""Error Parsers."" The ""Tool Settings"" tab is currently selected.\n\nOn the left side of the screen, there is a list of options, including ""Target Processor,"" ""Optimization,"" ""Warnings,"" ""Debugging,"" ""GNU ARM Cross Assembler,"" ""Preprocessor,"" ""Includes,"" ""Warnings,"" ""Miscellaneous,"" ""GNU ARM Cross C Compiler,"" ""Preprocessor,"" ""Includes,"" ""Optimization,"" ""Warnings,"" ""Miscellaneous,"" ""GNU ARM Cross C Linker,"" ""General,"" ""Libraries,"" ""Miscellaneous,"" ""GNU ARM Cross Create Flash Image,"" ""General,"" and ""GNU ARM Cross Print Size."" The ""Generate assembler listing (-Wa,-adhlns= ""@.lst"")"" option is highlighted in red and has a checkbox next to it.\n\nIn the middle of the screen, there is a text box labeled ""Other compiler flags"" with a blank space for input. The background of the image is white, with a gray border around the edges. Overall, the image appears to be a screenshot of a computer program used for building and configuring software projects.', 'The image shows a screenshot of a computer file explorer window, with a list of files and folders on the left side and a toolbar at the top. The window is titled ""Project Explorer"" and has a gray background.\n\n*   **File Explorer Window**\n    *   The window is titled ""Project Explorer"" and has a gray background.\n    *   There is a toolbar at the top with various icons and menus.\n    *   The left side of the window shows a list of files and folders, with each item represented by an icon and a name.\n    *   The list includes folders such as ""Binaries"", ""Includes"", ""ra_gen"", ""src"", ""Debug"", ""ra"", ""ra_gen"", ""src"", ""common_init.o - [arm/le]"", ""hal_entry.o - [arm/le]"", ""r_usb_pcdc_descriptor.o - [arm/le]"", ""common_init.d"", ""common_init.o.lst"", ""hal_entry.d"", ""hal_entry.o.lst"", ""r_usb_pcdc_descriptor.d"", ""r_usb_pcdc_descriptor.o.lst"", ""subdir.mk"", and ""quickstart_ek_ra6m3_ep.elf - [arm/le]"".\n    *   The list also includes files such as ""hal_entry.o"" and ""r_usb_pcdc_descriptor.o"".\n    *   There are several icons and symbols throughout the list, including a folder icon, a file icon, and a symbol for a USB device.\n*   **Toolbar**\n    *   The toolbar is located at the top of the window and has several icons and menus.\n    *   The icons include a folder icon, a file icon, and a symbol for a USB device.\n    *   The menus include options such as ""File"", ""Edit"", ""View"", and ""Help"".\n*   **Background**\n    *   The background of the window is gray.\n\nOverall, the image shows a screenshot of a computer file explorer window, with a list of files and folders on the left side and a toolbar at the top. The window is titled ""Project Explorer"" and has a gray background.']"
a99864bca4f479357225dc1a3b28125b,"Question:
How to communicate with multiple slave devices on the same I2C bus.
Answer:
When communicating with multiple I2C slave devices on the same bus, it is necessary to switch the slave address to communicate. There are two ways to do this.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)
(2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
The following steps describe each method.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)

By using the I2C Communication Device (rm_comms_i2c), the I2C master driver can communicate with multiple slave device via the I2C Shared bus. Either the r_iic_master driver or the r_sci_i2c driver can be used as the I2C master driver. Every instance of rm_comms_i2c has a 'Slave Address' setting in its properties, which can be configured independently. When an rm_comms_i2c instance communicates with a slave I2C device, the I2C Shared Bus switches to the respective slave device and communicates with it.

When using an RTOS, rm_comms_i2c provides the following features:
Blocking operation using a mutex for RM_COMMS_I2C_Write(), RM_COMMS_I2C_Read() and RM_COMMS_I2C_WriteRead().
Bus lock using a mutex.
Here is an example. In this case, the address of the g_comms_i2c_dvice0 instance is 0x44, and the address of the g_comms_i2c_device1 is 0x55.
    Pseudo code to show how to use shared i2c bus.
// Open Each device
g_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);
g_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);
  // Call I2C Communication Device Write or Read to communicate with Device(0x44)
g_comms_i2c_device0.p_api->write(...);
g_comms_i2c_device0.p_api->read(...);
  // Call I2C Communication Device Write or Read to communicate with Device(0x55)
g_comms_i2c_device1.p_api->write(...);
g_comms_i2c_device1.p_api->read(...);
  (2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
This method creates one instance of the I2C master driver. The application then uses the slaveAddressSet API to switch the slave devices for communication. Here is an example where the addresses for the slave devices are 0x44 and 0x55.
The default slave address of the I2C master driver instance is set to 0x44 in this case.
Pseudo code to show when to use the slaveAddressSet API.
// Open
g_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);
  // Switch Slave address to 0x55
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x55)
g_i2c_master.p_api->write(…);
g_i2c_master.p_api->read(…);
  // Switch Slave address to 0x44
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x44)
g_i2c_master.p_api->write(…);
g_i2c_master.p_api->read(…);
  Suitable Products
RA
How to communicate with multiple slave devices on the same I2C bus.
How to communicate with multiple slave devices on the same I2C bus.
Answer:
When communicating with multiple I2C slave devices on the same bus, it is necessary to switch the slave address to communicate. There are two ways to do this.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)
(2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
The following steps describe each method.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)

By using the I2C Communication Device (rm_comms_i2c), the I2C master driver can communicate with multiple slave device via the I2C Shared bus. Either the r_iic_master driver or the r_sci_i2c driver can be used as the I2C master driver. Every instance of rm_comms_i2c has a 'Slave Address' setting in its properties, which can be configured independently. When an rm_comms_i2c instance communicates with a slave I2C device, the I2C Shared Bus switches to the respective slave device and communicates with it.

When using an RTOS, rm_comms_i2c provides the following features:
Blocking operation using a mutex for RM_COMMS_I2C_Write(), RM_COMMS_I2C_Read() and RM_COMMS_I2C_WriteRead().
Bus lock using a mutex.
Here is an example. In this case, the address of the g_comms_i2c_dvice0 instance is 0x44, and the address of the g_comms_i2c_device1 is 0x55.
    Pseudo code to show how to use shared i2c bus.
// Open Each device
g_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);
g_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);
  // Call I2C Communication Device Write or Read to communicate with Device(0x44)
g_comms_i2c_device0.p_api->write(...);
g_comms_i2c_device0.p_api->read(...);
  // Call I2C Communication Device Write or Read to communicate with Device(0x55)
g_comms_i2c_device1.p_api->write(...);
g_comms_i2c_device1.p_api->read(...);
  (2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
This method creates one instance of the I2C master driver. The application then uses the slaveAddressSet API to switch the slave devices for communication. Here is an example where the addresses for the slave devices are 0x44 and 0x55.
The default slave address of the I2C master driver instance is set to 0x44 in this case.
Pseudo code to show when to use the slaveAddressSet API.
// Open
g_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);
  // Switch Slave address to 0x55
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x55)
g_i2c_master.p_api->write(…);
g_i2c_master.p_api->read(…);
  // Switch Slave address to 0x44
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x44)
g_i2c_master.p_api->write(…);
g_i2c_master.p_api->read(…);
  Suitable Products
RA
When communicating with multiple I2C slave devices on the same bus, it is necessary to switch the slave address to communicate. There are two ways to do this.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)
(2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
The following steps describe each method.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)

By using the I2C Communication Device (rm_comms_i2c), the I2C master driver can communicate with multiple slave device via the I2C Shared bus. Either the r_iic_master driver or the r_sci_i2c driver can be used as the I2C master driver. Every instance of rm_comms_i2c has a 'Slave Address' setting in its properties, which can be configured independently. When an rm_comms_i2c instance communicates with a slave I2C device, the I2C Shared Bus switches to the respective slave device and communicates with it.

When using an RTOS, rm_comms_i2c provides the following features:
Blocking operation using a mutex for RM_COMMS_I2C_Write(), RM_COMMS_I2C_Read() and RM_COMMS_I2C_WriteRead().
Bus lock using a mutex.
Here is an example. In this case, the address of the g_comms_i2c_dvice0 instance is 0x44, and the address of the g_comms_i2c_device1 is 0x55.
    Pseudo code to show how to use shared i2c bus.
// Open Each device
g_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);
g_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);
  // Call I2C Communication Device Write or Read to communicate with Device(0x44)
g_comms_i2c_device0.p_api->write(...);
g_comms_i2c_device0.p_api->read(...);
  // Call I2C Communication Device Write or Read to communicate with Device(0x55)
g_comms_i2c_device1.p_api->write(...);
g_comms_i2c_device1.p_api->read(...);
  (2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
This method creates one instance of the I2C master driver. The application then uses the slaveAddressSet API to switch the slave devices for communication. Here is an example where the addresses for the slave devices are 0x44 and 0x55.
The default slave address of the I2C master driver instance is set to 0x44 in this case.
Pseudo code to show when to use the slaveAddressSet API.
// Open
g_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);
  // Switch Slave address to 0x55
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x55)
g_i2c_master.p_api->write(…);
g_i2c_master.p_api->read(…);
  // Switch Slave address to 0x44
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x44)
g_i2c_master.p_api->write(…);
g_i2c_master.p_api->read(…);
When communicating with multiple I2C slave devices on the same bus, it is necessary to switch the slave address to communicate. There are two ways to do this.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)
(2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
The following steps describe each method.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)

By using the I2C Communication Device (rm_comms_i2c), the I2C master driver can communicate with multiple slave device via the I2C Shared bus. Either the r_iic_master driver or the r_sci_i2c driver can be used as the I2C master driver. Every instance of rm_comms_i2c has a 'Slave Address' setting in its properties, which can be configured independently. When an rm_comms_i2c instance communicates with a slave I2C device, the I2C Shared Bus switches to the respective slave device and communicates with it.
When using an RTOS, rm_comms_i2c provides the following features:
Here is an example. In this case, the address of the g_comms_i2c_dvice0 instance is 0x44, and the address of the g_comms_i2c_device1 is 0x55.
Pseudo code to show how to use shared i2c bus.
// Open Each device
// Open Each device
g_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);
g_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);
g_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);
g_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);
// Call I2C Communication Device Write or Read to communicate with Device(0x44)
// Call I2C Communication Device Write or Read to communicate with Device(0x44)
g_comms_i2c_device0.p_api->write(...);
g_comms_i2c_device0.p_api->write(...);
g_comms_i2c_device0.p_api->read(...);
g_comms_i2c_device0.p_api->read(...);
// Call I2C Communication Device Write or Read to communicate with Device(0x55)
// Call I2C Communication Device Write or Read to communicate with Device(0x55)
g_comms_i2c_device1.p_api->write(...);
g_comms_i2c_device1.p_api->write(...);
g_comms_i2c_device1.p_api->read(...);
g_comms_i2c_device1.p_api->read(...);
(2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
This method creates one instance of the I2C master driver. The application then uses the slaveAddressSet API to switch the slave devices for communication. Here is an example where the addresses for the slave devices are 0x44 and 0x55.
The default slave address of the I2C master driver instance is set to 0x44 in this case.
Pseudo code to show when to use the slaveAddressSet API.
// Open
// Open
g_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);
g_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);
// Switch Slave address to 0x55
// Switch Slave address to 0x55
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);
// Call I2C Write or Read to communicate with Device(0x55)
// Call I2C Write or Read to communicate with Device(0x55)
g_i2c_master.p_api->write(…);
g_i2c_master.p_api->write(…);
g_i2c_master.p_api->read(…);
g_i2c_master.p_api->read(…);
// Switch Slave address to 0x44
// Switch Slave address to 0x44
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);
// Call I2C Write or Read to communicate with Device(0x44)
// Call I2C Write or Read to communicate with Device(0x44)
g_i2c_master.p_api->write(…);
g_i2c_master.p_api->write(…);
g_i2c_master.p_api->read(…);
g_i2c_master.p_api->read(…);
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/a99864bca4f479357225dc1a3b28125b/images/ff0aac27a8295db8711e768439012d33.png', 'data/categories/ra_family/rafsp_knowledge_base/a99864bca4f479357225dc1a3b28125b/images/f29a51e936e6ae9513fd7a00975c96e5.png', 'data/categories/ra_family/rafsp_knowledge_base/a99864bca4f479357225dc1a3b28125b/images/d64868d36d44647fd2ee9e59f9fb9956.png', 'data/categories/ra_family/rafsp_knowledge_base/a99864bca4f479357225dc1a3b28125b/images/2e580bd593297ef469b5117b0538ee27.png', 'data/categories/ra_family/rafsp_knowledge_base/a99864bca4f479357225dc1a3b28125b/images/c6b896f74b9aca6fc83de3770c201369.png']",[],"['|  |\n|  |\n| // Open Each device\ng_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);\ng_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);\n  // Call I2C Communication Device Write or Read to communicate with Device(0x44)\ng_comms_i2c_device0.p_api->write(...);\ng_comms_i2c_device0.p_api->read(...);\n  // Call I2C Communication Device Write or Read to communicate with Device(0x55)\ng_comms_i2c_device1.p_api->write(...);\ng_comms_i2c_device1.p_api->read(...); |', '|  |\n|  |\n| // Open\ng_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);\n  // Switch Slave address to 0x55\ng_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);\n  // Call I2C Write or Read to communicate with Device(0x55)\ng_i2c_master.p_api->write(…);\ng_i2c_master.p_api->read(…);\n  // Switch Slave address to 0x44\ng_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);\n  // Call I2C Write or Read to communicate with Device(0x44)\ng_i2c_master.p_api->write(…);\ng_i2c_master.p_api->read(…); |', '|  |\n|  |\n| RA |']","{'title': 'RA Family: How to communicate with multiple slave devices on the same I2C bus.', 'url': 'https://en-support.renesas.com/knowledgeBase/21132844', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:06.353475'}","Question How to communicate with multiple slave devices on the same I2C bus. Answer When communicating with multiple I2C slave devices on the same bus, it is necessary to switch the slave address to communicate. There are two ways to do this. (1) Use the shared bus function of the I2C Communication Device (rmcommsi2c) (2) Switch the slave address using the slaveAddressSet API of the I2C Master driver The following steps describe each method. By using the I2C Communication Device (rmcommsi2c), the I2C master driver can communicate with multiple slave device via the I2C Shared bus. Either the riicmaster driver or the rscii2c driver can be used as the I2C master driver. Every instance of rmcommsi2c has a 'Slave Address' setting in its properties, which can be configured independently. When an rmcommsi2c instance communicates with a slave I2C device, the I2C Shared Bus switches to the respective slave device and communicates with it. When using an RTOS, rmcommsi2c provides the following features Blocking operation using a mutex for RMCOMMSI2CWrite(), RMCOMMSI2CRead() and RMCOMMSI2CWriteRead(). Bus lock using a mutex. Here is an example. In this case, the address of the gcommsi2cdvice0 instance is 0x44, and the address of the gcommsi2cdevice1 is 0x55. Pseudo code to show how to use shared i2c bus. // Open Each device gcommsi2cdevice0.papi-open(gcommsi2cdevice0.pctrl, gcommsi2cdevice0.pcfg); gcommsi2cdevice1.papi-open(gcommsi2cdevice1.pctrl, gcommsi2cdevice1.pcfg); // Call I2C Communication Device Write or Read to communicate with Device(0x44) gcommsi2cdevice0.papi-write(...); gcommsi2cdevice0.papi-read(...); // Call I2C Communication Device Write or Read to communicate with Device(0x55) gcommsi2cdevice1.papi-write(...); gcommsi2cdevice1.papi-read(...); (2) Switch the slave address using the slaveAddressSet API of the I2C Master driver This method creates one instance of the I2C master driver. The application then uses the slaveAddressSet API to switch the slave devices for communication. Here is an example where the addresses for the slave devices are 0x44 and 0x55. The default slave address of the I2C master driver instance is set to 0x44 in this case. Pseudo code to show when to use the slaveAddressSet API. // Open gi2cmaster.papi-open(gi2cmaster.pctrl, gi2cmaster.pcfg); // Switch Slave address to 0x55 gi2cmaster.papi-slaveAddressSet(gi2cmaster.pctrl, 0x55, I2CMASTERADDRMODE7BIT); // Call I2C Write or Read to communicate with Device(0x55) gi2cmaster.papi-write(); gi2cmaster.papi-read(); // Switch Slave address to 0x44 gi2cmaster.papi-slaveAddressSet(gi2cmaster.pctrl, 0x44, I2CMASTERADDRMODE7BIT); // Call I2C Write or Read to communicate with Device(0x44) Suitable Products RA Pseudo code to show how to use shared i2c bus. // Call I2C Communication Device Write or Read to communicate with Device(0x44) // Call I2C Communication Device Write or Read to communicate with Device(0x55) // Switch Slave address to 0x55 // Call I2C Write or Read to communicate with Device(0x55) // Switch Slave address to 0x44 // Call I2C Write or Read to communicate with Device(0x44) Suitable Products","['The image shows a screenshot of a computer program, specifically a diagram of HAL/ Common Stacks. The diagram is divided into several sections, each representing a different component or stack.\n\n*   **g_comms_i2c_device0 I2C Communication Device (rm_comms_i2c)**\n    *   This section represents a communication device that uses the I2C protocol.\n    *   It is labeled as ""g_comms_i2c_device0"" and has a yellow highlight on the text ""I2C Shared Bus (rm_comms_i2c)"".\n*   **g_comms_i2c_device1 I2C Communication Device (rm_comms_i2c)**\n    *   This section represents another communication device that uses the I2C protocol.\n    *   It is labeled as ""g_comms_i2c_device1"" and has a yellow highlight on the text ""I2C Shared Bus (rm_comms_i2c)"".\n*   **g_i2c_master0 I2C Master (r_iic_master)**\n    *   This section represents an I2C master device.\n    *   It is labeled as ""g_i2c_master0"" and has a yellow highlight on the text ""I2C Shared Bus (rm_comms_i2c)"".\n*   **g_i2c_master1 I2C Master (r_iic_master)**\n    *   This section represents another I2C master device.\n    *   It is labeled as ""g_i2c_master1"" and has a yellow highlight on the text ""I2C Shared Bus (rm_comms_i2c)"".\n*   **Add DTC Driver for Transmission [Optional]**\n    *   This section represents an optional driver for transmission.\n    *   It is labeled as ""Add DTC Driver for Transmission [Optional]"" and has a yellow highlight on the text ""I2C Shared Bus (rm_comms_i2c)"".\n*   **Add DTC Driver for Reception [Optional]**\n    *   This section represents an optional driver for reception.\n    *   It is labeled as ""Add DTC Driver for Reception [Optional]"" and has a yellow highlight on the text ""I2C Shared Bus (rm_comms_i2c)"".\n\nIn summary, the image shows a diagram of HAL/ Common Stacks, which includes several components such as communication devices, I2C masters, and optional drivers for transmission and reception. The diagram highlights the I2C shared bus and the optional drivers for transmission and reception.', 'The image shows a screenshot of a computer program with a list of settings for a communication device. The title at the top of the image reads ""g_comms_i2c_device0 I2C Communication Device (rm_comms_i2c)"" in black text.\n\nBelow the title, there are several sections with different settings. The first section is labeled ""Settings"" and has a dropdown menu with options such as ""Common"", ""Parameter Checking"", and ""Module_g_comms_i2c_device0 I2C Communication Device (rm_comms_i2c)"". The second section is labeled ""API Info"" and has a dropdown menu with options such as ""Name"", ""Semaphore Timeout (RTOS only)"", ""Slave Address"", ""Address Mode"", and ""Callback"".\n\nThe ""Slave Address"" option is highlighted in yellow, indicating that it is the current setting. The value of this setting is ""0x44"". The ""Address Mode"" option is also highlighted in yellow, indicating that it is the current setting. The value of this setting is ""7-Bit"".\n\nOverall, the image appears to be a screenshot of a computer program used to configure a communication device. The program allows users to set various parameters, including the slave address and address mode, to customize the behavior of the device.', 'The image shows a screenshot of a computer screen displaying a settings page for a communication device. The title at the top of the page reads ""g_comms_i2c_device1 I2C Communication Device (rm_comms_i2c)"" in black text.\n\nBelow the title, there are several sections with headings and subheadings. The first section is labeled ""Settings"" and has a dropdown menu with options such as ""Common"", ""Parameter Checking"", and ""Default (BSP)"". The second section is labeled ""API Info"" and has a dropdown menu with options such as ""Module g_comms_i2c_device1 I2C Communication Device (rm_comms_i2c)"", ""Name"", ""Semaphore Timeout (RTOS only)"", ""Slave Address"", ""Address Mode"", and ""Callback"".\n\nThe ""Slave Address"" field is highlighted in yellow, indicating that it is the current value being edited. The value in this field is ""0x55"". The ""Address Mode"" field is also highlighted in yellow, indicating that it is the current value being edited. The value in this field is ""7-Bit"".\n\nOverall, the image appears to be a screenshot of a computer screen displaying a settings page for a communication device, with the user currently editing the ""Slave Address"" and ""Address Mode"" fields.', 'The image presents a flowchart illustrating the process of adding DTC drivers for transmission and reception. The flowchart is divided into three sections, each representing a distinct step in the process.\n\n*   **Step 1: g_i2c_master I2C Master (r_iic_master)**\n    *   This section serves as the starting point of the flowchart.\n    *   It represents the initial step in the process, where the I2C master is activated.\n*   **Step 2: Add DTC Driver for Transmission [Optional]**\n    *   This section indicates that adding a DTC driver for transmission is an optional step.\n    *   It suggests that the user has the flexibility to choose whether to include this step in the process.\n*   **Step 3: Add DTC Driver for Reception [Optional]**\n    *   Similar to the previous section, this step is also optional.\n    *   It implies that the user can decide whether to add a DTC driver for reception or not.\n\nIn summary, the flowchart outlines a three-step process for adding DTC drivers for transmission and reception. The first step involves activating the I2C master, while the subsequent steps are optional and allow the user to choose whether to include them in the process.', 'The image shows a screenshot of a computer program\'s settings menu, specifically the ""g_i2c_master I2C Master (r_iic_master)"" section. The menu is organized into two columns, with the left column listing various settings and the right column displaying their corresponding values.\n\n**Settings:**\n\n*   **Parameter Checking**\n    *   Default (BSP)\n*   **DTC on Transmission and Reception**\n    *   Disabled\n*   **10-bit slave addressing**\n    *   Disabled\n*   **Module g_i2c_master I2C Master (r_iic_master)**\n    *   Name: g_i2c_master\n    *   Channel: 0\n    *   Rate: Standard\n    *   Rise Time (ns): 120\n    *   Fall Time (ns): 120\n    *   Duty Cycle (%): 50\n    *   Slave Address: 0x44\n    *   Address Mode: 7-Bit\n    *   Timeout Mode: Short Mode\n    *   Timeout during SCL Low: Enabled\n    *   Callback: i2c_master_callback\n\nThe background of the image is white, with a gray bar at the top that contains the title ""g_i2c_master I2C Master (r_iic_master)"" in black text. The overall design of the menu is clean and easy to read, with clear headings and concise descriptions for each setting.']"
3bd11c96d3d55f88c63f92852438247c,"Question:
How to debug code from a specified address on Renesas RA MCUs - e2 studio
Answer:
As more and more devices require OTA (Over The Air) code upgrades, there is an increasing need for parallel development of bootloaders and applications. This requires that in the development stage, the application project address can be offset to be consistent with the final address space division.
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, as shown in the following figure (take the RA2L1 manual as an example), so if the 0 address is full FFh, the code cannot be debugged.
To solve this issue, the address offset required for MCU operation can be respecified in the IDE (Initial stack pointer and Initial program counter in the figure above). In this article, we will take e2 Studio as an example.
1. Linker script file (code writing phase).
First, you need to modify the linker script file. Take the memory_regions.ld file as an example. FLASH_START is the basic offset address when the code is compiled, the default is 0, and the target offset address of the application is modified according to the requirements, such as 0x4000. Recompile the project, check the generated SREC file or MOT file, and make sure that the file starts at 0x4000, as shown below.
2. Debug Configuration Settings (Code Debugging Phase)
In the Debug Configuration, add the following three lines of code to Startup > Run Commands.
set $sp = *0x4000
set $pc = *0x4004
set {int}0xe000ed08 = 0x00020000
The meanings of these 3 lines of code are explained as follows:
set $sp = *0x20000
Since the stack pointer address is required at the start of the code, as shown in the following figure, it points to 0x20000
set $pc = *0x20004
This is the address where the reset vector is stored.
set {int}0xe000ed08 = 0x00020000
E000ED08h is the address of the Vector Table Offset Register, which is a common register for ARM core chips, which can be found in the corresponding core manual and related documents of the MCU.
For example, the Arm® Cortex-M4® is detailed at the following link:
https://developer.arm.com/documentation/ddi0337/e/nested-vectored-interrupt-controller/nvic-programmer-s-model/nvic-register-descriptions
Click the debug button in the following figure to confirm the following content in the new interface: the RESET vector is located at the 0x4C45, and the code stops at the 0x4C44 after powering on.
Regarding the difference between the last bit, the explanation is as follows:
After powering up, the CPU check address is offset to the lowest bit of data at the 0x0004, if the bit is 1, it means that this is a usable thumb address. The bit is then ignored (set to 0) and the first instruction is taken as the reset handle at the modified address.
For more details, please refer to the Arm processor documentation.
Suitable Products
RA
How to debug code from a specified address on Renesas RA MCUs - e2 studio
How to debug code from a specified address on Renesas RA MCUs - e2 studio
Answer:
As more and more devices require OTA (Over The Air) code upgrades, there is an increasing need for parallel development of bootloaders and applications. This requires that in the development stage, the application project address can be offset to be consistent with the final address space division.
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, as shown in the following figure (take the RA2L1 manual as an example), so if the 0 address is full FFh, the code cannot be debugged.
To solve this issue, the address offset required for MCU operation can be respecified in the IDE (Initial stack pointer and Initial program counter in the figure above). In this article, we will take e2 Studio as an example.
1. Linker script file (code writing phase).
First, you need to modify the linker script file. Take the memory_regions.ld file as an example. FLASH_START is the basic offset address when the code is compiled, the default is 0, and the target offset address of the application is modified according to the requirements, such as 0x4000. Recompile the project, check the generated SREC file or MOT file, and make sure that the file starts at 0x4000, as shown below.
2. Debug Configuration Settings (Code Debugging Phase)
In the Debug Configuration, add the following three lines of code to Startup > Run Commands.
set $sp = *0x4000
set $pc = *0x4004
set {int}0xe000ed08 = 0x00020000
The meanings of these 3 lines of code are explained as follows:
set $sp = *0x20000
Since the stack pointer address is required at the start of the code, as shown in the following figure, it points to 0x20000
set $pc = *0x20004
This is the address where the reset vector is stored.
set {int}0xe000ed08 = 0x00020000
E000ED08h is the address of the Vector Table Offset Register, which is a common register for ARM core chips, which can be found in the corresponding core manual and related documents of the MCU.
For example, the Arm® Cortex-M4® is detailed at the following link:
https://developer.arm.com/documentation/ddi0337/e/nested-vectored-interrupt-controller/nvic-programmer-s-model/nvic-register-descriptions
Click the debug button in the following figure to confirm the following content in the new interface: the RESET vector is located at the 0x4C45, and the code stops at the 0x4C44 after powering on.
Regarding the difference between the last bit, the explanation is as follows:
After powering up, the CPU check address is offset to the lowest bit of data at the 0x0004, if the bit is 1, it means that this is a usable thumb address. The bit is then ignored (set to 0) and the first instruction is taken as the reset handle at the modified address.
For more details, please refer to the Arm processor documentation.
Suitable Products
RA
As more and more devices require OTA (Over The Air) code upgrades, there is an increasing need for parallel development of bootloaders and applications. This requires that in the development stage, the application project address can be offset to be consistent with the final address space division.
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, as shown in the following figure (take the RA2L1 manual as an example), so if the 0 address is full FFh, the code cannot be debugged.
To solve this issue, the address offset required for MCU operation can be respecified in the IDE (Initial stack pointer and Initial program counter in the figure above). In this article, we will take e2 Studio as an example.
1. Linker script file (code writing phase).
First, you need to modify the linker script file. Take the memory_regions.ld file as an example. FLASH_START is the basic offset address when the code is compiled, the default is 0, and the target offset address of the application is modified according to the requirements, such as 0x4000. Recompile the project, check the generated SREC file or MOT file, and make sure that the file starts at 0x4000, as shown below.
2. Debug Configuration Settings (Code Debugging Phase)
In the Debug Configuration, add the following three lines of code to Startup > Run Commands.
set $sp = *0x4000
set $pc = *0x4004
set {int}0xe000ed08 = 0x00020000
The meanings of these 3 lines of code are explained as follows:
set $sp = *0x20000
Since the stack pointer address is required at the start of the code, as shown in the following figure, it points to 0x20000
set $pc = *0x20004
This is the address where the reset vector is stored.
set {int}0xe000ed08 = 0x00020000
E000ED08h is the address of the Vector Table Offset Register, which is a common register for ARM core chips, which can be found in the corresponding core manual and related documents of the MCU.
For example, the Arm® Cortex-M4® is detailed at the following link:
https://developer.arm.com/documentation/ddi0337/e/nested-vectored-interrupt-controller/nvic-programmer-s-model/nvic-register-descriptions
Click the debug button in the following figure to confirm the following content in the new interface: the RESET vector is located at the 0x4C45, and the code stops at the 0x4C44 after powering on.
Regarding the difference between the last bit, the explanation is as follows:
After powering up, the CPU check address is offset to the lowest bit of data at the 0x0004, if the bit is 1, it means that this is a usable thumb address. The bit is then ignored (set to 0) and the first instruction is taken as the reset handle at the modified address.
For more details, please refer to the Arm processor documentation.
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/d98f6ed3e504092b8b3205f0158ca374.png', 'data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/23d194c409158fde805663e56127b821.png', 'data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/a7f760fa48cda337d6e3104e0a1f085e.png', 'data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/2beb26c8b6a12577661dada123099777.png', 'data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/55bf506502ee2f112969644f1b511f19.png', 'data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/acb69985710331559e0ec7affc678611.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'How to debug code from a specified address on Renesas RA MCUs - e2 studio', 'url': 'https://en-support.renesas.com/knowledgeBase/21174040', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:54.223259'}","Question How to debug code from a specified address on Renesas RA MCUs - e2 studio Answer As more and more devices require OTA (Over The Air) code upgrades, there is an increasing need for parallel development of bootloaders and applications. This requires that in the development stage, the application project address can be offset to be consistent with the final address space division. For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, as shown in the following figure (take the RA2L1 manual as an example), so if the 0 address is full FFh, the code cannot be debugged. To solve this issue, the address offset required for MCU operation can be respecified in the IDE (Initial stack pointer and Initial program counter in the figure above). In this article, we will take e2 Studio as an example. 1. Linker script file (code writing phase). First, you need to modify the linker script file. Take the memoryregions.ld file as an example. FLASHSTART is the basic offset address when the code is compiled, the default is 0, and the target offset address of the application is modified according to the requirements, such as 0x4000. Recompile the project, check the generated SREC file or MOT file, and make sure that the file starts at 0x4000, as shown below. 2. Debug Configuration Settings (Code Debugging Phase) In the Debug Configuration, add the following three lines of code to Startup  Run Commands. set sp  0x4000 set pc  0x4004 set int0xe000ed08  0x00020000 The meanings of these 3 lines of code are explained as follows set sp  0x20000 Since the stack pointer address is required at the start of the code, as shown in the following figure, it points to 0x20000 set pc  0x20004 This is the address where the reset vector is stored. E000ED08h is the address of the Vector Table Offset Register, which is a common register for ARM core chips, which can be found in the corresponding core manual and related documents of the MCU. For example, the Arm Cortex-M4 is detailed at the following link https//developer.arm.com/documentation/ddi0337/e/nested-vectored-interrupt-controller/nvic-programmer-s-model/nvic-register-descriptions Click the debug button in the following figure to confirm the following content in the new interface the RESET vector is located at the 0x4C45, and the code stops at the 0x4C44 after powering on. Regarding the difference between the last bit, the explanation is as follows After powering up, the CPU check address is offset to the lowest bit of data at the 0x0004, if the bit is 1, it means that this is a usable thumb address. The bit is then ignored (set to 0) and the first instruction is taken as the reset handle at the modified address. For more details, please refer to the Arm processor documentation. Suitable Products RA","['The image displays a table from a technical document, specifically from the Intel 64 and IA-32 Architectures Optimization Reference Manual, 2019 Edition, Volume 2: System Programming Guide, Part 2. The table is titled ""Table 12.3"" and is located in section 12.3.1, which describes the interrupt vector table.\n\n**Table 12.3: Interrupt Vector Table**\n\n| Exception number | IRQ number | Vector offset | Source | Description |\n| --- | --- | --- | --- | --- |\n| 0 | — | 0x000 | Arm | Initial stack pointer |\n| 1 | — | 0x004 | Arm | Initial program counter (reset vector) |\n| 2 | — | 0x008 | Arm | Non-Maskable Interrupt (NMI) |\n| 3 | — | 0x00C | Arm | Hard Fault |\n\nThe table provides information about the interrupt vector table, including the exception number, IRQ number, vector offset, source, and description for each entry. The table is divided into four columns, with the first column listing the exception number, the second column listing the IRQ number, the third column listing the vector offset, the fourth column listing the source, and the fifth column listing the description.\n\nThe table is located in section 12.3.1 of the document, which describes the interrupt vector table. The table is used to describe the interrupt vector table, which is a table that contains the addresses of the interrupt handlers for each exception number. The table is used by the processor to determine which interrupt handler to call when an interrupt occurs.\n\nOverall, the table provides important information about the interrupt vector table, including the exception numbers, IRQ numbers, vector offsets, sources, and descriptions for each entry. This information is useful for understanding how the processor handles interrupts and how to program the interrupt vector table.', 'The image shows a screenshot of a code editor with a blue bar at the top left corner that says ""memory_regions.ld"" in white text. The code is written in C and appears to be a memory region file, as indicated by the file extension "".ld"". \n\nThe code is organized into sections, each with a number and a description. The first section is labeled ""1"" and contains the line ""/* generated memory regions file - do not edit */"". This suggests that the code was automatically generated and should not be edited manually.\n\nThe second section is labeled ""2"" and contains the line ""RAM_START = 0x20004000;"". This line defines a variable named ""RAM_START"" and assigns it the value 0x20004000, which is a hexadecimal address.\n\nThe third section is labeled ""3"" and contains the line ""RAM_LENGTH = 0x4000;"". This line defines a variable named ""RAM_LENGTH"" and assigns it the value 0x4000, which is a hexadecimal value representing the length of the RAM region.\n\nThe fourth section is labeled ""4"" and contains the line ""/* FLASH_START = 0x00000000; */"". This line defines a variable named ""FLASH_START"" and assigns it the value 0x00000000, which is a hexadecimal address. The comment suggests that this value may be used later in the code.\n\nThe fifth section is labeled ""5"" and contains the line ""FLASH_START = 0x00000000;"". This line redefines the ""FLASH_START"" variable with the same value as before, but with a different comment. The comment suggests that this value may be used later in the code.\n\nThe sixth section is labeled ""6"" and contains the line ""FLASH_LENGTH = 0x20000;"". This line defines a variable named ""FLASH_LENGTH"" and assigns it the value 0x20000, which is a hexadecimal value representing the length of the flash region.\n\nThe seventh section is labeled ""7"" and contains the line ""DATA_FLASH_START = 0x40100000;"". This line defines a variable named ""DATA_FLASH_START"" and assigns it the value 0x40100000, which is a hexadecimal address.\n\nThe eighth section is labeled ""8"" and contains the line ""DATA_FLASH_LENGTH = 0x1000;"". This line defines a variable named ""DATA_FLASH_LENGTH"" and assigns it the value 0x1000, which is a hexadecimal value representing the length of the data flash region.\n\nThe ninth section is labeled ""9"" and contains the line ""OPTION_SETTING_START = 0x00000000;"". This line defines a variable named ""OPTION_SETTING_START"" and assigns it the value 0x00000000, which is a hexadecimal address.\n\nThe tenth section is labeled ""10"" and contains the line ""OPTION_SETTING_LENGTH = 0x0;"". This line defines a variable named ""OPTION_SETTING_LENGTH"" and assigns it the value 0x0, which is a hexadecimal value representing the length of the option setting region.\n\nOverall, the code appears to be defining various memory regions and their corresponding addresses and lengths. The use of hexadecimal addresses and values suggests that the code is intended for use in a specific embedded system or microcontroller.', ""The image presents a hexadecimal code snippet, comprising six lines of text. Each line is numbered from 1 to 6, and the text is displayed in a combination of colors, including red, yellow, green, and black.\n\nThe hexadecimal code appears to be a sequence of numbers and letters, with each line containing a unique set of characters. The code is not easily readable due to its complexity and the use of different colors for each line.\n\nWithout additional context or information about the purpose of this code, it is challenging to provide a detailed explanation of its meaning or function. However, based on the visual representation, it seems to be a technical or programming-related code, possibly used in a specific software or system.\n\nTo better understand the content of this image, further context or information about the code's origin, purpose, or intended use would be necessary."", 'The image shows a screenshot of a computer program, specifically a debugging configuration window. The window is titled ""Edit Renesas GDB Hardware Debugging configuration ra2e1_blinky_app_0x20000 Debug_Flat for Debug"" and has several fields and options for configuring the debugging process.\n\n*   **Launch Configuration Name**: This field is pre-populated with the name ""ra2e1_blinky_app_0x20000 Debug_Flat"".\n*   **Main Debugger**: This field is set to ""Common"" by default.\n*   **Runtime Options**: This section has several checkboxes, including:\n    *   **Set program counter at (hex)**: This checkbox is unchecked.\n    *   **Set breakpoint at**: This field is empty.\n    *   **Resume**: This checkbox is unchecked.\n*   **Run Commands**: This section has a text box where commands can be entered. The text box contains the following commands:\n    *   `set $tp = *0x4000`\n    *   `set $pc = *0x4004`\n    *   `set (int)0x0000ed08 = 0x400000`\n\nOverall, the image shows a debugging configuration window with various fields and options for customizing the debugging process. The window is likely used to configure the debugging settings for a specific program or application.', 'The image displays a table titled ""Interrupt vector table (1 of 4)"" from Table 14.3. The table has four columns and five rows, with the first row serving as a header.\n\n**Columns:**\n\n*   **Exception number**: This column lists the exception numbers, ranging from 0 to 3.\n*   **IRQ number**: This column is empty for all rows.\n*   **Vector offset**: This column contains the vector offset values, which are 000h, 004h, 008h, and 00Ch for the corresponding exception numbers.\n*   **Source**: This column indicates the source of the interrupt, which is Arm for all rows.\n*   **Description**: This column provides a brief description of the interrupt, including:\n    *   Initial stack pointer for exception number 0\n    *   Initial program counter (reset vector) for exception number 1\n    *   Non-maskable interrupt (NMI) for exception number 2\n    *   Hard fault for exception number 3\n\n**Summary:**\n\nThe table provides information about the interrupt vector table, including the exception numbers, vector offsets, sources, and descriptions. The table is divided into four columns, with the first row serving as a header. The table is titled ""Interrupt vector table (1 of 4)"" and is part of Table 14.3.', 'The image shows a screenshot of a computer program in a code editor, with a red box highlighting a specific line of code. The code is written in C# and appears to be part of a larger program.\n\n*   The code is displayed in a text editor window with a white background and black text.\n*   The code is organized into sections, with comments and whitespace used to separate different parts of the program.\n*   The highlighted line of code reads ""System.Diagnostics.Debug.WriteLine(""0x0000C46"");"" and is located near the top of the window.\n*   The code editor has various tools and menus available, including a toolbar at the top with buttons for editing, debugging, and other functions.\n*   The overall appearance of the image suggests that it is a screenshot of a developer working on a project in a code editor.\n\nThe image provides a glimpse into the world of software development, showcasing the complexity and detail involved in writing code. It highlights the importance of attention to detail and the need for clear organization in programming.']"
103fafbd04829dc8390f1a027b7c548b,"Question:
How to set the ID Code to disable ID code protection, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Unlocked (Ignore ID)” in the BSP property as shown below. In this case, “ID code (32 Hex Characters)” is ignored.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as  “00112233445566778899AABBCCDDEEFF”.
This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. You can see that the ID code is set as all FFh.
/* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */
#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0

In case of RA6M3:
S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08

In case of RA4E2:
S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38

Debugger connection in e2 studio (ID code authentication)
No ID code setting is required in the debug configuration.
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting ALeRASE ID code (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code.  It cannot be used when using J-Link. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
Connection by RFP (with ID code authentication)
There is no need to set the ID code in the connection settings.
Connection by RFP (with ALeRASE execution)
ALeRASE is not available.
Suitable Products
RA and FSP
How to set the ID Code to disable ID code protection, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Unlocked (Ignore ID)” in the BSP property as shown below. In this case, “ID code (32 Hex Characters)” is ignored.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as  “00112233445566778899AABBCCDDEEFF”.
This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. You can see that the ID code is set as all FFh.
/* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */
#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0

In case of RA6M3:
S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08

In case of RA4E2:
S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38

Debugger connection in e2 studio (ID code authentication)
No ID code setting is required in the debug configuration.
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting ALeRASE ID code (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code.  It cannot be used when using J-Link. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
Connection by RFP (with ID code authentication)
There is no need to set the ID code in the connection settings.
Connection by RFP (with ALeRASE execution)
ALeRASE is not available.
Suitable Products
RA and FSP
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Unlocked (Ignore ID)” in the BSP property as shown below. In this case, “ID code (32 Hex Characters)” is ignored.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as  “00112233445566778899AABBCCDDEEFF”.
This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. You can see that the ID code is set as all FFh.
/* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */
#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0

In case of RA6M3:
S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08

In case of RA4E2:
S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38

Debugger connection in e2 studio (ID code authentication)
No ID code setting is required in the debug configuration.
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting ALeRASE ID code (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code.  It cannot be used when using J-Link. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
Connection by RFP (with ID code authentication)
There is no need to set the ID code in the connection settings.
Connection by RFP (with ALeRASE execution)
ALeRASE is not available.
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Unlocked (Ignore ID)” in the BSP property as shown below. In this case, “ID code (32 Hex Characters)” is ignored.
“ID code (32 Hex Characters)”
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as  “00112233445566778899AABBCCDDEEFF”.
00112233
44556677
8899AABB
CCDDEEFF
This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. You can see that the ID code is set as all FFh.
/* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */
#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF)
/* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */
FFFFFFFF
FFFFFFFF
FFFFFFFF
FFFFFFFF
#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)
FFFFFFFF
#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)
FFFFFFFF
#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)
FFFFFFFF
#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF)
ffFFFFFF
The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0
S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
FFFFFFFF
FFFFFFFF
S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0
FFFFFFFF
FFFFFFFF
In case of RA6M3:
S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08
S3150100A150
FFFFFFFF
FFFFFFFF
FFFFFFFF
FFFFFFFF
08
In case of RA4E2:
S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38
S3150100A120
FFFFFFFF
FFFFFFFF
FFFFFFFF
FFFFFFFF
38
Debugger connection in e2 studio (ID code authentication)
No ID code setting is required in the debug configuration.
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting ALeRASE ID code (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code.  It cannot be used when using J-Link. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
(
FFFFFFFFFFFFFFFFFF45534152654C41
FFFFFFFF
FFFFFFFF
FF455341
52654C41
Connection by RFP (with ID code authentication)
There is no need to set the ID code in the connection settings.
Connection by RFP (with ALeRASE execution)
ALeRASE is not available.
Suitable Products
RA and FSP
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/103fafbd04829dc8390f1a027b7c548b/images/d17c6db86d4fa2c0a218d21ce110ff0e.png', 'data/categories/ra_family/rafsp_knowledge_base/103fafbd04829dc8390f1a027b7c548b/images/1f7dae96e4b4badaca4d402626b96f0c.png']",[],"['|  |\n|  |\n| /* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */\n#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)\n#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)\n#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)\n#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF) |', '|  |\n|  |\n| S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0\nS31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0 |', '|  |\n|  |\n| S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08 |', '|  |\n|  |\n| S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38 |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: ID code protection (in case of protection disabled)', 'url': 'https://en-support.renesas.com/knowledgeBase/20980155', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:32.770805'}","Question How to set the ID Code to disable ID code protection, and how to connect a debugger or programmer in that case? Answer How to set the ID code In the FSP configurator, set the ID Code Mode to Unlocked (Ignore ID) in the BSP property as shown below. In this case, ID code (32 Hex Characters) is ignored. The value of the ID code in the OSIS register In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to racfg/fspcfg/bsp/bspmcufamilycfg.h as shown below. You can see that the ID code is set as all FFh. / ID CODE FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF / define BSPCFGIDCODELONG1 (0xFFFFFFFF) define BSPCFGIDCODELONG2 (0xFFFFFFFF) define BSPCFGIDCODELONG3 (0xFFFFFFFF) define BSPCFGIDCODELONG4 (0xffFFFFFF) The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register In case of RA2L1 S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0 S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0 In case of RA6M3 S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08 In case of RA4E2 S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38 Debugger connection in e2 studio (ID code authentication) No ID code setting is required in the debug configuration. Debugger connection in e2 studio (with ALeRASE execution) In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting ALeRASE ID code (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution. Connection by RFP (with ID code authentication) There is no need to set the ID code in the connection settings. Connection by RFP (with ALeRASE execution) ALeRASE is not available. Suitable Products RA and FSP ID code (32 Hex Characters) 00112233 44556677 8899AABB CCDDEEFF FFFFFFFF ffFFFFFF S3150100A150 08 S3150100A120 38 ( FFFFFFFFFFFFFFFFFF45534152654C41 FF455341 52654C41","['The image displays a table with two columns and two rows. The first column is labeled ""ID Code Mode"" and the second column is labeled ""Unlocked (Ignore ID)"". The first row contains the text ""ID Code (32 Hex Characters)"" in the first column and the text ""00112233445566778899AABBCCDDEEFF"" in the second column. The background of the image is white.', 'The image shows a screenshot of a computer program, specifically a debugging tool. The top of the window has a menu bar with options such as ""Main"", ""Debugger"", ""Startup"", ""Common"", and ""Source"". Below this are several tabs, including ""Debug hardware:"", ""Target Device:"", and ""GDB Settings"".\n\n*   **Debug hardware:**\n    *   This section allows the user to select the type of hardware they are debugging.\n    *   The current selection is ""E2 Lite (ARM)"".\n*   **Target Device:**\n    *   This section allows the user to specify the target device for debugging.\n    *   The current selection is ""R7FA2L1AB"".\n*   **GDB Settings:**\n    *   This section provides various settings for the GDB debugger.\n    *   The current settings include:\n        *   **Connection Settings:** The connection settings are set to ""Debug Tool Settings"".\n        *   **Clock:** The clock setting is set to ""Connection with Target Board"".\n        *   **Power:** The power setting is set to ""Connection"".\n        *   **Connection:** The connection setting is set to ""Hold reset during connect"".\n        *   **D Code (Bytes):** The D code setting is set to ""FFFFFFFFFFFFFFFF45534152654C41"".\n        *   **Low Power Handling:** The low power handling setting is set to ""Yes"".\n\nOverall, the image shows a debugging tool with various settings and options for customizing the debugging process. The user can select the hardware and target device, set up the GDB debugger, and configure other settings as needed.']"
74b1913a749d3918a42ec334b062b43a,"Overview:
Some RA MCU series provide a CLKOUT pin/function to send the input or internal clock to an output pin. The CLKOUT function is sometimes overlooked as simply supplying a clock to an external IC, but it can also be used to check whether the external clock works as expected.
Some use cases include:
Probing the XCIN/XCOUT pins often attenuates the 32.768 KHz external clock (SUBCLK, SOSC) signal and stops oscillating, so CLKOUT can be used to check the frequency or continuity of the 32.768 KHz external clock.
Sometimes the MOSC (XTAL) clock introduces an external RC filter circuit to reduce the EMI noise caused by the MOSC. The CLKOUT pin can be used to verify how the sinewave-like MOSC clock input is recognized by the MCU.
Description:
The procedure to enable CLKOUT in e2 studio is described below. This is an example of using SUBCLK as a clock source on the EK-RA6M4 board, but this is generally applicable to other MCUs as well.
“Clocks” configuration
1. Set the clock source for CLKOUT.
2. Set the divider for CLKOUT.
  “Pins” configuration
1. Select the pin to use as the CLKOUT pin in CGC peripheral.
2. If necessary, change the drive capacity, pull up, output type, etc. of the CLKOUT pin.
  Test:
Simply “Generate Project Content” and run the code without adding/editing code. During the startup process (""SystemInit""), CLKOUT is enabled, and a square wave output can be seen from the CLKOUT pin as shown below.
  Suitable Products
RA
Some RA MCU series provide a CLKOUT pin/function to send the input or internal clock to an output pin. The CLKOUT function is sometimes overlooked as simply supplying a clock to an external IC, but it can also be used to check whether the external clock works as expected.
Some use cases include:
Probing the XCIN/XCOUT pins often attenuates the 32.768 KHz external clock (SUBCLK, SOSC) signal and stops oscillating, so CLKOUT can be used to check the frequency or continuity of the 32.768 KHz external clock.
Sometimes the MOSC (XTAL) clock introduces an external RC filter circuit to reduce the EMI noise caused by the MOSC. The CLKOUT pin can be used to verify how the sinewave-like MOSC clock input is recognized by the MCU.
Some RA MCU series provide a CLKOUT pin/function to send the input or internal clock to an output pin. The CLKOUT function is sometimes overlooked as simply supplying a clock to an external IC, but it can also be used to check whether the external clock works as expected.
Some use cases include:
Description:
The procedure to enable CLKOUT in e2 studio is described below. This is an example of using SUBCLK as a clock source on the EK-RA6M4 board, but this is generally applicable to other MCUs as well.
“Clocks” configuration
1. Set the clock source for CLKOUT.
2. Set the divider for CLKOUT.
  “Pins” configuration
1. Select the pin to use as the CLKOUT pin in CGC peripheral.
2. If necessary, change the drive capacity, pull up, output type, etc. of the CLKOUT pin.
  Test:
Simply “Generate Project Content” and run the code without adding/editing code. During the startup process (""SystemInit""), CLKOUT is enabled, and a square wave output can be seen from the CLKOUT pin as shown below.
  Suitable Products
RA
The procedure to enable CLKOUT in e2 studio is described below. This is an example of using SUBCLK as a clock source on the EK-RA6M4 board, but this is generally applicable to other MCUs as well.
“Clocks” configuration
1. Set the clock source for CLKOUT.
2. Set the divider for CLKOUT.
  “Pins” configuration
1. Select the pin to use as the CLKOUT pin in CGC peripheral.
2. If necessary, change the drive capacity, pull up, output type, etc. of the CLKOUT pin.
  Test:
Simply “Generate Project Content” and run the code without adding/editing code. During the startup process (""SystemInit""), CLKOUT is enabled, and a square wave output can be seen from the CLKOUT pin as shown below.
The procedure to enable CLKOUT in e2 studio is described below. This is an example of using SUBCLK as a clock source on the EK-RA6M4 board, but this is generally applicable to other MCUs as well.
“Clocks” configuration
1. Set the clock source for CLKOUT.
2. Set the divider for CLKOUT.
“Pins” configuration
1. Select the pin to use as the CLKOUT pin in CGC peripheral.
2. If necessary, change the drive capacity, pull up, output type, etc. of the CLKOUT pin.
Simply “Generate Project Content” and run the code without adding/editing code. During the startup process (""SystemInit""), CLKOUT is enabled, and a square wave output can be seen from the CLKOUT pin as shown below.
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/74b1913a749d3918a42ec334b062b43a/images/60f300b1cb538a165d18b3f268b4c019.png', 'data/categories/ra_family/rafsp_knowledge_base/74b1913a749d3918a42ec334b062b43a/images/f26958db61359f960f0cd667fca2ae1d.png', 'data/categories/ra_family/rafsp_knowledge_base/74b1913a749d3918a42ec334b062b43a/images/f1728bd1d2cd7a5c6ae4b68fd6e93384.png', 'data/categories/ra_family/rafsp_knowledge_base/74b1913a749d3918a42ec334b062b43a/images/e3bee845bdbe9416c7539f6434659cac.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'RA Family: Using CLKOUT to check if the external clock is working properly', 'url': 'https://en-support.renesas.com/knowledgeBase/21132842', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:10.036692'}","Overview Some RA MCU series provide a CLKOUT pin/function to send the input or internal clock to an output pin. The CLKOUT function is sometimes overlooked as simply supplying a clock to an external IC, but it can also be used to check whether the external clock works as expected. Some use cases include Probing the XCIN/XCOUT pins often attenuates the 32.768 KHz external clock (SUBCLK, SOSC) signal and stops oscillating, so CLKOUT can be used to check the frequency or continuity of the 32.768 KHz external clock. Sometimes the MOSC (XTAL) clock introduces an external RC filter circuit to reduce the EMI noise caused by the MOSC. The CLKOUT pin can be used to verify how the sinewave-like MOSC clock input is recognized by the MCU. Description The procedure to enable CLKOUT in e2 studio is described below. This is an example of using SUBCLK as a clock source on the EK-RA6M4 board, but this is generally applicable to other MCUs as well. Clocks configuration 1. Set the clock source for CLKOUT. 2. Set the divider for CLKOUT. Pins configuration 1. Select the pin to use as the CLKOUT pin in CGC peripheral. 2. If necessary, change the drive capacity, pull up, output type, etc. of the CLKOUT pin. Test Simply Generate Project Content and run the code without adding/editing code. During the startup process (""SystemInit""), CLKOUT is enabled, and a square wave output can be seen from the CLKOUT pin as shown below. Suitable Products RA Pins configuration Suitable Products","['The image depicts a screenshot of a computer program, specifically a configuration interface for clock settings. The title ""Clocks Configuration"" is displayed in the top-left corner, accompanied by a green circle with a white checkmark and the text ""Generate Project Content"" in the top-right corner. Below this, a gray bar features the text ""Restore Defaults"" in black.\n\nThe main content of the image consists of a flowchart with various boxes and arrows, which appear to represent different clock settings and their relationships. The flowchart is divided into two main sections: the left side, which contains a list of clock settings, and the right side, which displays the corresponding clock frequencies.\n\nThe clock settings on the left side include:\n\n* XTAL 24MHz\n* HOCO 20MHz\n* IOCO 32768Hz\n* MOCO 8MHz\n* SUBCLK 32768Hz\n\nEach of these settings has an arrow pointing to the right, indicating that they are connected to the clock frequencies on the right side. The clock frequencies on the right side include:\n\n* ICLK Div /1\n* ICLK 200MHz\n* PCLKA Div /2\n* PCLKA 100MHz\n* PCLKB Div /4\n* PCLKB 50MHz\n* PCLKC Div /4\n* PCLKC 50MHz\n* PCLKD Div /2\n* PCLKD 100MHz\n* BCLK Div /2\n* BCLK 100MHz\n* EBCLK Div /2\n* EBCLK 50MHz\n* FCLK Div /4\n* FCLK 50MHz\n\nThe flowchart also includes several boxes with the text ""PLL Src: XTAL"", ""PLL Div /3"", ""PLL Mul x25.0"", ""PLL 200MHz"", ""PLL2 Disabled"", ""PLL2 Div /2"", ""PLL2 Mul x20.0"", and ""PLL2 0Hz"". These boxes are connected to the clock settings and frequencies through arrows, indicating that they are related to the clock configuration.\n\nOverall, the image appears to be a screenshot of a computer program used to configure clock settings for a project or device. The flowchart provides a visual representation of the relationships between different clock settings and frequencies, allowing users to easily navigate and modify the clock configuration.', 'The image shows a screenshot of a computer program with a white background and black text. The program is titled ""Pin Configuration"" and has several sections, including ""Select Pin Configuration,"" ""Pin Selection,"" and ""Pin Configuration.""\n\n**Select Pin Configuration**\n\n*   This section allows the user to select a pin configuration from a dropdown menu.\n*   The current selection is ""R7FA6M4AF3CFB.pincfg.""\n\n**Pin Selection**\n\n*   This section lists various pins that can be selected for configuration.\n*   The pins are organized into categories, such as ""Peripherals,"" ""Analog:ADC,"" ""Analog:ANALOG,"" and ""Connectivity:CAN.""\n*   Each pin has a checkbox next to it, indicating whether it is currently selected or not.\n\n**Pin Configuration**\n\n*   This section displays the current pin configuration settings.\n*   The settings include the name of the pin, its value, and its lock status.\n*   The pin name is ""CGC0,"" and its value is ""P205.""\n*   The lock status is indicated by a lock icon next to the pin name.\n\n**Other Features**\n\n*   The program has a ""Generate data"" button at the top right corner, which allows the user to generate data for the selected pin configuration.\n*   There is also a ""Cycle Pin Group"" button, which allows the user to cycle through different pin groups.\n*   The program has a ""Pin Function"" dropdown menu at the bottom left corner, which allows the user to select a specific pin function.\n\nOverall, the program appears to be a tool for configuring and managing pins on a computer system. It provides a user-friendly interface for selecting and configuring pins, as well as generating data and cycling through different pin groups.', 'The image shows a screenshot of a computer program, specifically a pin configuration window. The window is titled ""Pin Configuration"" and has several sections, including:\n\n*   **Select Pin Configuration**: This section allows the user to select a specific pin configuration from a list of available options.\n*   **Pin Selection**: This section displays a list of pins that are currently selected for configuration. The user can add or remove pins from this list by clicking on the corresponding checkboxes.\n*   **Pin Configuration**: This section provides a detailed view of the selected pin\'s configuration. It includes fields for entering the pin\'s name, value, and link, as well as a table for specifying the pin\'s peripheral mode, mode, pull-up, IRQ, drive capacity, output type, and input/output.\n*   **Module name**: This section displays the name of the module that the pin is associated with.\n*   **Port Capabilities**: This section lists the port capabilities of the module, including the AGT1, AGT2, BUS, ASYNC, A16, CGCO, CLKOUT, CTSUO, TS01, ETHERC, MIIO, and ETO WOL.\n\nOverall, the image suggests that the user is configuring the pin settings for a specific module or device. The program provides a range of options for customizing the pin configuration, including selecting the peripheral mode, mode, pull-up, IRQ, drive capacity, output type, and input/output.', 'The image shows a graph with a black background and a grid pattern of small white dots. The graph has a blue line that oscillates between two values, 3 and 1, over time. The x-axis is labeled ""Frequency"" and the y-axis is labeled ""32.76kHz"". The graph appears to be a representation of a signal or waveform, possibly from an oscilloscope or other electronic device.\n\nHere are some key features of the image:\n\n* **Graph:** The graph is the main focus of the image, and it shows a blue line that oscillates between two values, 3 and 1, over time.\n* **X-axis:** The x-axis is labeled ""Frequency"" and it appears to represent the time axis of the graph.\n* **Y-axis:** The y-axis is labeled ""32.76kHz"" and it appears to represent the amplitude of the signal.\n* **Grid pattern:** The background of the image has a grid pattern of small white dots, which may be used to help read the graph.\n* **Labels:** There are several labels on the graph, including ""Frequency"", ""32.76kHz"", and ""3"" and ""1"" on the y-axis.\n* **Color scheme:** The graph is displayed in a blue color scheme, with the blue line representing the signal and the background being black.\n\nOverall, the image appears to be a representation of a signal or waveform, possibly from an oscilloscope or other electronic device. The graph shows a blue line that oscillates between two values, 3 and 1, over time, and the x-axis and y-axis are labeled to provide context for the graph.']"
eb5398e2857dbf77add8914dd9a5fb71,"Question:
How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Locked” and set 16bytes ID code to “ID Code (32 Hex Characters)” in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. Since it should be Bit127=1 and Bit126=0, FF is changed to BF as follows.
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEBFEC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEBF40

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEBF70

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. The Bit127 and Bit126 of the ID Code should be 1 and 0 each like (00112233445566778899AABBCCDDEEBF). It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking “…” button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (BFEEDDCCBBAA99887766554433221100) in which Bit127=1 and Bit126=0 as shown below.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in an RFP, even if you enter the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the RFP displays an authentication failure error.

Suitable Products
RA and FSP
How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Locked” and set 16bytes ID code to “ID Code (32 Hex Characters)” in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. Since it should be Bit127=1 and Bit126=0, FF is changed to BF as follows.
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEBFEC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEBF40

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEBF70

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. The Bit127 and Bit126 of the ID Code should be 1 and 0 each like (00112233445566778899AABBCCDDEEBF). It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking “…” button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (BFEEDDCCBBAA99887766554433221100) in which Bit127=1 and Bit126=0 as shown below.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in an RFP, even if you enter the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the RFP displays an authentication failure error.

Suitable Products
RA and FSP
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Locked” and set 16bytes ID code to “ID Code (32 Hex Characters)” in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. Since it should be Bit127=1 and Bit126=0, FF is changed to BF as follows.
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEBFEC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEBF40

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEBF70

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. The Bit127 and Bit126 of the ID Code should be 1 and 0 each like (00112233445566778899AABBCCDDEEBF). It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking “…” button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (BFEEDDCCBBAA99887766554433221100) in which Bit127=1 and Bit126=0 as shown below.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in an RFP, even if you enter the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the RFP displays an authentication failure error.
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Locked” and set 16bytes ID code to “ID Code (32 Hex Characters)” in the BSP property as shown below.
ID Code Mode
Locked
ID Code (32 Hex Characters)
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. Since it should be Bit127=1 and Bit126=0, FF is changed to BF as follows.
00112233
44556677
8899AABB
CCDDEEFF
”.
FF
B
F
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
33221100
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
77665544
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
BBAA9988
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
b
fEEDDCC
The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEBFEC
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEBFEC
00112233
44556677
8899AABB
CCDDEE
B
F
In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEBF40
S3150100A150
00112233
44556677
8899AABB
CCDDEE
B
F
40
In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEBF70
S3150100A120
00112233
44556677
8899AABB
CCDDEE
B
F
70
Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. The Bit127 and Bit126 of the ID Code should be 1 and 0 each like (00112233445566778899AABBCCDDEEBF). It shows the case of J-Link, but the same applies to the E2 and E2 Lite.
00112233445566778899AABBCCDDEEBF)
The figure below is the dialog which appears by clicking “…” button. You can also set the ID Code on this dialog.
If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:
In case of E2/E2 Lite debugger:
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.
FFFFFFFFFFFFFFFFFF45534152654C41
Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (BFEEDDCCBBAA99887766554433221100) in which Bit127=1 and Bit126=0 as shown below.
BFEEDDCCBBAA99887766554433221100
)
After creating an RFP project, set the ID code as follows.
Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in an RFP, even if you enter the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the RFP displays an authentication failure error.
414C6552415345FFFFFFFFFFFFFFFFFF
Suitable Products
RA and FSP
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/9e1e30eb623c16ce59dc27cd8fd920e5.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/e86100f13c8fed56cba07e67a271ff46.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/875ee25ef365ecd8f08139927e4cfe2f.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/935ee6d1f77d68972fce8359d5df2325.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/a9ab9d975dec7e57d59fb7929becadf7.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/dafaf34c84728dcc0c9cd8878cc41161.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/16f04dff9a4b60ed50c5e54ec6b04314.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/93a395f271ab47b1424eadb3382985ea.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/868004a5e25c3fcade36c269c0fbd8b6.png']",[],"['|  |\n|  |\n| /* ID CODE: 00112233445566778899AABBCCDDEEbf */\n#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)\n#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)\n#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)\n#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC) |', '|  |\n|  |\n| S3150101001800112233FFFFFFFF44556677FFFFFFFFFC\nS311010100288899AABBFFFFFFFFCCDDEEBFEC |', '|  |\n|  |\n| S3150100A15000112233445566778899AABBCCDDEEBF40 |', '|  |\n|  |\n| S3150100A12000112233445566778899AABBCCDDEEBF70 |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: ID code protection (in case of protection enabled with Bit127=1 and Bit126=0)', 'url': 'https://en-support.renesas.com/knowledgeBase/20980157', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:45.344081'}","Question How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case? Answer How to set the ID code In the FSP configurator, set the ID Code Mode to Locked and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below. The value of the ID code in the OSIS register In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to racfg/fspcfg/bsp/bspmcufamilycfg.h as shown below. Since it should be Bit1271 and Bit1260, FF is changed to BF as follows. / ID CODE 00112233445566778899AABBCCDDEEbf / define BSPCFGIDCODELONG1 (0x33221100) define BSPCFGIDCODELONG2 (0x77665544) define BSPCFGIDCODELONG3 (0xBBAA9988) define BSPCFGIDCODELONG4 (0xbfEEDDCC) The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register  In case of RA2L1 S3150101001800112233FFFFFFFF44556677FFFFFFFFFC S311010100288899AABBFFFFFFFFCCDDEEBFEC In case of RA6M3 S3150100A15000112233445566778899AABBCCDDEEBF40 In case of RA4E2 S3150100A12000112233445566778899AABBCCDDEEBF70 Debugger connection in e2 studio (ID code authentication) When connecting with e2 studio, set the ID code in Debugger - Connection Settings - Connection - ID Code (Bytes) as shown below. The Bit127 and Bit126 of the ID Code should be 1 and 0 each like (00112233445566778899AABBCCDDEEBF). It shows the case of J-Link, but the same applies to the E2 and E2 Lite. The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog. If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed. In case of J-Link debugger In case of E2/E2 Lite debugger Debugger connection in e2 studio (with ALeRASE execution) In case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed. Connection by RFP (with ID code authentication) If the authentication dialog is displayed when connecting in RFP, enter the ID code (BFEEDDCCBBAA99887766554433221100) in which Bit1271 and Bit1260 as shown below. After creating an RFP project, set the ID code as follows. Connection by RFP (with ALeRASE execution) If an authentication dialog is displayed when connecting in an RFP, even if you enter the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the RFP displays an authentication failure error. Suitable Products RA and FSP ID Code Mode Locked ID Code (32 Hex Characters) 00112233 44556677 8899AABB CCDDEEFF . FF B F 33221100 77665544 BBAA9988 b fEEDDCC CCDDEE S3150100A150 40 S3150100A120 70 00112233445566778899AABBCCDDEEBF) FFFFFFFFFFFFFFFFFF45534152654C41 BFEEDDCCBBAA99887766554433221100 ) 414C6552415345FFFFFFFFFFFFFFFFFF","['The image displays a table with two columns and two rows. The first row contains the text ""ID Code Mode"" in the first column and ""Locked"" in the second column. The second row contains the text ""ID Code (32 Hex Characters)"" in the first column and a series of hexadecimal characters in the second column.\n\nThe hexadecimal characters are: 00112233445566778899AABBCCDDEEFF\n\nThe background of the image is white, and the text is black. The word ""Locked"" is highlighted in yellow.', 'The image shows a screenshot of a computer program, specifically a debugging tool. The program is open on a computer screen, with a white background and black text.\n\n*   **Main Menu**\n    *   The main menu is located at the top of the screen and includes options such as ""Main"", ""Debugger"", ""Startup"", ""Source"", and ""Common"".\n    *   The ""Debugger"" option is highlighted in green, indicating that it is the current tab.\n*   **Debug Hardware**\n    *   The ""Debug hardware"" section is located below the main menu and includes options such as ""J-Link ARM"" and ""Target Device: R7FA2L1AB"".\n    *   The ""J-Link ARM"" option is selected, indicating that it is the current debug hardware.\n*   **GDB Settings**\n    *   The ""GDB Settings"" section is located below the ""Debug hardware"" section and includes options such as ""Connection Settings"" and ""Debug Tool Settings"".\n    *   The ""Connection Settings"" option is selected, indicating that it is the current setting.\n*   **Connection Settings**\n    *   The ""Connection Settings"" section includes options such as ""J-Link"", ""Interface"", ""JTAG Scan Chain"", and ""Connection"".\n    *   The ""Connection"" option is selected, indicating that it is the current setting.\n*   **Connection**\n    *   The ""Connection"" section includes options such as ""Register initialization"", ""Reset on connection"", ""Reset before run"", ""ID Code (Bytes)"", and ""Hold reset during connect"".\n    *   The ""ID Code (Bytes)"" option is highlighted in yellow, indicating that it is the current setting.\n*   **ID Code (Bytes)**\n    *   The ""ID Code (Bytes)"" section displays the ID code in bytes, which is ""00112233445566778899AABBCCDDEEBF"".\n    *   The ID code is highlighted in yellow, indicating that it is the current setting.\n\nOverall, the image shows a debugging tool with various settings and options for configuring the connection and debugging process. The highlighted options indicate the current settings, which are used to connect to the target device and perform debugging operations.', 'The image depicts a screenshot of a computer program designed to convert a hexadecimal value into a single 128-bit hex value. The program is titled ""ID Code (Bytes)"" and features a blue logo in the top-left corner.\n\n**Key Features:**\n\n*   **Input Field:** A text box at the top of the program allows users to enter a hexadecimal value.\n*   **Conversion Options:** Below the input field, there are four key options for converting the hexadecimal value:\n    *   Key 1: 33221100\n    *   Key 2: 77665544\n    *   Key 3: BBAA9988\n    *   Key 4: BFEEDDCC\n*   **Output Field:** A text box at the bottom of the program displays the converted single 128-bit hex value.\n*   **Preview Button:** A button labeled ""Preview"" allows users to view the converted value without saving it.\n\n**Program Functionality:**\n\nThe program appears to be a tool for converting hexadecimal values into a single 128-bit hex value. It provides four different key options for conversion, allowing users to choose the most suitable method for their needs. The program also includes a preview feature, enabling users to view the converted value before saving it.\n\n**Overall:**\n\nThe image shows a screenshot of a computer program designed to convert hexadecimal values into a single 128-bit hex value. The program provides four key options for conversion and includes a preview feature for viewing the converted value.', 'The image shows a screenshot of a computer error message. The message is titled ""Debug connection failed"" and has a yellow triangle with an exclamation mark inside it. Below the title, there is a paragraph of text that reads: ""Could not connect to target. Please check the GDB Server console for more information!"" \n\nBelow this, there is a list of possible causes for the error, numbered from 1 to 7. The list includes:\n\n1. Target hardware does not match debug project hardware.\n2. Not all cables are connected.\n3. Debug options do not match those required by the hardware.\n4. No external power is being applied to the target.\n5. The wrong power is being applied to the target.\n6. The emulator .dll or .so file specified in the device file could not be found.\n7. The device connected or the device specified to GDB Server does not match the device specified in the Debug Configuration.\n\nAt the bottom of the message, there is a button labeled ""OK"". The background of the message is white, with black text. There is a gray bar at the top of the image with the words ""Debug connection failed"" in it. In the top-right corner, there is a small ""X"" button. \n\nOverall, the image appears to be an error message from a debugging tool, indicating that there was a problem connecting to the target device.', 'The image shows a screenshot of an error message that appears when attempting to connect to a GDB server. The error message is displayed in a pop-up window with a yellow triangle containing an exclamation mark, indicating a fatal error.\n\n*   **Error Message:**\n    *   The error message reads: ""Error 0x00020004: Authentication failed. The emulator cannot be connected.""\n    *   This message indicates that the authentication process has failed, preventing the emulator from connecting.\n*   **Fatal Error Indicator:**\n    *   A yellow triangle with an exclamation mark is displayed next to the error message, serving as a visual indicator of the fatal error.\n*   **OK Button:**\n    *   Below the error message, there is an ""OK"" button that allows the user to dismiss the error message and continue with their task.\n*   **Background:**\n    *   The background of the error message is white, providing a clean and neutral visual environment for the error message to stand out.\n\nIn summary, the image shows a fatal error message that appears when attempting to connect to a GDB server due to authentication failure. The error message is accompanied by a yellow triangle with an exclamation mark and an ""OK"" button to dismiss the message.', 'The image displays a fatal error message from a GDB server, indicating that the ID failed to erase all flash memory by the ID for erasing all flash memory.\n\n*   The message is displayed in a pop-up window with a yellow triangle containing an exclamation mark inside it.\n*   The text of the message reads: ""Error 0x0003011D: Failed to erase all flash memory by the ID for erasing all flash memory.""\n*   There is a button labeled ""OK"" at the bottom right corner of the window.\n*   The background of the window is white, and the text is black.\n\nThe image suggests that the GDB server has encountered an error while attempting to erase all flash memory using the ID for erasing all flash memory. The error message provides a specific error code (0x0003011D) and a brief description of the problem. The presence of the ""OK"" button indicates that the user can close the error message and continue with their work.', 'The image shows a screenshot of a computer window with the title ""Authentication"" at the top left. The window has a gray background and white text.\n\n*   **Title and Logo**\n    *   The title ""Authentication"" is displayed in black text at the top left of the window.\n    *   A small yellow and gray logo is located to the left of the title.\n*   **Authentication Code**\n    *   Below the title, there is a text box labeled ""Authentication Code"" with a red line underneath it.\n    *   The text box contains a series of numbers and letters: ""BFEEDDCCGBAA99887766554433221100"".\n*   **ID Code**\n    *   To the right of the text box, there is a label that reads ""ID Code:"" in black text.\n    *   The ID code is not visible in the image.\n*   **Auto Authentication**\n    *   Below the ID code label, there is a checkbox labeled ""Auto Authentication"" with a white box next to it.\n    *   The checkbox is unchecked.\n*   **OK and Cancel Buttons**\n    *   At the bottom right of the window, there are two buttons: ""OK"" and ""Cancel"".\n    *   The ""OK"" button is highlighted in blue, indicating that it is the default action.\n*   **Window Border and Minimize/Close Buttons**\n    *   The window has a gray border around it, with a minimize button (-) and a close button (X) at the top right.\n\nIn summary, the image shows a computer window with a title ""Authentication"" and a text box for entering an authentication code. The window has a gray background and white text, with a checkbox for auto authentication and buttons for OK and Cancel. The ""OK"" button is highlighted in blue, indicating that it is the default action.', 'The image shows a screenshot of the Renesas Flash Programmer software, with the ""Connect Settings"" tab open. The purpose of this image is to provide a visual representation of the software\'s interface and highlight specific features.\n\n* A screenshot of a computer screen:\n\t+ The screenshot is in grayscale, with a white background.\n\t+ The top-left corner displays the software\'s logo and name, ""Renesas Flash Programmer V3.11.00"".\n* A menu bar with various options:\n\t+ The menu bar is located at the top of the screen.\n\t+ It includes options such as ""File"", ""Target Device"", ""Help"", and ""Operation"".\n\t+ The ""Operation"" option is highlighted in yellow, indicating that it is the current tab.\n* A list of settings for connecting to a device:\n\t+ The ""Connect Settings"" tab is open, displaying a list of settings for connecting to a device.\n\t+ The settings include ""Tool"", ""Interface"", ""Speed"", and ""Device Authentication"".\n\t+ The ""Tool"" setting is set to ""E2 emulator Lite"".\n\t+ The ""Interface"" setting is set to ""2 wire UART"".\n\t+ The ""Speed"" setting is set to ""1,000,000 bps"".\n\t+ The ""Device Authentication"" setting is set to ""Settings..."".\n* A button to connect to a device:\n\t+ A yellow button labeled ""Connect"" is located at the bottom of the screen.\n\t+ The button is highlighted in yellow, indicating that it is the current action.\n\nOverall, the image provides a clear view of the Renesas Flash Programmer software\'s interface and highlights the key features for connecting to a device. The highlighted settings and button suggest that the user is in the process of configuring the software for a specific device.', 'The image shows a screenshot of an error message on a computer screen. The error message is in red text and reads: ""Error(E0004002): Mismatch of Authentication Code."" Below this, it says: ""Disconnecting the tool"" and ""Error(E1000007): An authentication code error occurred in the device. (Command: 30. Response: DB) Operation failed.""\n\nThe background of the image is white, with a gray bar at the top that has the words ""Flash Operation"" in black text. Below this, there is a large gray button that says ""Start"" in black text. To the right of this button, there is a red button that says ""NG"" in black text.\n\nOverall, the image appears to be a screenshot of an error message that occurs when trying to flash an operation on a device. The error message indicates that there is a mismatch of authentication codes, which is preventing the operation from completing successfully.']"
786e38d1afb6627e6d13c5245a7a42a1,"How to remap the execution address of an application?
To change the start address, of the application in Code Flash, we should edit the linker script fsp.ld and create in folder Debug a new script like memory_regions.ld.
We assume that we want our application to start from address 0x0000_4000 instead of  the default address which is 0x0000_0000.
In this example we are using RA6M4. The specific MCU has Code Flash size equal to 1MB, which corresponds to FLASH_LENGTH = 0x10_0000.
FLASH_START address and FLASH_LENGTH can be found in memory_regions.ld script generated in Debug Folder of the project:
In order to change the start address of our application we should follow these steps:
1) We should go in Debug folder and create a new script called user_regions.ld, this script will now include the new start address for Code Flash memory and
the new length. The new length can be calculated like this: new_flash_length = old_flash_length – new_flash_start_address.
2) Then we should modify the linker script fsp.ld to include the new user_regions.ld instead of memory_regions.ld.
4) Next step is to go to Debug Configurations of the project, select Startup and go to Run Commands to set the Program Counter and the Initial Stack pointer registers.
5)  Perform Clean Project and then Build Project.
6) Make sure you have previously erased the code flash and then launch a debug session to load and run your application.
Press Resume twice:
And this is it, we have our application up and running from the start address we selected.
Below you will find some readings of code flash, showing that our application is starting from address 0x0000_4000 instead of 0x0000_00000.
Suitable Products
RA , FSP, e2studio","['data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/4d0ed07b3d162a9082e3747fa1a6feef.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/96022d5e30256f44099d0f8a9bf36133.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/a12fc3526b1af203aa0c63ebc2e04329.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/82b23f25d1ff272dcd3e5106184d5b1c.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/01447c0b0028633049197b1573bf1613.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/1b1c5782246eb5255555ae899fb84abc.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/e042428b3919943dda496a2b516cac55.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/f2e5c5a78325ec5888bd9807acf499bf.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/3e698a09312b11228783afe5e12f41c8.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/be90c517b5fb851c583e835bfd7b2e62.png']",[],"['|  |\n|  |\n| RA , FSP, e2studio |']","{'title': 'RA Family: How to remap execution address', 'url': 'https://en-support.renesas.com/knowledgeBase/21094312', 'last_updated': None, 'extracted_at': '2025-03-08T23:20:41.126991'}","How to remap the execution address of an application? To change the start address, of the application in Code Flash, we should edit the linker script fsp.ld and create in folder Debug a new script like memoryregions.ld. We assume that we want our application to start from address 0x00004000 instead of the default address which is 0x00000000. In this example we are using RA6M4. The specific MCU has Code Flash size equal to 1MB, which corresponds to FLASHLENGTH  0x100000. FLASHSTART address and FLASHLENGTH can be found in memoryregions.ld script generated in Debug Folder of the project In order to change the start address of our application we should follow these steps 1) We should go in Debug folder and create a new script called userregions.ld, this script will now include the new start address for Code Flash memory and the new length. The new length can be calculated like this newflashlength  oldflashlength  newflashstartaddress. 2) Then we should modify the linker script fsp.ld to include the new userregions.ld instead of memoryregions.ld. 4) Next step is to go to Debug Configurations of the project, select Startup and go to Run Commands to set the Program Counter and the Initial Stack pointer registers. 5) Perform Clean Project and then Build Project. 6) Make sure you have previously erased the code flash and then launch a debug session to load and run your application. Press Resume twice And this is it, we have our application up and running from the start address we selected. Below you will find some readings of code flash, showing that our application is starting from address 0x00004000 instead of 0x000000000. Suitable Products RA , FSP, e2studio","['The image shows a screenshot of a computer file directory, with the title ""RA6M4_NetX_ethernet"" at the top. The directory is organized into folders and files, with various icons and labels indicating their types and contents.\n\nHere are the main points of the image:\n\n*   **Title and Directory Structure**\n    *   The title ""RA6M4_NetX_ethernet"" is displayed at the top of the image.\n    *   The directory structure is organized into folders and files, with various icons and labels indicating their types and contents.\n*   **Folders and Files**\n    *   The folders and files are listed in a hierarchical structure, with subfolders and subfiles nested within each other.\n    *   The icons and labels provide information about the contents of each folder and file, such as their type, size, and modification date.\n*   **Icons and Labels**\n    *   The icons and labels are used to provide additional information about the contents of each folder and file.\n    *   The icons are used to represent different types of files and folders, such as documents, images, and videos.\n    *   The labels provide more detailed information about the contents of each folder and file, such as their name, size, and modification date.\n*   **Color Scheme**\n    *   The color scheme of the image is primarily gray, with accents of blue and green.\n    *   The gray background provides a neutral and professional-looking backdrop for the directory structure.\n    *   The blue and green accents are used to highlight important information, such as folder names and file types.\n\nOverall, the image provides a clear and organized view of a computer file directory, with easy-to-understand icons and labels that help to identify the contents of each folder and file.', 'The image shows a screenshot of a computer program in a code editor, with a list of memory regions. The code is written in C and is displayed in a monospaced font. The code is organized into sections, each with a number and a description of the memory region. The code includes variables such as ""RAM_START"", ""RAM_LENGTH"", ""FLASH_START"", ""FLASH_LENGTH"", ""DATA_FLASH_START"", ""DATA_FLASH_LENGTH"", ""OPTION_SETTING_START"", ""OPTION_SETTING_LENGTH"", ""OPTION_SETTING_S_START"", ""OPTION_SETTING_S_LENGTH"", ""ID_CODE_START"", ""ID_CODE_LENGTH"", ""SDRAM_START"", ""SDRAM_LENGTH"", ""QSPI_FLASH_START"", ""QSPI_FLASH_LENGTH"", ""QSPI_DEVICE_0_START"", ""QSPI_DEVICE_0_LENGTH"", ""QSPI_DEVICE_1_START"", ""QSPI_DEVICE_1_LENGTH"", and ""RAM_NS_BUFFER_LENGTH"". The code also includes comments and whitespace to make it easier to read and understand.\n\nOverall, the image appears to be a screenshot of a computer program that is used to manage memory regions in a microcontroller or other embedded system. The code is written in C and is organized into sections, each with a number and a description of the memory region. The code includes variables and comments to make it easier to read and understand.', 'The image shows a screenshot of a computer file directory, with the title ""RA6M4_NetX_ethernet"" at the top. The directory is organized into folders and files, with the following structure:\n\n*   **Folders:**\n    *   Binaries\n    *   Includes\n    *   ra\n    *   ra_gen\n    *   src\n    *   Debug\n    *   ra_gen\n    *   src\n    *   RA6M4_NetX_ethernet.elf - [arm/le]\n    *   makefile\n    *   makefile.init\n    *   memory_regions.ld\n    *   objects.mk\n    *   RA6M4_NetX_ethernet.elf.in\n    *   RA6M4_NetX_ethernet.map\n    *   RA6M4_NetX_ethernet.rpd\n    *   RA6M4_NetX_ethernet.sbd\n    *   RA6M4_NetX_ethernet.srec\n    *   sources.mk\n    *   ra cfg\n*   **Files:**\n    *   user_regions.ld\n\nThe directory appears to be related to a project or program, with various files and folders organized in a logical structure. The presence of files with names like ""RA6M4_NetX_ethernet.elf"" and ""memory_regions.ld"" suggests that the project is related to embedded systems or microcontrollers. The ""user_regions.ld"" file is highlighted in red, indicating that it may be a key file or a file of interest. Overall, the image provides a snapshot of a computer file directory, showcasing the organization and structure of a project or program.', 'The image shows a screenshot of a code editor with a highlighted line of code. The code is written in C++ and appears to be part of a larger program.\n\n*   The highlighted line of code is:\n    *   `FLASH_LENGTH = 0x00004000;`\n    *   This line defines a constant named `FLASH_LENGTH` and assigns it the value `0x00004000`.\n    *   The value `0x00004000` is a hexadecimal number that represents a 32-bit integer.\n    *   The comment above the line suggests that this value represents the length of a flash region in bytes.\n*   The code editor is displaying the file `memory_regions.ld` in the top-left corner.\n*   The code is written in a monospaced font and is displayed in a gray background with black text.\n*   The highlighted line of code is surrounded by a red rectangle, which makes it stand out from the rest of the code.\n*   The code appears to be part of a larger program that is managing memory regions.\n*   The use of hexadecimal numbers and the definition of a constant suggest that the program is working with low-level memory management.\n\nOverall, the image shows a specific line of code that defines a constant for the length of a flash region in bytes. The code is part of a larger program that is managing memory regions, and the highlighted line of code is likely important for understanding how the program works.', 'The image shows a screenshot of a code editor with a large block of code in the center. The code is written in C# and appears to be part of a larger program.\n\n*   The code is written in a monospaced font and is colored in shades of green, red, and black.\n*   The code is divided into several sections, each with its own set of comments and variables.\n*   The code includes several functions, including `LinkerFileForRenesasFSP` and `OPTION_SETTING_START`.\n*   The code also includes several variables, such as `XIP_SECONDARY_SLOT_IMAGE` and `OPTION_SETTING_START`.\n*   The code is surrounded by a gray border, with a white background.\n*   In the top-left corner, there is a small window with the text ""fsp.id"" in it.\n*   In the bottom-left corner, there is a small window with the text ""fsp.id | Memory | Sections | Graphical"" in it.\n\nOverall, the image appears to be a screenshot of a code editor with a large block of code in the center. The code is written in C# and includes several functions and variables. The image also includes several windows and menus, which suggest that it is a screenshot of a code editor or IDE.', 'The image shows a screenshot of a computer screen displaying a code editor with a red box highlighting the ""Debug As"" and ""Debug Configurations..."" options. \n\n*   The code editor is open on the screen, with a red box highlighting the ""Debug As"" and ""Debug Configurations..."" options.\n    *   The ""Debug As"" option is located at the top of the window, and the ""Debug Configurations..."" option is located below it.\n    *   Both options are highlighted in red, indicating that they are the focus of the image.\n*   The code editor has a white background with black text, and the red box is a bright red color that stands out against the background.\n    *   The code editor appears to be a standard coding environment, with a menu bar at the top and a text editor area below it.\n    *   The text in the code editor is not legible, but it appears to be a programming language such as C++ or Java.\n*   The overall atmosphere of the image is one of focus and attention to detail, as the red box highlights the important options for debugging code.\n    *   The image suggests that the user is working on a complex project and needs to carefully consider their debugging options.\n    *   The use of a red box to highlight the options adds a sense of urgency and importance to the image.\n\nIn summary, the image shows a code editor with a red box highlighting the ""Debug As"" and ""Debug Configurations..."" options, suggesting that the user is working on a complex project and needs to carefully consider their debugging options.', 'The image shows a screenshot of a computer program, specifically the ""Debug Configurations"" window in Visual Studio. The window is open on a Windows computer, and it appears to be a development environment for creating, managing, and running configurations for debugging purposes.\n\nHere are the key elements in the image:\n\n*   **Title Bar**\n    *   The title bar at the top of the window reads ""Debug Configurations"" in black text.\n    *   To the right of the title bar, there is a small icon of a blue square with a white bug inside it.\n*   **Menu Bar**\n    *   The menu bar is located below the title bar and contains several options, including ""File"", ""Edit"", ""View"", ""Debug"", and ""Help"".\n    *   The ""Debug"" menu is highlighted in red, indicating that it is the current menu being used.\n*   **Toolbar**\n    *   Below the menu bar, there is a toolbar with several buttons, including ""New"", ""Open"", ""Save"", ""Print"", and ""Exit"".\n    *   The ""New"" button is highlighted in red, indicating that it is the current button being used.\n*   **Workspace**\n    *   The workspace is the main area of the window where the user can interact with the program.\n    *   It contains several sections, including a list of available configurations on the left side and a detailed view of the selected configuration on the right side.\n    *   The selected configuration is highlighted in red, indicating that it is the current configuration being edited.\n*   **Configuration Details**\n    *   The configuration details section shows information about the selected configuration, including its name, type, and settings.\n    *   The name of the configuration is ""RA6M4_NetX_ethernet_Debug_Flat"".\n    *   The type of the configuration is ""Startup"".\n    *   The settings for the configuration include the load image and symbols, runtime options, and run commands.\n*   **Run Commands**\n    *   The run commands section shows the commands that will be executed when the configuration is run.\n    *   There are two commands listed: ""set Sp = *0x00004000"" and ""set Spc = *0x0004004"".\n    *   These commands appear to be setting the stack pointer and stack pointer count to specific values.\n\nOverall, the image shows a screenshot of a computer program used for debugging purposes. The program allows users to create, manage, and run configurations for debugging, and it provides a detailed view of the selected configuration\'s settings and run commands.', 'The image shows a screenshot of a computer screen displaying a code editor with a list of files and folders on the left side and a code snippet in the main window. The code snippet is written in C++ and appears to be a part of a larger program.\n\n*   **Code Editor**\n    *   The code editor is open on the right side of the screen, with a list of files and folders on the left side.\n    *   The code snippet is written in C++ and includes several lines of code, including function definitions, variable declarations, and conditional statements.\n    *   The code is highlighted in different colors, indicating different types of code, such as comments, strings, and keywords.\n*   **Files and Folders**\n    *   The list of files and folders on the left side of the screen includes several directories, such as ""RAGM4_NetX_ethernet"" and ""RAGM4_NetX_ethernet_Debu"".\n    *   Each directory contains several files, including ""Debug As"", ""Team"", ""Compare With"", and ""Restore from Local History"".\n    *   Some of the files have icons next to them, indicating their type, such as a folder icon for directories and a file icon for individual files.\n*   **Code Snippet**\n    *   The code snippet in the main window is written in C++ and includes several lines of code, including function definitions, variable declarations, and conditional statements.\n    *   The code is highlighted in different colors, indicating different types of code, such as comments, strings, and keywords.\n    *   The code appears to be part of a larger program, possibly a game or simulation, given the presence of variables such as ""RAGM4_NetX_ethernet"" and ""RAGM4_NetX_ethernet_Debu"".\n\nOverall, the image suggests that the user is working on a C++ project, possibly a game or simulation, and is using a code editor to write and edit the code. The presence of files and folders on the left side of the screen indicates that the user has organized their project into different directories and subdirectories.', 'The image shows a screenshot of a computer screen displaying a code editor with a large window open, containing lines of code in a programming language. The code is written in C# and appears to be part of a larger project.\n\n*   The code editor has a gray background and a white text box in the center, where the code is displayed.\n    *   The code is written in a monospaced font and is divided into sections by comments and whitespace.\n    *   The code includes variables, functions, and control structures, such as if-else statements and loops.\n    *   There are also several error messages and warnings displayed in the code editor, indicating potential issues with the code.\n*   The top of the screen has a menu bar with various options, including ""File"", ""Edit"", ""Source"", ""Refactor"", ""Navigate"", ""Search"", ""Project"", ""Run"", ""Window"", and ""Help"".\n    *   The ""File"" menu includes options for opening and saving files, as well as creating new projects.\n    *   The ""Edit"" menu includes options for cutting, copying, and pasting text, as well as finding and replacing text.\n    *   The ""Source"" menu includes options for managing the code editor\'s settings and preferences.\n    *   The ""Refactor"" menu includes options for renaming variables and functions, as well as reorganizing the code structure.\n    *   The ""Navigate"" menu includes options for jumping to specific parts of the code, as well as viewing the project\'s structure.\n    *   The ""Search"" menu includes options for searching for specific text within the code, as well as searching for references to specific variables and functions.\n    *   The ""Project"" menu includes options for managing the project\'s structure and dependencies.\n    *   The ""Run"" menu includes options for compiling and running the code.\n    *   The ""Window"" menu includes options for managing the code editor\'s windows and panes.\n    *   The ""Help"" menu includes options for accessing documentation and tutorials.\n*   The bottom of the screen has a status bar with information about the current file and project, as well as a progress bar indicating the completion of tasks.\n    *   The status bar also includes a button for switching between different views of the code, such as the ""Code"" view and the ""Design"" view.\n*   The overall design of the code editor is clean and intuitive, with clear labels and icons for each menu and option.\n    *   The use of a monospaced font and consistent spacing makes the code easy to read and understand.\n    *   The inclusion of error messages and warnings helps developers identify and fix issues with their code.\n\nIn summary, the image shows a screenshot of a computer screen displaying a code editor with a large window open, containing lines of code in a programming language. The code editor has a gray background and a white text box in the center, where the code is displayed. The top of the screen has a menu bar with various options, including ""File"", ""Edit"", ""Source"", ""Refactor"", ""Navigate"", ""Search"", ""Project"", ""Run"", ""Window"", and ""Help"". The bottom of the screen has a status bar with information about the current file and project, as well as a progress bar indicating the completion of tasks. The overall design of the code editor is clean and intuitive, with clear labels and icons for each menu and option.', 'The image shows a screenshot of the J-Link Commander V7.82 program, which is used to communicate with and program microcontrollers. The program displays a list of hexadecimal values in a grid format, with each row representing a different command or data packet. The values are displayed in a monospaced font, with each byte represented by a pair of hexadecimal digits.\n\nThe top-left corner of the image shows the program\'s title, ""J-Link Commander V7.82"", in a small blue font. The top-right corner shows a small icon of a link, which is likely the logo for the J-Link company.\n\nThe background of the image is a dark gray color, which helps to make the white text stand out. Overall, the image appears to be a screenshot of the J-Link Commander program in action, with a list of hexadecimal values being displayed on the screen.']"
0dd1a081bea9d7610affb979994a0449,"Some RA family MCUs have an ID Code protection function that prohibits programming via serial programming and on-chip debugging. This ID code protection function has the following four modes depending on the ID code setting. Refer to the links below for ID code authentication when connecting to the debugger and execution of the ALeRASE function in these four modes.
  ID Code ID Code Authentication
Bit127 Bit126 Bit125 - Bit0
(1)  Link  1 1 All bits are 1 Not required
(2)  Link  1 1 At least one of bit is 0 Required
(3)  Link  1 0 Don’t care Required
(4)  Link  0 x Don’t care Always failed

  ALeRASE function
e2 studio RFP
E2/E2 Lite J-Link
(1) Available Not available (*2) Not available
(2) Available Not available (*2) Available
(3) Not available Not available Not available
(4) Available (*1) Not available (*2) Not available
Note 1: Depends on MCU. Refer to the hardware user’s manual as follows.
RA2E2 (R01UH0919EJ0100):
RA4E2 (R01UH0996EJ0110):
Note 2: By using the J-Link script file in RA6M3_ALeRASE.zip uploaded on the forum, available in the article posted at the below link, users can execute ALeRASE on the J-Link commander.
RA6M1/T1: Mass-erase not performed with ID code “ALeRASE”

Suitable Products
RA and FSP
Some RA family MCUs have an ID Code protection function that prohibits programming via serial programming and on-chip debugging. This ID code protection function has the following four modes depending on the ID code setting. Refer to the links below for ID code authentication when connecting to the debugger and execution of the ALeRASE function in these four modes.
  ID Code ID Code Authentication
Bit127 Bit126 Bit125 - Bit0
(1)  Link  1 1 All bits are 1 Not required
(2)  Link  1 1 At least one of bit is 0 Required
(3)  Link  1 0 Don’t care Required
(4)  Link  0 x Don’t care Always failed

  ALeRASE function
e2 studio RFP
E2/E2 Lite J-Link
(1) Available Not available (*2) Not available
(2) Available Not available (*2) Available
(3) Not available Not available Not available
(4) Available (*1) Not available (*2) Not available
Note 1: Depends on MCU. Refer to the hardware user’s manual as follows.
RA2E2 (R01UH0919EJ0100):
RA4E2 (R01UH0996EJ0110):
Note 2: By using the J-Link script file in RA6M3_ALeRASE.zip uploaded on the forum, available in the article posted at the below link, users can execute ALeRASE on the J-Link commander.
RA6M1/T1: Mass-erase not performed with ID code “ALeRASE”

Suitable Products
RA and FSP
Some RA family MCUs have an ID Code protection function that prohibits programming via serial programming and on-chip debugging. This ID code protection function has the following four modes depending on the ID code setting. Refer to the links below for ID code authentication when connecting to the debugger and execution of the ALeRASE function in these four modes.
  ID Code ID Code Authentication
Bit127 Bit126 Bit125 - Bit0
(1)  Link  1 1 All bits are 1 Not required
(2)  Link  1 1 At least one of bit is 0 Required
(3)  Link  1 0 Don’t care Required
(4)  Link  0 x Don’t care Always failed

  ALeRASE function
e2 studio RFP
E2/E2 Lite J-Link
(1) Available Not available (*2) Not available
(2) Available Not available (*2) Available
(3) Not available Not available Not available
(4) Available (*1) Not available (*2) Not available
Note 1: Depends on MCU. Refer to the hardware user’s manual as follows.
RA2E2 (R01UH0919EJ0100):
RA4E2 (R01UH0996EJ0110):
Note 2: By using the J-Link script file in RA6M3_ALeRASE.zip uploaded on the forum, available in the article posted at the below link, users can execute ALeRASE on the J-Link commander.
RA6M1/T1: Mass-erase not performed with ID code “ALeRASE”
Some RA family MCUs have an ID Code protection function that prohibits programming via serial programming and on-chip debugging. This ID code protection function has the following four modes depending on the ID code setting. Refer to the links below for ID code authentication when connecting to the debugger and execution of the ALeRASE function in these four modes.
ID Code
ID Code Authentication
Bit127
Bit126
Bit125 - Bit0
ALeRASE function
e2 studio
RFP
E2/E2 Lite
J-Link
Note 1: Depends on MCU. Refer to the hardware user’s manual as follows.
RA2E2 (R01UH0919EJ0100):
RA4E2 (R01UH0996EJ0110):
Note 2: By using the J-Link script file in RA6M3_ALeRASE.zip uploaded on the forum, available in the article posted at the below link, users can execute ALeRASE on the J-Link commander.
Suitable Products
RA and FSP
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/0dd1a081bea9d7610affb979994a0449/images/f3fcb20ca71b749a986ad62df09e9a9c.png', 'data/categories/ra_family/rafsp_knowledge_base/0dd1a081bea9d7610affb979994a0449/images/8af16c2e63e5df68aacbd6c6b897fe8e.png']",[],"['|  |\n|  |\n|  | ID Code | ID Code Authentication |\n| Bit127 | Bit126 | Bit125 - Bit0 |\n| (1) | Link | 1 | 1 | All bits are 1 | Not required |\n| (2) | Link | 1 | 1 | At least one of bit is 0 | Required |\n| (3) | Link | 1 | 0 | Don’t care | Required |\n| (4) | Link | 0 | x | Don’t care | Always failed |', '|  |\n|  |\n|  | ALeRASE function |\n| e2 studio | RFP |\n| E2/E2 Lite | J-Link |\n| (1) | Available | Not available (*2) | Not available |\n| (2) | Available | Not available (*2) | Available |\n| (3) | Not available | Not available | Not available |\n| (4) | Available (*1) | Not available (*2) | Not available |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: ID Code protection with debugging and ALeRASE (Overview)', 'url': 'https://en-support.renesas.com/knowledgeBase/20980154', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:23.405639'}","Some RA family MCUs have an ID Code protection function that prohibits programming via serial programming and on-chip debugging. This ID code protection function has the following four modes depending on the ID code setting. Refer to the links below for ID code authentication when connecting to the debugger and execution of the ALeRASE function in these four modes. ID Code ID Code Authentication Bit127 Bit126 Bit125 - Bit0 (1) Link 1 1 All bits are 1 Not required (2) Link 1 1 At least one of bit is 0 Required (3) Link 1 0 Dont care Required (4) Link 0 x Dont care Always failed ALeRASE function e2 studio RFP E2/E2 Lite J-Link (1) Available Not available (2) Not available (2) Available Not available (2) Available (3) Not available Not available Not available (4) Available (1) Not available (2) Not available Note 1 Depends on MCU. Refer to the hardware users manual as follows. RA2E2 (R01UH0919EJ0100) RA4E2 (R01UH0996EJ0110) Note 2 By using the J-Link script file in RA6M3ALeRASE.zip uploaded on the forum, available in the article posted at the below link, users can execute ALeRASE on the J-Link commander. RA6M1/T1 Mass-erase not performed with ID code ALeRASE Suitable Products RA and FSP ID Code ID Code Authentication Bit127 Bit126 Bit125 - Bit0 ALeRASE function e2 studio RFP E2/E2 Lite J-Link","['The image presents a table with three columns and two rows, accompanied by a red box containing text. The table\'s columns are labeled ""Bit [127] = 0"", ""Protection enabled"", and ""The ID code is not checked, the ID code is always mismatching, the connection to the serial programmer or the on-chip debugger is prohibited."" The first row contains the text ""Bit [127] = 0"" in the first column, while the second row is empty.\n\nThe red box, situated to the right of the table, contains a paragraph of text that reads:\n\n""When the ID code sent from the on-chip debugger is ALeRASE in ASCII code (0x414C_6552_4153_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF_45FF', 'The image presents a table with two columns and two rows, providing information about the protection of embedded systems. The first column, labeled ""Bit [127] = 0,"" contains a single entry, which is blank. The second column, titled ""Protection embedded,"" contains a single entry that reads, ""The ID code is not checked, the ID code is always mismatching, the connection to the programmer or the on-chip debugger is prohibited, and Renesas cannot access the test mode."" This table appears to be part of a larger document or presentation discussing the security features of embedded systems.']"
1b85af70b205c9fe6c3bbe2ec5136bd0,"As we all know, an analog-to-digital converter, commonly known as ADC, refers to a device that converts an analog signal of a continuous variable into a discrete digital signal. It is mainly used for digital acquisition of analog signals for data processing. Typically, the conversion result is read when the conversion is complete. The window comparison feature in the ADC detects whether the ADC result is below or above a certain threshold, and can trigger an interrupt when the conversion result is within a certain range, with little to no software intervention. This configuration is very useful in that it monitors whether the signal is maintained within a specific range as required, or when the signal moves out of the range, as when a battery is low or overcharged.
In this article, the RA4M2 is used as an example to describe how to set up the ADC window comparison function.
RA MCUs typically include a 12-bit successive approximation A/D converter (ADC12) unit with up to 13 analog input channels, temperature sensor outputs, and internal reference voltages for conversion.
The ADC12 provides a comparison function (Window A and Window B). The comparison function specifies the upper and lower limits of the reference value for window A and window B, respectively, and the output is interrupted when the A/D conversion value of the selected channel satisfies the comparison conditions. The main differences between Window A and Window B are the difference in their interrupt output signals and the restriction that Window B can only select one channel.
This section uses window A as an example. Window A has the following 4 comparison modes.
The result is below the threshold
The result is above the threshold
The results are within the window
The results are outside the window
The registers related to the Window A comparison function are ADCMPCR, ADCMPLR0/1, and ADCMPDR0/1 registers, which can be found in the RA hardware manual for details.
The ADC data is compared to a settable high and low threshold, and a comparison break can be automatically generated for the ADC data within, outside of, high, or low within the set threshold. There are three option locations that need to be set, and we'll go through each of the property settings and user code in each case.
1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To implement the above comparison function, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example it is set to 1000.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When the AD conversion result is > ADCMPDR0 (at the time of the Lower Reference setting), a Compare interrupt is generated.
2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example 1000 is used.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
When the AD conversion result is < ADCMPDR0 (Lower Reference setting), a Compare interrupt is generated.
3. The A/D conversion result is within the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When ADCMPDR0 ( Lower Reference set) < AD conversion result < ADCMPDR1 ( Upper Reference set), a Compare interrupt is generated.
4. The A/D conversion result is outside the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
Generated when the AD conversion result < ADCMPDR0 (at the Lower Reference setting) or > ADCMPDR1 (at the Upper Reference setting). Compare is interrupted.
Also, be aware of the following limitations when using the window comparison feature:
The compare function cannot be used together with the self-diagnosis function or double-trigger mode. (The compare function is not available for ADRD, ADDBLDR, ADDBLDRA, and ADDBLDRB.)
Specify single scan mode when using match/mismatch event outputs.
When the temperature sensor output or internal reference voltage is selected for Window A, Window B operations are disabled.
When the temperature sensor output or internal reference voltage is selected for Window B, Window A operations are disabled.
Setting the same channel for Window A and Window B is prohibited.
Set the reference voltage values so that the high-potential reference voltage value is equal to or larger than the low-potential reference voltage value.
Suitable Products
RA
As we all know, an analog-to-digital converter, commonly known as ADC, refers to a device that converts an analog signal of a continuous variable into a discrete digital signal. It is mainly used for digital acquisition of analog signals for data processing. Typically, the conversion result is read when the conversion is complete. The window comparison feature in the ADC detects whether the ADC result is below or above a certain threshold, and can trigger an interrupt when the conversion result is within a certain range, with little to no software intervention. This configuration is very useful in that it monitors whether the signal is maintained within a specific range as required, or when the signal moves out of the range, as when a battery is low or overcharged.
In this article, the RA4M2 is used as an example to describe how to set up the ADC window comparison function.
RA MCUs typically include a 12-bit successive approximation A/D converter (ADC12) unit with up to 13 analog input channels, temperature sensor outputs, and internal reference voltages for conversion.
The ADC12 provides a comparison function (Window A and Window B). The comparison function specifies the upper and lower limits of the reference value for window A and window B, respectively, and the output is interrupted when the A/D conversion value of the selected channel satisfies the comparison conditions. The main differences between Window A and Window B are the difference in their interrupt output signals and the restriction that Window B can only select one channel.
This section uses window A as an example. Window A has the following 4 comparison modes.
The result is below the threshold
The result is above the threshold
The results are within the window
The results are outside the window
The registers related to the Window A comparison function are ADCMPCR, ADCMPLR0/1, and ADCMPDR0/1 registers, which can be found in the RA hardware manual for details.
The ADC data is compared to a settable high and low threshold, and a comparison break can be automatically generated for the ADC data within, outside of, high, or low within the set threshold. There are three option locations that need to be set, and we'll go through each of the property settings and user code in each case.
1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To implement the above comparison function, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example it is set to 1000.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When the AD conversion result is > ADCMPDR0 (at the time of the Lower Reference setting), a Compare interrupt is generated.
2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example 1000 is used.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
When the AD conversion result is < ADCMPDR0 (Lower Reference setting), a Compare interrupt is generated.
3. The A/D conversion result is within the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When ADCMPDR0 ( Lower Reference set) < AD conversion result < ADCMPDR1 ( Upper Reference set), a Compare interrupt is generated.
4. The A/D conversion result is outside the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
Generated when the AD conversion result < ADCMPDR0 (at the Lower Reference setting) or > ADCMPDR1 (at the Upper Reference setting). Compare is interrupted.
Also, be aware of the following limitations when using the window comparison feature:
The compare function cannot be used together with the self-diagnosis function or double-trigger mode. (The compare function is not available for ADRD, ADDBLDR, ADDBLDRA, and ADDBLDRB.)
Specify single scan mode when using match/mismatch event outputs.
When the temperature sensor output or internal reference voltage is selected for Window A, Window B operations are disabled.
When the temperature sensor output or internal reference voltage is selected for Window B, Window A operations are disabled.
Setting the same channel for Window A and Window B is prohibited.
Set the reference voltage values so that the high-potential reference voltage value is equal to or larger than the low-potential reference voltage value.
Suitable Products
RA
As we all know, an analog-to-digital converter, commonly known as ADC, refers to a device that converts an analog signal of a continuous variable into a discrete digital signal. It is mainly used for digital acquisition of analog signals for data processing. Typically, the conversion result is read when the conversion is complete. The window comparison feature in the ADC detects whether the ADC result is below or above a certain threshold, and can trigger an interrupt when the conversion result is within a certain range, with little to no software intervention. This configuration is very useful in that it monitors whether the signal is maintained within a specific range as required, or when the signal moves out of the range, as when a battery is low or overcharged.
In this article, the RA4M2 is used as an example to describe how to set up the ADC window comparison function.
RA MCUs typically include a 12-bit successive approximation A/D converter (ADC12) unit with up to 13 analog input channels, temperature sensor outputs, and internal reference voltages for conversion.
The ADC12 provides a comparison function (Window A and Window B). The comparison function specifies the upper and lower limits of the reference value for window A and window B, respectively, and the output is interrupted when the A/D conversion value of the selected channel satisfies the comparison conditions. The main differences between Window A and Window B are the difference in their interrupt output signals and the restriction that Window B can only select one channel.
This section uses window A as an example. Window A has the following 4 comparison modes.
The result is below the threshold
The result is above the threshold
The results are within the window
The results are outside the window
The registers related to the Window A comparison function are ADCMPCR, ADCMPLR0/1, and ADCMPDR0/1 registers, which can be found in the RA hardware manual for details.
The ADC data is compared to a settable high and low threshold, and a comparison break can be automatically generated for the ADC data within, outside of, high, or low within the set threshold. There are three option locations that need to be set, and we'll go through each of the property settings and user code in each case.
1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To implement the above comparison function, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example it is set to 1000.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When the AD conversion result is > ADCMPDR0 (at the time of the Lower Reference setting), a Compare interrupt is generated.
2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example 1000 is used.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
When the AD conversion result is < ADCMPDR0 (Lower Reference setting), a Compare interrupt is generated.
3. The A/D conversion result is within the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When ADCMPDR0 ( Lower Reference set) < AD conversion result < ADCMPDR1 ( Upper Reference set), a Compare interrupt is generated.
4. The A/D conversion result is outside the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
Generated when the AD conversion result < ADCMPDR0 (at the Lower Reference setting) or > ADCMPDR1 (at the Upper Reference setting). Compare is interrupted.
Also, be aware of the following limitations when using the window comparison feature:
The compare function cannot be used together with the self-diagnosis function or double-trigger mode. (The compare function is not available for ADRD, ADDBLDR, ADDBLDRA, and ADDBLDRB.)
Specify single scan mode when using match/mismatch event outputs.
When the temperature sensor output or internal reference voltage is selected for Window A, Window B operations are disabled.
When the temperature sensor output or internal reference voltage is selected for Window B, Window A operations are disabled.
Setting the same channel for Window A and Window B is prohibited.
Set the reference voltage values so that the high-potential reference voltage value is equal to or larger than the low-potential reference voltage value.
Suitable Products
As we all know, an analog-to-digital converter, commonly known as ADC, refers to a device that converts an analog signal of a continuous variable into a discrete digital signal. It is mainly used for digital acquisition of analog signals for data processing. Typically, the conversion result is read when the conversion is complete. The window comparison feature in the ADC detects whether the ADC result is below or above a certain threshold, and can trigger an interrupt when the conversion result is within a certain range, with little to no software intervention. This configuration is very useful in that it monitors whether the signal is maintained within a specific range as required, or when the signal moves out of the range, as when a battery is low or overcharged.
In this article, the RA4M2 is used as an example to describe how to set up the ADC window comparison function.
RA MCUs typically include a 12-bit successive approximation A/D converter (ADC12) unit with up to 13 analog input channels, temperature sensor outputs, and internal reference voltages for conversion.
The ADC12 provides a comparison function (Window A and Window B). The comparison function specifies the upper and lower limits of the reference value for window A and window B, respectively, and the output is interrupted when the A/D conversion value of the selected channel satisfies the comparison conditions. The main differences between Window A and Window B are the difference in their interrupt output signals and the restriction that Window B can only select one channel.
This section uses window A as an example. Window A has the following 4 comparison modes.
The registers related to the Window A comparison function are ADCMPCR, ADCMPLR0/1, and ADCMPDR0/1 registers, which can be found in the RA hardware manual for details.
The ADC data is compared to a settable high and low threshold, and a comparison break can be automatically generated for the ADC data within, outside of, high, or low within the set threshold. There are three option locations that need to be set, and we'll go through each of the property settings and user code in each case.
1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To implement the above comparison function, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example it is set to 1000.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When the AD conversion result is > ADCMPDR0 (at the time of the Lower Reference setting), a Compare interrupt is generated.
2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example 1000 is used.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
When the AD conversion result is < ADCMPDR0 (Lower Reference setting), a Compare interrupt is generated.
3. The A/D conversion result is within the threshold
3. The A/D conversion result is within the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When ADCMPDR0 ( Lower Reference set) < AD conversion result < ADCMPDR1 ( Upper Reference set), a Compare interrupt is generated.
4. The A/D conversion result is outside the threshold
4. The A/D conversion result is outside the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
Generated when the AD conversion result < ADCMPDR0 (at the Lower Reference setting) or > ADCMPDR1 (at the Upper Reference setting). Compare is interrupted.
Also, be aware of the following limitations when using the window comparison feature:
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/d87addccaa64a37b2de1b6ce35a3fc20.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/85076eaadd05b2b85cdb03413febc1d6.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/8243f5f1f0b45b6a9aa66e32c0eff26a.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/aefd2391f61244eb09509f4a4f4c9f3e.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/b88da847a54e7310acd325b21115ce0c.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/2a172554f5487ca05f21c1b7fdd9b64b.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/d785d3abb43924fe5f041421faf1ffc2.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/136e2ee1647946c3071f78d47c4f536c.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/17ec2fd2cc4932adbbc491c130f8e81b.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/96e783e0d56bae3cc97e3e8efc927d13.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/4823cb8007478edb2932ebcab0aae23f.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/e1b2d46a0a7d7beeca2bd441a936ec05.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/a7bb5592d458bf25484228a4747be724.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'How to use the ADC window comparison feature in an RA MCU', 'url': 'https://en-support.renesas.com/knowledgeBase/21397542', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:35.642159'}","As we all know, an analog-to-digital converter, commonly known as ADC, refers to a device that converts an analog signal of a continuous variable into a discrete digital signal. It is mainly used for digital acquisition of analog signals for data processing. Typically, the conversion result is read when the conversion is complete. The window comparison feature in the ADC detects whether the ADC result is below or above a certain threshold, and can trigger an interrupt when the conversion result is within a certain range, with little to no software intervention. This configuration is very useful in that it monitors whether the signal is maintained within a specific range as required, or when the signal moves out of the range, as when a battery is low or overcharged. In this article, the RA4M2 is used as an example to describe how to set up the ADC window comparison function. RA MCUs typically include a 12-bit successive approximation A/D converter (ADC12) unit with up to 13 analog input channels, temperature sensor outputs, and internal reference voltages for conversion. The ADC12 provides a comparison function (Window A and Window B). The comparison function specifies the upper and lower limits of the reference value for window A and window B, respectively, and the output is interrupted when the A/D conversion value of the selected channel satisfies the comparison conditions. The main differences between Window A and Window B are the difference in their interrupt output signals and the restriction that Window B can only select one channel. This section uses window A as an example. Window A has the following 4 comparison modes. The result is below the threshold The result is above the threshold The results are within the window The results are outside the window The registers related to the Window A comparison function are ADCMPCR, ADCMPLR0/1, and ADCMPDR0/1 registers, which can be found in the RA hardware manual for details. The ADC data is compared to a settable high and low threshold, and a comparison break can be automatically generated for the ADC data within, outside of, high, or low within the set threshold. There are three option locations that need to be set, and we'll go through each of the property settings and user code in each case. 1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120CMPAI) is generated To implement the above comparison function, set the ADC properties in the FSP as shown in the figure below. (1) Input - Window Compare - Window A Enable Enabled Lower Reference Set the threshold here- in this example it is set to 1000. (2) Input - Window Compare Window Mode Disabled (3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below. RADC0-ADCMPLRb-CMPLCHA0  1; When the AD conversion result is  ADCMPDR0 (at the time of the Lower Reference setting), a Compare interrupt is generated. 2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120CMPAI) is generated To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below. Lower Reference Set the threshold here- in this example 1000 is used. (3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below. RADC0-ADCMPLRb-CMPLCHA0  0; When the AD conversion result is  ADCMPDR0 (Lower Reference setting), a Compare interrupt is generated. 3. The A/D conversion result is within the threshold Lower Reference, Upper Reference Set the threshold here- in this example 1000 and 3000 are used. Window Mode Enabled When ADCMPDR0 ( Lower Reference set)  AD conversion result  ADCMPDR1 ( Upper Reference set), a Compare interrupt is generated. 4. The A/D conversion result is outside the threshold Generated when the AD conversion result  ADCMPDR0 (at the Lower Reference setting) or  ADCMPDR1 (at the Upper Reference setting). Compare is interrupted. Also, be aware of the following limitations when using the window comparison feature The compare function cannot be used together with the self-diagnosis function or double-trigger mode. (The compare function is not available for ADRD, ADDBLDR, ADDBLDRA, and ADDBLDRB.) Specify single scan mode when using match/mismatch event outputs. When the temperature sensor output or internal reference voltage is selected for Window A, Window B operations are disabled. When the temperature sensor output or internal reference voltage is selected for Window B, Window A operations are disabled. Setting the same channel for Window A and Window B is prohibited. Set the reference voltage values so that the high-potential reference voltage value is equal to or larger than the low-potential reference voltage value. Suitable Products RA","['The image shows a table with the title ""ADCMPCR: A/D Compare Function Control Register"" at the top. The table has 15 columns and 7 rows, with the first row being the header row. The columns are labeled as follows:\n\n* Bit\n* Symbol\n* Function\n\nThe first column lists the bit position, ranging from 15 to 0. The second column lists the symbol for each bit, such as CMPAIE and CMPBIE. The third column describes the function of each bit, including the comparison conditions and the enable/disable status of the compare function.\n\nThe table appears to be a technical document or datasheet for a microcontroller or other digital circuit, providing information on the configuration and operation of the ADCMPCR register. The use of technical terms and abbreviations suggests that the document is intended for an audience with a strong background in electronics and computer science.\n\nOverall, the image provides a detailed and technical description of the ADCMPCR register and its functions, which would be useful for engineers and developers working with microcontrollers or other digital circuits.', 'The image displays a table with the title ""ADCMPLR0 : A/D Compare Function Window A Comparison Condition Setting"" at the top. The table is divided into four columns: ""Bit"", ""Symbol"", ""Function"", and ""R/W"". The ""Bit"" column lists the bit positions from 15 to 0, while the ""Symbol"" column provides the corresponding symbols for each bit position. The ""Function"" column describes the function of each bit position, and the ""R/W"" column indicates whether the bit is readable (R) or writable (W).\n\nThe table also includes a section at the bottom that provides additional information about the ADCMPLR0 register. This section includes a description of the register\'s purpose, its location in the ADC120 chip, and its offset address.\n\nOverall, the image appears to be a technical document or datasheet for the ADCMPLR0 register in the ADC120 chip. It provides detailed information about the register\'s structure, function, and usage, which would be useful for engineers or developers working with this chip.', 'The image displays a table with the title ""ADCMPLR1 : A/D Compare Function Window A Comparison Condition Setting Register 1"". The table has 3 columns and 16 rows, with the first column labeled ""Bit position:"", the second column labeled ""CMPL CHA3"", and the third column labeled ""CMPL CHA2"". The table is filled with numbers, with some cells containing ""0"" and others containing ""1"".\n\nThe table appears to be a binary representation of a register, with each row representing a bit position in the register. The ""Bit position:"" column lists the bit positions, ranging from 15 to 0. The ""CMPL CHA3"" and ""CMPL CHA2"" columns list the values for each bit position, with ""0"" indicating a clear bit and ""1"" indicating a set bit.\n\nThe table also includes a ""Base address:"" field at the top, which reads ""ADC120 = 0x4017_0000"". Additionally, there is an ""Offset address:"" field, which reads ""0x09A"".\n\nOverall, the image appears to be a technical diagram or table used to represent and compare the values of a register in a digital system.', 'The image displays a table with three columns: ""Bit"", ""Symbol"", and ""Function"". The first row contains the values ""15:0"", ""CMPLCHAn"", and ""Compare Window A Comparison Condition Select"". The second row explains that these bits set comparison conditions for channels to which Window A comparison conditions are applied. The third row provides a detailed explanation of the comparison conditions, including the values of ADCMPDR0 and ADCMPDR1, and the enabled or disabled state of the window function. The fourth row shows the comparison conditions for Bit 15 (CMPLCHA31) and Bit 0 (CMPLCHA16), which are associated with AN031 and AN016, respectively. The fifth row provides a comparison of the conditions shown in Figure 37.3. The sixth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The seventh row provides a comparison of the conditions shown in Figure 37.3. The eighth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The ninth row provides a comparison of the conditions shown in Figure 37.3. The tenth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The eleventh row provides a comparison of the conditions shown in Figure 37.3. The twelfth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The thirteenth row provides a comparison of the conditions shown in Figure 37.3. The fourteenth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The fifteenth row provides a comparison of the conditions shown in Figure 37.3. The sixteenth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The seventeenth row provides a comparison of the conditions shown in Figure 37.3. The eighteenth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The nineteenth row provides a comparison of the conditions shown in Figure 37.3. The twentieth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The twenty-first row provides a comparison of the conditions shown in Figure 37.3. The twenty-second row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The twenty-third row provides a comparison of the conditions shown in Figure 37.3. The twenty-fourth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The twenty-fifth row provides a comparison of the conditions shown in Figure 37.3. The twenty-sixth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The twenty-seventh row provides a comparison of the conditions shown in Figure 37.3. The twenty-eighth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The twenty-ninth row provides a comparison of the conditions shown in Figure 37.3. The thirtieth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The thirty-first row provides a comparison of the conditions shown in Figure 37.3. The thirty-second row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The thirty-third row provides a comparison of the conditions shown in Figure 37.3. The thirty-fourth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The thirty-fifth row provides a comparison of the conditions shown in Figure 37.3. The thirty-sixth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The thirty-seventh row provides a comparison of the conditions shown in Figure 37.3. The thirty-eighth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The thirty-ninth row provides a comparison of the conditions shown in Figure 37.3. The fortieth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The forty-first row provides a comparison of the conditions shown in Figure 37.3. The forty-second row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The forty-third row provides a comparison of the conditions shown in Figure 37.3. The forty-fourth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The forty-fifth row provides a comparison of the conditions shown in Figure 37.3. The forty-sixth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The forty-seventh row provides a comparison of the conditions shown in Figure 37.3. The forty-eighth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The forty-ninth row provides a comparison of the conditions shown in Figure 37.3. The fiftieth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The fifty-first row provides a comparison of the conditions shown in Figure 37.3. The fifty-second row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The fifty-third row provides a comparison of the conditions shown in Figure 37.3. The fifty-fourth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The fifty-fifth row provides a comparison of the conditions shown in Figure 37.3. The fifty-sixth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The fifty-seventh row provides a comparison of the conditions shown in Figure 37.3. The fifty-eighth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The fifty-ninth row provides a comparison of the conditions shown in Figure 37.3. The sixtieth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The sixty-first row provides a comparison of the conditions shown in Figure 37.3. The sixty-second row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The sixty-third row provides a comparison of the conditions shown in Figure 37.3. The sixty-fourth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The sixty-fifth row provides a comparison of the conditions shown in Figure 37.3. The sixty-sixth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The sixty-seventh row provides a comparison of the conditions shown in Figure 37.3. The sixty-eighth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The sixty-ninth row provides a comparison of the conditions shown in Figure 37.3. The seventieth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The seventy-first row provides a comparison of the conditions shown in Figure 37.3. The seventy-second row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The seventy-third row provides a comparison of the conditions shown in Figure 37.3. The seventy-fourth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The seventy-fifth row provides a comparison of the conditions shown in Figure 37.3. The seventy-sixth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The seventy-seventh row provides a comparison of the conditions shown in Figure 37.3. The seventy-eighth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The seventy-ninth row provides a comparison of the conditions shown in Figure 37.3. The eightieth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The eighty-first row provides a comparison of the conditions shown in Figure 37.3. The eighty-second row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The eighty-third row provides a comparison of the conditions shown in Figure 37.3. The eighty-fourth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The eighty-fifth row provides a comparison of the conditions shown in Figure 37.3. The eighty-sixth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The eighty-seventh row provides a comparison of the conditions shown in Figure 37.3. The eighty-eighth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The eighty-ninth row provides a comparison of the conditions shown in Figure 37.3. The ninetieth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The ninety-first row provides a comparison of the conditions shown in Figure 37.3. The ninety-second row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The ninety-third row provides a comparison of the conditions shown in Figure 37.3. The ninety-fourth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The ninety-fifth row provides a comparison of the conditions shown in Figure 37.3. The ninety-sixth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The ninety-seventh row provides a comparison of the conditions shown in Figure 37.3. The ninety-eighth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The ninety-ninth row provides a comparison of the conditions shown in Figure 37.3. The hundredth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-first row provides a comparison of the conditions shown in Figure 37.3. The hundred-and-second row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-third row provides a comparison of the conditions shown in Figure 37.3. The hundred-and-fourth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-fifth row provides a comparison of the conditions shown in Figure 37.3. The hundred-and-sixth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-seventh row provides a comparison of the conditions shown in Figure 37.3. The hundred-and-eighth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-ninth row provides a comparison of the conditions shown in Figure 37.3. The hundred-and-tenth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-eleventh row provides a comparison of the conditions shown in Figure 37.3. The hundred-and-twelfth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-thirteenth row provides a comparison of the conditions shown in Figure 37.3. The hundred-and-fourteenth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-fifteenth row provides a comparison of the conditions shown in Figure 37.3. The hundred-and-sixteenth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-seventeenth row provides a comparison of the conditions shown in Figure 37.3. The hundred-and-eighteenth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-nineteenth row provides a comparison of the conditions shown in Figure 37.3. The hundred-and-twentieth row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-twenty-first row provides a comparison of the conditions shown in Figure 37.3. The hundred-and-twenty-second row explains that when the window function is disabled, ADCMPDR0 and ADCMPDR1 have specific values, and when the window function is enabled, ADCMPDR0 and ADCMPDR1 have different values. The hundred-and-twenty-third row provides a comparison of the conditions shown in Figure 37.3', ""The image presents a technical diagram for an ADCMPDRn: A/D Compare Function Window A Lower-Side/Upper-Side Level Setting Register (n = 0, 1). The diagram is divided into two main sections: the top section provides information about the register, while the bottom section displays the register's bit positions and their corresponding values.\n\n**Top Section:**\n\n*   **37.2.28**: This is likely a version number or identifier for the document or software.\n*   **ADCMPDRn: A/D Compare Function Window A Lower-Side/Upper-Side Level Setting Register (n = 0, 1)**: This is the title of the diagram, indicating that it describes a specific register used in an Analog-to-Digital (A/D) converter or a similar electronic component.\n\n**Bottom Section:**\n\n*   **Base address:** **ADC120 = 0x4017_0000**: This line specifies the base address of the register in hexadecimal format. The base address is a unique identifier for the register within the system's memory map.\n*   **Offset address:** **0x09C + (0x2 x n)**: This line calculates the offset address of the register based on the value of 'n'. The offset address is used to determine the actual memory location of the register within the system's memory map.\n*   **Bit position:** **15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0**: This line lists the bit positions of the register, ranging from 0 to 15. Each bit position corresponds to a specific binary value (0 or 1).\n*   **Bit field:** **Value after reset:** **0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0**: This line shows the default or reset values of each bit position in the register. All bits are set to 0, indicating that the register is in its default state after a system reset.\n\nIn summary, the image provides detailed information about an ADCMPDRn: A/D Compare Function Window A Lower-Side/Upper-Side Level Setting Register, including its base address, offset address, bit positions, and default values. This information is crucial for software developers and hardware engineers working with A/D converters or similar electronic components."", 'The image presents a flowchart illustrating the process of determining whether the ADCMPDR0 value is less than or greater than the A/D converted value. The flowchart consists of two boxes, each containing a condition and an action.\n\n*   **First Box:**\n    *   Condition: ADCMPDR0 value < A/D converted value\n    *   Action: Met\n*   **Second Box:**\n    *   Condition: ADCMPDR0 value ≥ A/D converted value\n    *   Action: Not met\n\nThe flowchart is designed to guide the user through a step-by-step process, allowing them to determine the outcome based on the comparison between the ADCMPDR0 value and the A/D converted value.', 'The image shows a screenshot of a computer program\'s settings menu, specifically the ""Window Compare"" section. The menu is organized into two columns: ""Property"" and ""Value"". The ""Property"" column lists various settings, while the ""Value"" column displays the corresponding values for each setting.\n\nThe settings listed in the ""Property"" column include:\n\n* Window A\n* Channel comparison mode (channel availability varies by MCU and unit)\n* Enable\n* Lower Reference\n* Upper Reference\n* Window B\n* Window Mode\n* Event Output\n* Add/Average Count\n* Reference Voltage control\n* Interrupts\n* Normal/Group A Trigger\n* Group B Trigger\n* Group Priority (Valid only in Group Scan Mode)\n* Callback\n* Scan End Interrupt Priority\n* Scan End Group B Interrupt Priority\n* Window Compare A Interrupt Priority\n* Window Compare B Interrupt Priority\n\nThe values for each setting are displayed in the ""Value"" column. For example, the ""Enable"" setting has a value of ""Enabled"", while the ""Lower Reference"" setting has a value of ""1000"". The ""Upper Reference"" setting has a value of ""3000"", and the ""Window B"" setting has a value of ""Disabled"".\n\nOverall, the image suggests that the user is configuring the settings for a specific application or device, likely related to data acquisition or measurement. The settings appear to be related to the comparison of data between two windows, with options for enabling or disabling certain features and adjusting reference values.', 'The image presents a table with two rows and two columns, providing information about the comparison conditions when the window function is disabled. The table is titled ""Comparison conditions when the window function is disabled"" and has a subtitle ""CMPLCHAn = 0"".\n\n*   **Row 1:**\n    *   **Column 1:** ADCMPDR0 value ≤ A/D converted value\n    *   **Column 2:** Not met\n*   **Row 2:**\n    *   **Column 1:** ADCMPDR0 value > A/D converted value\n    *   **Column 2:** Met\n\nThe table indicates that if the ADCMPDR0 value is less than or equal to the A/D converted value, the condition is not met. Conversely, if the ADCMPDR0 value is greater than the A/D converted value, the condition is met.', 'The image shows a screenshot of a computer program\'s settings menu, specifically the ""g_adc0 ADC (r_adc)"" section. The menu is organized into two columns: ""Property"" and ""Value"". The ""Property"" column lists various settings, such as ""Window Compare"", ""Enable"", ""Lower Reference"", ""Upper Reference"", ""Window B"", ""Window Mode"", ""Event Output"", ""Add/Average Count"", ""Reference Voltage control"", and ""Interrupts"". The ""Value"" column displays the corresponding values for each setting.\n\nThe settings are color-coded, with green indicating enabled settings, red indicating disabled settings, and black indicating other settings. The background of the menu is white, with a light blue bar at the top that contains the title ""Settings"" and the ""API Info"" tab.\n\nOverall, the image provides a clear and organized view of the settings menu, allowing users to easily navigate and adjust the various parameters.', 'The image presents a table with three rows and two columns, providing information about the ADCMPDR1 and ADCMPDR0 values. The table is divided into two sections: the left column lists the ADCMPDR1 and ADCMPDR0 values, while the right column indicates whether these values are met or not.\n\n*   **ADCMPDR1 value ≤ A/D converted value**\n    *   ADCMPDR1 value ≤ A/D converted value\n    *   Not met\n*   **ADCMPDR0 value < A/D converted value < ADCMPDR1 value**\n    *   ADCMPDR0 value < A/D converted value < ADCMPDR1 value\n    *   Met\n*   **A/D converted value ≤ ADCMPDR0 value**\n    *   A/D converted value ≤ ADCMPDR0 value\n    *   Not met\n\nThe table provides a clear comparison between the ADCMPDR1 and ADCMPDR0 values and the A/D converted value, indicating whether these values are met or not.', 'The image shows a screenshot of a computer program\'s settings menu, specifically the ""g_adc0 ADC (r_adc)"" section. The menu is organized into two columns: ""Property"" and ""Value"". The ""Property"" column lists various settings, while the ""Value"" column displays the corresponding values for each setting.\n\nThe settings include:\n\n* Window Compare\n* Window A\n* Channel comparison mode\n* Enable\n* Lower Reference\n* Upper Reference\n* Window B\n* Event Output\n* Add/Average Count\n* Reference Voltage control\n* Interrupts\n* Normal/Group A Trigger\n* Group B Trigger\n* Group Priority (Valid only in Group Scan Mode)\n* Callback\n* Scan End Interrupt Priority\n* Scan End Group B Interrupt Priority\n* Window Compare A Interrupt Priority\n* Window Compare B Interrupt Priority\n\nEach setting has a corresponding value, which is displayed in the ""Value"" column. Some of the values are enabled or disabled, while others have specific numerical values.\n\nOverall, the image suggests that the user is configuring the settings for an ADC (Analog-to-Digital Converter) device, which is used to convert analog signals into digital data. The settings appear to be related to the device\'s operation, such as the window compare mode, channel comparison mode, and interrupt priorities.', 'The image presents a table comparing the conditions when the window function is enabled, specifically focusing on the CMPLCHAn = 0 scenario. The table is divided into three rows, each representing a distinct condition, and two columns that outline the corresponding ADCMPDR1 and ADCMPDR0 values.\n\n*   **Row 1: ADCMPDR1 value < A/D converted value**\n    *   ADCMPDR1 value: Less than the A/D converted value\n    *   ADCMPDR0 value: Not met\n*   **Row 2: ADCMPDR0 value ≤ A/D converted value ≤ ADCMPDR1 value**\n    *   ADCMPDR0 value: Less than or equal to the A/D converted value\n    *   ADCMPDR1 value: Less than or equal to the A/D converted value\n*   **Row 3: A/D converted value < ADCMPDR0 value**\n    *   A/D converted value: Less than the ADCMPDR0 value\n    *   ADCMPDR0 value: Met\n\nIn summary, the table provides a clear comparison of the conditions under which the window function is enabled, highlighting the specific ADCMPDR1 and ADCMPDR0 values that meet or do not meet the criteria for each condition.', 'The image shows a screenshot of a computer program\'s settings page, specifically the ""g_adc0 ADC (r_adc)"" section. The page is divided into two columns: ""Property"" and ""Value"". The ""Property"" column lists various settings, while the ""Value"" column displays the corresponding values for each setting.\n\nThe settings include:\n\n* Window Compare\n* Window A\n* Channel comparison mode\n* Enable\n* Lower Reference\n* Upper Reference\n* Window B\n* Event Output\n* Add/Average Count\n* Reference Voltage control\n* Interrupts\n* Normal/Group A Trigger\n* Group B Trigger\n* Group Priority (Valid only in Group Scan Mode)\n* Callback\n* Scan End Interrupt Priority\n* Scan End Group B Interrupt Priority\n* Window Compare A Interrupt Priority\n* Window Compare B Interrupt Priority\n\nEach setting has a corresponding value, which is displayed in the ""Value"" column. The values are either numerical or text-based, depending on the type of setting.\n\nOverall, the image provides a detailed view of the settings available for the ""g_adc0 ADC (r_adc)"" section of the computer program. It allows users to adjust various parameters to customize the behavior of the program.']"
13bbd2bddf0c6487f0d4b74e6915ba3d,"Question:
rand function of the C runtime library does not work 
Answer:
To use the rand() function of the C runtime library with newlib and the GCC toolchain, you need to specify some heap memory in the BSP tab of the configurator. At least 32 bytes of heap memory is required (in case of GCC v10.3.1).
  Suitable Products
RA and FSP
rand function of the C runtime library does not work
rand function of the C runtime library does not work
Answer:
To use the rand() function of the C runtime library with newlib and the GCC toolchain, you need to specify some heap memory in the BSP tab of the configurator. At least 32 bytes of heap memory is required (in case of GCC v10.3.1).
  Suitable Products
RA and FSP
To use the rand() function of the C runtime library with newlib and the GCC toolchain, you need to specify some heap memory in the BSP tab of the configurator. At least 32 bytes of heap memory is required (in case of GCC v10.3.1).
  Suitable Products
RA and FSP
To use the rand() function of the C runtime library with newlib and the GCC toolchain, you need to specify some heap memory in the BSP tab of the configurator. At least 32 bytes of heap memory is required (in case of GCC v10.3.1).
Suitable Products
RA and FSP
Go to Japanese
Go to Japanese",['data/categories/ra_family/rafsp_knowledge_base/13bbd2bddf0c6487f0d4b74e6915ba3d/images/6e2bade922c0494e97ecffd3d021648f.png'],[],['|  |\n|  |\n| RA and FSP |'],"{'title': 'RA Family: rand function of the C runtime library does not work', 'url': 'https://en-support.renesas.com/knowledgeBase/20797533', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:48.168732'}","Question rand function of the C runtime library does not work Answer To use the rand() function of the C runtime library with newlib and the GCC toolchain, you need to specify some heap memory in the BSP tab of the configurator. At least 32 bytes of heap memory is required (in case of GCC v10.3.1). Suitable Products RA and FSP rand function of the C runtime library does not work Suitable Products Go to Japanese","['The image shows a screenshot of a computer program, specifically a settings window for a BSP (Board Support Package). The window is titled ""Properties"" and has a blue bar at the top with the word ""Properties"" in white text. Below this, there are several tabs, including ""Summary"", ""Clocks"", ""Pins"", ""Interrupts"", ""Event Links"", ""Stacks"", and ""Components"".\n\nThe main content of the window is a table with two columns: ""Settings"" and ""Value"". The ""Settings"" column lists various properties that can be adjusted, such as ""RA Common"", ""Main stack size (bytes)"", ""Heap size (bytes)"", ""MCU Vcc (mV)"", ""Parameter checking"", ""Assert Failures"", ""Error Log"", and ""No Error Log"". The ""Value"" column shows the current values for each of these properties.\n\nIn the ""RA Common"" row, the value is set to ""0x400"". In the ""Main stack size (bytes)"" row, the value is set to ""0x20"". In the ""Heap size (bytes)"" row, the value is set to ""3300"". In the ""MCU Vcc (mV)"" row, the value is set to ""Disabled"". In the ""Parameter checking"" row, the value is set to ""Return FSP_ERR_ASSERTION"". In the ""Assert Failures"" row, the value is set to ""No Error Log"".\n\nOverall, the image suggests that the user is configuring the settings for a BSP, which is likely used for developing or testing embedded systems. The specific values set in the table will depend on the requirements of the project or application being worked on.']"
d6dec3c07b526ecc237a5c7f026ce410,"Question:
How to Debug Code from a Specified Address in Renesas RA MCUs - Keil
Answer:
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use Keil as an example.
1. Linker script file (code writing phase).
Modify the linker script, taking the memory_regions.scat file as an example. Change theFLASH_START value and seen below. The basic offset address is 0 by default when the code is compiled, and it is changed to the target offset address of the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000.
2. Debug Configuration Settings (Code Debugging Phase)
In Keil settings, first change the Linker > R/O Base to 0x4000.
Save the following as a *.ini file (for example, app_0x4000.ini) and place it in the script folder in the Project directory.

FUNC void Setup (void)
{
    SP = _RDWORD(0x00004000);           // Setup Stack Pointer
    PC = _RDWORD(0x00004004);           // Setup Program Counter
    _WDWORD(0xE000ED08, 0x00004000);    // Setup Vector Table Offset Register
}

LOAD Objects\RA4M2_TE_app.axf INCREMENTAL   // Download
Setup();                                    // Setup for Running
  Point to the *.ini file in the following image.
The debugging effect is shown in the following figure, and when the code jumps to the main() function, the address is at 0x4b7c.
 Suitable Products
RA
How to Debug Code from a Specified Address in Renesas RA MCUs - Keil
How to Debug Code from a Specified Address in Renesas RA MCUs - Keil
Answer:
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use Keil as an example.
1. Linker script file (code writing phase).
Modify the linker script, taking the memory_regions.scat file as an example. Change theFLASH_START value and seen below. The basic offset address is 0 by default when the code is compiled, and it is changed to the target offset address of the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000.
2. Debug Configuration Settings (Code Debugging Phase)
In Keil settings, first change the Linker > R/O Base to 0x4000.
Save the following as a *.ini file (for example, app_0x4000.ini) and place it in the script folder in the Project directory.

FUNC void Setup (void)
{
    SP = _RDWORD(0x00004000);           // Setup Stack Pointer
    PC = _RDWORD(0x00004004);           // Setup Program Counter
    _WDWORD(0xE000ED08, 0x00004000);    // Setup Vector Table Offset Register
}

LOAD Objects\RA4M2_TE_app.axf INCREMENTAL   // Download
Setup();                                    // Setup for Running
  Point to the *.ini file in the following image.
The debugging effect is shown in the following figure, and when the code jumps to the main() function, the address is at 0x4b7c.
 Suitable Products
RA
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use Keil as an example.
1. Linker script file (code writing phase).
Modify the linker script, taking the memory_regions.scat file as an example. Change theFLASH_START value and seen below. The basic offset address is 0 by default when the code is compiled, and it is changed to the target offset address of the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000.
2. Debug Configuration Settings (Code Debugging Phase)
In Keil settings, first change the Linker > R/O Base to 0x4000.
Save the following as a *.ini file (for example, app_0x4000.ini) and place it in the script folder in the Project directory.
FUNC void Setup (void)
{
    SP = _RDWORD(0x00004000);           // Setup Stack Pointer
    PC = _RDWORD(0x00004004);           // Setup Program Counter
    _WDWORD(0xE000ED08, 0x00004000);    // Setup Vector Table Offset Register
}

LOAD Objects\RA4M2_TE_app.axf INCREMENTAL   // Download
Setup();                                    // Setup for Running
Point to the *.ini file in the following image.
The debugging effect is shown in the following figure, and when the code jumps to the main() function, the address is at 0x4b7c.
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/d6dec3c07b526ecc237a5c7f026ce410/images/d521c0dfda3c12a355932ae5458780b8.png', 'data/categories/ra_family/rafsp_knowledge_base/d6dec3c07b526ecc237a5c7f026ce410/images/19ef5e588bdf6c0bf87980e87232cfd1.png', 'data/categories/ra_family/rafsp_knowledge_base/d6dec3c07b526ecc237a5c7f026ce410/images/09c1ba968000ac056e1655fd056a269b.png', 'data/categories/ra_family/rafsp_knowledge_base/d6dec3c07b526ecc237a5c7f026ce410/images/8f79736b75ed2293a93c3e8e3f0121d8.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'How to Debug Code from a Specified Address in Renesas RA MCUs - Keil', 'url': 'https://en-support.renesas.com/knowledgeBase/21172752', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:01.942895'}","Question How to Debug Code from a Specified Address in Renesas RA MCUs - Keil Answer For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged. To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use Keil as an example. 1. Linker script file (code writing phase). Modify the linker script, taking the memoryregions.scat file as an example. Change theFLASHSTART value and seen below. The basic offset address is 0 by default when the code is compiled, and it is changed to the target offset address of the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000. 2. Debug Configuration Settings (Code Debugging Phase) In Keil settings, first change the Linker  R/O Base to 0x4000. Save the following as a .ini file (for example, app0x4000.ini) and place it in the script folder in the Project directory. FUNC void Setup (void)  SP  RDWORD(0x00004000); // Setup Stack Pointer PC  RDWORD(0x00004004); // Setup Program Counter WDWORD(0xE000ED08, 0x00004000); // Setup Vector Table Offset Register  LOAD ObjectsRA4M2TEapp.axf INCREMENTAL // Download Setup(); // Setup for Running Point to the .ini file in the following image. The debugging effect is shown in the following figure, and when the code jumps to the main() function, the address is at 0x4b7c. Suitable Products RA Point to the .ini file in the following image. Suitable Products","[""The image shows a screenshot of a computer program, specifically a memory region file in a hexadecimal editor. The top section of the image displays the file's contents in a hexadecimal format, with each line representing a different memory region. The bottom section of the image shows the same data in a more readable format, with each line representing a different memory region.\n\nThe file appears to be a memory dump, which is a copy of the contents of a computer's memory at a specific point in time. The hexadecimal format is used to represent the binary data stored in the memory, with each byte represented by a pair of hexadecimal digits.\n\nThe file contains several different memory regions, each with its own unique characteristics. Some of the regions appear to be empty, while others contain data that is likely to be used by the computer's operating system or applications.\n\nOverall, the image provides a detailed view of the contents of a computer's memory, which can be useful for debugging, troubleshooting, and reverse engineering software."", 'The image shows a screenshot of a computer program, specifically the ""Options for Target \'Target 1\'"" window. The window is divided into several sections, each with its own set of options and settings.\n\n*   **Device**\n    *   The ""Device"" section is located at the top-left corner of the window.\n    *   It contains a dropdown menu with various options, including ""Use Memory Layout from Target Dialog"", ""Make RW Sections Position Independent"", ""Make RO Sections Position Independent"", ""Dogt Search Standard Libraries"", and ""Report \'might fail\' Conditions as Errors"".\n    *   The selected option is ""Use Memory Layout from Target Dialog"".\n*   **X/O Base**\n    *   The ""X/O Base"" section is located below the ""Device"" section.\n    *   It contains a text box with the value ""0x4000"".\n    *   There is a red dotted line around the text box, indicating that it is a warning or error message.\n*   **R/W Base**\n    *   The ""R/W Base"" section is located below the ""X/O Base"" section.\n    *   It contains a text box with the value ""0x319,6314"".\n    *   There is a red dotted line around the text box, indicating that it is a warning or error message.\n*   **Scatter File**\n    *   The ""Scatter File"" section is located below the ""R/W Base"" section.\n    *   It contains a text box with the value ""-script/fsp.scat"".\n    *   There is a dropdown menu next to the text box, allowing the user to select a different file.\n*   **Misc controls**\n    *   The ""Misc controls"" section is located below the ""Scatter File"" section.\n    *   It contains a text box with the value ""-entry-Reset_Handler -no_startup -via* -script \\ac6/fsp_keep_via"".\n    *   There is a dropdown menu next to the text box, allowing the user to select a different file.\n*   **Linker control string**\n    *   The ""Linker control string"" section is located below the ""Misc controls"" section.\n    *   It contains a text box with the value ""-cpu=Cortex-M23 -o -library_type-microlib -diag_suppress 6319,6314 -scatter \\""\\script/fsp scat\\"""".\n    *   There is a dropdown menu next to the text box, allowing the user to select a different file.\n\nIn summary, the image shows a screenshot of a computer program with various options and settings for configuring a target device. The program appears to be related to embedded systems development, given the presence of options such as ""Make RW Sections Position Independent"" and ""Dogt Search Standard Libraries"". The warning messages in the ""X/O Base"" and ""R/W Base"" sections suggest that there may be issues with the memory layout or file system configuration. Overall, the image provides a detailed view of the program\'s interface and options, allowing users to customize their settings for specific development tasks.', 'The image shows a screenshot of a computer program, specifically the ""Options for Target \'Target 1\'"" window. The window is divided into two main sections: the left side contains a list of options, and the right side displays the current settings for each option.\n\n**Left Side:**\n\n*   **Device:** This section lists various devices that can be used with the program, including ""Target"", ""Output"", ""Listing"", ""User"", ""C/C++ (AC6)"", ""Asm"", ""Linker"", ""Debug"", and ""Utilities"".\n*   **Use Simulator:** This option allows the user to select whether to use a simulator or not.\n*   **Limit Speed to Real-Time:** This option limits the speed of the program to real-time.\n*   **Load Application at Startup:** This option loads the application at startup.\n*   **Initialization File:** This option allows the user to select an initialization file.\n*   **Restore Debug Session Settings:** This option restores debug session settings.\n*   **Breakpoints:** This option sets breakpoints.\n*   **Watch Windows & Performance Analyzer:** This option watches windows and performance analyzer.\n*   **Memory Display:** This option displays memory.\n*   **System Viewer:** This option displays the system viewer.\n\n**Right Side:**\n\n*   **CPU DLL:** This section lists the current CPU DLL settings, including the parameter ""-MPU"".\n*   **Dialog DLL:** This section lists the current dialog DLL settings, including the parameter ""-CM4"".\n*   **Driver DLL:** This section lists the current driver DLL settings, including the parameter ""-MPU"".\n*   **Dialog DLL:** This section lists the current dialog DLL settings, including the parameter ""-CM4"".\n\n**Bottom Section:**\n\n*   **OK:** This button saves the changes and closes the window.\n*   **Cancel:** This button cancels the changes and closes the window.\n*   **Defaults:** This button resets the settings to their default values.\n*   **Help:** This button opens the help menu.\n\nOverall, the image shows a comprehensive window for configuring various settings related to a computer program. The user can customize the program\'s behavior, including loading applications at startup, setting breakpoints, and displaying memory. The window also provides options for managing component viewer description files and restoring debug session settings.', 'The image shows a screenshot of a computer program in a code editor, with a disassembly window open. The code editor is on the left side of the image, and the disassembly window is on the right side.\n\n*   **Code Editor:**\n    *   The code editor is open to a C++ file.\n    *   The file name is ""memory_regions.cat"".\n    *   The code is written in a dark gray font on a light gray background.\n    *   The code includes several lines of comments and variable declarations.\n    *   The code appears to be a part of a larger program that is designed to manage memory regions.\n*   **Disassembly Window:**\n    *   The disassembly window is open to the same file as the code editor.\n    *   The disassembly window shows the machine code that corresponds to the C++ code in the code editor.\n    *   The machine code is displayed in a hexadecimal format.\n    *   The disassembly window includes several lines of comments and labels.\n    *   The disassembly window appears to be a useful tool for debugging and optimizing the program.\n*   **Overall:**\n    *   The image suggests that the programmer is using a code editor and a disassembly window to develop and test a program.\n    *   The programmer may be using the disassembly window to understand how the program is being executed at the machine code level.\n    *   The programmer may be using the code editor to make changes to the program and test them in the disassembly window.']"
5f362f41de5146bdb7a53fe58dbf28c4,"Question:
Why does the actual IIC transfer rate differ from the rate defined in the configurator?
Answer:
The FSP r_iic_master driver calculates the following register values so that they are close to the transfer rate (Rate), including the Rise Time and Fall Time set in the configurator.
Bit Rate High-Level Period (ICBRH.BRH)
Bit Rate Low-Level Period (ICBRL.BRL)
Internal Reference Clock Select (ICMR1.CKS)
The calculated values can be confirmed in ra_gen/hal_data.c as follows.
const iic_master_extended_cfg_t g_i2c_master0_extend =
{
(omitted)
/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */
 .clock_settings.brl_value = 24,
 .clock_settings.brh_value = 23,
 .clock_settings.cks_value = 0,
(omitted)
};
  The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator.
Suitable Products
RA Family
Why does the actual IIC transfer rate differ from the rate defined in the configurator?
Why does the actual IIC transfer rate differ from the rate defined in the configurator?
Answer:
The FSP r_iic_master driver calculates the following register values so that they are close to the transfer rate (Rate), including the Rise Time and Fall Time set in the configurator.
Bit Rate High-Level Period (ICBRH.BRH)
Bit Rate Low-Level Period (ICBRL.BRL)
Internal Reference Clock Select (ICMR1.CKS)
The calculated values can be confirmed in ra_gen/hal_data.c as follows.
const iic_master_extended_cfg_t g_i2c_master0_extend =
{
(omitted)
/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */
 .clock_settings.brl_value = 24,
 .clock_settings.brh_value = 23,
 .clock_settings.cks_value = 0,
(omitted)
};
  The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator.
Suitable Products
RA Family
The FSP r_iic_master driver calculates the following register values so that they are close to the transfer rate (Rate), including the Rise Time and Fall Time set in the configurator.
Bit Rate High-Level Period (ICBRH.BRH)
Bit Rate Low-Level Period (ICBRL.BRL)
Internal Reference Clock Select (ICMR1.CKS)
The calculated values can be confirmed in ra_gen/hal_data.c as follows.
const iic_master_extended_cfg_t g_i2c_master0_extend =
{
(omitted)
/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */
 .clock_settings.brl_value = 24,
 .clock_settings.brh_value = 23,
 .clock_settings.cks_value = 0,
(omitted)
};
  The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator.
The FSP r_iic_master driver calculates the following register values so that they are close to the transfer rate (Rate), including the Rise Time and Fall Time set in the configurator.
The calculated values can be confirmed in ra_gen/hal_data.c as follows.
const iic_master_extended_cfg_t g_i2c_master0_extend =
{
const
iic_master_extended_cfg_t
g_i2c_master0_extend =
{
(omitted)
/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */
 .clock_settings.brl_value = 24,
 .clock_settings.brh_value = 23,
 .clock_settings.cks_value = 0,
(omitted)
(omitted)
/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */
.clock_settings.brl_value = 24
,
.clock_settings.brh_value = 23,
.clock_settings.cks_value = 0,
(omitted)
};
};
The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator.
Suitable Products
RA Family
日本語
日本語",['data/categories/ra_family/rafsp_knowledge_base/5f362f41de5146bdb7a53fe58dbf28c4/images/3a67e70c85b65e0c7dd7a29df378e88a.png'],[],"['|  |\n|  |\n| const iic_master_extended_cfg_t g_i2c_master0_extend =\n{\n(omitted)\n/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */\n .clock_settings.brl_value = 24,\n .clock_settings.brh_value = 23,\n .clock_settings.cks_value = 0,\n(omitted)\n}; |', '|  |\n|  |\n| RA Family |']","{'title': 'RA Family: Why does the actual IIC transfer rate differ from the rate defined in the configurator?', 'url': 'https://en-support.renesas.com/knowledgeBase/21652593', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:12.934662'}","Question Why does the actual IIC transfer rate differ from the rate defined in the configurator? Answer The FSP riicmaster driver calculates the following register values so that they are close to the transfer rate (Rate), including the Rise Time and Fall Time set in the configurator. Bit Rate High-Level Period (ICBRH.BRH) Bit Rate Low-Level Period (ICBRL.BRL) Internal Reference Clock Select (ICMR1.CKS) The calculated values can be confirmed in ragen/haldata.c as follows. const iicmasterextendedcfgt gi2cmaster0extend   (omitted) / Actual calculated bitrate 394997. Actual calculated duty cycle 49. / .clocksettings.brlvalue  24, .clocksettings.brhvalue  23, .clocksettings.cksvalue  0, ; The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator. Suitable Products RA Family const iicmasterextendedcfgt gi2cmaster0extend  .clocksettings.brlvalue  24 , .clocksettings.brhvalue  23, .clocksettings.cksvalue  0, The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator. ","['The image shows a screenshot of a computer program\'s settings page, specifically the ""Properties"" window for a module named ""g_i2c_master0 I2C Master (r_iic_master)"". The window is divided into two main sections: ""Settings"" and ""API Info"".\n\n**Settings Section:**\n\n*   **Property:** This section lists various properties that can be adjusted, including:\n    *   **Module g_i2c_master0 I2C Master (r_iic_master)**\n    *   **Name:** g_i2c_master0\n    *   **Channel:** 0\n    *   **Rate:** Fast-mode\n    *   **Custom Rate (bps):** 0\n    *   **Rise Time (ns):** 120\n    *   **Fall Time (ns):** 120\n    *   **Duty Cycle (%):** 50\n    *   **Slave Address:** 0x00\n    *   **Address Mode:** 7-Bit\n    *   **Timeout Mode:** Short Mode\n    *   **Timeout during SCL Low:** Enabled\n    *   **Callback:** NULL\n    *   **Interrupt Priority Level:** Priority 2\n\n**API Info Section:**\n\n*   This section provides additional information about the API, including:\n    *   **Module g_i2c_master0 I2C Master (r_iic_master)**\n    *   **Name:** g_i2c_master0\n    *   **Channel:** 0\n    *   **Rate:** Fast-mode\n    *   **Custom Rate (bps):** 0\n    *   **Rise Time (ns):** 120\n    *   **Fall Time (ns):** 120\n    *   **Duty Cycle (%):** 50\n    *   **Slave Address:** 0x00\n    *   **Address Mode:** 7-Bit\n    *   **Timeout Mode:** Short Mode\n    *   **Timeout during SCL Low:** Enabled\n    *   **Callback:** NULL\n    *   **Interrupt Priority Level:** Priority 2\n\nOverall, the image shows a detailed view of the settings and API information for a specific module in a computer program. The settings are organized into categories, making it easy to navigate and adjust the various properties.']"
22e1c8081711a1e3ff1a1860fa7ced4f,"Question:
When using USBX Host Printer Class, UX_NO_TD_AVAILABLE error occurs
Answer:
If the number of TDs (Transfer Descriptor)s is insufficient, the UX_NO_TD_AVAILABLE error occurs. If wMaxPacketSize is small (eg 8 bytes), many TDs are needed. Setting a large number of TDs will eliminate the error. The Maximum TDs (default value is 128) can be defined in the USBX Source property. See “USBX Source Component Overview” in the SSP Users Manual.
  Suitable Products
RA and FSP
When using USBX Host Printer Class, UX_NO_TD_AVAILABLE error occurs
When using USBX Host Printer Class, UX_NO_TD_AVAILABLE error occurs
Answer:
If the number of TDs (Transfer Descriptor)s is insufficient, the UX_NO_TD_AVAILABLE error occurs. If wMaxPacketSize is small (eg 8 bytes), many TDs are needed. Setting a large number of TDs will eliminate the error. The Maximum TDs (default value is 128) can be defined in the USBX Source property. See “USBX Source Component Overview” in the SSP Users Manual.
  Suitable Products
RA and FSP
If the number of TDs (Transfer Descriptor)s is insufficient, the UX_NO_TD_AVAILABLE error occurs. If wMaxPacketSize is small (eg 8 bytes), many TDs are needed. Setting a large number of TDs will eliminate the error. The Maximum TDs (default value is 128) can be defined in the USBX Source property. See “USBX Source Component Overview” in the SSP Users Manual.
If the number of TDs (Transfer Descriptor)s is insufficient, the UX_NO_TD_AVAILABLE error occurs. If wMaxPacketSize is small (eg 8 bytes), many TDs are needed. Setting a large number of TDs will eliminate the error. The Maximum TDs (default value is 128) can be defined in the USBX Source property. See “USBX Source Component Overview” in the SSP Users Manual.
Suitable Products
RA and FSP
Go to Japanese
Go to Japanese",['data/categories/ra_family/rafsp_knowledge_base/22e1c8081711a1e3ff1a1860fa7ced4f/images/6aea1a04b7917f35d212489e4b52e9cb.png'],[],['|  |\n|  |\n| RA and FSP |'],"{'title': 'When using USBX Host Printer Class, UX_NO_TD_AVAILABLE error occurs', 'url': 'https://en-support.renesas.com/knowledgeBase/20459401', 'last_updated': '2022-05-04', 'extracted_at': '2025-03-08T23:25:25.639024'}","Question When using USBX Host Printer Class, UXNOTDAVAILABLE error occurs Answer If the number of TDs (Transfer Descriptor)s is insufficient, the UXNOTDAVAILABLE error occurs. If wMaxPacketSize is small (eg 8 bytes), many TDs are needed. Setting a large number of TDs will eliminate the error. The Maximum TDs (default value is 128) can be defined in the USBX Source property. See USBX Source Component Overview in the SSP Users Manual. Suitable Products RA and FSP Suitable Products Go to Japanese","['The image shows a screenshot of a settings page for a USBX source, with a list of properties and their corresponding values. The page is titled ""USBX Source"" and has a dropdown menu labeled ""Settings"" with options for ""Property"" and ""Value"". \n\n*   The list of properties includes:\n    *   Ticks per seconds for USBX system\n    *   Maximum Classes\n    *   Maximum Slave Classes\n    *   Maximum Slave Interfaces\n    *   Maximum Host Class Containers\n    *   Maximum Device Class Containers\n    *   Maximum Host Controllers\n    *   Maximum Devices\n    *   Maximum EDs\n    *   Maximum TDs\n    *   Maximum Isochronous TDs\n    *   Stack size for USBX threads\n\n*   The value for ""Maximum Isochronous TDs"" is highlighted in red, indicating that it is the current setting.\n\n*   A note at the bottom of the page explains that the value represents the maximum number of Isochronous TDs for a controller.\n\nOverall, the image appears to be a settings page for configuring the USBX source, with options for adjusting various properties related to USBX system performance.']"
dc6375c87e892c02b82496f5573a59eb,"Question:
The input pin level and the level indicated by the GPIO register do not match
Answer:
Some I/O pins may require initialization depending on the relationship with other functions assigned to the pins. For example, in the case of RA4M2, P402, P403, P404 can function as RTC input or AGT input function being enabled by VBTICTLR setting in addition to the I/O port configuration. As the VBTICTLR register setting is not initialized by reset, be careful that those pins will not be initialized to be input pins automatically by reset. In typical FSP-based projects, the register is initialized by R_IOPORT_Open() that is called in R_BSP_WarmStart(); therefore, you don’t need to take care of the register initialization. However, if you don't use the initialization code provided in FSP, you need to handle the register initialization by yourself.
  Suitable Products
RA and FSP
The input pin level and the level indicated by the GPIO register do not match
The input pin level and the level indicated by the GPIO register do not match
Answer:
Some I/O pins may require initialization depending on the relationship with other functions assigned to the pins. For example, in the case of RA4M2, P402, P403, P404 can function as RTC input or AGT input function being enabled by VBTICTLR setting in addition to the I/O port configuration. As the VBTICTLR register setting is not initialized by reset, be careful that those pins will not be initialized to be input pins automatically by reset. In typical FSP-based projects, the register is initialized by R_IOPORT_Open() that is called in R_BSP_WarmStart(); therefore, you don’t need to take care of the register initialization. However, if you don't use the initialization code provided in FSP, you need to handle the register initialization by yourself.
  Suitable Products
RA and FSP
Some I/O pins may require initialization depending on the relationship with other functions assigned to the pins. For example, in the case of RA4M2, P402, P403, P404 can function as RTC input or AGT input function being enabled by VBTICTLR setting in addition to the I/O port configuration. As the VBTICTLR register setting is not initialized by reset, be careful that those pins will not be initialized to be input pins automatically by reset. In typical FSP-based projects, the register is initialized by R_IOPORT_Open() that is called in R_BSP_WarmStart(); therefore, you don’t need to take care of the register initialization. However, if you don't use the initialization code provided in FSP, you need to handle the register initialization by yourself.
  Suitable Products
RA and FSP
Some I/O pins may require initialization depending on the relationship with other functions assigned to the pins. For example, in the case of RA4M2, P402, P403, P404 can function as RTC input or AGT input function being enabled by VBTICTLR setting in addition to the I/O port configuration. As the VBTICTLR register setting is not initialized by reset, be careful that those pins will not be initialized to be input pins automatically by reset. In typical FSP-based projects, the register is initialized by R_IOPORT_Open() that is called in R_BSP_WarmStart(); therefore, you don’t need to take care of the register initialization. However, if you don't use the initialization code provided in FSP, you need to handle the register initialization by yourself.
Suitable Products
RA and FSP
Go to Japanese
Go to Japanese",['data/categories/ra_family/rafsp_knowledge_base/dc6375c87e892c02b82496f5573a59eb/images/0699ccd2c9c8fc887b16383a9d5dec58.png'],[],['|  |\n|  |\n| RA and FSP |'],"{'title': 'RA Family: The input pin level and the level indicated by the GPIO register do not match', 'url': 'https://en-support.renesas.com/knowledgeBase/20797631', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:50.972493'}","Question The input pin level and the level indicated by the GPIO register do not match Answer Some I/O pins may require initialization depending on the relationship with other functions assigned to the pins. For example, in the case of RA4M2, P402, P403, P404 can function as RTC input or AGT input function being enabled by VBTICTLR setting in addition to the I/O port configuration. As the VBTICTLR register setting is not initialized by reset, be careful that those pins will not be initialized to be input pins automatically by reset. In typical FSP-based projects, the register is initialized by RIOPORTOpen() that is called in RBSPWarmStart(); therefore, you dont need to take care of the register initialization. However, if you don't use the initialization code provided in FSP, you need to handle the register initialization by yourself. Suitable Products RA and FSP Suitable Products Go to Japanese","['The image presents a technical diagram, specifically a block diagram, which is a visual representation of the internal structure and organization of a system or process. The diagram is titled ""RA4M2 User\'s Manual"" and features a white background with black text and lines.\n\n**Key Components:**\n\n*   **Title:** ""RA4M2 User\'s Manual""\n*   **Background:** White\n*   **Text and Lines:** Black\n*   **Diagram Type:** Block diagram\n\n**Diagram Description:**\n\nThe diagram is divided into several sections, each representing a different component or function of the system. The components are connected by lines, indicating the flow of data or control signals between them. The diagram also includes various symbols and abbreviations, such as ""VBATT Input Control Register,"" ""Peripheral output enable,"" and ""Peripheral output.""\n\n**Notable Features:**\n\n*   **VBATT Input Control Register:** A rectangular box with a label indicating its function.\n*   **Peripheral output enable:** A line connecting the VBATT Input Control Register to another component, labeled ""Peripheral output.""\n*   **Peripheral output:** A line connecting the Peripheral output enable to another component, labeled ""P402 to P404.""\n\n**Overall Impression:**\n\nThe diagram appears to be a detailed and technical representation of a complex system or process. It suggests that the system has multiple components and functions, and that these components interact with each other in a specific way. The use of symbols and abbreviations adds to the technical nature of the diagram, making it clear that it is intended for an audience with a strong background in electronics or computer science.']"
48180f9f6caba0ae2fa0892b01439cef,"In some cases it is possible that erasing or re-programming your target fails. Especially, if the option-setting memory area is overwritten, there is risk that the Security MPU settings have been enabled.
In some cases it is possible that erasing or re-programming your target fails. Especially, if the option-setting memory area is overwritten, there is risk that the Security MPU settings have been enabled.
To check if your MCU has been locked permanently try to run the script attached in folder RA2A1_Erase_Block_0.zip.
This script erases block 0 of code flash. You must edit  the JLink_path.bat to point to the location of JLink.exe, and then open command prompt in order to run the script.
If the script runs successfully and block 0 is erased you should see something like this:
Suitable Products
Suitable Products
RA2A1,RA2L1,RA2E1,RA2E2,RA2E3,RA2A2,RA4M1,RA4W1
RA2A1,RA2L1,RA2E1,RA2E2,RA2E3,RA2A2,RA4M1,RA4W1","['data/categories/ra_family/rafsp_knowledge_base/48180f9f6caba0ae2fa0892b01439cef/images/81ced95fcbb6498447d038057d318a86.png', 'data/categories/ra_family/rafsp_knowledge_base/48180f9f6caba0ae2fa0892b01439cef/images/94ad7f229d34cea54071080227b331d6.png']",[],[],"{'title': 'Cannot erase or program RA2A1', 'url': 'https://en-support.renesas.com/knowledgeBase/21732378', 'last_updated': None, 'extracted_at': '2025-03-08T23:22:33.779996'}","In some cases it is possible that erasing or re-programming your target fails. Especially, if the option-setting memory area is overwritten, there is risk that the Security MPU settings have been enabled. To check if your MCU has been locked permanently try to run the script attached in folder RA2A1EraseBlock0.zip. This script erases block 0 of code flash. You must edit the JLinkpath.bat to point to the location of JLink.exe, and then open command prompt in order to run the script. If the script runs successfully and block 0 is erased you should see something like this Suitable Products RA2A1,RA2L1,RA2E1,RA2E2,RA2E3,RA2A2,RA4M1,RA4W1","['The image depicts a technical diagram illustrating the configuration of an option-setting memory area. The diagram is divided into two sections: the top section, which displays the address and configuration setting area, and the bottom section, which provides detailed information about the option-setting memory area.\n\n**Top Section:**\n\n*   **Address:** The address is represented by a series of hexadecimal numbers, including 0x0101_0018 to 0x0101_0033 and 0x0101_0010 to 0x0101_0013.\n*   **Configuration Setting Area:** This area is labeled as ""Configuration setting area"" and contains several lines of text, including ""OCD/Serial Programmer ID Setting Register (OSID)"" and ""Access Window Setting Register (AWS)"".\n\n**Bottom Section:**\n\n*   **Option-Setting Memory Area:** This section is highlighted in red and contains several lines of text, including ""Security MPU (SECMPUxxx)"" and ""Option Function Select Register 0 (OF50)"".\n*   **Note 1:** This note states that the option-setting memory must be allocated to the user area of the flash memory.\n*   **Note 2:** This note provides additional details about the option-setting memory area, including the address range and the number of registers.\n*   **Note 3:** This note explains that the address of these registers will be changed when the boot swap is set.\n\n**Additional Information:**\n\n*   **Figure 6.1:** This figure is labeled as ""Option-setting memory area"" and provides a visual representation of the option-setting memory area.\n*   **Table 6.2:** This table is not visible in the image, but it is mentioned in Note 2 as providing additional details about the option-setting memory area.\n\nOverall, the image provides a detailed diagram of the option-setting memory area, including its configuration and layout. The notes and additional information provide further context and explanation of the diagram.', 'The image shows a computer screen displaying a list of text in a monochrome color scheme, with a black background and white text. The text is arranged in a vertical column, with each line consisting of a series of characters that appear to be a combination of letters and symbols.\n\nThe text is too small and blurry to be legible, making it difficult to determine the exact content or meaning of the image. However, based on the layout and formatting, it appears to be some kind of technical or programming-related output, possibly from a command-line interface or a programming language.\n\nOverall, the image suggests that the user is interacting with a computer system or programming environment, and the text is likely related to a specific task or operation being performed.']"
d19612efac1ff72ba73b5e38e6da5a23,"Question:
Is there a way to customize the Interrupt Service Routine (ISR) settings in FSP Configurator?
For instance:
Stacks tab: Replace the ISR of the added driver with a user-defined one.
Register a new ISR corresponding to the interrupt event of each peripheral function.
Answer:
In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows.
If you add a new gpt_user_isr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gpt_user_isr will be registered as an ISR as shown below.
For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure.
References:
FSP User's Manual ""Configuring a Project""
URL: https://renesas.github.io/fsp/_s_t_a_r_t__d_e_v.html#configuring-a-project
RA and FSP Curriculum: I-002A Fundamentals of FSP (Non-Trustzone)
FSP CONFIGURATOR – INTERRUPT LINKS TAB
Suitable Products
RA Family
Is there a way to customize the Interrupt Service Routine (ISR) settings in FSP Configurator?
For instance:
Stacks tab: Replace the ISR of the added driver with a user-defined one.
Register a new ISR corresponding to the interrupt event of each peripheral function.
Is there a way to customize the Interrupt Service Routine (ISR) settings in FSP Configurator?
For instance:
Answer:
In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows.
If you add a new gpt_user_isr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gpt_user_isr will be registered as an ISR as shown below.
For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure.
References:
FSP User's Manual ""Configuring a Project""
URL: https://renesas.github.io/fsp/_s_t_a_r_t__d_e_v.html#configuring-a-project
RA and FSP Curriculum: I-002A Fundamentals of FSP (Non-Trustzone)
FSP CONFIGURATOR – INTERRUPT LINKS TAB
Suitable Products
RA Family
In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows.
If you add a new gpt_user_isr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gpt_user_isr will be registered as an ISR as shown below.
For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure.
References:
FSP User's Manual ""Configuring a Project""
URL: https://renesas.github.io/fsp/_s_t_a_r_t__d_e_v.html#configuring-a-project
RA and FSP Curriculum: I-002A Fundamentals of FSP (Non-Trustzone)
FSP CONFIGURATOR – INTERRUPT LINKS TAB
Suitable Products
In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows.
If you add a new gpt_user_isr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gpt_user_isr will be registered as an ISR as shown below.
For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure.
References:
FSP User's Manual ""Configuring a Project""
URL: https://renesas.github.io/fsp/_s_t_a_r_t__d_e_v.html#configuring-a-project
RA and FSP Curriculum: I-002A Fundamentals of FSP (Non-Trustzone)
FSP CONFIGURATOR – INTERRUPT LINKS TAB
In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows.
If you add a new gpt_user_isr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gpt_user_isr will be registered as an ISR as shown below.
For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure.
References:
Suitable Products
RA Family
日本語
日本語","['data/categories/ra_family/rafsp_knowledge_base/d19612efac1ff72ba73b5e38e6da5a23/images/9edb7aca4a002bf48ee5a2733b1dee14.png', 'data/categories/ra_family/rafsp_knowledge_base/d19612efac1ff72ba73b5e38e6da5a23/images/c8e473e2186a3c1cb0b28651ef694ee9.png']",[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: How to customize (add or replace) interrupt service routines (ISRs)', 'url': 'https://en-support.renesas.com/knowledgeBase/21715563', 'last_updated': '2024-10-12', 'extracted_at': '2025-03-08T23:22:39.749204'}","Question Is there a way to customize the Interrupt Service Routine (ISR) settings in FSP Configurator? For instance Stacks tab Replace the ISR of the added driver with a user-defined one. Register a new ISR corresponding to the interrupt event of each peripheral function. Answer In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows. If you add a new gptuserisr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gptuserisr will be registered as an ISR as shown below. For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure. References FSP User's Manual ""Configuring a Project"" URL https//renesas.github.io/fsp/startdev.htmlconfiguring-a-project RA and FSP Curriculum I-002A Fundamentals of FSP (Non-Trustzone) FSP CONFIGURATOR  INTERRUPT LINKS TAB Suitable Products RA Family ","['The image shows a screenshot of the ""Interrupts Configuration"" window in a software development environment, likely for a microcontroller or embedded system. The window is divided into two main sections: ""User Events"" and ""Allocations"".\n\n**User Events**\n\n*   **Event**: This section is empty, indicating that no user events have been defined or configured.\n*   **New User Event**: A button to create a new user event, which would allow the user to define a custom interrupt handler.\n\n**Allocations**\n\n*   **Interrupt**: This section lists the available interrupts, which are:\n    *   **0**: GPT0 COUNTER OVERFLOW (Overflow)\n    *   **1**: GPT0 CAPTURE COMPARE A (Capture/Compare match A)\n*   **Event**: This column shows the corresponding event for each interrupt, which are:\n    *   **GPT0 COUNTER OVERFLOW (Overflow)**: Interrupt 0\n    *   **GPT0 CAPTURE COMPARE A (Capture/Compare match A)**: Interrupt 1\n*   **ISR**: This column shows the Interrupt Service Routine (ISR) for each interrupt, which are:\n    *   **gpt_counter_overflow_isr**: Interrupt 0\n    *   **gpt_capture_compare_a_isr**: Interrupt 1\n\nIn summary, the ""Interrupts Configuration"" window allows users to define and configure custom interrupt handlers for specific events. The window lists the available interrupts and their corresponding events and ISRs, providing a clear overview of the system\'s interrupt handling capabilities.', 'The image shows a screenshot of a computer program with a gray background and black text. The title at the top reads ""Interrupts Configuration"" in bold black font.\n\nBelow the title, there are two sections: ""User Events"" and ""Allocations"". The ""User Events"" section has a red box around it, highlighting the text inside. The text reads ""GPT0 COUNTER OVERFLOW (Overflow)"" and ""gpt_user_isr"". The ""Allocations"" section also has a red box around it, highlighting the text inside. The text reads ""GPT0 COUNTER OVERFLOW (Overflow)"" and ""gpt_user_isr"".\n\nIn the top-right corner, there is a green button with a white arrow pointing to the right, labeled ""Generate Project Content"". Below this button, there is a dropdown menu with the options ""New User Event"" and ""Remove"".\n\nOverall, the image appears to be a screenshot of a computer program used for configuring interrupts, specifically for a GPT0 counter overflow event. The red boxes highlight the specific event and allocation being configured.']"
21dd805601c92b592dd87633f353b9a8,"Question:
In the Problems tab of e2 studio, you might see the message ""Pin with no drivers"" related to the RA Family Smart Configurator. What does this mean? Also, is there a way to get rid of this display?
Answer:
""Pin with no drivers"" means that there are no drivers associated with the pins to which peripheral functions are assigned in the pin configuration of the configurator. You can find out if there are any unwanted pin settings by checking the pin settings to which this indication applies.
To change the display conditions of Pin Driver Warnings, set them in Configure Pin Driver Warnings.
Suitable Products
RA Family
In the Problems tab of e2 studio, you might see the message ""Pin with no drivers"" related to the RA Family Smart Configurator. What does this mean? Also, is there a way to get rid of this display?
In the Problems tab of e2 studio, you might see the message ""Pin with no drivers"" related to the RA Family Smart Configurator. What does this mean? Also, is there a way to get rid of this display?
Answer:
""Pin with no drivers"" means that there are no drivers associated with the pins to which peripheral functions are assigned in the pin configuration of the configurator. You can find out if there are any unwanted pin settings by checking the pin settings to which this indication applies.
To change the display conditions of Pin Driver Warnings, set them in Configure Pin Driver Warnings.
Suitable Products
RA Family
""Pin with no drivers"" means that there are no drivers associated with the pins to which peripheral functions are assigned in the pin configuration of the configurator. You can find out if there are any unwanted pin settings by checking the pin settings to which this indication applies.
To change the display conditions of Pin Driver Warnings, set them in Configure Pin Driver Warnings.
Suitable Products
""Pin with no drivers"" means that there are no drivers associated with the pins to which peripheral functions are assigned in the pin configuration of the configurator. You can find out if there are any unwanted pin settings by checking the pin settings to which this indication applies.
To change the display conditions of Pin Driver Warnings, set them in Configure Pin Driver Warnings.
Suitable Products
RA Family
日本語
日本語","['data/categories/ra_family/rafsp_knowledge_base/21dd805601c92b592dd87633f353b9a8/images/41673741faaf59dfe0f3076cf4fd51a3.png', 'data/categories/ra_family/rafsp_knowledge_base/21dd805601c92b592dd87633f353b9a8/images/6c012154347ef0129ea5503782ff0f87.png']",[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: What does it mean when I see the message ""Pin with no drivers"" related to Smart Configurator?', 'url': 'https://en-support.renesas.com/knowledgeBase/21698319', 'last_updated': None, 'extracted_at': '2025-03-08T23:22:45.585503'}","Question In the Problems tab of e2 studio, you might see the message ""Pin with no drivers"" related to the RA Family Smart Configurator. What does this mean? Also, is there a way to get rid of this display? Answer ""Pin with no drivers"" means that there are no drivers associated with the pins to which peripheral functions are assigned in the pin configuration of the configurator. You can find out if there are any unwanted pin settings by checking the pin settings to which this indication applies. To change the display conditions of Pin Driver Warnings, set them in Configure Pin Driver Warnings. Suitable Products RA Family ","['The image shows a screenshot of a Windows Explorer window displaying a list of files and folders. The window is titled ""Properties"" and has a menu bar at the top with options such as ""View,"" ""Edit,"" and ""Help."" \n\n*   The main content area of the window is a list of files and folders, with each item displayed in a separate row.\n    *   Each row includes the name of the file or folder, its location, and other details such as the file type and size.\n    *   The list is sorted alphabetically by file name, with the most recently accessed files at the top.\n*   The window also includes a toolbar at the top with buttons for common actions such as ""New,"" ""Open,"" and ""Save.""\n    *   The toolbar is customizable, allowing users to add or remove buttons as needed.\n*   In the bottom-right corner of the window, there is a status bar that displays information about the current file or folder, such as its location and size.\n    *   The status bar can be customized to display additional information, such as the file\'s creation date or author.\n\nOverall, the image shows a typical Windows Explorer window, which is used to manage files and folders on a computer. The window provides a range of features and tools for organizing and accessing files, making it a useful tool for users who need to work with files regularly.', 'The image shows a screenshot of a computer program with a white background and black text. The title at the top reads ""Pin Configuration"" in bold black font.\n\nBelow the title, there are two sections: ""Select Pin Configuration"" and ""Generate Project Content"". The ""Select Pin Configuration"" section has a dropdown menu with the option ""RABD1 EK"" selected. To the right of this section, there is a button labeled ""Export to CSV file"" and another button labeled ""Configure Pin Driver Warnings"".\n\nIn the ""Generate Project Content"" section, there is a checkbox labeled ""Generate data:"" with the text ""g_bsp_pin_cfg"" next to it. Below this section, there is a button labeled ""Manage configurations..."" and another button labeled ""Generate Project Content"".\n\nA red box highlights the ""Configure Pin Driver Warnings"" button. The overall design of the program appears to be a user-friendly interface for configuring and managing pin settings.']"
c0c620d4b540c9d439bcd389811414af,"Question:
AES encryption performance difference when C-/S-caches are on/off
Answer:
This article intends to demonstrate how the performance of RA SCE9 Encryption engine operation can be improved when C-Cache and S-Cache are both enabled. In this case study, the AES-CBC mode and key size of 256 bits are used as a base example for doing the performance comparison. A brief operation flow of SCE9 HW AES Encryption operation and the workspace environment setting are listed below. In addition, the operation time measurement uses either toggling the GPIO output level or DWT cycle counter.
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize more)
System Clock configuration: ICLK=200MHz
Peripheral Clock configuration: PCLKA=100MHz
Board: EK-RA6M4
The CPU process time for each step is measured as below based on GPIO output level change:
Message size is 2048 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23.26us
HW_SCE_Aes256EncryptDecryptUpdateSub 65.37us
HW_SCE_Aes256EncryptDecryptFinalSub 3.02us
Whole AE256 CBC Encryption process 89us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.8us
HW_SCE_Aes256EncryptDecryptUpdateSub 66.8us
HW_SCE_Aes256EncryptDecryptFinalSub 3.3us
Whole AE256 CBC Encryption process 95.6us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.76us
HW_SCE_Aes256EncryptDecryptUpdateSub 75.62us
HW_SCE_Aes256EncryptDecryptFinalSub 4.05us
Whole AE256 CBC Encryption process 114.3us
  Message size is 1024 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23us
HW_SCE_Aes256EncryptDecryptUpdateSub 34us
HW_SCE_Aes256EncryptDecryptFinalSub 2.8us
Whole AE256 CBC Encryption process 60us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 26us
HW_SCE_Aes256EncryptDecryptUpdateSub 35.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.1us
Whole AE256 CBC Encryption process 62.82us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 35us
HW_SCE_Aes256EncryptDecryptUpdateSub 39.8us
HW_SCE_Aes256EncryptDecryptFinalSub 4.3us
Whole AE256 CBC Encryption process 78.1us
  Message size is 256 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 22.85us
HW_SCE_Aes256EncryptDecryptUpdateSub 10.4us
HW_SCE_Aes256EncryptDecryptFinalSub 3us
Whole AE256 CBC Encryption process 36.05us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.9us
HW_SCE_Aes256EncryptDecryptUpdateSub 11.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.25us
Whole AE256 CBC Encryption process 39.84us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.6us
HW_SCE_Aes256EncryptDecryptUpdateSub 13us
HW_SCE_Aes256EncryptDecryptFinalSub 4.12us
Whole AE256 CBC Encryption process 51.22us
  According to the result, we can identify over 20% performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus
Reference Attachments:
Example project on EK-RA6M4 for above performance benchmarking test (below)
Suitable Products
RA Devices with SCE9
AES encryption performance difference when C-/S-caches are on/off
AES encryption performance difference when C-/S-caches are on/off
Answer:
This article intends to demonstrate how the performance of RA SCE9 Encryption engine operation can be improved when C-Cache and S-Cache are both enabled. In this case study, the AES-CBC mode and key size of 256 bits are used as a base example for doing the performance comparison. A brief operation flow of SCE9 HW AES Encryption operation and the workspace environment setting are listed below. In addition, the operation time measurement uses either toggling the GPIO output level or DWT cycle counter.
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize more)
System Clock configuration: ICLK=200MHz
Peripheral Clock configuration: PCLKA=100MHz
Board: EK-RA6M4
The CPU process time for each step is measured as below based on GPIO output level change:
Message size is 2048 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23.26us
HW_SCE_Aes256EncryptDecryptUpdateSub 65.37us
HW_SCE_Aes256EncryptDecryptFinalSub 3.02us
Whole AE256 CBC Encryption process 89us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.8us
HW_SCE_Aes256EncryptDecryptUpdateSub 66.8us
HW_SCE_Aes256EncryptDecryptFinalSub 3.3us
Whole AE256 CBC Encryption process 95.6us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.76us
HW_SCE_Aes256EncryptDecryptUpdateSub 75.62us
HW_SCE_Aes256EncryptDecryptFinalSub 4.05us
Whole AE256 CBC Encryption process 114.3us
  Message size is 1024 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23us
HW_SCE_Aes256EncryptDecryptUpdateSub 34us
HW_SCE_Aes256EncryptDecryptFinalSub 2.8us
Whole AE256 CBC Encryption process 60us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 26us
HW_SCE_Aes256EncryptDecryptUpdateSub 35.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.1us
Whole AE256 CBC Encryption process 62.82us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 35us
HW_SCE_Aes256EncryptDecryptUpdateSub 39.8us
HW_SCE_Aes256EncryptDecryptFinalSub 4.3us
Whole AE256 CBC Encryption process 78.1us
  Message size is 256 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 22.85us
HW_SCE_Aes256EncryptDecryptUpdateSub 10.4us
HW_SCE_Aes256EncryptDecryptFinalSub 3us
Whole AE256 CBC Encryption process 36.05us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.9us
HW_SCE_Aes256EncryptDecryptUpdateSub 11.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.25us
Whole AE256 CBC Encryption process 39.84us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.6us
HW_SCE_Aes256EncryptDecryptUpdateSub 13us
HW_SCE_Aes256EncryptDecryptFinalSub 4.12us
Whole AE256 CBC Encryption process 51.22us
  According to the result, we can identify over 20% performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus
Reference Attachments:
Example project on EK-RA6M4 for above performance benchmarking test (below)
Suitable Products
RA Devices with SCE9
This article intends to demonstrate how the performance of RA SCE9 Encryption engine operation can be improved when C-Cache and S-Cache are both enabled. In this case study, the AES-CBC mode and key size of 256 bits are used as a base example for doing the performance comparison. A brief operation flow of SCE9 HW AES Encryption operation and the workspace environment setting are listed below. In addition, the operation time measurement uses either toggling the GPIO output level or DWT cycle counter.
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize more)
System Clock configuration: ICLK=200MHz
Peripheral Clock configuration: PCLKA=100MHz
Board: EK-RA6M4
The CPU process time for each step is measured as below based on GPIO output level change:
Message size is 2048 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23.26us
HW_SCE_Aes256EncryptDecryptUpdateSub 65.37us
HW_SCE_Aes256EncryptDecryptFinalSub 3.02us
Whole AE256 CBC Encryption process 89us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.8us
HW_SCE_Aes256EncryptDecryptUpdateSub 66.8us
HW_SCE_Aes256EncryptDecryptFinalSub 3.3us
Whole AE256 CBC Encryption process 95.6us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.76us
HW_SCE_Aes256EncryptDecryptUpdateSub 75.62us
HW_SCE_Aes256EncryptDecryptFinalSub 4.05us
Whole AE256 CBC Encryption process 114.3us
  Message size is 1024 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23us
HW_SCE_Aes256EncryptDecryptUpdateSub 34us
HW_SCE_Aes256EncryptDecryptFinalSub 2.8us
Whole AE256 CBC Encryption process 60us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 26us
HW_SCE_Aes256EncryptDecryptUpdateSub 35.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.1us
Whole AE256 CBC Encryption process 62.82us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 35us
HW_SCE_Aes256EncryptDecryptUpdateSub 39.8us
HW_SCE_Aes256EncryptDecryptFinalSub 4.3us
Whole AE256 CBC Encryption process 78.1us
  Message size is 256 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 22.85us
HW_SCE_Aes256EncryptDecryptUpdateSub 10.4us
HW_SCE_Aes256EncryptDecryptFinalSub 3us
Whole AE256 CBC Encryption process 36.05us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.9us
HW_SCE_Aes256EncryptDecryptUpdateSub 11.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.25us
Whole AE256 CBC Encryption process 39.84us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.6us
HW_SCE_Aes256EncryptDecryptUpdateSub 13us
HW_SCE_Aes256EncryptDecryptFinalSub 4.12us
Whole AE256 CBC Encryption process 51.22us
  According to the result, we can identify over 20% performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus
Reference Attachments:
Example project on EK-RA6M4 for above performance benchmarking test (below)
This article intends to demonstrate how the performance of RA SCE9 Encryption engine operation can be improved when C-Cache and S-Cache are both enabled. In this case study, the AES-CBC mode and key size of 256 bits are used as a base example for doing the performance comparison. A brief operation flow of SCE9 HW AES Encryption operation and the workspace environment setting are listed below. In addition, the operation time measurement uses either toggling the GPIO output level or DWT cycle counter.
The CPU process time for each step is measured as below based on GPIO output level change:
According to the result, we can identify over 20% performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus
Reference Attachments:
Suitable Products
RA Devices with SCE9",['data/categories/ra_family/rafsp_knowledge_base/c0c620d4b540c9d439bcd389811414af/images/55d5633c8b99d64dee61199f13a6b3e1.png'],[],"['|  |\n|  |\n| HW SCE operation | S-Cache | C-Cache | F-Cache | Process time |\n| HW_SCE_Aes256EncryptDecryptInitSub | Enable | Enable | Enable | 23.26us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 65.37us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 3.02us |\n| Whole AE256 CBC Encryption process | 89us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Enable | Enable | 25.8us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 66.8us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 3.3us |\n| Whole AE256 CBC Encryption process | 95.6us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Disable | Enable | 34.76us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 75.62us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 4.05us |\n| Whole AE256 CBC Encryption process | 114.3us |', '|  |\n|  |\n| HW SCE operation | S-Cache | C-Cache | F-Cache | Process time |\n| HW_SCE_Aes256EncryptDecryptInitSub | Enable | Enable | Enable | 23us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 34us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 2.8us |\n| Whole AE256 CBC Encryption process | 60us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Enable | Enable | 26us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 35.3us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 3.1us |\n| Whole AE256 CBC Encryption process | 62.82us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Disable | Enable | 35us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 39.8us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 4.3us |\n| Whole AE256 CBC Encryption process | 78.1us |', '|  |\n|  |\n| HW SCE operation | S-Cache | C-Cache | F-Cache | Process time |\n| HW_SCE_Aes256EncryptDecryptInitSub | Enable | Enable | Enable | 22.85us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 10.4us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 3us |\n| Whole AE256 CBC Encryption process | 36.05us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Enable | Enable | 25.9us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 11.3us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 3.25us |\n| Whole AE256 CBC Encryption process | 39.84us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Disable | Enable | 34.6us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 13us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 4.12us |\n| Whole AE256 CBC Encryption process | 51.22us |', '|  |\n|  |\n| RA Devices with SCE9 |']","{'title': 'RA Devices with SCE9: AES encryption performance difference when C-/S-caches are on/off', 'url': 'https://en-support.renesas.com/knowledgeBase/21177409', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:39.352193'}","Question AES encryption performance difference when C-/S-caches are on/off Answer This article intends to demonstrate how the performance of RA SCE9 Encryption engine operation can be improved when C-Cache and S-Cache are both enabled. In this case study, the AES-CBC mode and key size of 256 bits are used as a base example for doing the performance comparison. A brief operation flow of SCE9 HW AES Encryption operation and the workspace environment setting are listed below. In addition, the operation time measurement uses either toggling the GPIO output level or DWT cycle counter. Compiler GCC10.3.1 Compiler Optimization Level O2 (Optimize more) System Clock configuration ICLK200MHz Peripheral Clock configuration PCLKA100MHz Board EK-RA6M4 The CPU process time for each step is measured as below based on GPIO output level change Message size is 2048 bytes HW SCE operation S-Cache C-Cache F-Cache Process time HWSCEAes256EncryptDecryptInitSub Enable Enable Enable 23.26us HWSCEAes256EncryptDecryptUpdateSub 65.37us HWSCEAes256EncryptDecryptFinalSub 3.02us Whole AE256 CBC Encryption process 89us HWSCEAes256EncryptDecryptInitSub Disable Enable Enable 25.8us HWSCEAes256EncryptDecryptUpdateSub 66.8us HWSCEAes256EncryptDecryptFinalSub 3.3us Whole AE256 CBC Encryption process 95.6us HWSCEAes256EncryptDecryptInitSub Disable Disable Enable 34.76us HWSCEAes256EncryptDecryptUpdateSub 75.62us HWSCEAes256EncryptDecryptFinalSub 4.05us Whole AE256 CBC Encryption process 114.3us Message size is 1024 bytes HWSCEAes256EncryptDecryptInitSub Enable Enable Enable 23us HWSCEAes256EncryptDecryptUpdateSub 34us HWSCEAes256EncryptDecryptFinalSub 2.8us Whole AE256 CBC Encryption process 60us HWSCEAes256EncryptDecryptInitSub Disable Enable Enable 26us HWSCEAes256EncryptDecryptUpdateSub 35.3us HWSCEAes256EncryptDecryptFinalSub 3.1us Whole AE256 CBC Encryption process 62.82us HWSCEAes256EncryptDecryptInitSub Disable Disable Enable 35us HWSCEAes256EncryptDecryptUpdateSub 39.8us HWSCEAes256EncryptDecryptFinalSub 4.3us Whole AE256 CBC Encryption process 78.1us Message size is 256 bytes HWSCEAes256EncryptDecryptInitSub Enable Enable Enable 22.85us HWSCEAes256EncryptDecryptUpdateSub 10.4us HWSCEAes256EncryptDecryptFinalSub 3us Whole AE256 CBC Encryption process 36.05us HWSCEAes256EncryptDecryptInitSub Disable Enable Enable 25.9us HWSCEAes256EncryptDecryptUpdateSub 11.3us HWSCEAes256EncryptDecryptFinalSub 3.25us Whole AE256 CBC Encryption process 39.84us HWSCEAes256EncryptDecryptInitSub Disable Disable Enable 34.6us HWSCEAes256EncryptDecryptUpdateSub 13us HWSCEAes256EncryptDecryptFinalSub 4.12us Whole AE256 CBC Encryption process 51.22us According to the result, we can identify over 20 performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus Reference Attachments Example project on EK-RA6M4 for above performance benchmarking test (below) Suitable Products RA Devices with SCE9 According to the result, we can identify over 20 performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus","['The image depicts a flowchart illustrating the process of encrypting a plaintext input until it reaches a specified data length. The flowchart consists of eight steps, each represented by a purple box with black text, connected by black arrows.\n\n**Step 1: Plaintext Key to KeyIndex Conversion**\nThe first step involves converting the plaintext key to a KeyIndex using the function `->HW_SCE_GenerateOemKeyIndexPrivate`.\n\n**Step 2: Start First Measurement**\nThe second step initiates the first measurement.\n\n**Step 3: Preparations for AES256 CBC Encryption**\nThe third step prepares for the execution of an AES256 CBC encryption using the function `->HW_SCE_Aes256EncryptDecryptInitSub`.\n\n**Step 4: Stop First Measurement**\nThe fourth step stops the first measurement.\n\n**Step 5: Start Second Measurement**\nThe fifth step initiates the second measurement.\n\n**Step 6: Encrypt the Plaintext Input**\nThe sixth step encrypts the plaintext input until it reaches the specified data length, and the encrypted result is output using the function `->HW_SCE_Aes256EncryptDecryptUpdateSub`.\n\n**Step 7: Stop Second Measurement**\nThe seventh step stops the second measurement.\n\n**Step 8: Call HW_SCE_Aes256EncryptDecryptFinalSub**\nThe eighth and final step calls the function `HW_SCE_Aes256EncryptDecryptFinalSub` to complete the encryption process.\n\n**Step 9: Stop Third Measurement**\nThe ninth and final step stops the third measurement.\n\nThe flowchart provides a clear and concise visual representation of the encryption process, making it easier to understand and follow.']"
e05a984f1d6cd781dca3f23d9adddc7d,"Question:
How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Locked with All Erase support” and set 16bytes ID code to “ID Code (32 Hex Characters)” in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/* ID CODE: 00112233445566778899AABBCCDDEEff */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEFFAC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEFF00

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEFF30

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking “…” button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.


Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below.

You can also set it in the authentication code settings dialog as follows:

Suitable Products
RA and FSP
How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Locked with All Erase support” and set 16bytes ID code to “ID Code (32 Hex Characters)” in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/* ID CODE: 00112233445566778899AABBCCDDEEff */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEFFAC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEFF00

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEFF30

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking “…” button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.


Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below.

You can also set it in the authentication code settings dialog as follows:

Suitable Products
RA and FSP
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Locked with All Erase support” and set 16bytes ID code to “ID Code (32 Hex Characters)” in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/* ID CODE: 00112233445566778899AABBCCDDEEff */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEFFAC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEFF00

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEFF30

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking “…” button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.


Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below.

You can also set it in the authentication code settings dialog as follows:
How to set the ID code
In the FSP configurator, set the “ID Code Mode” to “Locked with All Erase support” and set 16bytes ID code to “ID Code (32 Hex Characters)” in the BSP property as shown below.
In the FSP configurator, set the “ID Code Mode” to “Locked with All Erase support” and set 16bytes ID code to “ID Code (32 Hex Characters)” in the BSP property as shown below.
The value of the ID code in the OSIS register
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
00112233
44556677
8899AABB
CCDDEEFF
/* ID CODE: 00112233445566778899AABBCCDDEEff */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC)
/* ID CODE: 00112233445566778899AABBCCDDEEff */
00112233
44556677
8899AABB
CCDDEEff
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
33221100
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
77665544
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
BBAA9988
#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC)
ffEEDDCC
The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEFFAC
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEFFAC
00112233
44556677
8899AABB
CCDDEEFF
In case of RA6M3:
In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEFF00
S3150100A15000112233445566778899AABBCCDDEEFF00
S3150100A150
00112233
44556677
8899AABB
CCDDEEFF
00
In case of RA4E2:
In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEFF30
S3150100A12000112233445566778899AABBCCDDEEFF30
S3150100A120
00112233
44556677
8899AABB
CCDDEEFF
30
Debugger connection in e2 studio (ID code authentication)
Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite.
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite.
Debugger -> Connection Settings -> Connection -> ID Code (Bytes)
The figure below is the dialog which appears by clicking “…” button. You can also set the ID Code on this dialog.
The figure below is the dialog which appears by clicking “…” button. You can also set the ID Code on this dialog.
If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:
In case of J-Link debugger:
In case of E2/E2 Lite debugger:
In case of E2/E2 Lite debugger:
Debugger connection in e2 studio (with ALeRASE execution)
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
FFFFFFFFFFFFFFFFFF45534152654C41
Connection by RFP (with ID code authentication)
Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows.
If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows.
FFEEDDCCBBAA99887766554433221100
After creating an RFP project, set the ID code as follows.
After creating an RFP project, set the ID code as follows.
Connection by RFP (with ALeRASE execution)
Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below.
If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below.
414C6552415345FFFFFFFFFFFFFFFFFF
You can also set it in the authentication code settings dialog as follows:
You can also set it in the authentication code settings dialog as follows:
Suitable Products
RA and FSP
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/554c3a81b680af1327e431109948edca.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/2c0157a51d02c7082d8f894babfe8f5a.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/5e4235c17e0c01a9d6a2e6a06e1a67b7.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/3db10a56bfc92cef3458194713044596.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/2f1f3cdcdd90872ee62ce9b91849211f.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/d893c47bf86a17ffd26853130cedaaee.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/c6c3f4892cabdd6ed0fb5bc4567691f3.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/df748f5dfd1a525d1c0bf87d2bf69208.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/2cf0d837f17e0ca296d4653753336afb.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/f05a8f46caf53abb4b5d7a40891de95c.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/edfbb8594ea5c98174d951ddf325565e.png']",[],"['|  |\n|  |\n| /* ID CODE: 00112233445566778899AABBCCDDEEff */\n#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)\n#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)\n#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)\n#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC) |', '|  |\n|  |\n| S3150101001800112233FFFFFFFF44556677FFFFFFFFFC\nS311010100288899AABBFFFFFFFFCCDDEEFFAC |', '|  |\n|  |\n| S3150100A15000112233445566778899AABBCCDDEEFF00 |', '|  |\n|  |\n| S3150100A12000112233445566778899AABBCCDDEEFF30 |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: ID code protection (in case of protection enabled with Bit127=1 and Bit126=1)', 'url': 'https://en-support.renesas.com/knowledgeBase/20980156', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:39.424703'}","Question How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case? Answer How to set the ID code In the FSP configurator, set the ID Code Mode to Locked with All Erase support and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below. The value of the ID code in the OSIS register In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to racfg/fspcfg/bsp/bspmcufamilycfg.h as shown below. / ID CODE 00112233445566778899AABBCCDDEEff / define BSPCFGIDCODELONG1 (0x33221100) define BSPCFGIDCODELONG2 (0x77665544) define BSPCFGIDCODELONG3 (0xBBAA9988) define BSPCFGIDCODELONG4 (0xffEEDDCC) The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register In case of RA2L1 S3150101001800112233FFFFFFFF44556677FFFFFFFFFC S311010100288899AABBFFFFFFFFCCDDEEFFAC In case of RA6M3 S3150100A15000112233445566778899AABBCCDDEEFF00 In case of RA4E2 S3150100A12000112233445566778899AABBCCDDEEFF30 Debugger connection in e2 studio (ID code authentication) When connecting with e2 studio, set the ID code in Debugger - Connection Settings - Connection - ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite. The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog. If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed. In case of J-Link debugger In case of E2/E2 Lite debugger Debugger connection in e2 studio (with ALeRASE execution) In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution. Connection by RFP (with ID code authentication) If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows. After creating an RFP project, set the ID code as follows. Connection by RFP (with ALeRASE execution) If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below. You can also set it in the authentication code settings dialog as follows Suitable Products RA and FSP 00112233 44556677 8899AABB CCDDEEFF CCDDEEff 33221100 77665544 BBAA9988 ffEEDDCC S3150100A150 00 S3150100A120 30 Debugger - Connection Settings - Connection - ID Code (Bytes) FFFFFFFFFFFFFFFFFF45534152654C41 FFEEDDCCBBAA99887766554433221100 414C6552415345FFFFFFFFFFFFFFFFFF","['The image displays a table with two columns and two rows. The first column is labeled ""ID Code Mode"" and the second column is labeled ""ID Code (32 Hex Characters)"". The first row contains the text ""Locked with All Erase support"" in the first column and the text ""00112233445566778899AABBCCDDEEFF"" in the second column.\n\nThe table appears to be a simple data entry form, with the first column providing a description of the ID code mode and the second column providing the actual ID code. The use of hexadecimal characters in the second column suggests that the ID code is a unique identifier that is used to authenticate or authorize access to a system or application.\n\nOverall, the image suggests that the ID code is a critical component of a security system, and that it is used to ensure that only authorized users have access to a particular resource or system.', 'The image shows a screenshot of a computer program, specifically a debugging tool. The program is open on a computer screen, with a white background and black text.\n\n*   **Menu Bar**\n    *   The menu bar is located at the top of the window and contains several options, including ""Main"", ""Debugger"", ""Startup"", ""Source"", and ""Common"".\n    *   The ""Debugger"" option is currently selected, indicating that the user is in the debugging mode.\n*   **Debug Hardware**\n    *   Below the menu bar, there is a section labeled ""Debug hardware:"" with a dropdown menu that allows the user to select the type of hardware they are debugging.\n    *   The current selection is ""J-Link ARM"", which suggests that the user is debugging an ARM-based microcontroller.\n*   **Target Device**\n    *   To the right of the ""Debug hardware:"" section, there is a field labeled ""Target Device:"" where the user can enter the specific device they are debugging.\n    *   The current entry is ""R7FA2L1AB"", which appears to be a unique identifier for a specific microcontroller.\n*   **GDB Settings**\n    *   Below the ""Target Device:"" field, there is a section labeled ""GDB Settings"" with several options for configuring the debugging session.\n    *   The options include ""Connection Settings"", ""J-Link"", ""Interface"", ""JTAG Scan Chain"", and ""Connection"".\n    *   The ""Connection"" option is currently selected, and the user has chosen to ""Register initialization"" and ""Reset on connection"".\n*   **ID Code (Bytes)**\n    *   At the bottom of the window, there is a field labeled ""ID Code (Bytes)"" that displays a hexadecimal code.\n    *   The code is ""00112233445566778899AABBCCDDEEFF"", which appears to be a unique identifier for the device being debugged.\n*   **Reset before run**\n    *   To the right of the ""ID Code (Bytes)"" field, there is a checkbox labeled ""Reset before run"" that allows the user to choose whether to reset the device before running the program.\n    *   The checkbox is currently unchecked, indicating that the user does not want to reset the device before running the program.\n\nOverall, the image suggests that the user is using a debugging tool to debug an ARM-based microcontroller. The user has configured the debugging session to use the J-Link ARM hardware and has selected the R7FA2L1AB device. The user has also chosen to register initialization and reset on connection, and has displayed the ID code for the device.', 'The image depicts a screenshot of a computer program designed to convert a 32-bit hexadecimal value into a 128-bit hexadecimal value. The program is titled ""ID Code (Bytes)"" and features a white background with black text.\n\n**Key Features:**\n\n*   **Input Field:** A text box at the top of the window allows users to enter a 32-bit hexadecimal value.\n*   **Key 1-4:** Four key fields are provided, each containing a 32-bit hexadecimal value. These values are:\n    *   Key 1: 33221100\n    *   Key 2: 77665544\n    *   Key 3: BBAA9988\n    *   Key 4: FFEEDDCC\n*   **Output Field:** A text box below the input field displays the converted 128-bit hexadecimal value.\n*   **Preview:** A preview section at the bottom of the window shows the converted value in a larger format.\n\n**Program Functionality:**\n\nThe program appears to be a simple tool for converting 32-bit hexadecimal values into 128-bit hexadecimal values. It does not provide any additional features or functionality beyond this basic conversion process.\n\n**Conclusion:**\n\nIn summary, the image shows a screenshot of a computer program designed to convert 32-bit hexadecimal values into 128-bit hexadecimal values. The program features a simple user interface with input and output fields, as well as a preview section. While the program\'s functionality is limited, it may be useful for specific tasks or applications that require this type of conversion.', 'The image shows a screenshot of a computer error message. The message is titled ""Debug connection failed"" and has a yellow triangle with an exclamation mark inside it. Below the title, there is a paragraph of text that reads: ""Could not connect to target. Please check the GDB Server console for more information!"" \n\nBelow this, there is a list of possible causes for the error, numbered from 1 to 7. The list includes:\n\n1. Target hardware does not match debug project hardware.\n2. Not all cables are connected.\n3. Debug options do not match those required by the hardware.\n4. No external power is being applied to the target.\n5. The wrong power is being applied to the target.\n6. The emulator .dll or .so file specified in the device file could not be found.\n7. The device connected or the device specified to GDB Server does not match the device specified in the Debug Configuration.\n\nAt the bottom of the message, there is a button labeled ""OK"". The background of the message is white, with black text. There is a gray bar at the top of the image with the words ""Debug connection failed"" in it. In the top-right corner, there is a small ""X"" button. \n\nOverall, the image appears to be an error message from a debugging tool, indicating that there was a problem connecting to the target device.', 'The image shows a fatal error message in a pop-up window. The message is titled ""FATAL ERROR (GDB Server):"" and has a yellow triangle with an exclamation mark inside it to the left of the text. The text reads: ""Error 0x00020004: Authentication failed. The emulator cannot be connected."" Below the text is a gray ""OK"" button.\n\nThe background of the image is white, with a gray bar at the bottom. The overall atmosphere suggests that the user is experiencing a technical issue with their emulator, and the error message is indicating that authentication has failed, preventing the emulator from connecting.', 'The image shows a screenshot of a computer program, specifically a debugging tool. The top of the window has a menu bar with options such as ""Main"", ""Debugger"", ""Startup"", ""Common"", and ""Source"". Below this are several tabs, including ""Debug hardware:"", ""Target Device:"", and ""GDB Settings"".\n\n*   **Debug hardware:**\n    *   This section allows the user to select the type of hardware they are debugging.\n    *   The current selection is ""E2 Lite (ARM)"".\n*   **Target Device:**\n    *   This section allows the user to specify the target device for debugging.\n    *   The current selection is ""R7FA2L1AB"".\n*   **GDB Settings:**\n    *   This section provides various settings for the GDB debugger.\n    *   The current settings include:\n        *   **Connection Settings:** The connection settings are set to ""Debug Tool Settings"".\n        *   **Clock:** The clock setting is set to ""Connection with Target Board"".\n        *   **Power:** The power setting is set to ""Connection"".\n        *   **Connection:** The connection setting is set to ""Hold reset during connect"".\n        *   **D Code (Bytes):** The D code setting is set to ""FFFFFFFFFFFFFFFF45534152654C41"".\n        *   **Low Power Handling:** The low power handling setting is set to ""Yes"".\n\nOverall, the image shows a debugging tool with various settings and options for customizing the debugging process. The user can select the hardware and target device, set up the GDB debugger, and configure other settings as needed.', 'The image depicts a screenshot of a computer program designed to convert a 128-bit hexadecimal value into a 32-bit hexadecimal value. The program is titled ""ID Code (Bytes)"" and features a white background with black text.\n\n**Program Interface:**\n\n*   The program\'s interface consists of a single text box at the top, labeled ""Specify ID Code in the format of:"".\n*   Below this text box, there are four smaller text boxes, each containing a key labeled ""Key 1"", ""Key 2"", ""Key 3"", and ""Key 4"".\n*   Each key has a corresponding input field where users can enter their 128-bit hexadecimal value.\n*   A checkbox labeled ""Input value as big endian format"" is located below the input fields.\n*   At the bottom of the program, there is a preview section displaying the converted 32-bit hexadecimal value.\n\n**Program Functionality:**\n\n*   The program is designed to take a 128-bit hexadecimal value as input and convert it into a 32-bit hexadecimal value.\n*   The user can enter their 128-bit hexadecimal value in the input fields and select the ""Input value as big endian format"" checkbox if necessary.\n*   Once the user clicks the ""Preview"" button, the program will display the converted 32-bit hexadecimal value in the preview section.\n\n**Program Purpose:**\n\n*   The purpose of this program is to provide a convenient way for users to convert 128-bit hexadecimal values into 32-bit hexadecimal values.\n*   This can be useful in various applications, such as data encryption, compression, and storage.\n\n**Program Limitations:**\n\n*   The program only supports 128-bit hexadecimal values as input.\n*   The program does not provide any error handling or validation for invalid input.\n*   The program does not offer any advanced features or options for customizing the conversion process.\n\nOverall, the program is a simple and straightforward tool for converting 128-bit hexadecimal values into 32-bit hexadecimal values. While it has some limitations, it can still be a useful resource for users who need to perform this type of conversion.', 'The image shows a screenshot of an authentication window. The window is titled ""Authentication"" and has a gray background with black text. \n\n*   The title bar at the top of the window has a small icon on the left side, which appears to be a yellow and gray square with a white arrow pointing to the right. To the right of the icon is the word ""Authentication"" in gray text.\n*   Below the title bar are two lines of text: ""Authentication Code"" and ""ID Code:"". The ""Authentication Code"" line is in bold black text, while the ""ID Code:"" line is in regular black text.\n*   Underneath the ""ID Code:"" line is a text box with the ID code ""FFEDDCBBA998877665554493221100"" typed into it.\n*   Below the text box are two buttons: ""Auto Authentication"" and ""OK"". The ""Auto Authentication"" button is a checkbox, while the ""OK"" button is a rectangular button with a blue outline.\n*   In the top-right corner of the window is a small ""X"" button, which likely closes the window when clicked.\n\nOverall, the image appears to be a screenshot of an authentication window, possibly from a computer program or application. The window is asking for an authentication code and has options for auto-authentication and a ""OK"" button to proceed.', 'The image shows a screenshot of the Renesas Flash Programmer software, with various settings and options displayed. The software is open on a computer screen, and the user is in the process of configuring the device.\n\n*   **Device Authentication**\n    *   The device authentication settings are highlighted in yellow.\n    *   The ""Device Authentication"" tab is selected, and the ""Settings..."" button is clicked.\n    *   A pop-up window appears with the ""Authentication Codes"" section.\n    *   The ""General"" tab is selected, and the ""Auto Authentication"" checkbox is checked.\n    *   The ""ID Code"" field is filled in with a unique code.\n    *   The ""Yes"" button is clicked to confirm the settings.\n*   **Operation Settings**\n    *   The operation settings are displayed below the device authentication settings.\n    *   The ""Operation Settings"" tab is selected, and the ""Block Settings"" section is highlighted in yellow.\n    *   The ""Connect Settings"" section is also highlighted in yellow.\n    *   The ""Communication"" section is displayed, with options for the tool, interface, speed, and power.\n    *   The ""Tool"" dropdown menu is set to ""E2 emulator Lite"".\n    *   The ""Interface"" dropdown menu is set to ""2 wire UART"".\n    *   The ""Speed"" field is set to ""1,000,000 bps"".\n    *   The ""Power"" dropdown menu is set to ""None"".\n*   **File Menu**\n    *   The file menu is displayed at the top of the screen.\n    *   The ""File"" dropdown menu is selected, and the ""Target Device"" option is highlighted in yellow.\n    *   The ""Help"" option is also highlighted in yellow.\n\nOverall, the image shows the user configuring the device authentication settings and operation settings in the Renesas Flash Programmer software. The user has selected the ""Device Authentication"" tab and clicked the ""Settings..."" button to access the ""Authentication Codes"" section. They have also selected the ""Operation Settings"" tab and highlighted the ""Block Settings"" and ""Connect Settings"" sections. The user has set the tool to ""E2 emulator Lite"", the interface to ""2 wire UART"", the speed to ""1,000,000 bps"", and the power to ""None"". Finally, the user has selected the ""File"" dropdown menu and highlighted the ""Target Device"" and ""Help"" options.', 'The image depicts a screenshot of a computer window with the title ""Authentication"" at the top left. The window is divided into two sections: the top section contains the title and a small icon, while the bottom section features a text box labeled ""Authentication Code"" and a button labeled ""OK"".\n\nThe ""Authentication Code"" text box is highlighted in yellow, indicating that it is the focus of the window. Below the text box, there is a checkbox labeled ""Auto Authentication"", which is unchecked. To the right of the checkbox, there is a button labeled ""Cancel"".\n\nIn the top-right corner of the window, there is a small ""X"" button, which is likely used to close the window. The background of the window is a light gray color, providing a clean and neutral visual environment for the user to interact with the authentication code.\n\nOverall, the image suggests that the user is being prompted to enter an authentication code to access a particular system or application. The presence of the ""Auto Authentication"" checkbox and the ""Cancel"" button implies that the user has the option to automatically authenticate or cancel the authentication process altogether.', 'The image shows a screenshot of the Renesas Flash Programmer software, with the ""Device Authentication"" window open. The window is divided into two sections: the top section displays the settings for the device, and the bottom section shows the authentication codes.\n\n*   **Top Section:**\n    *   **Operation Settings:** The operation settings are set to ""E2 emulator Lite"".\n    *   **Interface:** The interface is set to ""2 wire UART"".\n    *   **Speed:** The speed is set to 1,000,000 bps.\n    *   **Tool Details:** The tool details are set to ""Num: AutoSelect Power: None"".\n*   **Bottom Section:**\n    *   **Authentication Codes:** The authentication codes are displayed in a text box, with the following values:\n        *   General: Auto Authentication\n        *   ID Code: Yes\n        *   ID Code: 414C6532415345FFFFFFFFFFF\n\nThe image suggests that the user is attempting to authenticate a device using the Renesas Flash Programmer software. The authentication codes are displayed in a text box, and the user must enter the correct code to complete the authentication process.']"
4d17671567f62cc5962bcb0d85084af8,"Question:
Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP?
Answer:
You can find the ADPCM tool in the sample code of “RX62N Group ADPCM Audio Compression Record and Playback (R01AN0698)”. This tool can convert WAVE data to PCM data, and can convert WAVE data to ADPCM data. See ""9. Single File Audio Format Conversion GUI"" in the application note.
  Suitable Products
RA/FSP
Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP?
Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP?
Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP?
Answer:
You can find the ADPCM tool in the sample code of “RX62N Group ADPCM Audio Compression Record and Playback (R01AN0698)”. This tool can convert WAVE data to PCM data, and can convert WAVE data to ADPCM data. See ""9. Single File Audio Format Conversion GUI"" in the application note.
  Suitable Products
RA/FSP
You can find the ADPCM tool in the sample code of “RX62N Group ADPCM Audio Compression Record and Playback (R01AN0698)”. This tool can convert WAVE data to PCM data, and can convert WAVE data to ADPCM data. See ""9. Single File Audio Format Conversion GUI"" in the application note.
You can find the ADPCM tool in the sample code of “RX62N Group ADPCM Audio Compression Record and Playback (R01AN0698)”. This tool can convert WAVE data to PCM data, and can convert WAVE data to ADPCM data. See ""9. Single File Audio Format Conversion GUI"" in the application note.
Suitable Products
RA/FSP",['data/categories/ra_family/rafsp_knowledge_base/4d17671567f62cc5962bcb0d85084af8/images/cbfb37090cb812b1d09214a4e80fcb59.png'],[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'RA Family: Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP?', 'url': 'https://en-support.renesas.com/knowledgeBase/21177413', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:44.419412'}","Question Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP? Answer You can find the ADPCM tool in the sample code of RX62N Group ADPCM Audio Compression Record and Playback (R01AN0698). This tool can convert WAVE data to PCM data, and can convert WAVE data to ADPCM data. See ""9. Single File Audio Format Conversion GUI"" in the application note. Suitable Products RA/FSP Suitable Products","['The image shows a screenshot of a computer program with a blue bar at the top that reads ""ARPCM Tool"" in white text. The program is open on a grey background, and the window has a title bar with a yellow icon in the top-left corner.\n\nBelow the title bar, there are several options listed in a dropdown menu:\n\n*   **PCM/ADPCM File Format**\n    *   Binary\n    *   Text\n*   **Conversion Type**\n    *   Create PCM (WAVE = > PCM)\n    *   Encode (WAVE = > ADPCM)\n    *   Decode (ADPCM = > WAVE)\n*   **Sample Rate Fulfilled in Decoding**\n    *   11.025 kHz\n    *   8.000 kHz\n    *   11.025 kHz\n    *   22.050 kHz\n    *   44.100 kHz\n    *   48.000 kHz\n\nThe program appears to be a tool for converting audio files between different formats, such as PCM and ADPCM. The user can select the desired conversion type and sample rate from the dropdown menus.']"
d4911ae109dcb672b6288191a7fb62ce,"Question:
How to change the QSPI flash memory pin settings when using J-Link?
Answer:
After connecting the target board by using J-Link, start the J-Link Control Panel. The J-Link Web control panel will open in your browser. Change the External QSPI flash pins in the flash menu as shown below.
Suitable Products
RA/FSP
How to change the QSPI flash memory pin settings when using J-Link?
How to change the QSPI flash memory pin settings when using J-Link?
Answer:
After connecting the target board by using J-Link, start the J-Link Control Panel. The J-Link Web control panel will open in your browser. Change the External QSPI flash pins in the flash menu as shown below.
Suitable Products
RA/FSP
After connecting the target board by using J-Link, start the J-Link Control Panel. The J-Link Web control panel will open in your browser. Change the External QSPI flash pins in the flash menu as shown below.
After connecting the target board by using J-Link, start the J-Link Control Panel. The J-Link Web control panel will open in your browser. Change the External QSPI flash pins in the flash menu as shown below.
Suitable Products
RA/FSP","['data/categories/ra_family/rafsp_knowledge_base/d4911ae109dcb672b6288191a7fb62ce/images/d6816c97df5fb8d42c699c323f1e1352.png', 'data/categories/ra_family/rafsp_knowledge_base/d4911ae109dcb672b6288191a7fb62ce/images/5f548d10f7040c146bf84a1cf50e8f55.png']",[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'RA Family: How to change the QSPI flash memory pin settings when using J-Link?', 'url': 'https://en-support.renesas.com/knowledgeBase/21177416', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:49.812098'}","Question How to change the QSPI flash memory pin settings when using J-Link? Answer After connecting the target board by using J-Link, start the J-Link Control Panel. The J-Link Web control panel will open in your browser. Change the External QSPI flash pins in the flash menu as shown below. Suitable Products RA/FSP","['The image shows a screenshot of a Windows Explorer window displaying a list of files and folders. The window is titled ""SEGGER - J-Link V7.92n"" and has a yellow folder icon in the top-left corner. Below the title, there are several files and folders listed, including:\n\n* J-Flash Lite V7.92n\n* J-Flash SPI V7.92n\n* J-Flash V7.92n\n* J-Link Commander V7.92n\n* J-Link Configurator V7.92n\n* J-Link Control Panel V7.92n\n* J-Link DLL Updater V7.92n\n* J-Link GDB Server V7.92n\n\nThe background of the window is dark gray, and the text is white. The overall appearance of the image suggests that it is a screenshot of a computer program or software application, possibly related to programming or development.', 'The image shows a screenshot of the J-Link Web control panel, specifically the ""Flash"" tab. The panel is divided into two main sections: the top section displays the menu bar and the bottom section displays the flash banks.\n\n**Menu Bar:**\n\n*   The menu bar is located at the top of the image and contains the following options:\n    *   General\n    *   Settings\n    *   Commander\n    *   Breakpoints\n    *   Flash\n    *   CPU Regs\n    *   RTT\n    *   Target Power\n    *   SWV\n    *   RAWTrace\n    *   Trace\n    *   Log\n    *   Help\n\n**Flash Banks:**\n\n*   The flash banks section is located below the menu bar and contains the following information:\n    *   Base Address: This column displays the base address of each flash bank.\n    *   Name: This column displays the name of each flash bank.\n    *   Loader: This column displays the loader used for each flash bank.\n    *   Size: This column displays the size of each flash bank in bytes.\n    *   Sectorization: This column displays the sectorization of each flash bank.\n    *   External QSPI flash: This column displays the external QSPI flash information for each flash bank.\n\n**External QSPI Flash:**\n\n*   The external QSPI flash section is located below the flash banks section and contains the following information:\n    *   Base Address: This column displays the base address of the external QSPI flash.\n    *   Name: This column displays the name of the external QSPI flash.\n    *   Loader: This column displays the loader used for the external QSPI flash.\n    *   Size: This column displays the size of the external QSPI flash in bytes.\n    *   Sectorization: This column displays the sectorization of the external QSPI flash.\n\n**Cache:**\n\n*   The cache section is located below the external QSPI flash section and contains the following information:\n    *   Base Address: This column displays the base address of the cache.\n    *   Name: This column displays the name of the cache.\n    *   Loader: This column displays the loader used for the cache.\n    *   Size: This column displays the size of the cache in bytes.\n    *   Sectorization: This column displays the sectorization of the cache.\n\n**Range:**\n\n*   The range section is located below the cache section and contains the following information:\n    *   Start Address: This column displays the start address of the range.\n    *   End Address: This column displays the end address of the range.\n    *   Size: This column displays the size of the range in bytes.\n\nOverall, the image provides a detailed view of the J-Link Web control panel\'s ""Flash"" tab, which allows users to manage and configure the flash memory of their device.']"
b81ba8ce217ee3a82fe49074afa7a178,"Some RA devices have available the USB boot mode. The USB boot mode is a state where the on-chip flash memory routine (USB boot program), stored in the boot area within the MCU is used.
In this mode the on-chip flash, including the code and data flash memory, can be modified from outside the MCU by using USB.
To put the MCU on this state you need to drive the MD pin (P201) to low level. The example on this FAQ uses the EK-RA4M2. To drive the MD pin to low on EK-RA4M2 you need to close jumper J16.
The MCU will start in USB boot mode, if the MD pin is held low on release from reset state.
To use the USB boot mode the USB Full Speed Port, must be used. On EK-RA4M2 you need to:
Press the reset button and as soon as you release the button the MCU will start in USB boot mode.
In device manager you should see a COM port recognized as RA USB Boot CDC.
In Renesas Flash Programmer create a new project and in Communication Settings select the COM port recognized as shown below:
And then you can select your image file to program the MCU, while being in boot mode through RFP using the USB Full Speed.
You can download Renesas Flash Programmer and it's User's Manual from here:
https://www.renesas.com/en/software-tool/renesas-flash-programmer-programming-gui
Suitable Products
RA Family, RFP
Suitable Products
RA Family, RFP
RA Family, RFP","['data/categories/ra_family/rafsp_knowledge_base/b81ba8ce217ee3a82fe49074afa7a178/images/ef8fed64e0402a6014add2a65043aec3.png', 'data/categories/ra_family/rafsp_knowledge_base/b81ba8ce217ee3a82fe49074afa7a178/images/634062737dc677a0544c409a10ebf216.png', 'data/categories/ra_family/rafsp_knowledge_base/b81ba8ce217ee3a82fe49074afa7a178/images/9cbf530cd478a4ebca53a63fd65a981c.png', 'data/categories/ra_family/rafsp_knowledge_base/b81ba8ce217ee3a82fe49074afa7a178/images/eb2a879b1c90cef46786436b1f5a7303.png', 'data/categories/ra_family/rafsp_knowledge_base/b81ba8ce217ee3a82fe49074afa7a178/images/e85e47e2b44524ae97b6e2bca25e84c1.png']",[],[],"{'title': 'Using USB Boot with RA and RFP', 'url': 'https://en-support.renesas.com/knowledgeBase/21678358', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:04.541448'}","Some RA devices have available the USB boot mode. The USB boot mode is a state where the on-chip flash memory routine (USB boot program), stored in the boot area within the MCU is used. In this mode the on-chip flash, including the code and data flash memory, can be modified from outside the MCU by using USB. To put the MCU on this state you need to drive the MD pin (P201) to low level. The example on this FAQ uses the EK-RA4M2. To drive the MD pin to low on EK-RA4M2 you need to close jumper J16. The MCU will start in USB boot mode, if the MD pin is held low on release from reset state. To use the USB boot mode the USB Full Speed Port, must be used. On EK-RA4M2 you need to Press the reset button and as soon as you release the button the MCU will start in USB boot mode. In device manager you should see a COM port recognized as RA USB Boot CDC. In Renesas Flash Programmer create a new project and in Communication Settings select the COM port recognized as shown below And then you can select your image file to program the MCU, while being in boot mode through RFP using the USB Full Speed. You can download Renesas Flash Programmer and it's User's Manual from here https//www.renesas.com/en/software-tool/renesas-flash-programmer-programming-gui Suitable Products RA Family, RFP","['The image presents a flowchart illustrating the mode-setting pin level and operating mode. The flowchart is divided into three main sections: Single-chip mode, SCI boot mode, and USB boot mode.\n\n*   **Single-chip mode**\n    *   MD = 1 and release RES pin\n    *   Release POR\n*   **SCI boot mode**\n    *   MD = 0 and release RES pin\n*   **USB boot mode**\n    *   RES pin or POR occurs\n\nThe flowchart provides a clear and concise visual representation of the different modes and their corresponding actions. It helps to understand the sequence of events that occur when the mode-setting pin level changes.', 'The image displays a screenshot of a computer\'s device manager, specifically showing the ""Ports (COM & LPT)"" and ""RA USB Boot(CDC) (COM15)"" sections.\n\n*   The top-left corner features a small icon resembling a computer port, accompanied by the text ""Ports (COM & LPT)"" in black font.\n*   Below this, there is another icon that looks like a USB drive, followed by the text ""RA USB Boot(CDC) (COM15)"" in red font.\n*   The background of the image is white.\n\nIn summary, the image shows a computer\'s device manager with two sections: ""Ports (COM & LPT)"" and ""RA USB Boot(CDC) (COM15)"". The first section has a computer port icon and black text, while the second section has a USB drive icon and red text. The background of the image is white.', 'The image shows a screenshot of a computer program, specifically a project creation window for a microcontroller. The window is titled ""Create New Project"" and has several fields and buttons for entering project information and selecting tools.\n\n*   **Project Information**\n    *   Microcontroller: RA\n    *   Project Name: USB_Boot_ra4m2\n    *   Project Folder: C:\\Users\\...\n*   **Communication**\n    *   Tool: COM port\n    *   Interface: 2 wire UART\n*   **Buttons**\n    *   Connect\n    *   Cancel\n\nThe window also has a red box around the ""Tool"" field, which is currently set to ""COM port"". This suggests that the user is creating a project for a microcontroller that communicates over a serial interface using the COM port.\n\nOverall, the image shows a simple and straightforward interface for creating a new project for a microcontroller. The user can easily enter the project name, select the microcontroller and communication tool, and connect to the device.', 'The image shows a screenshot of the Renesas Flash Programmer V3.15.00 software, which is used to program and erase flash memory chips. The software is open on a computer screen, with various menus and options available for configuring the programmer.\n\n*   **Menu Bar**\n    *   The menu bar at the top of the window includes options such as ""File"", ""Target Device"", ""Help"", ""Operation"", ""Operation Settings"", ""Block Settings"", ""Flash Options"", ""Connect Settings"", and ""Unique Code"".\n*   **Project Information**\n    *   The ""Project Information"" section displays information about the current project, including the project name, current project, microcontroller, program and user key files, CRC-32, and command.\n*   **Command**\n    *   The ""Command"" section allows users to select from various commands, such as ""Erase"" and ""Program"", to perform operations on the flash memory chip.\n*   **Boot Firmware Version**\n    *   The ""Boot Firmware Version"" section displays the version of the boot firmware, which is currently set to V1.6.25.\n*   **Device Code**\n    *   The ""Device Code"" section displays the device code, which is currently set to 01.\n*   **Current State**\n    *   The ""Current State"" section displays the current state of the operation, which is currently set to ""SSD"".\n*   **NEC/PCD Key Injection**\n    *   The ""NEC/PCD Key Injection"" section displays the NEC/PCD key injection status, which is currently set to ""No"".\n*   **RMA Key Injection**\n    *   The ""RMA Key Injection"" section displays the RMA key injection status, which is currently set to ""No"".\n*   **Code Flash**\n    *   The ""Code Flash"" section displays information about the code flash, including the address, size, erase size, and erase status.\n*   **Data Flash**\n    *   The ""Data Flash"" section displays information about the data flash, including the address, size, erase size, and erase status.\n*   **Config Area**\n    *   The ""Config Area"" section displays information about the config area, including the address, size, erase size, and erase status.\n*   **Operation Completed**\n    *   The ""Operation Completed"" section displays a message indicating that the operation has been completed successfully.\n\nOverall, the image shows a screenshot of the Renesas Flash Programmer V3.15.00 software, which is used to program and erase flash memory chips. The software provides various menus and options for configuring the programmer, as well as displaying information about the current project and operation.', 'The image shows a computer screen displaying a code flash operation. The top of the screen has a gray bar with a vertical gray bar on the right side, and a gray box with a downward-pointing arrow in the bottom-right corner.\n\nBelow the gray bar, there is a white box with black text that reads:\n\n""Code Flash 1] 0x00000000 - 0x0000B7F size : 2.9 K""\n\nUnderneath this, there are several lines of text that appear to be a list of commands or operations being performed on the target device. The text is written in a monospaced font and includes various symbols and abbreviations, such as ""Config Area"" and ""size"".\n\nAt the bottom of the screen, there is a message that reads:\n\n""Disconnecting the tool!""\n\nBelow this, there is another message that reads:\n\n""Operation completed.""\n\nOverall, the image suggests that the code flash operation has been completed successfully, and the tool is now disconnecting from the target device.']"
66234f2936f314c9c9369acbfed185a1,"Question:
How to change the pin configuration at run time
Answer:
To change pin settings at run time, you need to add configuration data for the pin settings you want to change, and then set that data in the pinsCfg API of the I/O Port HAL Driver. The following is an example showing how to set pins for the IIC0 at run time.
1. Create a new pin configuration
In the Pin Configuration window, click ""Manage configurations... "" to display the “Manage Pin Configurations"" dialog.  In the dialog, click Add button to display “Configuration Name"" dialog. In the dialog, enter any name (e.g. New_IIC0) for the new configuration. Then click the OK button.
  2. Create the configuration forthe pin to be changed
In ""Select Pin Configuration"", select the newly created pin configuration above, and set the pin configuration of IIC0. Check the checkbox for ""Generate data:"" and input variable name for the new configuration data to the text box (e.g. g_bsp_pin_cfg_iic0). In the pin configuration, DEBUG0 is not required, so set it to Disabled. After setting up, click Generate Project Content.
Add pin setting for IIC0
  Remove pin settings for DEBUG0
  3. Confirm pin configuration data
Confirm that the data for the pin configuration added above is generated in ra_gen/pin_data.c as the specified variable.
4. Implementation of pin configuration change processing
Add the API call to set the pin configuration data created above to the application as follows.
/* Change pin configuration */
R_IOPORT_PinsCfg(&g_ioport_ctrl, &g_bsp_pin_cfg_iic0);
Suitable Products
RA and FSP
How to change the pin configuration at run time
How to change the pin configuration at run time
Answer:
To change pin settings at run time, you need to add configuration data for the pin settings you want to change, and then set that data in the pinsCfg API of the I/O Port HAL Driver. The following is an example showing how to set pins for the IIC0 at run time.
1. Create a new pin configuration
In the Pin Configuration window, click ""Manage configurations... "" to display the “Manage Pin Configurations"" dialog.  In the dialog, click Add button to display “Configuration Name"" dialog. In the dialog, enter any name (e.g. New_IIC0) for the new configuration. Then click the OK button.
  2. Create the configuration forthe pin to be changed
In ""Select Pin Configuration"", select the newly created pin configuration above, and set the pin configuration of IIC0. Check the checkbox for ""Generate data:"" and input variable name for the new configuration data to the text box (e.g. g_bsp_pin_cfg_iic0). In the pin configuration, DEBUG0 is not required, so set it to Disabled. After setting up, click Generate Project Content.
Add pin setting for IIC0
  Remove pin settings for DEBUG0
  3. Confirm pin configuration data
Confirm that the data for the pin configuration added above is generated in ra_gen/pin_data.c as the specified variable.
4. Implementation of pin configuration change processing
Add the API call to set the pin configuration data created above to the application as follows.
/* Change pin configuration */
R_IOPORT_PinsCfg(&g_ioport_ctrl, &g_bsp_pin_cfg_iic0);
Suitable Products
RA and FSP
To change pin settings at run time, you need to add configuration data for the pin settings you want to change, and then set that data in the pinsCfg API of the I/O Port HAL Driver. The following is an example showing how to set pins for the IIC0 at run time.
1. Create a new pin configuration
In the Pin Configuration window, click ""Manage configurations... "" to display the “Manage Pin Configurations"" dialog.  In the dialog, click Add button to display “Configuration Name"" dialog. In the dialog, enter any name (e.g. New_IIC0) for the new configuration. Then click the OK button.
  2. Create the configuration forthe pin to be changed
In ""Select Pin Configuration"", select the newly created pin configuration above, and set the pin configuration of IIC0. Check the checkbox for ""Generate data:"" and input variable name for the new configuration data to the text box (e.g. g_bsp_pin_cfg_iic0). In the pin configuration, DEBUG0 is not required, so set it to Disabled. After setting up, click Generate Project Content.
Add pin setting for IIC0
  Remove pin settings for DEBUG0
  3. Confirm pin configuration data
Confirm that the data for the pin configuration added above is generated in ra_gen/pin_data.c as the specified variable.
4. Implementation of pin configuration change processing
Add the API call to set the pin configuration data created above to the application as follows.
/* Change pin configuration */
R_IOPORT_PinsCfg(&g_ioport_ctrl, &g_bsp_pin_cfg_iic0);
To change pin settings at run time, you need to add configuration data for the pin settings you want to change, and then set that data in the pinsCfg API of the I/O Port HAL Driver. The following is an example showing how to set pins for the IIC0 at run time.
1. Create a new pin configuration
In the Pin Configuration window, click ""Manage configurations... "" to display the “Manage Pin Configurations"" dialog.  In the dialog, click Add button to display “Configuration Name"" dialog. In the dialog, enter any name (e.g. New_IIC0) for the new configuration. Then click the OK button.
2. Create the configuration forthe pin to be changed
In ""Select Pin Configuration"", select the newly created pin configuration above, and set the pin configuration of IIC0. Check the checkbox for ""Generate data:"" and input variable name for the new configuration data to the text box (e.g. g_bsp_pin_cfg_iic0). In the pin configuration, DEBUG0 is not required, so set it to Disabled. After setting up, click Generate Project Content.
Add pin setting for IIC0
Remove pin settings for DEBUG0
3. Confirm pin configuration data
Confirm that the data for the pin configuration added above is generated in ra_gen/pin_data.c as the specified variable.
4. Implementation of pin configuration change processing
Add the API call to set the pin configuration data created above to the application as follows.
Suitable Products
RA and FSP
Go to Japanese
Go to Japanese","['data/categories/ra_family/rafsp_knowledge_base/66234f2936f314c9c9369acbfed185a1/images/7e94ef95521b98bd714fea56642fef6b.png', 'data/categories/ra_family/rafsp_knowledge_base/66234f2936f314c9c9369acbfed185a1/images/360ebfa84b5b568eb5f1a4db2115f711.png', 'data/categories/ra_family/rafsp_knowledge_base/66234f2936f314c9c9369acbfed185a1/images/6d6e129fcf2ce0199dc6805c5fe6b2e7.png', 'data/categories/ra_family/rafsp_knowledge_base/66234f2936f314c9c9369acbfed185a1/images/d03be10b8be848523e16f947d8e526aa.png']",[],['|  |\n|  |\n| RA and FSP |'],"{'title': 'RA Family: How to change the pin configuration at run time', 'url': 'https://en-support.renesas.com/knowledgeBase/20481444', 'last_updated': None, 'extracted_at': '2025-03-08T23:18:39.686443'}","Question How to change the pin configuration at run time Answer To change pin settings at run time, you need to add configuration data for the pin settings you want to change, and then set that data in the pinsCfg API of the I/O Port HAL Driver. The following is an example showing how to set pins for the IIC0 at run time. 1. Create a new pin configuration In the Pin Configuration window, click ""Manage configurations... "" to display the Manage Pin Configurations"" dialog. In the dialog, click Add button to display Configuration Name"" dialog. In the dialog, enter any name (e.g. NewIIC0) for the new configuration. Then click the OK button. 2. Create the configuration forthe pin to be changed In ""Select Pin Configuration"", select the newly created pin configuration above, and set the pin configuration of IIC0. Check the checkbox for ""Generate data"" and input variable name for the new configuration data to the text box (e.g. gbsppincfgiic0). In the pin configuration, DEBUG0 is not required, so set it to Disabled. After setting up, click Generate Project Content. Add pin setting for IIC0 Remove pin settings for DEBUG0 3. Confirm pin configuration data Confirm that the data for the pin configuration added above is generated in ragen/pindata.c as the specified variable. 4. Implementation of pin configuration change processing Add the API call to set the pin configuration data created above to the application as follows. / Change pin configuration / RIOPORTPinsCfg(gioportctrl, gbsppincfgiic0); Suitable Products RA and FSP 2. Create the configuration forthe pin to be changed Remove pin settings for DEBUG0 3. Confirm pin configuration data Go to Japanese","['The image shows a screenshot of a computer program with a light blue header and white body. The header has the title ""Pin Configuration"" in black text on the left side, and ""Generate Project Content"" in blue text on the right side. Below the header, there are several sections with different functions.\n\n*   **Select Pin Configuration**: This section allows users to select a pin configuration from a dropdown menu.\n*   **Pin Selection**: This section displays a list of available pins, with checkboxes next to each one. The user can select multiple pins by checking the boxes.\n*   **Pin Configuration**: This section provides a table with columns for ""Name"", ""Value"", ""Lock"", and ""Link"". The user can enter values in the ""Name"" and ""Value"" columns, and select options from the ""Lock"" and ""Link"" dropdown menus.\n*   **Multiple Pin Configuration Management**: This section allows users to modify the pin configuration list or import/export external files.\n*   **Configuration Name**: This section allows users to enter a name for the configuration.\n*   **New name**: This section allows users to enter a new name for the configuration.\n*   **OK**: This button is used to save the changes made to the configuration.\n\nOverall, the image shows a user-friendly interface for configuring pins in a computer program. The user can select multiple pins, enter values, and modify the pin configuration list or import/export external files.', 'The image shows a screenshot of a computer program with a light blue background and a white text box. The title at the top reads ""Pin Configuration"" in black text.\n\nBelow the title, there are several sections with different headings, including ""Select Pin Configuration"", ""Pin Selection"", and ""Pin Configuration"". Each section has a list of options or settings that can be adjusted.\n\nIn the ""Select Pin Configuration"" section, there is a dropdown menu with the option ""New IIC0"" selected. In the ""Pin Selection"" section, there is a list of pins with checkboxes next to them. The ""Pin Configuration"" section has a table with columns for ""Name"", ""Value"", ""Lock"", and ""Link"".\n\nThe overall design of the program appears to be user-friendly and easy to navigate, with clear headings and concise labels. The use of different colors and fonts helps to distinguish between different sections and options, making it easier for the user to focus on the relevant information.', 'The image shows a screenshot of a computer program with a light blue background and white text. The title at the top reads ""Pin Configuration"" in black text.\n\nBelow the title, there are several sections:\n\n*   **Select Pin Configuration**: This section has a dropdown menu with the option ""New_IIC0"" selected.\n*   **Pin Selection**: This section has a list of pins with checkboxes next to them. The pins are listed in a table format, with columns for ""Type filter text"", ""Name"", ""Value"", ""Lock"", and ""Link"". The pins are:\n    *   Storage:SDHI\n    *   System:BUS\n    *   System:CGC\n    *   System:DEBUG\n    *   DEBUG0\n    *   System:TRACE\n    *   Timer:AGT\n    *   Timer:GPT\n    *   Timer:OPS\n*   **Pin Configuration**: This section has a table with columns for ""Name"", ""Value"", ""Lock"", and ""Link"". The pins are listed in the same order as in the ""Pin Selection"" section. The ""Value"" column shows the current value of each pin, which is mostly ""Disabled"".\n*   **Generate data**: This section has a checkbox next to the text ""g_bsp_pin_cfg_iic0"". The checkbox is checked.\n\nOverall, the image appears to be a screenshot of a computer program used for configuring pins on a microcontroller or other electronic device. The program allows users to select which pins to use, set their values, and lock or unlock them.', 'The image presents a code snippet in C programming language, specifically focusing on the configuration of pins for a microcontroller. The code is written in a clear and concise manner, with each line dedicated to a specific task.\n\n**Code Structure**\n\nThe code is divided into two main sections:\n\n1. **Pin Configuration**: The first section configures the pins for the microcontroller. It sets the direction of the pins, enabling them to be used as input or output.\n2. **Pin Initialization**: The second section initializes the pins, setting their initial state to a specific value.\n\n**Key Features**\n\n* **Pin Configuration**: The code uses the `pin_config` function to configure the pins. This function takes two arguments: the pin number and the direction (input or output).\n* **Pin Initialization**: The code uses the `pin_init` function to initialize the pins. This function takes two arguments: the pin number and the initial state (high or low).\n* **Pin Numbers**: The code uses specific pin numbers, such as `IO_PORT_04_PIN_00` and `IO_PORT_04_PIN_01`, to configure and initialize the pins.\n* **Direction and State**: The code sets the direction of the pins to input or output and initializes them to a specific state (high or low).\n\n**Conclusion**\n\nIn summary, the code snippet demonstrates how to configure and initialize pins for a microcontroller using the C programming language. It provides a clear and concise example of how to use the `pin_config` and `pin_init` functions to set up the pins for input or output operations.']"
19ceb21a03c55ecaf0dd56dbe4f4b506,"Answer:
The attached sample reference application generates an RSA self-signed x509 certificate by leveraging FSP middleware MbedTLS stack and RSIP IP of RA on the EK-RA8M1 board.
Below are the list of operations that can be verified using the sample application -
The Sample application basically utilizes the MbedTLS stack with the underlying SCE as RSIP to generate the RSA 3K bits pair of keys and can also generate the 2K bits pair of keys by defining RSA_2048_BITS_KEY macro in the file “crypto_ep.h”. This application can be further explored to generate 4K keys pair as well in the RA8.
It utilizes the MbedTLS “x509write_crt” feature to generate a self-signed certificate in PEM or DER format by defining MBEDTLS_X509_FORMAT_PEM or MBEDTLS_X509_FORMAT_DER respectively in the function “gen_certificates” of the file “create_cert.c”.
It utilizes the MbedTLS “x509_cert” feature to parse the certificate in PEM or DER format and display basic parameter in the RTT Viewer as can be seen below –
Example DER certificate in RTT viewer –
Example PEM certificate in RTT viewer –
To verify the generated PEM certificate, just copy the raw PEM data to online tool (example - https://certlogik.com/decoder/) to parse the certificate.
Example of PEM certificates decode via online tool –
Details of sample project:
Board:             EK-RA8M1
FSP:                v5.5.0 or later
IDE:                 e2studio - 2024-07 (24.7.0) or later
Compiler:        GCC - 12.2.1.arm-12-mpacbti-34 or later
Suitable Products
RA8M1, RA8D1, RA8T1
Answer:
The attached sample reference application generates an RSA self-signed x509 certificate by leveraging FSP middleware MbedTLS stack and RSIP IP of RA on the EK-RA8M1 board.
Below are the list of operations that can be verified using the sample application -
The Sample application basically utilizes the MbedTLS stack with the underlying SCE as RSIP to generate the RSA 3K bits pair of keys and can also generate the 2K bits pair of keys by defining RSA_2048_BITS_KEY macro in the file “crypto_ep.h”. This application can be further explored to generate 4K keys pair as well in the RA8.
It utilizes the MbedTLS “x509write_crt” feature to generate a self-signed certificate in PEM or DER format by defining MBEDTLS_X509_FORMAT_PEM or MBEDTLS_X509_FORMAT_DER respectively in the function “gen_certificates” of the file “create_cert.c”.
It utilizes the MbedTLS “x509_cert” feature to parse the certificate in PEM or DER format and display basic parameter in the RTT Viewer as can be seen below –
Example DER certificate in RTT viewer –
Example PEM certificate in RTT viewer –
To verify the generated PEM certificate, just copy the raw PEM data to online tool (example - https://certlogik.com/decoder/) to parse the certificate.
Example of PEM certificates decode via online tool –
Details of sample project:
Board:             EK-RA8M1
FSP:                v5.5.0 or later
IDE:                 e2studio - 2024-07 (24.7.0) or later
Compiler:        GCC - 12.2.1.arm-12-mpacbti-34 or later
Suitable Products
RA8M1, RA8D1, RA8T1
The attached sample reference application generates an RSA self-signed x509 certificate by leveraging FSP middleware MbedTLS stack and RSIP IP of RA on the EK-RA8M1 board.
Below are the list of operations that can be verified using the sample application -
The Sample application basically utilizes the MbedTLS stack with the underlying SCE as RSIP to generate the RSA 3K bits pair of keys and can also generate the 2K bits pair of keys by defining RSA_2048_BITS_KEY macro in the file “crypto_ep.h”. This application can be further explored to generate 4K keys pair as well in the RA8.
It utilizes the MbedTLS “x509write_crt” feature to generate a self-signed certificate in PEM or DER format by defining MBEDTLS_X509_FORMAT_PEM or MBEDTLS_X509_FORMAT_DER respectively in the function “gen_certificates” of the file “create_cert.c”.
It utilizes the MbedTLS “x509_cert” feature to parse the certificate in PEM or DER format and display basic parameter in the RTT Viewer as can be seen below –
Example DER certificate in RTT viewer –
Example PEM certificate in RTT viewer –
To verify the generated PEM certificate, just copy the raw PEM data to online tool (example - https://certlogik.com/decoder/) to parse the certificate.
Example of PEM certificates decode via online tool –
Details of sample project:
Board:             EK-RA8M1
FSP:                v5.5.0 or later
IDE:                 e2studio - 2024-07 (24.7.0) or later
Compiler:        GCC - 12.2.1.arm-12-mpacbti-34 or later
The attached sample reference application generates an RSA self-signed x509 certificate by leveraging FSP middleware MbedTLS stack and RSIP IP of RA on the EK-RA8M1 board.
Below are the list of operations that can be verified using the sample application -
Example DER certificate in RTT viewer –
Example PEM certificate in RTT viewer –
Example of PEM certificates decode via online tool –
Details of sample project:
Suitable Products
RA8M1, RA8D1, RA8T1
Japanese
Japanese","['data/categories/ra_family/rafsp_knowledge_base/19ceb21a03c55ecaf0dd56dbe4f4b506/images/2290ce30b1d74b28d71b47a7ca70055d.png', 'data/categories/ra_family/rafsp_knowledge_base/19ceb21a03c55ecaf0dd56dbe4f4b506/images/bd789e7e1d26a94e2e1bd4e1b44909b6.png', 'data/categories/ra_family/rafsp_knowledge_base/19ceb21a03c55ecaf0dd56dbe4f4b506/images/dbd22d9341284afa7554c16209833ccd.png']",[],"['|  |\n|  |\n| RA8M1, RA8D1, RA8T1 |']","{'title': 'RA Family: How to generate self-signed x509 certificate using MbedTLS stack', 'url': 'https://en-support.renesas.com/knowledgeBase/21789660', 'last_updated': '2025-04-02', 'extracted_at': '2025-03-08T23:22:24.686098'}","Answer The attached sample reference application generates an RSA self-signed x509 certificate by leveraging FSP middleware MbedTLS stack and RSIP IP of RA on the EK-RA8M1 board. Below are the list of operations that can be verified using the sample application - The Sample application basically utilizes the MbedTLS stack with the underlying SCE as RSIP to generate the RSA 3K bits pair of keys and can also generate the 2K bits pair of keys by defining RSA2048BITSKEY macro in the file cryptoep.h. This application can be further explored to generate 4K keys pair as well in the RA8. It utilizes the MbedTLS x509writecrt feature to generate a self-signed certificate in PEM or DER format by defining MBEDTLSX509FORMATPEM or MBEDTLSX509FORMATDER respectively in the function gencertificates of the file createcert.c. It utilizes the MbedTLS x509cert feature to parse the certificate in PEM or DER format and display basic parameter in the RTT Viewer as can be seen below  Example DER certificate in RTT viewer  Example PEM certificate in RTT viewer  To verify the generated PEM certificate, just copy the raw PEM data to online tool (example - https//certlogik.com/decoder/) to parse the certificate. Example of PEM certificates decode via online tool  Details of sample project Board EK-RA8M1 FSP v5.5.0 or later IDE e2studio - 2024-07 (24.7.0) or later Compiler GCC - 12.2.1.arm-12-mpacbti-34 or later Suitable Products RA8M1, RA8D1, RA8T1 Japanese","['The image shows a screenshot of a terminal window displaying a list of commands and their outputs. The terminal window is open on a computer, with the title ""iLink RTT Viewer V7.96d"" at the top. The background of the terminal window is black, with white text.\n\nThe commands and their outputs are listed in a numbered format, starting from 00> and going up to 00>. The commands include:\n\n* Renesas FSP Example Project for mbed_crypto Module\n* Example Project Version 1.0\n* Flex Software Pack Version 5.5.0\n* Refer to readme.txt file for more details on Example Project and FSP User\'s Manual for more information about mbed_crypto driver\n* This Example Project demonstrates generation of RSA self-signed x509 certificate on EK-RABM1\n* RSA Operation Started\n* RSA Key Pair generated Successfully\n* print public key from RSA Instance:30821A282110ACCA7EB889C8365ACB3770E0CC95801D1F70ECB98098E\n* Key Information:\n\t+ cert. version : 3\n\t+ serial number : 31\n\t+ issuer name : CN=CA, O=embed TLS, C=UK\n\t+ subject name : CN=CA, O=embed TLS, C=UK\n\t+ issued on : 2030-12-31 23:59:59\n\t+ expires on : 2031-01-01 00:00:00\n\t+ signed using : RSA with SHA-256\n\t+ RSA key size : 2048 bits\n\t+ basic constraints : CA:true, max_pathlen=0\n* print public key from certificate:30821A282110ACCA7EB889C8365ACB3770E0CC95801D1F70ECB98098E5\n* gen_certificates Operations completed\n\nThe commands and their outputs suggest that the user is working with a cryptographic project, specifically generating RSA self-signed x509 certificates using the mbed_crypto driver. The output includes information about the certificate, such as its version, serial number, issuer name, subject name, and expiration date. The user has also printed the public key from the certificate and completed the generation of certificates operations.', 'The image shows a screenshot of a terminal window displaying a list of commands and their corresponding outputs. The terminal window is open on a computer, and the background is a light gray color.\n\n*   The terminal window is open on a computer.\n    *   The terminal window is open on a computer, as indicated by the presence of a command prompt and the ability to enter commands.\n*   The background is a light gray color.\n    *   The background of the terminal window is a light gray color, which provides a clean and neutral backdrop for the text.\n*   The terminal window displays a list of commands and their corresponding outputs.\n    *   The terminal window displays a list of commands and their corresponding outputs, which are displayed in a clear and readable format.\n*   The commands are displayed in a monospaced font.\n    *   The commands are displayed in a monospaced font, which makes it easy to read and understand the output.\n*   The output is displayed in a fixed-width font.\n    *   The output is displayed in a fixed-width font, which makes it easy to read and understand the output.\n*   The terminal window has a title bar with the text ""J-Link RTT Viewer V7.96d"".\n    *   The terminal window has a title bar with the text ""J-Link RTT Viewer V7.96d"", which indicates the name of the application and its version number.\n*   The terminal window has a menu bar with options for ""File"", ""Terminals"", ""Input"", ""Logging"", and ""Help"".\n    *   The terminal window has a menu bar with options for ""File"", ""Terminals"", ""Input"", ""Logging"", and ""Help"", which provide access to various features and functions of the application.\n\nOverall, the image shows a screenshot of a terminal window displaying a list of commands and their corresponding outputs, with a light gray background and a monospaced font. The terminal window has a title bar with the text ""J-Link RTT Viewer V7.96d"" and a menu bar with options for ""File"", ""Terminals"", ""Input"", ""Logging"", and ""Help"".', 'The image displays a screenshot of a computer screen displaying a certificate detailed information page. The page is titled ""Certificate Detailed Information"" in white text on a blue background at the top of the page.\n\nBelow the title, there are several sections of text that provide detailed information about the certificate, including:\n\n* **Certificate:** This section displays the version number, serial number, and signature algorithm used to create the certificate.\n* **Issuer:** This section lists the country name, organization name, and common name of the issuer of the certificate.\n* **Subject:** This section lists the country name, organization name, and common name of the subject of the certificate.\n* **Subject Public Key Info:** This section displays the public key algorithm and modulus used to create the certificate.\n* **X509v3 Basic Constraints:** This section lists the basic constraints of the certificate, including the critical extension and the path length constraint.\n* **Signature Algorithm:** This section lists the signature algorithm used to create the certificate.\n* **X509v3 Extended Key Usage:** This section lists the extended key usage of the certificate, including the critical extension and the key usage.\n\nThe background of the page is white, and the text is displayed in black. Overall, the image provides a detailed view of the certificate\'s information, which can be useful for verifying the authenticity and validity of the certificate.']"
7b999180cd3b3a17df5f6311b8cb98ea,"Question:
How to use the MCUboot logging function on FSP
Answer:
The MCUboot provides a logging function that allows you to output the running status and error information during image booting. This feature can be used to check the execution status of the bootloader.
The MCUboot logging function has trhe following four log levels.
MCUBOOT_LOG_ERR (Error)
MCUBOOT_LOG_WRN (Warning)
MCUBOOT_LOG_INF (Info)
MCUBOOT_LOG_DBG (Debug)
The below example shows how to use the MCUboot’s logging function on FSP.
Use of semi-hosting

By default, FSP implements the MCUboot logging feature using the printf() function defined in the standard I/O header (stdio.h). For use of semi-hosting as the output interface, the developer can use this implementation as is. It can be enabled by changing the Log Level to a level other than Off, in the MCUboot logging block properties on the Stack tab of the FSP configurator



The log levels available by the property settings of the MCUboot logging block are shown in the table below.
  Off Error Warning Info Debug
MCUBOOT_LOG_ERR - ✓ ✓ ✓ ✓
MCUBOOT_LOG_WRN - - ✓ ✓ ✓
MCUBOOT_LOG_INF - - - ✓ ✓
MCUBOOT_LOG_DBG
- - - - ✓
“✓”: Available, “-”: Not available

The developer should also apply the following changes required for semi-hosting to the project:
Add the initialization code for semi-hosting at the beginning of the program.
Resize the heap size to the appropriate size in the properties of the BSP tab.
Set the linker option ""--specs=rdimon.specs"" from C/C++ Build > Settings > Tool Settings > Cross ARM C Linker > Miscellaneous in the project properties.

Use of an output interface other than semi-hosting

To use an output interface other than semi-hosting, such as SEGGER J-Link RTT Viewer, the developer can apply any user-defined execution function by redefining the macro MCUBOOT_LOG_xxx with a new header file. The link of the created header file can be applied from the Common > General > Custom mcuboot_config.h in the MCUboot block properties on the Stacks tab.



For example, to output the information for MCUBOOT_LOG_ERR and MCUBOOT_LOG_INF to SEGGER J-Link RTT View, the developer will create a header file with references to the following and apply it to the MCUboot block properties. In this case, the log level selected in the MCUboot logging block on the FSP configurator is ignored.

mcuboot_config_custom.h
#include ""SEGGER_RTT/SEGGER_RTT.h""
#define MCUBOOT_LOG_ERR(_fmt, ...)  SEGGER_RTT_printf(0, ""[ERR] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_WRN(...)  IGNORE(__VA_ARGS__)
#define MCUBOOT_LOG_INF(_fmt, ...)  SEGGER_RTT_printf(0, ""[INF] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_DBG(...)  IGNORE(__VA_ARGS__)
Note: The MCUboot's logging feature may affect the performance of the MCUboot image boot process.
Suitable Products
RA and FSP
How to use the MCUboot logging function on FSP
How to use the MCUboot logging function on FSP
Answer:
The MCUboot provides a logging function that allows you to output the running status and error information during image booting. This feature can be used to check the execution status of the bootloader.
The MCUboot logging function has trhe following four log levels.
MCUBOOT_LOG_ERR (Error)
MCUBOOT_LOG_WRN (Warning)
MCUBOOT_LOG_INF (Info)
MCUBOOT_LOG_DBG (Debug)
The below example shows how to use the MCUboot’s logging function on FSP.
Use of semi-hosting

By default, FSP implements the MCUboot logging feature using the printf() function defined in the standard I/O header (stdio.h). For use of semi-hosting as the output interface, the developer can use this implementation as is. It can be enabled by changing the Log Level to a level other than Off, in the MCUboot logging block properties on the Stack tab of the FSP configurator



The log levels available by the property settings of the MCUboot logging block are shown in the table below.
  Off Error Warning Info Debug
MCUBOOT_LOG_ERR - ✓ ✓ ✓ ✓
MCUBOOT_LOG_WRN - - ✓ ✓ ✓
MCUBOOT_LOG_INF - - - ✓ ✓
MCUBOOT_LOG_DBG
- - - - ✓
“✓”: Available, “-”: Not available

The developer should also apply the following changes required for semi-hosting to the project:
Add the initialization code for semi-hosting at the beginning of the program.
Resize the heap size to the appropriate size in the properties of the BSP tab.
Set the linker option ""--specs=rdimon.specs"" from C/C++ Build > Settings > Tool Settings > Cross ARM C Linker > Miscellaneous in the project properties.

Use of an output interface other than semi-hosting

To use an output interface other than semi-hosting, such as SEGGER J-Link RTT Viewer, the developer can apply any user-defined execution function by redefining the macro MCUBOOT_LOG_xxx with a new header file. The link of the created header file can be applied from the Common > General > Custom mcuboot_config.h in the MCUboot block properties on the Stacks tab.



For example, to output the information for MCUBOOT_LOG_ERR and MCUBOOT_LOG_INF to SEGGER J-Link RTT View, the developer will create a header file with references to the following and apply it to the MCUboot block properties. In this case, the log level selected in the MCUboot logging block on the FSP configurator is ignored.

mcuboot_config_custom.h
#include ""SEGGER_RTT/SEGGER_RTT.h""
#define MCUBOOT_LOG_ERR(_fmt, ...)  SEGGER_RTT_printf(0, ""[ERR] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_WRN(...)  IGNORE(__VA_ARGS__)
#define MCUBOOT_LOG_INF(_fmt, ...)  SEGGER_RTT_printf(0, ""[INF] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_DBG(...)  IGNORE(__VA_ARGS__)
Note: The MCUboot's logging feature may affect the performance of the MCUboot image boot process.
Suitable Products
RA and FSP
The MCUboot provides a logging function that allows you to output the running status and error information during image booting. This feature can be used to check the execution status of the bootloader.
The MCUboot logging function has trhe following four log levels.
MCUBOOT_LOG_ERR (Error)
MCUBOOT_LOG_WRN (Warning)
MCUBOOT_LOG_INF (Info)
MCUBOOT_LOG_DBG (Debug)
The below example shows how to use the MCUboot’s logging function on FSP.
Use of semi-hosting

By default, FSP implements the MCUboot logging feature using the printf() function defined in the standard I/O header (stdio.h). For use of semi-hosting as the output interface, the developer can use this implementation as is. It can be enabled by changing the Log Level to a level other than Off, in the MCUboot logging block properties on the Stack tab of the FSP configurator



The log levels available by the property settings of the MCUboot logging block are shown in the table below.
  Off Error Warning Info Debug
MCUBOOT_LOG_ERR - ✓ ✓ ✓ ✓
MCUBOOT_LOG_WRN - - ✓ ✓ ✓
MCUBOOT_LOG_INF - - - ✓ ✓
MCUBOOT_LOG_DBG
- - - - ✓
“✓”: Available, “-”: Not available

The developer should also apply the following changes required for semi-hosting to the project:
Add the initialization code for semi-hosting at the beginning of the program.
Resize the heap size to the appropriate size in the properties of the BSP tab.
Set the linker option ""--specs=rdimon.specs"" from C/C++ Build > Settings > Tool Settings > Cross ARM C Linker > Miscellaneous in the project properties.

Use of an output interface other than semi-hosting

To use an output interface other than semi-hosting, such as SEGGER J-Link RTT Viewer, the developer can apply any user-defined execution function by redefining the macro MCUBOOT_LOG_xxx with a new header file. The link of the created header file can be applied from the Common > General > Custom mcuboot_config.h in the MCUboot block properties on the Stacks tab.



For example, to output the information for MCUBOOT_LOG_ERR and MCUBOOT_LOG_INF to SEGGER J-Link RTT View, the developer will create a header file with references to the following and apply it to the MCUboot block properties. In this case, the log level selected in the MCUboot logging block on the FSP configurator is ignored.

mcuboot_config_custom.h
#include ""SEGGER_RTT/SEGGER_RTT.h""
#define MCUBOOT_LOG_ERR(_fmt, ...)  SEGGER_RTT_printf(0, ""[ERR] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_WRN(...)  IGNORE(__VA_ARGS__)
#define MCUBOOT_LOG_INF(_fmt, ...)  SEGGER_RTT_printf(0, ""[INF] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_DBG(...)  IGNORE(__VA_ARGS__)
Note: The MCUboot's logging feature may affect the performance of the MCUboot image boot process.
The MCUboot provides a logging function that allows you to output the running status and error information during image booting. This feature can be used to check the execution status of the bootloader.
The MCUboot logging function has trhe following four log levels.
The below example shows how to use the MCUboot’s logging function on FSP.
MCUBOOT_LOG_DBG
“✓”: Available, “-”: Not available

The developer should also apply the following changes required for semi-hosting to the project:
Note: The MCUboot's logging feature may affect the performance of the MCUboot image boot process.
Suitable Products
RA and FSP
Go to Japanese
Go to Japanese","['data/categories/ra_family/rafsp_knowledge_base/7b999180cd3b3a17df5f6311b8cb98ea/images/a7bb6ffd472152fefff6a630494d8701.png', 'data/categories/ra_family/rafsp_knowledge_base/7b999180cd3b3a17df5f6311b8cb98ea/images/6fd16807f3b6ca0e8fd76db470da62c6.png', 'data/categories/ra_family/rafsp_knowledge_base/7b999180cd3b3a17df5f6311b8cb98ea/images/9ae95bc7101afe5dc0b7fa6a3ab5ba7a.png']",[],"['|  |\n|  |\n|  | Off | Error | Warning | Info | Debug |\n| MCUBOOT_LOG_ERR | - | ✓ | ✓ | ✓ | ✓ |\n| MCUBOOT_LOG_WRN | - | - | ✓ | ✓ | ✓ |\n| MCUBOOT_LOG_INF | - | - | - | ✓ | ✓ |\n| MCUBOOT_LOG_DBG | - | - | - | - | ✓ |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: How to use the MCUboot logging function on FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/20465583', 'last_updated': '2022-08-04', 'extracted_at': '2025-03-08T23:20:29.842257'}","Question How to use the MCUboot logging function on FSP Answer The MCUboot provides a logging function that allows you to output the running status and error information during image booting. This feature can be used to check the execution status of the bootloader. The MCUboot logging function has trhe following four log levels. MCUBOOTLOGERR (Error) MCUBOOTLOGWRN (Warning) MCUBOOTLOGINF (Info) MCUBOOTLOGDBG (Debug) The below example shows how to use the MCUboots logging function on FSP. Use of semi-hosting By default, FSP implements the MCUboot logging feature using the printf() function defined in the standard I/O header (stdio.h). For use of semi-hosting as the output interface, the developer can use this implementation as is. It can be enabled by changing the Log Level to a level other than Off, in the MCUboot logging block properties on the Stack tab of the FSP configurator The log levels available by the property settings of the MCUboot logging block are shown in the table below. Off Error Warning Info Debug MCUBOOTLOGERR -     MCUBOOTLOGWRN - -    MCUBOOTLOGINF - - -   MCUBOOTLOGDBG - - - -   Available, - Not available The developer should also apply the following changes required for semi-hosting to the project Add the initialization code for semi-hosting at the beginning of the program. Resize the heap size to the appropriate size in the properties of the BSP tab. Set the linker option ""--specsrdimon.specs"" from C/C Build  Settings  Tool Settings  Cross ARM C Linker  Miscellaneous in the project properties. Use of an output interface other than semi-hosting To use an output interface other than semi-hosting, such as SEGGER J-Link RTT Viewer, the developer can apply any user-defined execution function by redefining the macro MCUBOOTLOGxxx with a new header file. The link of the created header file can be applied from the Common  General  Custom mcubootconfig.h in the MCUboot block properties on the Stacks tab. For example, to output the information for MCUBOOTLOGERR and MCUBOOTLOGINF to SEGGER J-Link RTT View, the developer will create a header file with references to the following and apply it to the MCUboot block properties. In this case, the log level selected in the MCUboot logging block on the FSP configurator is ignored. mcubootconfigcustom.h include ""SEGGERRTT/SEGGERRTT.h"" define MCUBOOTLOGERR(fmt, ...) SEGGERRTTprintf(0, ""ERR "" fmt ""n"",  VAARGS) define MCUBOOTLOGWRN(...) IGNORE(VAARGS) define MCUBOOTLOGINF(fmt, ...) SEGGERRTTprintf(0, ""INF "" fmt ""n"",  VAARGS) define MCUBOOTLOGDBG(...) IGNORE(VAARGS) Note The MCUboot's logging feature may affect the performance of the MCUboot image boot process. Suitable Products RA and FSP Go to Japanese","['The image shows a screenshot of a computer settings page, specifically the ""MCUboot logging"" section. The page is divided into two main sections: the left side, which lists various settings options, and the right side, which displays the current value for each setting.\n\n**Left Side:**\n\n*   **Settings:** This section lists several settings options, including:\n    *   **Property**\n    *   **Common**\n    *   **Debugging**\n    *   **Debug Level**\n\n**Right Side:**\n\n*   **Value:** This section displays the current value for each setting. The current value for the ""Debug Level"" setting is highlighted in red, indicating that it is the selected option.\n*   **Debug Level:** This setting has several options, including:\n    *   **Off**\n    *   **Error**\n    *   **Warning**\n    *   **Info**\n    *   **Debug**\n\nThe background of the page is white, with a light blue border around the edges. The text is black, and the icons are gray. Overall, the image suggests that the user is configuring the MCUboot logging settings on their computer.', 'The image shows a code snippet in a programming language, likely C#. The code is written in a monospaced font and is displayed on a white background. The code snippet is highlighted in red, with a red rectangle around the highlighted text.\n\nThe code snippet appears to be a method definition for a class called ""initialise_monitor_handles"". The method takes no parameters and returns void. The code is written in a clear and concise manner, with proper indentation and spacing.\n\nThe code snippet is likely part of a larger program or project, and its purpose is to initialize monitor handles for a specific application or system. The method may be used to set up or configure monitor handles, such as setting up display settings or configuring audio output.\n\nOverall, the code snippet is well-structured and easy to read, making it suitable for use in a professional or academic setting.', 'The image shows a screenshot of the MCUboot settings page, with a red box highlighting the ""Custom mcuboot_config.h"" and ""mcuboot_config.custom.h"" options. The page has a white background with black text and blue headers.\n\n*   **Settings Page**\n    *   The page is titled ""MCUboot"" in the top-left corner.\n    *   There are several sections on the page, including ""Property"", ""Common"", and ""General"".\n    *   The ""Property"" section has a dropdown menu with options such as ""Value"" and ""Settings"".\n    *   The ""Common"" section has a dropdown menu with options such as ""API info"" and ""Settings"".\n    *   The ""General"" section has a dropdown menu with options such as ""Custom mcuboot_config.h"" and ""mcuboot_config.custom.h"".\n*   **Red Box**\n    *   The red box highlights the ""Custom mcuboot_config.h"" and ""mcuboot_config.custom.h"" options in the ""General"" section.\n    *   The box is rectangular and has a red border.\n    *   The text inside the box is black and reads ""Custom mcuboot_config.h"" and ""mcuboot_config.custom.h"".\n*   **Background**\n    *   The background of the page is white.\n    *   There are no other images or graphics on the page.\n\nOverall, the image shows a screenshot of the MCUboot settings page with a red box highlighting the ""Custom mcuboot_config.h"" and ""mcuboot_config.custom.h"" options. The page has a white background with black text and blue headers.']"
10ac896828b929a82e180fe94235abc4,"Question:
How to set the ID Code to enable protection and disable authentication, and how to connect a debugger or programmer in that case?
Answer:
Caution: If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore.
How to set the ID code
This setting is not available in the FSP configurator. It is enabled by adding the definition of BSP_ID_CODE_PERMANENTLY_LOCKED in the C Preprocessor setting as shown below.

The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. The ID code is set as all 00h in  ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/*
 ID Code
 Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.
 WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
 */
#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)
            #define BSP_CFG_ID_CODE_LONG_1 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_2 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_3 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_4 (0x00000000)
            #else
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
#endif

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800000000FFFFFFFF00000000FFFFFFFFD8
S3110101002800000000FFFFFFFF00000000C8

In case of RA6M3:
S3150100A15000000000000000000000000000000000F8

In case of RA4E2:
S3150100A1200000000000000000000000000000000028

Debugger connection in e2 studio (ID code authentication)
Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below.
In case of J-Link:

In case of E2 / E2 Lite:

Debugger connection in e2 studio (with ALeRASE execution)
In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

On the MCUs which ALeRASE is available in this mode (*1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
 
*1: ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command” (TN-RA*-A0014A/E)
Connection by RFP (with ID code authentication)
Since the ID code authentication always mismatches, a connection failure error is displayed as follows.

Connection by RFP (with ALeRASE execution)
Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below.

Suitable Products
RA and FSP
How to set the ID Code to enable protection and disable authentication, and how to connect a debugger or programmer in that case?
Answer:
Caution: If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore.
How to set the ID code
This setting is not available in the FSP configurator. It is enabled by adding the definition of BSP_ID_CODE_PERMANENTLY_LOCKED in the C Preprocessor setting as shown below.

The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. The ID code is set as all 00h in  ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/*
 ID Code
 Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.
 WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
 */
#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)
            #define BSP_CFG_ID_CODE_LONG_1 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_2 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_3 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_4 (0x00000000)
            #else
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
#endif

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800000000FFFFFFFF00000000FFFFFFFFD8
S3110101002800000000FFFFFFFF00000000C8

In case of RA6M3:
S3150100A15000000000000000000000000000000000F8

In case of RA4E2:
S3150100A1200000000000000000000000000000000028

Debugger connection in e2 studio (ID code authentication)
Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below.
In case of J-Link:

In case of E2 / E2 Lite:

Debugger connection in e2 studio (with ALeRASE execution)
In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

On the MCUs which ALeRASE is available in this mode (*1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
 
*1: ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command” (TN-RA*-A0014A/E)
Connection by RFP (with ID code authentication)
Since the ID code authentication always mismatches, a connection failure error is displayed as follows.

Connection by RFP (with ALeRASE execution)
Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below.

Suitable Products
RA and FSP
Caution: If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore.
How to set the ID code
This setting is not available in the FSP configurator. It is enabled by adding the definition of BSP_ID_CODE_PERMANENTLY_LOCKED in the C Preprocessor setting as shown below.

The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. The ID code is set as all 00h in  ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/*
 ID Code
 Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.
 WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
 */
#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)
            #define BSP_CFG_ID_CODE_LONG_1 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_2 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_3 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_4 (0x00000000)
            #else
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
#endif

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800000000FFFFFFFF00000000FFFFFFFFD8
S3110101002800000000FFFFFFFF00000000C8

In case of RA6M3:
S3150100A15000000000000000000000000000000000F8

In case of RA4E2:
S3150100A1200000000000000000000000000000000028

Debugger connection in e2 studio (ID code authentication)
Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below.
In case of J-Link:

In case of E2 / E2 Lite:

Debugger connection in e2 studio (with ALeRASE execution)
In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

On the MCUs which ALeRASE is available in this mode (*1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
 
*1: ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command” (TN-RA*-A0014A/E)
Connection by RFP (with ID code authentication)
Since the ID code authentication always mismatches, a connection failure error is displayed as follows.

Connection by RFP (with ALeRASE execution)
Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below.
Caution: If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore.
Caution: If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore.
How to set the ID code
How to set the ID code
This setting is not available in the FSP configurator. It is enabled by adding the definition of BSP_ID_CODE_PERMANENTLY_LOCKED in the C Preprocessor setting as shown below.
This setting is not available in the FSP configurator. It is enabled by adding the definition of BSP_ID_CODE_PERMANENTLY_LOCKED in the C Preprocessor setting as shown below.
BSP_ID_CODE_PERMANENTLY_LOCKED
The value of the ID code in the OSIS register
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. The ID code is set as all 00h in  ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as “00112233445566778899AABBCCDDEEFF”. The ID code is set as all 00h in  ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
00112233
44556677
8899AABB
CCDDEEFF
/*
 ID Code
 Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.
 WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
 */
#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)
            #define BSP_CFG_ID_CODE_LONG_1 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_2 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_3 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_4 (0x00000000)
            #else
/*
ID Code
Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.
WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
*/
#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)
#define BSP_CFG_ID_CODE_LONG_1 (0x00000000)
#define BSP_CFG_ID_CODE_LONG_1 (0x
00000000
)
#define BSP_CFG_ID_CODE_LONG_2 (0x00000000)
#define BSP_CFG_ID_CODE_LONG_2 (0x
00000000
)
#define BSP_CFG_ID_CODE_LONG_3 (0x00000000)
#define BSP_CFG_ID_CODE_LONG_3 (0x
00000000
)
#define BSP_CFG_ID_CODE_LONG_4 (0x00000000)
#define BSP_CFG_ID_CODE_LONG_4 (0x
00000000
)
#else
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
#endif
#endif
The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
The ID code is generated in the program image file as shown below.
It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
In case of RA2L1:
S3150101001800000000FFFFFFFF00000000FFFFFFFFD8
S3110101002800000000FFFFFFFF00000000C8
S3150101001800000000FFFFFFFF00000000FFFFFFFFD8
S31501010018
00000000
FFFFFFFF
00000000
FFFFFFFFD8
S3110101002800000000FFFFFFFF00000000C8
S31101010028
00000000
FFFFFFFF
00000000
C8
In case of RA6M3:
In case of RA6M3:
S3150100A15000000000000000000000000000000000F8
S3150100A15000000000000000000000000000000000F8
S3150100A150
00000000
00000000
00000000
00000000
F8
In case of RA4E2:
In case of RA4E2:
S3150100A1200000000000000000000000000000000028
S3150100A1200000000000000000000000000000000028
S3150100A120
00000000
00000000
00000000
00000000
28
Debugger connection in e2 studio (ID code authentication)
Debugger connection in e2 studio (ID code authentication)
Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below.
Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below.
In case of J-Link:
In case of J-Link:
In case of E2 / E2 Lite:
In case of E2 / E2 Lite:
Debugger connection in e2 studio (with ALeRASE execution)
Debugger connection in e2 studio (with ALeRASE execution)
In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.
In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.
FFFFFFFFFFFFFFFFFF45534152654C41
On the MCUs which ALeRASE is available in this mode (*1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
On the MCUs which ALeRASE is available in this mode (*1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
FFFFFFFFFFFFFFFFFF45534152654C41
*1: ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command” (TN-RA*-A0014A/E)
*1: ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command” (TN-RA*-A0014A/E)
Connection by RFP (with ID code authentication)
Connection by RFP (with ID code authentication)
Since the ID code authentication always mismatches, a connection failure error is displayed as follows.
Since the ID code authentication always mismatches, a connection failure error is displayed as follows.
Connection by RFP (with ALeRASE execution)
Connection by RFP (with ALeRASE execution)
Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below.
Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below.
414C6552415345FFFFFFFFFFFFFFFFFF
),
Suitable Products
RA and FSP
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/917aab28b4420ae2c907ff1d61b797f5.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/92b941204089dc9a89be81f639e897b9.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/67dc4ef70e8fcf05c7e316962407377d.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/28b387332674ea54f1c83e2a5de9a2c6.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/3b53be40f9ad9b91c7fcac55e580d9ab.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/a1c6a50c20807d83810931e82a20f53e.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/1801211fb7c9ff75f297b7f3e511b6d4.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/977ad1a02a8b575729a1cd648baaa147.png']",[],"['|  |\n|  |\n| /*\n ID Code\n Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.\n WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.\n */\n#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)\n            #define BSP_CFG_ID_CODE_LONG_1 (0x00000000)\n            #define BSP_CFG_ID_CODE_LONG_2 (0x00000000)\n            #define BSP_CFG_ID_CODE_LONG_3 (0x00000000)\n            #define BSP_CFG_ID_CODE_LONG_4 (0x00000000)\n            #else\n/* ID CODE: 00112233445566778899AABBCCDDEEbf */\n#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)\n#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)\n#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)\n#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)\n#endif |', '|  |\n|  |\n| S3150101001800000000FFFFFFFF00000000FFFFFFFFD8\nS3110101002800000000FFFFFFFF00000000C8 |', '|  |\n|  |\n| S3150100A15000000000000000000000000000000000F8 |', '|  |\n|  |\n| S3150100A1200000000000000000000000000000000028 |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: ID code protection (in case of protection enabled with Bit127=0)', 'url': 'https://en-support.renesas.com/knowledgeBase/20980158', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:29.252672'}","Question How to set the ID Code to enable protection and disable authentication, and how to connect a debugger or programmer in that case? Answer Caution If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore. How to set the ID code This setting is not available in the FSP configurator. It is enabled by adding the definition of BSPIDCODEPERMANENTLYLOCKED in the C Preprocessor setting as shown below. The value of the ID code in the OSIS register In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. The ID code is set as all 00h in racfg/fspcfg/bsp/bspmcufamilycfg.h as shown below. / ID Code Note To permanently lock and disable the debug interface define the BSPIDCODEPERMANENTLYLOCKED in the compiler settings. WARNING This will disable debug access to the part and cannot be reversed by a debug probe. / if defined(BSPIDCODEPERMANENTLYLOCKED) define BSPCFGIDCODELONG1 (0x00000000) define BSPCFGIDCODELONG2 (0x00000000) define BSPCFGIDCODELONG3 (0x00000000) define BSPCFGIDCODELONG4 (0x00000000) else / ID CODE 00112233445566778899AABBCCDDEEbf / define BSPCFGIDCODELONG1 (0x33221100) define BSPCFGIDCODELONG2 (0x77665544) define BSPCFGIDCODELONG3 (0xBBAA9988) define BSPCFGIDCODELONG4 (0xbfEEDDCC) endif The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register  In case of RA2L1 S3150101001800000000FFFFFFFF00000000FFFFFFFFD8 S3110101002800000000FFFFFFFF00000000C8 In case of RA6M3 S3150100A15000000000000000000000000000000000F8 In case of RA4E2 S3150100A1200000000000000000000000000000000028 Debugger connection in e2 studio (ID code authentication) Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below. In case of J-Link In case of E2 / E2 Lite Debugger connection in e2 studio (with ALeRASE execution) In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed. On the MCUs which ALeRASE is available in this mode (1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution. 1 ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command (TN-RA-A0014A/E) Connection by RFP (with ID code authentication) Since the ID code authentication always mismatches, a connection failure error is displayed as follows. Connection by RFP (with ALeRASE execution) Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below. Suitable Products RA and FSP BSPIDCODEPERMANENTLYLOCKED 00112233 44556677 8899AABB CCDDEEFF ID Code Note To permanently lock and disable the debug interface define the BSPIDCODEPERMANENTLYLOCKED in the compiler settings. WARNING This will disable debug access to the part and cannot be reversed by a debug probe. / define BSPCFGIDCODELONG1 (0x00000000) define BSPCFGIDCODELONG1 (0x 00000000 ) define BSPCFGIDCODELONG2 (0x00000000) define BSPCFGIDCODELONG2 (0x define BSPCFGIDCODELONG3 (0x00000000) define BSPCFGIDCODELONG3 (0x define BSPCFGIDCODELONG4 (0x00000000) define BSPCFGIDCODELONG4 (0x else The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register  S31501010018 FFFFFFFF FFFFFFFFD8 S31101010028 C8 S3150100A150 F8 S3150100A120 28 FFFFFFFFFFFFFFFFFF45534152654C41 414C6552415345FFFFFFFFFFFFFFFFFF ),","['The image shows a screenshot of the ""Settings"" window in Visual Studio, with the ""Tool Settings"" tab selected. The window is divided into two main sections: the left side lists various categories, and the right side displays the settings for the selected category.\n\n*   **Left Side:**\n    *   The left side of the window is a list of categories, including:\n        *   Resource\n        *   Builders\n        *   C/C++ Build\n        *   Build Variables\n        *   Environment\n        *   Logging\n        *   Settings\n        *   Tool Chain Editor\n        *   C/C++ General\n        *   MCU\n        *   Project Natures\n        *   Project References\n        *   Renesas QE\n        *   Run/Debug Settings\n        *   Task Tags\n        *   Validation\n*   **Right Side:**\n    *   The right side of the window displays the settings for the selected category, which is ""Tool Settings"".\n    *   The settings are organized into subcategories, including:\n        *   Target Processor\n        *   Optimization\n        *   Warnings\n        *   Debugging\n        *   GNU Arm Cross Assembler\n        *   Preprocessor\n        *   Includes\n        *   Warnings\n        *   Miscellaneous\n        *   GNU Arm Cross C Compiler\n        *   Preprocessor\n        *   Includes\n        *   Optimization\n        *   Warnings\n        *   Miscellaneous\n*   **Highlighted Settings:**\n    *   The highlighted settings are:\n        *   _RENESAS_RA_\n        *   BSP_ID_CODE_PERMANENTLY_LOCKED\n        *   RA_CORE_CM23\n\nOverall, the image shows the ""Settings"" window in Visual Studio, with the ""Tool Settings"" tab selected and various categories and subcategories listed on the left side. The right side displays the settings for the selected category, with some settings highlighted.', 'The image shows a screenshot of a computer error message. The message is titled ""Debug connection failed"" and has a yellow triangle with an exclamation mark inside it to the left of the text. Below the title, there is a paragraph of text that reads: ""Could not connect to target. Please check the GDB Server console for more information!"" Below this, there is a list of possible causes for the error, numbered from 1 to 7. The list includes:\n\n1. Target hardware does not match debug project hardware.\n2. Not all cables are connected.\n3. Debug options do not match those required by the hardware.\n4. No external power is being applied to the target.\n5. The wrong power is being applied to the target.\n6. The emulator .dll or .so file specified in the device file could not be found.\n7. The device connected or the device specified to GDB Server does not match the device specified in the Debug Configuration.\n\nAt the bottom of the message, there is a button labeled ""OK"". The background of the message is white, with black text. There is a gray bar at the top of the image with the words ""Debug connection failed"" in it, and a small icon of a computer to the left of the text. In the top-right corner, there is a small ""X"" icon that can be clicked to close the message. Overall, the image appears to be a standard error message that would be displayed on a computer screen when there is a problem with the debug connection.', 'The image shows a screenshot of an error message that appears when attempting to connect to a GDB server. The error message is displayed in a pop-up window with a yellow triangle containing an exclamation mark, indicating a fatal error.\n\n*   **Error Message:**\n    *   The error message reads: ""Error 0x00020004: Authentication failed. The emulator cannot be connected.""\n    *   This message indicates that the authentication process has failed, preventing the emulator from connecting.\n*   **Fatal Error Indicator:**\n    *   A yellow triangle with an exclamation mark is displayed next to the error message, serving as a visual indicator of the fatal error.\n*   **OK Button:**\n    *   Below the error message, there is an ""OK"" button that allows the user to dismiss the error message and continue with their task.\n*   **Background:**\n    *   The background of the error message is white, providing a clean and neutral visual environment for the error message to stand out.\n\nIn summary, the image shows a fatal error message that appears when attempting to connect to a GDB server due to authentication failure. The error message is accompanied by a yellow triangle with an exclamation mark and an ""OK"" button to dismiss the message.', 'The image displays a fatal error message from a GDB server, indicating that the ID failed to erase all flash memory by the ID for erasing all flash memory.\n\n*   The message is displayed in a pop-up window with a yellow triangle containing an exclamation mark inside it.\n*   The text of the message reads: ""Error 0x0003011D: Failed to erase all flash memory by the ID for erasing all flash memory.""\n*   There is a button labeled ""OK"" at the bottom right corner of the window.\n*   The background of the window is white, and the text is black.\n\nThe image suggests that the GDB server has encountered an error while attempting to erase all flash memory using the ID for erasing all flash memory. The error message provides a specific error code (0x0003011D) and a brief description of the problem. The presence of the ""OK"" button indicates that the user can close the error message and continue with their work.', 'The image shows a screenshot of a computer program, specifically a debugging tool. The top of the window has a menu bar with options such as ""Main"", ""Debugger"", ""Startup"", ""Common"", and ""Source"". Below this are several tabs, including ""Debug hardware:"", ""Target Device:"", and ""GDB Settings"".\n\n*   **Debug hardware:**\n    *   This section allows the user to select the type of hardware they are debugging. In this case, it is set to ""E2 Lite (ARM)"".\n*   **Target Device:**\n    *   This section allows the user to specify the target device they are debugging. In this case, it is set to ""R7FA2L1AB"".\n*   **GDB Settings:**\n    *   This section provides various settings for the GDB (GNU Debugger) tool. The options include:\n        *   **Clock:** This setting controls the clock speed of the target device.\n        *   **Connection with Target Board:** This setting determines how the debugger connects to the target board.\n        *   **Power:** This setting controls the power management of the target device.\n        *   **Connection:** This setting determines how the debugger connects to the target device.\n        *   **Hold reset during connect:** This setting determines whether the reset pin is held high during the connection process.\n        *   **D Code (Bytes):** This setting displays the debug code in bytes.\n        *   **Low Power Handling:** This setting controls how the debugger handles low power situations.\n\nOverall, the image shows a debugging tool with various settings and options for configuring the debugging process. The user can select the target device, set up the GDB settings, and control the power management of the target device.', 'The image depicts a screenshot of a computer program designed to convert a 128-bit hexadecimal value into a 32-bit hexadecimal value. The program is titled ""ID Code (Bytes)"" and features a white background with black text.\n\n**Program Interface:**\n\n*   The program\'s interface consists of a single text box at the top, labeled ""Specify ID Code in the format of:"".\n*   Below this text box, there are four smaller text boxes, each containing a key labeled ""Key 1"", ""Key 2"", ""Key 3"", and ""Key 4"".\n*   Each key has a corresponding input field where users can enter their 128-bit hexadecimal value.\n*   A checkbox labeled ""Input value as big endian format"" is located below the input fields.\n*   At the bottom of the program, there is a preview section displaying the converted 32-bit hexadecimal value.\n\n**Program Functionality:**\n\n*   The program is designed to take a 128-bit hexadecimal value as input and convert it into a 32-bit hexadecimal value.\n*   The conversion process involves breaking down the 128-bit value into four 32-bit segments, each corresponding to one of the keys (Key 1, Key 2, Key 3, and Key 4).\n*   The program then combines these segments to form a single 32-bit hexadecimal value, which is displayed in the preview section.\n\n**Program Purpose:**\n\n*   The purpose of this program is to facilitate the conversion of large hexadecimal values into smaller, more manageable formats.\n*   This can be useful in various applications, such as data compression, encryption, or storage optimization.\n\n**Program Limitations:**\n\n*   The program only supports 128-bit hexadecimal values as input.\n*   It does not provide any error handling or validation for invalid input values.\n*   The program\'s output is limited to a single 32-bit hexadecimal value, which may not be suitable for all applications.\n\nOverall, the program appears to be a simple tool for converting large hexadecimal values into smaller formats. However, its limitations and lack of error handling may make it less useful in certain scenarios.', 'The image shows a screenshot of an error message on a computer screen. The error message is in red and black text, and it reads: ""Error(E3000105): The device is not responding."" Below this, there is a paragraph of text that explains the error and provides instructions on how to resolve it. The background of the image is white, with a gray bar at the bottom that contains a button labeled ""Clear status and message"". \n\nThe error message is likely related to a problem with a device or connection, and the instructions provided are intended to help the user troubleshoot and resolve the issue. Overall, the image suggests that the user is experiencing technical difficulties with their computer or device, and needs to take action to resolve the problem.', 'The image shows a screenshot of an error message on a computer screen. The error message is in red text and reads: ""Error (E100000C): A serial programming connection is prohibited for this device. (Command: 30. Response: DC) Operation failed.""\n\n*   The error message is displayed in a white box with a blue border at the top of the screen.\n*   Below the error message, there are several lines of text that provide additional information about the error, including:\n    *   ""Emulator\'s supply power: OFF""\n    *   ""Emulator\'s firmware version: 3.03.00.005""\n    *   ""Connecting to the target device""\n    *   ""Setting the target device""\n*   At the bottom of the screen, there is a gray button with the text ""Clear status and message"" in black font.\n*   In the top-right corner of the screen, there is a red button with the text ""NG"" in white font.\n\nOverall, the image suggests that there is an issue with the emulator\'s connection to the target device, and the user needs to clear the status and message to resolve the problem.']"
22d51b554b6047c545f82565e4d5f950,"Often product developers find themselves in a position where application configuration parameters need to be uniquely programmed into a MCU’s memory. To do so, often firmware is created which is flashed into the MCU which is responsible for the acquisition of the needed application configuration parameters. MAC addresses, IP Addresses, SSID Names, Passwords, Public/Private keys, etc. are examples of application configuration parameters. The issue with an approach where the firmware handles acquisition of the ACPs is the need to create auxiliary code which adds limited value to the main application. This in turn leads to additional test efforts, and longer development times.
A way to avoid such issues is to modularize your application and store the ACPs as a blob of structured binary data located in a fixed location in memory. So when your application starts, it is able to access the fixed location, read the data in a fixed manner, and adjust the mode of operation.
When you have achieved such modularization, you can segment your application in to two parts:
Your ACP data can then be converted into a S-Record file and programmed into the fixed memory location.
Let’s look at an example where a certificate is part of the ACP and needs to be programmed into the Data Flash Address of a RA6M4 MCU.
The certificate above is stored into a file called sample.pem.
Use srec_cat to convert this into a srecord file.
srec_cat sample.pem -Binary -offset 0x08000000 -output dstfile.srec -obs=16 -data-only
srec_cat sample.pem -Binary -offset 0x08000000 -output dstfile.srec -obs=16 -data-only
The above command treats sample.pem as a binary to be programmed at address 0x08000000 using an output block size of 16 bytes. This is the main data you want to load to the RA6M4 using the Renesas Flash Programmer. But you will find that RFP fails to program the device.
This is mainly due to a malformed srec file. You need a header and a start address to pass through RFP’s checklist for a S-record file. So, we adjust the options of srec_cat.
srec_cat sample.pem -Binary -offset 0x08000000 -fill 0xFF 0x08000000 0x08002000 -header=dstfile.srec -output dstfile.srec -obs=16 -start-address 0x00000000
srec_cat sample.pem -Binary -offset 0x08000000 -fill 0xFF 0x08000000 0x08002000 -header=dstfile.srec -output dstfile.srec -obs=16 -start-address 0x00000000
Let’s breakdown the new command options used in the command above.
-fill value minimum maximum ensures that any missing data between the minimum and maximum address range is filled with value i.e. 0xFF. You should adjust the value of the maximum based on the block erase size of the memory region being programmed.
-header=string places the string at the start of the srec file using the S0 Record field. Typically, this is the name of the file.
-start-address 0x00000000 places an Execution Start Address towards the end.
When you pass the output file to RFP, it should be able to program the RA6M4 MCU. Note, you may have to power cycle the MCU after each RFP operation.
Finally, to confirm the values programmed, you can use RFP’s Target Device > Read Memory functionality and compare it against what was written.
As you can see, data matches, but the header and some other record fields may not.
This will now allow you to create unique ACP data srec files for each MCU you intend to program. Next to program both the main application and ACP srec file combinations, you can use the rfp-cli.exe command to program multiple files.
First you need to erase the entire chip:
""c:\Program Files (x86)\Renesas Electronics\Programming Tools\Renesas Flash Programmer V3.09\rfp-cli.exe"" -d RA -port COM6 -erase-chip
""c:\Program Files (x86)\Renesas Electronics\Programming Tools\Renesas Flash Programmer V3.09\rfp-cli.exe"" -d RA -port COM6 -erase-chip
To program both files over USB/SCI Boot mode, first add the Boot Mode Jumper, and then ensure the device is enumerated as a COM port. Finally, use the command below:
""c:\Program Files (x86)\Renesas Electronics\Programming Tools\Renesas Flash Programmer V3.09\rfp-cli.exe"" -d RA -port COM6 -a ""C:\Users\a5087427\Downloads\ek_ra6m4_blinky.srec"" ""C:\Users\a5087427\Downloads\dstfile.srec""
""c:\Program Files (x86)\Renesas Electronics\Programming Tools\Renesas Flash Programmer V3.09\rfp-cli.exe"" -d RA -port COM6 -a ""C:\Users\a5087427\Downloads\ek_ra6m4_blinky.srec"" ""C:\Users\a5087427\Downloads\dstfile.srec""
A successful operation will output:
You can confirm the contents by reading memory from RFP or by removing the Boot mode jumper and allowing normal operation of the MCU.
References:
R20AN0547 - Renesas Flash Programmer - Usage from the Command Line
Suitable Products
RA and FSP
Suitable Products
RA and FSP
Suitable Products
RA and FSP
Suitable Products
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/22d51b554b6047c545f82565e4d5f950/images/02443a476d5136bbfbcff6480f708278.png', 'data/categories/ra_family/rafsp_knowledge_base/22d51b554b6047c545f82565e4d5f950/images/c84dab45df9c417f6739b2346626f5fc.png', 'data/categories/ra_family/rafsp_knowledge_base/22d51b554b6047c545f82565e4d5f950/images/c4bfaa06a0496ddc64b5510c5f4ae90f.png', 'data/categories/ra_family/rafsp_knowledge_base/22d51b554b6047c545f82565e4d5f950/images/f27c45f011f90adcf9c272d5739ffecb.png', 'data/categories/ra_family/rafsp_knowledge_base/22d51b554b6047c545f82565e4d5f950/images/ccde583e8942470ea175c24655233bd0.png']",[],['|  |\n|  |\n| RA and FSP |'],"{'title': 'Production Configuration for RA MCUs with srec_cat and Renesas Flash Programmer', 'url': 'https://en-support.renesas.com/knowledgeBase/20498707', 'last_updated': None, 'extracted_at': '2025-03-08T23:25:22.998290'}","Often product developers find themselves in a position where application configuration parameters need to be uniquely programmed into a MCUs memory. To do so, often firmware is created which is flashed into the MCU which is responsible for the acquisition of the needed application configuration parameters. MAC addresses, IP Addresses, SSID Names, Passwords, Public/Private keys, etc. are examples of application configuration parameters. The issue with an approach where the firmware handles acquisition of the ACPs is the need to create auxiliary code which adds limited value to the main application. This in turn leads to additional test efforts, and longer development times. A way to avoid such issues is to modularize your application and store the ACPs as a blob of structured binary data located in a fixed location in memory. So when your application starts, it is able to access the fixed location, read the data in a fixed manner, and adjust the mode of operation. When you have achieved such modularization, you can segment your application in to two parts Your ACP data can then be converted into a S-Record file and programmed into the fixed memory location. Lets look at an example where a certificate is part of the ACP and needs to be programmed into the Data Flash Address of a RA6M4 MCU. The certificate above is stored into a file called sample.pem. Use sreccat to convert this into a srecord file. sreccat sample.pem -Binary -offset 0x08000000 -output dstfile.srec -obs16 -data-only The above command treats sample.pem as a binary to be programmed at address 0x08000000 using an output block size of 16 bytes. This is the main data you want to load to the RA6M4 using the Renesas Flash Programmer. But you will find that RFP fails to program the device. This is mainly due to a malformed srec file. You need a header and a start address to pass through RFPs checklist for a S-record file. So, we adjust the options of sreccat. sreccat sample.pem -Binary -offset 0x08000000 -fill 0xFF 0x08000000 0x08002000 -headerdstfile.srec -output dstfile.srec -obs16 -start-address 0x00000000 Lets breakdown the new command options used in the command above. -fill value minimum maximum ensures that any missing data between the minimum and maximum address range is filled with value i.e. 0xFF. You should adjust the value of the maximum based on the block erase size of the memory region being programmed. -headerstring places the string at the start of the srec file using the S0 Record field. Typically, this is the name of the file. -start-address 0x00000000 places an Execution Start Address towards the end. When you pass the output file to RFP, it should be able to program the RA6M4 MCU. Note, you may have to power cycle the MCU after each RFP operation. Finally, to confirm the values programmed, you can use RFPs Target Device  Read Memory functionality and compare it against what was written. As you can see, data matches, but the header and some other record fields may not. This will now allow you to create unique ACP data srec files for each MCU you intend to program. Next to program both the main application and ACP srec file combinations, you can use the rfp-cli.exe command to program multiple files. First you need to erase the entire chip ""cProgram Files (x86)Renesas ElectronicsProgramming ToolsRenesas Flash Programmer V3.09rfp-cli.exe"" -d RA -port COM6 -erase-chip To program both files over USB/SCI Boot mode, first add the Boot Mode Jumper, and then ensure the device is enumerated as a COM port. Finally, use the command below ""cProgram Files (x86)Renesas ElectronicsProgramming ToolsRenesas Flash Programmer V3.09rfp-cli.exe"" -d RA -port COM6 -a ""CUsersa5087427Downloadsekra6m4blinky.srec"" ""CUsersa5087427Downloadsdstfile.srec"" A successful operation will output You can confirm the contents by reading memory from RFP or by removing the Boot mode jumper and allowing normal operation of the MCU. References R20AN0547 - Renesas Flash Programmer - Usage from the Command Line Suitable Products RA and FSP","['The image shows a screenshot of the Renesas Flash Programmer V3.09.01 software, which is used to program and verify microcontrollers. The software is open on a Windows computer, with the main window displaying various tabs and fields for configuring the programmer.\n\n*   **Main Window**\n    *   The main window has several tabs, including ""Operation"", ""Operation Settings"", ""Block Settings"", ""Flash Options"", ""Connect Settings"", ""Unique Code"", and ""User Keys"".\n    *   The ""Operation"" tab is currently selected, and it displays a list of available operations, including ""Project Information"", ""Current Project"", ""Microcontroller"", ""Program File"", and ""Flash Operation"".\n    *   The ""Program File"" field is highlighted, indicating that the user has selected a program file to load into the programmer.\n    *   The ""Flash Operation"" field is also highlighted, indicating that the user has selected a flash operation to perform on the microcontroller.\n*   **Device Information**\n    *   Below the main window, there is a section displaying device information, including the device name, device code, MCU unique ID, boot firmware version, code flash size, data flash size, and configuration area size.\n    *   The device information is displayed in a table format, with each column representing a different piece of information.\n*   **Error Message**\n    *   At the bottom of the window, there is an error message indicating that the file is corrupted and cannot be opened.\n    *   The error message is displayed in red text, with a red ""NG"" symbol next to it.\n*   **Buttons**\n    *   There are several buttons at the bottom of the window, including ""Start"", ""NG"", and ""Clear status and message"".\n    *   The ""Start"" button is highlighted, indicating that the user has clicked on it to begin the programming process.\n    *   The ""NG"" button is also highlighted, indicating that the user has clicked on it to cancel the programming process.\n\nOverall, the image shows a screenshot of the Renesas Flash Programmer V3.09.01 software, which is used to program and verify microcontrollers. The software is open on a Windows computer, with the main window displaying various tabs and fields for configuring the programmer. The device information section displays details about the selected device, and the error message indicates that the file is corrupted and cannot be opened. The buttons at the bottom of the window allow the user to start or cancel the programming process.', 'The image shows a screenshot of the Renesas Flash Programmer software, which is used to program and verify microcontrollers. The software is open on a Windows computer, with the main window displaying various tabs and options for configuring the programmer.\n\n*   **Main Window**\n    *   The main window is titled ""Renesas Flash Programmer V3.09.01"" and has a gray background.\n    *   There are several tabs at the top of the window, including ""File"", ""Target Device"", ""Help"", ""Operation"", ""Operation Settings"", ""Block Settings"", ""Flash Options"", ""Connect Settings"", ""Unique Code"", and ""User Keys"".\n    *   Below the tabs, there are several sections for configuring the programmer, including ""Project Information"", ""Program File"", ""Flash Operation"", and ""Erase >> Program >> Verify"".\n    *   The ""Project Information"" section displays information about the current project, including the project name, microcontroller type, and program file.\n    *   The ""Program File"" section allows the user to select a program file to upload to the microcontroller.\n    *   The ""Flash Operation"" section provides options for erasing and verifying the microcontroller.\n    *   The ""Erase >> Program >> Verify"" section allows the user to erase, program, and verify the microcontroller.\n*   **Bottom Section**\n    *   The bottom section of the window displays a list of commands that have been executed, including ""Erasing the selected blocks"", ""Writing data to the target device"", and ""Verifying data"".\n    *   The list also includes the size of the data being written or verified, as well as the status of the operation (e.g. ""size : 1.0 M"" or ""size : 8 K"").\n    *   The list is updated in real-time as the user performs operations on the microcontroller.\n*   **Buttons**\n    *   There are several buttons at the bottom of the window, including ""Start"", ""OK"", and ""Clear status and message"".\n    *   The ""Start"" button is used to begin the programming process.\n    *   The ""OK"" button is used to confirm the operation and close the window.\n    *   The ""Clear status and message"" button is used to clear the list of commands and reset the window.\n\nOverall, the image shows a screenshot of the Renesas Flash Programmer software, which is used to program and verify microcontrollers. The software provides a user-friendly interface for configuring the programmer and performing operations on the microcontroller.', 'The image shows a screenshot of a computer program, specifically a memory information window. The window is titled ""Read Memory Information"" and has several sections with various fields and buttons.\n\n*   **Select Area**\n    *   This section allows the user to select the area of memory to read from.\n    *   There are two options: ""All Areas"" and ""Code Flash 1"".\n    *   The ""Data Flash 1"" option is highlighted in blue, indicating that it is the currently selected area.\n*   **Select Address**\n    *   This section allows the user to enter the starting and ending addresses of the memory range to read from.\n    *   The starting address is set to 0x08000000, and the ending address is set to 0x8001FFF.\n    *   The length of the memory range is calculated as 2000.\n*   **Read**\n    *   This button is used to initiate the read operation.\n    *   It is located at the bottom of the window and is highlighted in blue, indicating that it is the currently selected option.\n*   **Cancel**\n    *   This button is used to cancel the read operation.\n    *   It is located next to the ""Read"" button and is not highlighted in blue.\n\nOverall, the image shows a simple and intuitive interface for reading memory information. The user can easily select the area of memory to read from, enter the starting and ending addresses, and initiate the read operation.', 'The image shows two windows of hexadecimal code, with the first window displaying a large block of hexadecimal code and the second window displaying a smaller block of hexadecimal code. The first window has a blue title bar with the text ""C:\\Users\\as087427\\Downloads\\srcfile.mot"" and the second window has a blue title bar with the text ""C:\\Users\\as087427\\Downloads\\dstfile.srec"". Both windows have a white background and black text. The first window has a red line at the top, and the second window has a gray bar at the bottom. The hexadecimal code in both windows is displayed in a monospaced font, with each line of code separated by a space. The code appears to be a binary file, possibly a computer program or data file. The image suggests that the user is comparing or analyzing the contents of these two files.', 'The image shows a screenshot of a command prompt window displaying the output of a Renesas Flash Programmer CLI tool. The tool is used to program and erase flash memory on Renesas microcontrollers.\n\n*   **Command Prompt Window**\n    *   The window has a white title bar with the text ""Command Prompt"" in black font.\n    *   The window is open on a Windows operating system, as indicated by the title bar and the command prompt icon.\n*   **Renesas Flash Programmer CLI Tool**\n    *   The tool is running in the command prompt window, displaying its output in a monospaced font.\n    *   The tool is connected to a target device, as indicated by the text ""Connected to R7FA6M4AF3CFB"".\n    *   The tool is erasing the target device, as indicated by the text ""Erasing the target device"".\n    *   The tool is writing data to the target device, as indicated by the text ""Writing data to the target device"".\n    *   The tool is verifying data on the target device, as indicated by the text ""Verifying data on the target device"".\n    *   The tool is successful in its operations, as indicated by the text ""Operation successful"".\n*   **Code Flash 1**\n    *   The tool is working with Code Flash 1, as indicated by the text ""Code Flash 1"".\n    *   The tool is erasing Code Flash 1, as indicated by the text ""Erasing the target device"".\n    *   The tool is writing data to Code Flash 1, as indicated by the text ""Writing data to the target device"".\n    *   The tool is verifying data on Code Flash 1, as indicated by the text ""Verifying data on the target device"".\n*   **Data Flash 1**\n    *   The tool is working with Data Flash 1, as indicated by the text ""Data Flash 1"".\n    *   The tool is erasing Data Flash 1, as indicated by the text ""Erasing the target device"".\n    *   The tool is writing data to Data Flash 1, as indicated by the text ""Writing data to the target device"".\n    *   The tool is verifying data on Data Flash 1, as indicated by the text ""Verifying data on the target device"".\n\nIn summary, the image shows a command prompt window displaying the output of a Renesas Flash Programmer CLI tool. The tool is connected to a target device and performs various operations such as erasing, writing, and verifying data on the device. The tool is successful in its operations, as indicated by the text ""Operation successful"".']"
1ea78483764d956552ea9fac90a28ba7,"Overview:
During compilation on the e2studio/GCC toolchain, we can look at the output of the arm-none-eabi-size to see the amount of ROM/RAM used.
For an RA6M4 project using ethernet the netx ftp example project in this case), the RAM (bss) shows high usage : 260564 bytes out of total 256 kbyte available.  This is due to a special requirement to place the EDMAC buffers in non-secure RAM. Non-secure RAM is typically assigned to the end of usable RAM.
You can see below that the linker script relocates the “.ns_buffer” towards the end of RAM.
To find out the available RAM for this project, look at the project’s .map file and see the amount that has been skipped.
  In the figure above, the *fill* amount in .ns_buffer is 0x264d0 ( 158,880 bytes). These are skipped over, to place ethernet buffers at the end of RAM.  This 158kb is the available (unused) RAM for this project.
Suitable Products
RA6M4, RA6M5
During compilation on the e2studio/GCC toolchain, we can look at the output of the arm-none-eabi-size to see the amount of ROM/RAM used.
For an RA6M4 project using ethernet the netx ftp example project in this case), the RAM (bss) shows high usage : 260564 bytes out of total 256 kbyte available.  This is due to a special requirement to place the EDMAC buffers in non-secure RAM. Non-secure RAM is typically assigned to the end of usable RAM.
You can see below that the linker script relocates the “.ns_buffer” towards the end of RAM.
To find out the available RAM for this project, look at the project’s .map file and see the amount that has been skipped.
  In the figure above, the *fill* amount in .ns_buffer is 0x264d0 ( 158,880 bytes). These are skipped over, to place ethernet buffers at the end of RAM.  This 158kb is the available (unused) RAM for this project.
During compilation on the e2studio/GCC toolchain, we can look at the output of the arm-none-eabi-size to see the amount of ROM/RAM used.
For an RA6M4 project using ethernet the netx ftp example project in this case), the RAM (bss) shows high usage : 260564 bytes out of total 256 kbyte available.  This is due to a special requirement to place the EDMAC buffers in non-secure RAM. Non-secure RAM is typically assigned to the end of usable RAM.
You can see below that the linker script relocates the “.ns_buffer” towards the end of RAM.
To find out the available RAM for this project, look at the project’s .map file and see the amount that has been skipped.
In the figure above, the *fill* amount in .ns_buffer is 0x264d0 ( 158,880 bytes). These are skipped over, to place ethernet buffers at the end of RAM.  This 158kb is the available (unused) RAM for this project.
Suitable Products
RA6M4, RA6M5
Suitable Products
RA6M4, RA6M5","['data/categories/ra_family/rafsp_knowledge_base/1ea78483764d956552ea9fac90a28ba7/images/6d7ee47dbcf937332cd8d72cbdad173f.png', 'data/categories/ra_family/rafsp_knowledge_base/1ea78483764d956552ea9fac90a28ba7/images/831bb49657123d6a425750c990b62915.png', 'data/categories/ra_family/rafsp_knowledge_base/1ea78483764d956552ea9fac90a28ba7/images/1e8380b690b9337b323dc07bfd1daaab.png']",[],"['|  |\n|  |\n| RA6M4, RA6M5 |']","{'title': 'RA Family: RAM remaining for an RA6M4 ethernet project', 'url': 'https://en-support.renesas.com/knowledgeBase/21618619', 'last_updated': '2024-04-10', 'extracted_at': '2025-03-08T23:23:22.319010'}","Overview During compilation on the e2studio/GCC toolchain, we can look at the output of the arm-none-eabi-size to see the amount of ROM/RAM used. For an RA6M4 project using ethernet the netx ftp example project in this case), the RAM (bss) shows high usage  260564 bytes out of total 256 kbyte available. This is due to a special requirement to place the EDMAC buffers in non-secure RAM. Non-secure RAM is typically assigned to the end of usable RAM. You can see below that the linker script relocates the .nsbuffer towards the end of RAM. To find out the available RAM for this project, look at the projects .map file and see the amount that has been skipped. In the figure above, the fill amount in .nsbuffer is 0x264d0 ( 158,880 bytes). These are skipped over, to place ethernet buffers at the end of RAM. This 158kb is the available (unused) RAM for this project. Suitable Products RA6M4, RA6M5 In the figure above, the fill amount in .nsbuffer is 0x264d0 ( 158,880 bytes). These are skipped over, to place ethernet buffers at the end of RAM. This 158kb is the available (unused) RAM for this project.","['The image shows a screenshot of a terminal window displaying the output of a command. The title at the top of the window reads ""CDT Build Console [NetX_ftp_client_ek_ra6m4_ep]"". Below this, there is a line of text that says ""Extracting support files..."" followed by a series of lines of code and data. The code is written in blue text, while the data is displayed in black text. The background of the window is white.\n\nThe code appears to be a build script for a project called ""NetX_ftp_client_ek_ra6m4_ep"", and it includes commands such as ""make -r -j8 all"" and ""arm-none-eabi-size --format=berkeley \'NetX_ftp_client_ek_ra6m4_ep.elf\'"". The data displayed includes information about the size of the compiled executable file, including its format and size in bytes.\n\nOverall, the image suggests that the user is building a project using a build tool such as CDT (Cross Development Tools) and is monitoring the progress of the build process in real-time.', 'The image displays a code snippet in C programming language, specifically focusing on the implementation of a non-secure RAM (Random Access Memory) buffer. The code is written in a clear and concise manner, with comments providing explanations for each section.\n\n**Code Snippet:**\n\n```c\n/* Non-secure buffers must be in non-secure RAM. This is primarily used for the EDMAC in flat projects. */\n/* The EDMAC is a non-secure bus master and can only access non-secure RAM. */\n\n/* Allocate RAM on a 32-byte boundary to help with placement of Ethernet buffers. */\n/* . = _RESERVE_NS_RAM ? ABSOLUTE(RAM_NS_BUFFER_START & 0xFFFFFFE0) : .; */\n\nKEEP(*(.ns_buffer*)) > RAM\n```\n\n**Explanation:**\n\n*   The first comment explains that non-secure buffers must be located in non-secure RAM, which is primarily used for the EDMAC (Ethernet DMA Controller) in flat projects.\n*   The second comment clarifies that the EDMAC is a non-secure bus master and can only access non-secure RAM.\n*   The third comment allocates RAM on a 32-byte boundary to facilitate the placement of Ethernet buffers.\n*   The fourth line uses the `ABSOLUTE` directive to specify the starting address of the RAM buffer, which is aligned to a 32-byte boundary.\n*   The `KEEP` directive is used to ensure that the `.ns_buffer` section is placed in non-secure RAM.\n\n**Context:**\n\n*   The code is likely part of a larger project that involves the use of the EDMAC and Ethernet buffers.\n*   The non-secure RAM buffer is used to store data that needs to be accessed by the EDMAC.\n*   The code is written in a way that ensures the buffer is allocated on a 32-byte boundary, which helps with the placement of Ethernet buffers.\n\n**Conclusion:**\n\nIn summary, the code snippet provides a clear and concise implementation of a non-secure RAM buffer, which is essential for the EDMAC in flat projects. The use of comments and directives ensures that the buffer is allocated on a 32-byte boundary and placed in non-secure RAM, facilitating the placement of Ethernet buffers.', 'The image shows a code snippet in a programming language, likely C or C++. The code is written in a monospaced font and is displayed on a white background.\n\nThe code snippet appears to be a function definition, with the function name ""fill"" and a parameter list that includes a pointer to a buffer and a size parameter. The function body contains a series of assignments and comparisons, which suggest that it is performing some kind of data processing or validation.\n\nThe code also includes several comments, which provide additional information about the purpose and behavior of the function. These comments are written in a different color than the rest of the code, making them stand out.\n\nOverall, the image suggests that the code is part of a larger program or system, and that it plays a specific role in that system. The use of comments and the structure of the code suggest that the programmer is trying to make the code as clear and readable as possible, which is an important aspect of software development.\n\nHere is a breakdown of the code:\n\n*   `fill*`: This is the function name, which suggests that the function is responsible for filling a buffer with data.\n*   `0x20006430`: This is the address of the buffer that the function will fill.\n*   `0x264d0`: This is the size of the buffer.\n*   `0x2002c900`: This is the address of a second buffer that the function will use.\n*   `0x13140`: This is the size of the second buffer.\n*   `g_packet_pool0_pool_memory`: This is a variable that the function will use to store the filled buffer.\n\nOverall, the code appears to be a simple function that fills a buffer with data from another buffer. The use of comments and the structure of the code suggest that the programmer is trying to make the code as clear and readable as possible.']"
a99bdc1c2932b067ff371ba2aeedfe12,"Question:
How to use the Debug Out function of J-Link OB on EK (Evaluation Kit)
Answer:
Renesas has equipped each EK (Evaluation Kit) for RA MCUs, such as EK-RA2E1, EK-RA2E2, EK-RA2L1, EK-RA2A1, etcEK-RA4M1、EK-RA4M2、EK-RA4M3、EK-RA4W1、EK-RA6M1、EK-RA6M2, EK-RA6M3, EK-RA6M4, EK-RA6M5, etc., all EKs come with J-Link OB (On-Board Debugger), which means that the user can evaluate, debug, and test the MCU with only one USB cable, eliminating the need for a separate J-Link emulator. Most of these EKs have the J-Link OB's Debug Out function, which means that the J-Link OB (On-Board Debugger) on the board can be used to debug not only the MCU on the board, but also the customer's RA target board through the Debug OB function. However, some EKs do not support this function, such as EK-RA2A1, EK-RA4M1, EK-RA6M1, EK-RA6M2, etc.
It is important to emphasize that this on-board debugger is officially provided by Renesas, and the firmware can be updated with the update of the SEGGER tool.
In this article, EK-RA6M3 is used as an example to describe the specific implementation method.
Refer to the schematic diagram of EK-RA6M3:
J29 can be used with J8 and J9 to achieve the Debug Out function, J9 does not connect to the jumper cap[WM1] [MM2] , and J8 connects to Pin2 and Pin3.
To connect the customer target board, use the following pins of the J29:
J29 Customer Targets Board
Pin6 P108/SWDIO
Pin8 P300/SWCLK
Pin2 P110/RXD9
Pin4 P109/TXD9
J8 Customer Targets Board
Pin1 RESET
  Annotation:
These pins are all 2.0 pitch.
To control the MD pin of the RA with J-Link OB, connect Pin 8 of J29 to the MD/P201 pin of the target board chip at the same time.
Since the above pins do not have GND pins, it is also necessary to connect the GND of the user board to the GND on the EK board. The following pins can be used with double-row pins: Pin30 for J1, Pin39 for J2, Pin39 for J3, Pin39 for J4.
If the customer's target board needs power from the EK-RA6M3, please note that there are two options: 3.3V or 5V.
The following pins on J1, J2, J3, and J4 can be used to power the customer's target board:
3.3V 5V
J1: Pin 36 J1: Pin 40
J2: Pin 1  
J3: Pin 1  
J4: Pin 1  
  Suitable Products
RA
How to use the Debug Out function of J-Link OB on EK (Evaluation Kit)
How to use the Debug Out function of J-Link OB on EK (Evaluation Kit)
Answer:
Renesas has equipped each EK (Evaluation Kit) for RA MCUs, such as EK-RA2E1, EK-RA2E2, EK-RA2L1, EK-RA2A1, etcEK-RA4M1、EK-RA4M2、EK-RA4M3、EK-RA4W1、EK-RA6M1、EK-RA6M2, EK-RA6M3, EK-RA6M4, EK-RA6M5, etc., all EKs come with J-Link OB (On-Board Debugger), which means that the user can evaluate, debug, and test the MCU with only one USB cable, eliminating the need for a separate J-Link emulator. Most of these EKs have the J-Link OB's Debug Out function, which means that the J-Link OB (On-Board Debugger) on the board can be used to debug not only the MCU on the board, but also the customer's RA target board through the Debug OB function. However, some EKs do not support this function, such as EK-RA2A1, EK-RA4M1, EK-RA6M1, EK-RA6M2, etc.
It is important to emphasize that this on-board debugger is officially provided by Renesas, and the firmware can be updated with the update of the SEGGER tool.
In this article, EK-RA6M3 is used as an example to describe the specific implementation method.
Refer to the schematic diagram of EK-RA6M3:
J29 can be used with J8 and J9 to achieve the Debug Out function, J9 does not connect to the jumper cap[WM1] [MM2] , and J8 connects to Pin2 and Pin3.
To connect the customer target board, use the following pins of the J29:
J29 Customer Targets Board
Pin6 P108/SWDIO
Pin8 P300/SWCLK
Pin2 P110/RXD9
Pin4 P109/TXD9
J8 Customer Targets Board
Pin1 RESET
  Annotation:
These pins are all 2.0 pitch.
To control the MD pin of the RA with J-Link OB, connect Pin 8 of J29 to the MD/P201 pin of the target board chip at the same time.
Since the above pins do not have GND pins, it is also necessary to connect the GND of the user board to the GND on the EK board. The following pins can be used with double-row pins: Pin30 for J1, Pin39 for J2, Pin39 for J3, Pin39 for J4.
If the customer's target board needs power from the EK-RA6M3, please note that there are two options: 3.3V or 5V.
The following pins on J1, J2, J3, and J4 can be used to power the customer's target board:
3.3V 5V
J1: Pin 36 J1: Pin 40
J2: Pin 1  
J3: Pin 1  
J4: Pin 1  
  Suitable Products
RA
Renesas has equipped each EK (Evaluation Kit) for RA MCUs, such as EK-RA2E1, EK-RA2E2, EK-RA2L1, EK-RA2A1, etcEK-RA4M1、EK-RA4M2、EK-RA4M3、EK-RA4W1、EK-RA6M1、EK-RA6M2, EK-RA6M3, EK-RA6M4, EK-RA6M5, etc., all EKs come with J-Link OB (On-Board Debugger), which means that the user can evaluate, debug, and test the MCU with only one USB cable, eliminating the need for a separate J-Link emulator. Most of these EKs have the J-Link OB's Debug Out function, which means that the J-Link OB (On-Board Debugger) on the board can be used to debug not only the MCU on the board, but also the customer's RA target board through the Debug OB function. However, some EKs do not support this function, such as EK-RA2A1, EK-RA4M1, EK-RA6M1, EK-RA6M2, etc.
It is important to emphasize that this on-board debugger is officially provided by Renesas, and the firmware can be updated with the update of the SEGGER tool.
In this article, EK-RA6M3 is used as an example to describe the specific implementation method.
Refer to the schematic diagram of EK-RA6M3:
J29 can be used with J8 and J9 to achieve the Debug Out function, J9 does not connect to the jumper cap[WM1] [MM2] , and J8 connects to Pin2 and Pin3.
To connect the customer target board, use the following pins of the J29:
Annotation:
These pins are all 2.0 pitch.
To control the MD pin of the RA with J-Link OB, connect Pin 8 of J29 to the MD/P201 pin of the target board chip at the same time.
Since the above pins do not have GND pins, it is also necessary to connect the GND of the user board to the GND on the EK board. The following pins can be used with double-row pins: Pin30 for J1, Pin39 for J2, Pin39 for J3, Pin39 for J4.
If the customer's target board needs power from the EK-RA6M3, please note that there are two options: 3.3V or 5V.
The following pins on J1, J2, J3, and J4 can be used to power the customer's target board:
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/a99bdc1c2932b067ff371ba2aeedfe12/images/d04f7b2a50278e8a71083c1281a886da.png', 'data/categories/ra_family/rafsp_knowledge_base/a99bdc1c2932b067ff371ba2aeedfe12/images/d33da1157bd9149b1155edbfb98e466d.png', 'data/categories/ra_family/rafsp_knowledge_base/a99bdc1c2932b067ff371ba2aeedfe12/images/a566c3b8770512310391ff5eade85f34.png']",[],"['|  |\n|  |\n| J29 | Customer Targets Board |\n| Pin6 | P108/SWDIO |\n| Pin8 | P300/SWCLK |\n| Pin2 | P110/RXD9 |\n| Pin4 | P109/TXD9 |\n| J8 | Customer Targets Board |\n| Pin1 | RESET |', '|  |\n|  |\n| 3.3V | 5V |\n| J1: Pin 36 | J1: Pin 40 |\n| J2: Pin 1 |  |\n| J3: Pin 1 |  |\n| J4: Pin 1 |  |', '|  |\n|  |\n| RA |']","{'title': 'RA Family: How to use the Debug Out function of J-Link OB on EK (Evaluation Kit)', 'url': 'https://en-support.renesas.com/knowledgeBase/21172753', 'last_updated': None, 'extracted_at': '2025-03-08T23:20:33.441941'}","Question How to use the Debug Out function of J-Link OB on EK (Evaluation Kit) Answer Renesas has equipped each EK (Evaluation Kit) for RA MCUs, such as EK-RA2E1, EK-RA2E2, EK-RA2L1, EK-RA2A1, etcEK-RA4M1EK-RA4M2EK-RA4M3EK-RA4W1EK-RA6M1EK-RA6M2, EK-RA6M3, EK-RA6M4, EK-RA6M5, etc., all EKs come with J-Link OB (On-Board Debugger), which means that the user can evaluate, debug, and test the MCU with only one USB cable, eliminating the need for a separate J-Link emulator. Most of these EKs have the J-Link OB's Debug Out function, which means that the J-Link OB (On-Board Debugger) on the board can be used to debug not only the MCU on the board, but also the customer's RA target board through the Debug OB function. However, some EKs do not support this function, such as EK-RA2A1, EK-RA4M1, EK-RA6M1, EK-RA6M2, etc. It is important to emphasize that this on-board debugger is officially provided by Renesas, and the firmware can be updated with the update of the SEGGER tool. In this article, EK-RA6M3 is used as an example to describe the specific implementation method. Refer to the schematic diagram of EK-RA6M3 J29 can be used with J8 and J9 to achieve the Debug Out function, J9 does not connect to the jumper capWM1 MM2 , and J8 connects to Pin2 and Pin3. To connect the customer target board, use the following pins of the J29 J29 Customer Targets Board Pin6 P108/SWDIO Pin8 P300/SWCLK Pin2 P110/RXD9 Pin4 P109/TXD9 J8 Customer Targets Board Pin1 RESET Annotation These pins are all 2.0 pitch. To control the MD pin of the RA with J-Link OB, connect Pin 8 of J29 to the MD/P201 pin of the target board chip at the same time. Since the above pins do not have GND pins, it is also necessary to connect the GND of the user board to the GND on the EK board. The following pins can be used with double-row pins Pin30 for J1, Pin39 for J2, Pin39 for J3, Pin39 for J4. If the customer's target board needs power from the EK-RA6M3, please note that there are two options 3.3V or 5V. The following pins on J1, J2, J3, and J4 can be used to power the customer's target board 3.3V 5V J1 Pin 36 J1 Pin 40 J2 Pin 1 J3 Pin 1 J4 Pin 1 Suitable Products RA Annotation Suitable Products","['The image presents a technical diagram, likely from an electronics or computer engineering context, featuring a complex network of lines, symbols, and text. The diagram is divided into several sections, each with its own set of components and labels.\n\n*   **Top Section:**\n    *   A series of lines and symbols are connected to a central point, labeled ""NRPN042PAEN-RC.""\n    *   The lines are numbered from 1 to 9, with some having additional labels or annotations.\n    *   The symbols include various shapes and abbreviations, such as ""P110-TDI,"" ""P109-TDO,"" and ""P108-SWDIO.""\n*   **Middle Section:**\n    *   A large rectangle dominates this section, containing a series of smaller rectangles and lines.\n    *   The rectangles are labeled with abbreviations like ""JTAG RESET#,"" ""NRPN03PAEN-RC,"" and ""Jumper default placement is pins 1-2.""\n    *   The lines connect the rectangles and symbols, forming a complex network.\n*   **Bottom Section:**\n    *   A series of small rectangles are arranged in a row, each containing a single line of text.\n    *   The text includes abbreviations like ""Shunt Jumper 2mm"" and ""Jumper 2mm.""\n    *   The rectangles are connected by lines, forming a horizontal chain.\n*   **Right Side:**\n    *   A column of text provides additional information and labels for the diagram.\n    *   The text includes phrases like ""For normal operation (on-board debugger):"" and ""For external debug:.""\n\nIn summary, the image presents a technical diagram that appears to be related to electronics or computer engineering. The diagram features a complex network of lines, symbols, and text, with various sections and components labeled with abbreviations and annotations. The diagram likely represents a specific circuit or system, but without additional context, it is difficult to determine its exact purpose or function.', 'The image depicts a circuit diagram, showcasing a complex network of interconnected components. The diagram is divided into two main sections: the left side, which features a yellow background with black text and red X\'s, and the right side, which has a white background with blue lines and symbols.\n\nOn the left side, a list of abbreviations and symbols is presented in black text, accompanied by red X\'s. These symbols likely represent specific components or connections within the circuit. The abbreviations include ""P110,"" ""P109,"" ""P108,"" ""P301,"" ""P302,"" ""P303,"" ""P304,"" ""P200,"" ""P201/MD,"" ""RES#,"" ""P204,"" ""P205,"" and ""P206."" Each abbreviation is followed by a number, indicating its corresponding value or position in the circuit.\n\nIn contrast, the right side of the diagram features a white background with blue lines and symbols. This section appears to represent the actual circuit layout, with various components and connections illustrated using blue lines and symbols. The components include resistors (R9, R45, R47K0), capacitors (C32, C31), and other unidentified elements. The blue lines represent the flow of electrical current through the circuit, while the symbols indicate the connections between components.\n\nOverall, the image provides a detailed representation of a complex circuit, allowing viewers to understand the relationships between its various components and connections.', 'The image presents a detailed diagram of the pin headers for an LCD module, specifically the Parallel RGB565 color depth. The diagram is divided into three sections, each displaying a different aspect of the pin headers.\n\n**Top Section:**\n\n*   The top section features a table with 40 columns and 3 rows, labeled ""P000"" to ""P407"" and ""I1"", ""I2"", and ""I3"", respectively.\n*   Each column represents a specific pin on the LCD module, while the rows correspond to the different pin headers.\n*   The table includes various symbols and abbreviations, such as ""P"", ""I"", ""SCL"", ""SDA"", ""R"", ""G"", ""B"", ""DE"", ""B0"", ""B1"", ""B2"", ""B3"", ""B4"", ""B5"", ""B6"", ""B7"", ""B8"", ""B9"", ""B10"", ""B11"", ""B12"", ""B13"", ""B14"", ""B15"", ""B16"", ""B17"", ""B18"", ""B19"", ""B20"", ""B21"", ""B22"", ""B23"", ""B24"", ""B25"", ""B26"", ""B27"", ""B28"", ""B29"", ""B30"", ""B31"", ""B32"", ""B33"", ""B34"", ""B35"", ""B36"", ""B37"", ""B38"", ""B39"", ""B40"", ""B41"", ""B42"", ""B43"", ""B44"", ""B45"", ""B46"", ""B47"", ""B48"", ""B49"", ""B50"", ""B51"", ""B52"", ""B53"", ""B54"", ""B55"", ""B56"", ""B57"", ""B58"", ""B59"", ""B60"", ""B61"", ""B62"", ""B63"", ""B64"", ""B65"", ""B66"", ""B67"", ""B68"", ""B69"", ""B70"", ""B71"", ""B72"", ""B73"", ""B74"", ""B75"", ""B76"", ""B77"", ""B78"", ""B79"", ""B80"", ""B81"", ""B82"", ""B83"", ""B84"", ""B85"", ""B86"", ""B87"", ""B88"", ""B89"", ""B90"", ""B91"", ""B92"", ""B93"", ""B94"", ""B95"", ""B96"", ""B97"", ""B98"", ""B99"", ""B100"", ""B101"", ""B102"", ""B103"", ""B104"", ""B105"", ""B106"", ""B107"", ""B108"", ""B109"", ""B110"", ""B111"", ""B112"", ""B113"", ""B114"", ""B115"", ""B116"", ""B117"", ""B118"", ""B119"", ""B120"", ""B121"", ""B122"", ""B123"", ""B124"", ""B125"", ""B126"", ""B127"", ""B128"", ""B129"", ""B130"", ""B131"", ""B132"", ""B133"", ""B134"", ""B135"", ""B136"", ""B137"", ""B138"", ""B139"", ""B140"", ""B141"", ""B142"", ""B143"", ""B144"", ""B145"", ""B146"", ""B147"", ""B148"", ""B149"", ""B150"", ""B151"", ""B152"", ""B153"", ""B154"", ""B155"", ""B156"", ""B157"", ""B158"", ""B159"", ""B160"", ""B161"", ""B162"", ""B163"", ""B164"", ""B165"", ""B166"", ""B167"", ""B168"", ""B169"", ""B170"", ""B171"", ""B172"", ""B173"", ""B174"", ""B175"", ""B176"", ""B177"", ""B178"", ""B179"", ""B180"", ""B181"", ""B182"", ""B183"", ""B184"", ""B185"", ""B186"", ""B187"", ""B188"", ""B189"", ""B190"", ""B191"", ""B192"", ""B193"", ""B194"", ""B195"", ""B196"", ""B197"", ""B198"", ""B199"", ""B200"", ""B201"", ""B202"", ""B203"", ""B204"", ""B205"", ""B206"", ""B207"", ""B208"", ""B209"", ""B210"", ""B211"", ""B212"", ""B213"", ""B214"", ""B215"", ""B216"", ""B217"", ""B218"", ""B219"", ""B220"", ""B221"", ""B222"", ""B223"", ""B224"", ""B225"", ""B226"", ""B227"", ""B228"", ""B229"", ""B230"", ""B231"", ""B232"", ""B233"", ""B234"", ""B235"", ""B236"", ""B237"", ""B238"", ""B239"", ""B240"", ""B241"", ""B242"", ""B243"", ""B244"", ""B245"", ""B246"", ""B247"", ""B248"", ""B249"", ""B250"", ""B251"", ""B252"", ""B253"", ""B254"", ""B255"", ""B256"", ""B257"", ""B258"", ""B259"", ""B260"", ""B261"", ""B262"", ""B263"", ""B264"", ""B265"", ""B266"", ""B267"", ""B268"", ""B269"", ""B270"", ""B271"", ""B272"", ""B273"", ""B274"", ""B275"", ""B276"", ""B277"", ""B278"", ""B279"", ""B280"", ""B281"", ""B282"", ""B283"", ""B284"", ""B285"", ""B286"", ""B287"", ""B288"", ""B289"", ""B290"", ""B291"", ""B292"", ""B293"", ""B294"", ""B295"", ""B296"", ""B297"", ""B298"", ""B299"", ""B300"", ""B301"", ""B302"", ""B303"", ""B304"", ""B305"", ""B306"", ""B307"", ""B308"", ""B309"", ""B310"", ""B311"", ""B312"", ""B313"", ""B314"", ""B315"", ""B316"", ""B317"", ""B318"", ""B319"", ""B320"", ""B321"", ""B322"", ""B323"", ""B324"", ""B325"", ""B326"", ""B327"", ""B328"", ""B329"", ""B330"", ""B331"", ""B332"", ""B333"", ""B334"", ""B335"", ""B336"", ""B337"", ""B338"", ""B339"", ""B340"", ""B341"", ""B342"", ""B343"", ""B344"", ""B345"", ""B346"", ""B347"", ""B348"", ""B349"", ""B350"", ""B351"", ""B352"", ""B353"", ""B354"", ""B355"", ""B356"", ""B357"", ""B358"", ""B359"", ""B360"", ""B361"", ""B362"", ""B363"", ""B364"", ""B365"", ""B366"", ""B367"", ""B368"", ""B369"", ""B370"", ""B371"", ""B372"", ""B373"", ""B374"", ""B375"", ""B376"", ""B377"", ""B378"", ""B379"", ""B380"", ""B381"", ""B382"", ""B383"", ""B384"", ""B385"", ""B386"", ""B387"", ""B388"", ""B389"", ""B390"", ""B391"", ""B392"", ""B393"", ""B394"", ""B395"", ""B396"", ""B397"", ""B398"", ""B399"", ""B400"", ""B401"", ""B402"", ""B403"", ""B404"", ""B405"", ""B406"", ""B407"", ""B408"", ""B409"", ""B410"", ""B411"", ""B412"", ""B413"", ""B414"", ""B415"", ""B416"", ""B417"", ""B418"", ""B419"", ""B420"", ""B421"", ""B422"", ""B423"", ""B424"", ""B425"", ""B426"", ""B427"", ""B428"", ""B429"", ""B430"", ""B431"", ""B432"", ""B433"", ""B434"", ""B435"", ""B436"", ""B437"", ""B438"", ""B439"", ""B440"", ""B441"", ""B442"", ""B443"", ""B444"", ""B445"", ""B446"", ""B447"", ""B448"", ""B449"", ""B450"", ""B451"", ""B452"", ""B453"", ""B454"", ""B455"", ""B456"", ""B457"", ""B458"", ""B459"", ""B460"", ""B461"", ""B462"", ""B463"", ""B464"", ""B465"", ""B466"", ""B467"", ""B468"", ""B469"", ""B470"", ""B471"", ""B472"", ""B473"", ""B474"", ""B475"", ""B476"", ""B477"", ""B478"", ""B479"", ""B480"", ""B481"", ""B482"", ""B483"", ""B484"", ""B485"", ""B486"", ""B487"", ""B488"", ""B489"", ""B490"", ""B491"", ""B492"", ""B493"", ""B494"", ""B495"", ""B496"", ""B497"", ""B498"", ""B499"", ""B500"", ""B501"", ""B502"", ""B503"", ""B504"", ""B505"", ""B506"", ""B507"", ""B508"", ""B509"", ""B510"", ""B511"", ""B512"", ""B513"", ""B514"", ""B515"", ""B516"", ""B517"", ""B518"", ""B519"", ""B520"", ""B521"", ""B522"", ""B523"", ""B524"", ""B525"", ""B526"", ""B527"", ""B528"", ""B529"", ""B530"", ""B531"", ""B532"", ""B533"", ""B534"", ""B535"", ""B536"", ""B537"", ""B538"", ""B539"", ""B540"", ""B541"", ""B542"", ""B543"", ""B544"", ""B545"", ""B546"", ""B547"", ""B548"", ""B549"", ""B550"", ""B551"", ""B552"", ""B553"", ""B554"", ""B555"", ""B556"", ""B557"", ""B558"", ""B559"", ""B560"", ""B561"", ""B562"", ""B563"", ""B564"", ""B565"", ""B566"", ""B567"", ""B568"", ""B569"", ""B570"", ""B571"", ""B572"", ""B573"", ""B574"", ""B575"", ""B576"", ""B577"", ""B578"", ""B579"", ""B580"", ""B581"", ""B582"", ""B583"", ""B584"", ""B585"", ""B586"", ""B587"", ""B588"", ""B589"", ""B590"", ""B591"", ""B592"", ""B593"", ""B594"", ""B595"", ""B596"", ""B597"", ""B598"", ""B599"", ""B600"", ""B601"", ""B602"", ""B603"", ""B604"", ""B605"", ""B606"", ""B607"", ""B608"", ""B609"", ""B610"", ""B611"", ""B612"", ""B613"", ""B614"", ""B615"", ""B616"", ""B617"", ""B618"", ""B619"", ""B620"", ""B621"", ""B622"", ""B623"", ""B624"", ""B625"", ""B626"", ""B627"", ""B628"", ""B629"", ""B630"", ""B631"", ""B632"", ""B633"", ""B634"", ""B635"", ""B636"", ""B637"", ""B638"", ""B639"", ""B640"", ""B641"", ""B642"", ""B643"", ""B644"", ""B645"", ""B646"", ""B647"", ""B648"", ""B649"", ""B650"", ""B651"", ""B652"", ""B653"", ""B654"", ""B655"", ""B656"", ""B657"", ""B658"", ""B659"", ""B660"", ""B661"", ""B662"", ""B663"", ""B664"", ""B665"", ""B666"", ""B667"", ""B668"", ""B669"", ""B670"", ""B671"", ""B672"", ""B673"", ""B674"", ""B675"", ""B676"", ""B677"", ""B678"", ""B679"", ""B680"", ""B681"", ""B682"", ""B683"", ""B684"", ""B685"", ""B686"", ""B687"", ""B688"", ""B689"", ""B690"", ""B691"", ""B692"", ""B693"", ""B694"", ""B695"", ""B696"", ""B697"", ""B698"", ""B699"", ""B700"", ""B701"", ""B702"", ""B703"", ""B704"", ""B705"", ""B706"", ""B707"", ""B708"", ""B709"", ""B710"", ""B711"", ""B712"", ""B713"", ""B714"", ""B715"", ""B716"", ""B717"", ""B718"", ""B719"", ""B720"", ""B721"", ""B722"", ""B723"", ""B724"", ""B725"", ""B726"", ""B727"", ""B728"", ""B729"", ""B730"", ""B731"", ""B732"", ""B733"", ""B734"", ""B735"", ""B736"", ""B737"", ""B738"", ""B739"", ""B740"", ""B741"", ""B742"", ""B743"", ""B744"", ""B745"", ""B746"", ""B747"", ""B748"", ""B749"", ""B750"", ""B751"", ""B752"", ""B753"", ""B754"", ""B755"", ""B756"", ""B757"", ""B758"", ""B759"", ""B760"", ""B761"", ""B762"", ""B763"", ""B764"", ""B765"", ""B766"", ""B767"", ""B768"", ""B769"", ""B770"", ""B771"", ""B772"", ""B773"", ""B774"", ""B775"", ""B776"", ""B777"", ""B778"", ""B779"", ""B780"", ""B781"", ""B782"", ""B783"", ""B784"", ""B785"", ""B786"", ""B787"", ""B788"", ""B789"", ""B790"", ""B791"", ""B792"", ""B793"", ""B794"", ""B795"", ""B796"", ""B797"", ""B798"", ""B799"", ""B800"", ""B801"", ""B802"", ""B803"", ""B804"", ""B805"", ""B806"", ""B807"", ""B808"", ""B809"", ""B810"", ""B811"", ""B812"", ""B813"", ""B814"", ""B815"", ""B816"", ""B817"", ""B818"", ""B819"", ""B820"", ""B821"", ""B822"", ""B823"", ""B824"", ""B825"", ""B826"", ""B827"", ""B828"", ""B829"", ""B830"", ""B831"", ""B832"", ""B833"", ""B834"", ""B835"", ""B836"", ""B837"", ""B838"", ""B839"", ""B840"", ""B841"", ""B842"", ""B843"", ""B844"", ""B845"", ""B846"", ""B847"", ""B848"", ""B849"", ""B850"", ""B851"", ""B852"", ""B853"", ""B854"", ""B855"", ""B856"", ""B857"", ""B858"", ""B859"", ""B860"", ""B861"", ""B862"", ""B863"", ""B864"", ""B865"", ""B866"", ""B867"", ""B868"", ""B869"", ""B870"", ""B871"", ""B872"", ""B873"", ""B874"", ""B875"", ""B876"", ""B877"", ""B878"", ""B879"", ""B880"", ""B881"", ""B882"", ""B883"", ""B884"", ""B885"", ""B886"", ""B887"", ""B888"", ""B889"", ""B890"", ""B891"", ""B892"", ""B893"", ""B894"", ""B895"", ""B896"", ""B897"", ""B898"", ""B899"", ""B900"", ""B901"", ""B902"", ""B903"", ""B904"", ""B905"", ""B906"", ""B907"", ""B908"", ""B909"", ""B910"", ""B911"", ""B912"", ""B913"", ""B914"", ""B915"", ""B916"", ""B917"", ""B918"", ""B919"", ""B920"", ""B921"", ""B922"", ""B923"", ""B924"", ""B925"", ""B926"", ""B927"", ""B928"", ""B929"", ""B930"", ""B931"", ""B932"", ""B933"", ""B934"", ""B935"", ""B936"", ""B937"", ""B938"", ""B939"", ""B940"", ""B941"", ""B942"", ""B943"", ""B944"", ""B945"", ""B946"", ""B947"", ""B948"", ""B949"", ""B950"", ""B951"", ""B952"", ""B953"", ""B954"", ""B955"", ""B956"", ""B957"", ""B958"", ""B959"", ""B960"", ""B961"", ""B962"", ""B963"", ""B964"", ""B965"", ""B966"", ""B967"", ""B968"", ""B969"", ""B970"", ""B971"", ""B972"", ""B973"", ""B974"", ""B975"", ""B976"", ""B977"", ""B978"", ""B979"", ""B980"", ""B981"", ""B982"", ""B983"", ""B984"", ""B985"", ""']"
1e8081c528d379f61c9dd5652c68a2d8,"Question:
When creating a RA0E1 project and changing the optimization option to None (-O0), there is an error during compilation. If the optimization option is changed to any other optimization option, there is no error during compilation.
Answer:
Currently, the RA0E1 uses ""Fill gap"" and ""Optimize aggressively for size (-Oz)"" by default to optimize code size. According to the FSP manual, there is a section of code flash between the end of the vector table (near the beginning of the flash) and the ROM register (address 0x400). When the ""Fill Flash Gap"" option is selected to ""Fill gap"", the pre-selected setup function will be filled in this area to reduce the amount of the Code Flash used by the FSP. Therefore, when the user changes the optimization option to ""None (-O0)"", the compiled content of the function will occupy a larger Flash space, which will exceed the gap area, resulting in a compilation error.
To avoid this, the user can disable gap filling by changing the ""Fill Flash Gap"" setting to ""Do not fill gap"" in the BSP properties.
Appendix: For the meaning of ""Fill Flash Gap"", please refer to the content in the FSP manual as follows:
Suitable Products
RA
When creating a RA0E1 project and changing the optimization option to None (-O0), there is an error during compilation. If the optimization option is changed to any other optimization option, there is no error during compilation.
When creating a RA0E1 project and changing the optimization option to None (-O0), there is an error during compilation. If the optimization option is changed to any other optimization option, there is no error during compilation.
Answer:
Currently, the RA0E1 uses ""Fill gap"" and ""Optimize aggressively for size (-Oz)"" by default to optimize code size. According to the FSP manual, there is a section of code flash between the end of the vector table (near the beginning of the flash) and the ROM register (address 0x400). When the ""Fill Flash Gap"" option is selected to ""Fill gap"", the pre-selected setup function will be filled in this area to reduce the amount of the Code Flash used by the FSP. Therefore, when the user changes the optimization option to ""None (-O0)"", the compiled content of the function will occupy a larger Flash space, which will exceed the gap area, resulting in a compilation error.
To avoid this, the user can disable gap filling by changing the ""Fill Flash Gap"" setting to ""Do not fill gap"" in the BSP properties.
Appendix: For the meaning of ""Fill Flash Gap"", please refer to the content in the FSP manual as follows:
Suitable Products
RA
Currently, the RA0E1 uses ""Fill gap"" and ""Optimize aggressively for size (-Oz)"" by default to optimize code size. According to the FSP manual, there is a section of code flash between the end of the vector table (near the beginning of the flash) and the ROM register (address 0x400). When the ""Fill Flash Gap"" option is selected to ""Fill gap"", the pre-selected setup function will be filled in this area to reduce the amount of the Code Flash used by the FSP. Therefore, when the user changes the optimization option to ""None (-O0)"", the compiled content of the function will occupy a larger Flash space, which will exceed the gap area, resulting in a compilation error.
To avoid this, the user can disable gap filling by changing the ""Fill Flash Gap"" setting to ""Do not fill gap"" in the BSP properties.
Appendix: For the meaning of ""Fill Flash Gap"", please refer to the content in the FSP manual as follows:
Currently, the RA0E1 uses ""Fill gap"" and ""Optimize aggressively for size (-Oz)"" by default to optimize code size. According to the FSP manual, there is a section of code flash between the end of the vector table (near the beginning of the flash) and the ROM register (address 0x400). When the ""Fill Flash Gap"" option is selected to ""Fill gap"", the pre-selected setup function will be filled in this area to reduce the amount of the Code Flash used by the FSP. Therefore, when the user changes the optimization option to ""None (-O0)"", the compiled content of the function will occupy a larger Flash space, which will exceed the gap area, resulting in a compilation error.
To avoid this, the user can disable gap filling by changing the ""Fill Flash Gap"" setting to ""Do not fill gap"" in the BSP properties.
Appendix: For the meaning of ""Fill Flash Gap"", please refer to the content in the FSP manual as follows:
Suitable Products
RA
Chinese
Chinese","['data/categories/ra_family/rafsp_knowledge_base/1e8081c528d379f61c9dd5652c68a2d8/images/f38a5a98a38add192f308b9fb6a3c235.png', 'data/categories/ra_family/rafsp_knowledge_base/1e8081c528d379f61c9dd5652c68a2d8/images/bab6ca49ea558cbfc644566873843096.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'RA0E1: When I create a RA0E1 project and change the optimization option to none (-O0), an error occurs during compilation', 'url': 'https://en-support.renesas.com/knowledgeBase/21789662', 'last_updated': '2025-04-02', 'extracted_at': '2025-03-08T23:22:30.731699'}","Question When creating a RA0E1 project and changing the optimization option to None (-O0), there is an error during compilation. If the optimization option is changed to any other optimization option, there is no error during compilation. Answer Currently, the RA0E1 uses ""Fill gap"" and ""Optimize aggressively for size (-Oz)"" by default to optimize code size. According to the FSP manual, there is a section of code flash between the end of the vector table (near the beginning of the flash) and the ROM register (address 0x400). When the ""Fill Flash Gap"" option is selected to ""Fill gap"", the pre-selected setup function will be filled in this area to reduce the amount of the Code Flash used by the FSP. Therefore, when the user changes the optimization option to ""None (-O0)"", the compiled content of the function will occupy a larger Flash space, which will exceed the gap area, resulting in a compilation error. To avoid this, the user can disable gap filling by changing the ""Fill Flash Gap"" setting to ""Do not fill gap"" in the BSP properties. Appendix For the meaning of ""Fill Flash Gap"", please refer to the content in the FSP manual as follows Suitable Products RA Chinese","['The image shows a screenshot of a computer window with a list of settings. The window is titled ""RA0E1 Family"" and has a list of settings below it, including ""Enable inline BSP IRQ functions"", ""Main Oscillation Stabilization Time 2^18/X1"", ""Use Low Voltage Mode"", ""ID Code Mode"", ""ID Code (32 Hex Characters)"", ""Fill Flash Gap"", and ""RA Common"". \n\n*   The ""Fill Flash Gap"" setting is highlighted in gray and has a dropdown menu with two options: ""Fill gap"" and ""Do not fill gap"".\n*   The ""RA Common"" setting is highlighted in gray and has a dropdown menu with two options: ""Main stack size (bytes)"" and ""Fill gap"".\n*   The ""Fill gap"" option is selected for both settings.\n*   The background of the window is white, with a gray border around the edges.\n\nOverall, the image appears to be a screenshot of a computer window with a list of settings related to a specific device or component. The highlighted settings and dropdown menus suggest that the user is configuring the device\'s behavior or performance.', 'The image presents a table with three columns and two rows, providing information about the ""Fill Flash Gap"" in code flash. The table is divided into three columns: ""Fill Flash Gap,"" ""Do not fill gap,"" and ""Fill gap."" The first row contains the title ""Fill Flash Gap"" in the first column, while the second row is empty.\n\n**Key Points:**\n\n*   The table provides information about the ""Fill Flash Gap"" in code flash.\n*   The first row contains the title ""Fill Flash Gap"" in the first column.\n*   The second row is empty, indicating that there is no additional information to be filled in this section.\n\n**Summary:**\n\nThe image presents a table with three columns and two rows, providing information about the ""Fill Flash Gap"" in code flash. The first row contains the title ""Fill Flash Gap"" in the first column, while the second row is empty. The table does not provide any additional information about the ""Fill Flash Gap"" in code flash.']"
4753e664b55c0f90b45c0d867d04a93b,"Question:
In the RA8 user's manual, there is a description of ""Notes on transitioning to or canceling low power state"". What should I do if I use FSP?
Answer:
In the RA8 MCU, it is necessary to insert a certain period of NOP operation wait [MM1] [KK2] (no execution) during the transition and return to the low-power mode. The FSP contains functions corresponding to the source files ra/fsp/src/bsp/mcu/all/bsp_clocks.c of the MCU Board Support Package (BSP).
Processing when transitioning to low power consumption mode: bsp_prv_clock_prepare_pre_sleep ()
Processing when resuming from low power consumption mode: bsp_prv_clock_prepare_post_sleep ()
These functions are called internally by r_lpm driver's R_LPM_LowPowerModeEnter functions, so no additional processing is required when using them to perform low-power transitions.
However, if you do not use a r_lpm driver and perform the low-power mode transition in your application's own code, implement it in a way that meets the guidelines in the device's user's manual.  If necessary, you can use the above BSP functions.
Note: bsp_prv_clock_prepare_pre_sleep() and bsp_prv_clock_prepare_post_sleep() can be disabled in the BSP tab of the Configurator (Clocks -> Sleep Mode Entry and Exit Delays) ( Default: Enabled).
Suitable Products
RA Family
In the RA8 user's manual, there is a description of ""Notes on transitioning to or canceling low power state"". What should I do if I use FSP?
In the RA8 user's manual, there is a description of ""Notes on transitioning to or canceling low power state"". What should I do if I use FSP?
Answer:
In the RA8 MCU, it is necessary to insert a certain period of NOP operation wait [MM1] [KK2] (no execution) during the transition and return to the low-power mode. The FSP contains functions corresponding to the source files ra/fsp/src/bsp/mcu/all/bsp_clocks.c of the MCU Board Support Package (BSP).
Processing when transitioning to low power consumption mode: bsp_prv_clock_prepare_pre_sleep ()
Processing when resuming from low power consumption mode: bsp_prv_clock_prepare_post_sleep ()
These functions are called internally by r_lpm driver's R_LPM_LowPowerModeEnter functions, so no additional processing is required when using them to perform low-power transitions.
However, if you do not use a r_lpm driver and perform the low-power mode transition in your application's own code, implement it in a way that meets the guidelines in the device's user's manual.  If necessary, you can use the above BSP functions.
Note: bsp_prv_clock_prepare_pre_sleep() and bsp_prv_clock_prepare_post_sleep() can be disabled in the BSP tab of the Configurator (Clocks -> Sleep Mode Entry and Exit Delays) ( Default: Enabled).
Suitable Products
RA Family
In the RA8 MCU, it is necessary to insert a certain period of NOP operation wait [MM1] [KK2] (no execution) during the transition and return to the low-power mode. The FSP contains functions corresponding to the source files ra/fsp/src/bsp/mcu/all/bsp_clocks.c of the MCU Board Support Package (BSP).
Processing when transitioning to low power consumption mode: bsp_prv_clock_prepare_pre_sleep ()
Processing when resuming from low power consumption mode: bsp_prv_clock_prepare_post_sleep ()
These functions are called internally by r_lpm driver's R_LPM_LowPowerModeEnter functions, so no additional processing is required when using them to perform low-power transitions.
However, if you do not use a r_lpm driver and perform the low-power mode transition in your application's own code, implement it in a way that meets the guidelines in the device's user's manual.  If necessary, you can use the above BSP functions.
Note: bsp_prv_clock_prepare_pre_sleep() and bsp_prv_clock_prepare_post_sleep() can be disabled in the BSP tab of the Configurator (Clocks -> Sleep Mode Entry and Exit Delays) ( Default: Enabled).
In the RA8 MCU, it is necessary to insert a certain period of NOP operation wait [MM1] [KK2] (no execution) during the transition and return to the low-power mode. The FSP contains functions corresponding to the source files ra/fsp/src/bsp/mcu/all/bsp_clocks.c of the MCU Board Support Package (BSP).
These functions are called internally by r_lpm driver's R_LPM_LowPowerModeEnter functions, so no additional processing is required when using them to perform low-power transitions.
However, if you do not use a r_lpm driver and perform the low-power mode transition in your application's own code, implement it in a way that meets the guidelines in the device's user's manual.  If necessary, you can use the above BSP functions.
Note: bsp_prv_clock_prepare_pre_sleep() and bsp_prv_clock_prepare_post_sleep() can be disabled in the BSP tab of the Configurator (Clocks -> Sleep Mode Entry and Exit Delays) ( Default: Enabled).
Suitable Products
RA Family
日本語
日本語",['data/categories/ra_family/rafsp_knowledge_base/4753e664b55c0f90b45c0d867d04a93b/images/5b586fe81a17d9097fea0607f9bc66a8.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: Precautions when entering and exiting the low-power state in RA8', 'url': 'https://en-support.renesas.com/knowledgeBase/21698324', 'last_updated': None, 'extracted_at': '2025-03-08T23:22:55.465369'}","Question In the RA8 user's manual, there is a description of ""Notes on transitioning to or canceling low power state"". What should I do if I use FSP? Answer In the RA8 MCU, it is necessary to insert a certain period of NOP operation wait MM1 KK2 (no execution) during the transition and return to the low-power mode. The FSP contains functions corresponding to the source files ra/fsp/src/bsp/mcu/all/bspclocks.c of the MCU Board Support Package (BSP). Processing when transitioning to low power consumption mode bspprvclockpreparepresleep () Processing when resuming from low power consumption mode bspprvclockpreparepostsleep () These functions are called internally by rlpm driver's RLPMLowPowerModeEnter functions, so no additional processing is required when using them to perform low-power transitions. However, if you do not use a rlpm driver and perform the low-power mode transition in your application's own code, implement it in a way that meets the guidelines in the device's user's manual. If necessary, you can use the above BSP functions. Note bspprvclockpreparepresleep() and bspprvclockpreparepostsleep() can be disabled in the BSP tab of the Configurator (Clocks - Sleep Mode Entry and Exit Delays) ( Default Enabled). Suitable Products RA Family ","['The image shows a list of clock settings, with the ""Sleep Mode Entry and Exit Delays"" option highlighted in red. The list includes the following options:\n\n*   HOCO FLL Function\n*   Clock Settling Delay\n*   Sleep Mode Entry and Exit Delays\n*   RTOS Sleep on Idle\n*   MSTP Change Delays\n\nThe ""Sleep Mode Entry and Exit Delays"" option is highlighted in red, indicating that it is currently enabled. The background of the image is white, with a gray border around the edges. The text is black, and the red highlighting is used to draw attention to the selected option. Overall, the image appears to be a screenshot of a computer program or software interface, possibly related to clock settings or timing control.']"
dace1a997b96e94b9219abf318eb3463,"Answer:
FSP's USB driver is equipped with a debug log output function to check the execution status of the driver's internal program (e.g., enumeration status and event information). You can enable the debug output of the USB driver by defining the USB_DEBUG_ON with compiler options as shown below.
The output destination is implemented in the r_usb_basic_define.h file to execute the printf function of the standard library by default. If you want to change this to a different destination, edit the USB_PRINTFn macro definition in the r_usb_basic_define.h file or redefine the _write function in the User Application code.
To output the debug log with the SEGGER J-Link RTT function, define the _write function as follows.
int _write(int file, char *ptr, int len)
{
     FSP_PARAMETER_NOT_USED(file);
     int    ret;
          ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);
          return ret;
}
  Notes:
Enabling this feature may reduce the processing, execution, and performance of the USB driver.
Suitable Products
RA Family
Answer:
FSP's USB driver is equipped with a debug log output function to check the execution status of the driver's internal program (e.g., enumeration status and event information). You can enable the debug output of the USB driver by defining the USB_DEBUG_ON with compiler options as shown below.
The output destination is implemented in the r_usb_basic_define.h file to execute the printf function of the standard library by default. If you want to change this to a different destination, edit the USB_PRINTFn macro definition in the r_usb_basic_define.h file or redefine the _write function in the User Application code.
To output the debug log with the SEGGER J-Link RTT function, define the _write function as follows.
int _write(int file, char *ptr, int len)
{
     FSP_PARAMETER_NOT_USED(file);
     int    ret;
          ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);
          return ret;
}
  Notes:
Enabling this feature may reduce the processing, execution, and performance of the USB driver.
Suitable Products
RA Family
FSP's USB driver is equipped with a debug log output function to check the execution status of the driver's internal program (e.g., enumeration status and event information). You can enable the debug output of the USB driver by defining the USB_DEBUG_ON with compiler options as shown below.
The output destination is implemented in the r_usb_basic_define.h file to execute the printf function of the standard library by default. If you want to change this to a different destination, edit the USB_PRINTFn macro definition in the r_usb_basic_define.h file or redefine the _write function in the User Application code.
To output the debug log with the SEGGER J-Link RTT function, define the _write function as follows.
int _write(int file, char *ptr, int len)
{
     FSP_PARAMETER_NOT_USED(file);
     int    ret;
          ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);
          return ret;
}
  Notes:
Enabling this feature may reduce the processing, execution, and performance of the USB driver.
FSP's USB driver is equipped with a debug log output function to check the execution status of the driver's internal program (e.g., enumeration status and event information). You can enable the debug output of the USB driver by defining the USB_DEBUG_ON with compiler options as shown below.
The output destination is implemented in the r_usb_basic_define.h file to execute the printf function of the standard library by default. If you want to change this to a different destination, edit the USB_PRINTFn macro definition in the r_usb_basic_define.h file or redefine the _write function in the User Application code.
To output the debug log with the SEGGER J-Link RTT function, define the _write function as follows.
int _write(int file, char *ptr, int len)
int _write(int file, char *ptr, int len)
{
{
FSP_PARAMETER_NOT_USED(file);
FSP_PARAMETER_NOT_USED(file);
int    ret;
int    ret;
ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);
ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);
return ret;
return ret;
}
}
Notes:
Enabling this feature may reduce the processing, execution, and performance of the USB driver.
Suitable Products
RA Family
日本語
日本語",['data/categories/ra_family/rafsp_knowledge_base/dace1a997b96e94b9219abf318eb3463/images/f7d94c41c5a86cc8baed51846d34dba4.png'],[],"['|  |\n|  |\n| int _write(int file, char *ptr, int len)\n{\n     FSP_PARAMETER_NOT_USED(file);\n     int    ret;\n          ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);\n          return ret;\n} |', '|  |\n|  |\n| RA Family |']","{'title': 'RA Family: How to enable debug logging for USB driver', 'url': 'https://en-support.renesas.com/knowledgeBase/21652595', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:15.881018'}","Answer FSP's USB driver is equipped with a debug log output function to check the execution status of the driver's internal program (e.g., enumeration status and event information). You can enable the debug output of the USB driver by defining the USBDEBUGON with compiler options as shown below. The output destination is implemented in the rusbbasicdefine.h file to execute the printf function of the standard library by default. If you want to change this to a different destination, edit the USBPRINTFn macro definition in the rusbbasicdefine.h file or redefine the write function in the User Application code. To output the debug log with the SEGGER J-Link RTT function, define the write function as follows. int write(int file, char ptr, int len)  FSPPARAMETERNOTUSED(file); int ret; ret  (int)SEGGERRTTWrite(0, ptr, (unsigned int)len); return ret;  Notes Enabling this feature may reduce the processing, execution, and performance of the USB driver. Suitable Products RA Family FSPPARAMETERNOTUSED(file); int ret; ret  (int)SEGGERRTTWrite(0, ptr, (unsigned int)len); return ret; Notes ","['The image shows a screenshot of a computer program with a menu open, displaying various options and settings. The menu is titled ""Settings"" and has several sub-menus, including ""Tool Settings,"" ""Toolchain,"" ""Build Steps,"" ""Build Artifact,"" ""Binary Parsers,"" and ""Error Parsers."" \n\n*   The ""Tool Settings"" menu has options such as ""Target Processor,"" ""Optimization,"" ""Warnings,"" ""Debugging,"" ""GNU ARM Cross Assembler,"" and ""GNU ARM Cross C Compiler.""\n*   The ""Toolchain"" menu has options such as ""Build Steps,"" ""Build Artifact,"" ""Binary Parsers,"" and ""Error Parsers.""\n*   The ""Build Steps"" menu has options such as ""Preprocess only (-E),"" ""Defined symbols (-D),"" and ""Renesas RA.""\n*   The ""Build Artifact"" menu has options such as ""RA_OBJS_GMA,"" ""RA_LIBRARY,"" and ""USB_DEBUG_ON.""\n*   The ""Binary Parsers"" menu has options such as ""Do not search system directories (-nostdinc)"" and ""Preprocess only (-E).""\n*   The ""Error Parsers"" menu has options such as ""Defined symbols (-D)"" and ""Renesas RA.""\n\nOverall, the image appears to be a screenshot of a computer program used for building and debugging software, specifically for the Renesas RA microcontroller. The menu options suggest that the program is designed to allow users to customize various settings and parameters for building and debugging their code.']"
56b8d942e88e655c62d995783a04781a,"Answer:
RA6 MCU device supports QSPI memory controller for connecting serial ROM such as serial flash memory and has an SPI compatible interface. The QSPI controls the XIP mode for serial flash using serial data signals. Thus it is possible to run the code from external QSPI flash memory using XIP mode.
The attached reference example code builds on voice-ra6e1 kit, this board is equipped with AT25SF64 QSPI flash memory and connected to MCU QSPI interface as below –
To configure the board for QSPI flash memory, the jumper setting needs to be selected as mentioned above.
The reference sample application performs initial configuration for the AT25SF64 and enables the QSPI XIP mode, and subsequently runs the “blinky_fun” function which is placed in QSPI section "".qspi_flash"" of  external flash memory.
After loading the application into the MCU via e2studio, you can also confirm the QSPI external flash area through the memory view window of e2studio as below –
Environment details of sample project:
Board:       Voice-ra6e1 kit
FSP:          v5.5.0 or later
IDE:           e2studio - 2024-07 (24.7.0) or later
Compiler:  GCC - 12.2.1.arm-12-mpacbti-34 or later
Suitable Products
RA6E1
Answer:
RA6 MCU device supports QSPI memory controller for connecting serial ROM such as serial flash memory and has an SPI compatible interface. The QSPI controls the XIP mode for serial flash using serial data signals. Thus it is possible to run the code from external QSPI flash memory using XIP mode.
The attached reference example code builds on voice-ra6e1 kit, this board is equipped with AT25SF64 QSPI flash memory and connected to MCU QSPI interface as below –
To configure the board for QSPI flash memory, the jumper setting needs to be selected as mentioned above.
The reference sample application performs initial configuration for the AT25SF64 and enables the QSPI XIP mode, and subsequently runs the “blinky_fun” function which is placed in QSPI section "".qspi_flash"" of  external flash memory.
After loading the application into the MCU via e2studio, you can also confirm the QSPI external flash area through the memory view window of e2studio as below –
Environment details of sample project:
Board:       Voice-ra6e1 kit
FSP:          v5.5.0 or later
IDE:           e2studio - 2024-07 (24.7.0) or later
Compiler:  GCC - 12.2.1.arm-12-mpacbti-34 or later
Suitable Products
RA6E1
RA6 MCU device supports QSPI memory controller for connecting serial ROM such as serial flash memory and has an SPI compatible interface. The QSPI controls the XIP mode for serial flash using serial data signals. Thus it is possible to run the code from external QSPI flash memory using XIP mode.
The attached reference example code builds on voice-ra6e1 kit, this board is equipped with AT25SF64 QSPI flash memory and connected to MCU QSPI interface as below –
To configure the board for QSPI flash memory, the jumper setting needs to be selected as mentioned above.
The reference sample application performs initial configuration for the AT25SF64 and enables the QSPI XIP mode, and subsequently runs the “blinky_fun” function which is placed in QSPI section "".qspi_flash"" of  external flash memory.
After loading the application into the MCU via e2studio, you can also confirm the QSPI external flash area through the memory view window of e2studio as below –
Environment details of sample project:
Board:       Voice-ra6e1 kit
FSP:          v5.5.0 or later
IDE:           e2studio - 2024-07 (24.7.0) or later
Compiler:  GCC - 12.2.1.arm-12-mpacbti-34 or later
RA6 MCU device supports QSPI memory controller for connecting serial ROM such as serial flash memory and has an SPI compatible interface. The QSPI controls the XIP mode for serial flash using serial data signals. Thus it is possible to run the code from external QSPI flash memory using XIP mode.
The attached reference example code builds on voice-ra6e1 kit, this board is equipped with AT25SF64 QSPI flash memory and connected to MCU QSPI interface as below –
To configure the board for QSPI flash memory, the jumper setting needs to be selected as mentioned above.
The reference sample application performs initial configuration for the AT25SF64 and enables the QSPI XIP mode, and subsequently runs the “blinky_fun” function which is placed in QSPI section "".qspi_flash"" of  external flash memory.
After loading the application into the MCU via e2studio, you can also confirm the QSPI external flash area through the memory view window of e2studio as below –
Environment details of sample project:
Suitable Products
RA6E1
Japanese
Japanese","['data/categories/ra_family/rafsp_knowledge_base/56b8d942e88e655c62d995783a04781a/images/33546e3a71a70457d7afa0743683b8ba.png', 'data/categories/ra_family/rafsp_knowledge_base/56b8d942e88e655c62d995783a04781a/images/d498529cd3cf59e3deb93e4de610118a.png', 'data/categories/ra_family/rafsp_knowledge_base/56b8d942e88e655c62d995783a04781a/images/40e8725348c21bb7444d29076bf2830c.png']",[],['|  |\n|  |\n| RA6E1 |'],"{'title': 'RA Family: How to run code from external QSPI flash using XIP mode', 'url': 'https://en-support.renesas.com/knowledgeBase/21789659', 'last_updated': '2025-04-02', 'extracted_at': '2025-03-08T23:22:21.203943'}","Answer RA6 MCU device supports QSPI memory controller for connecting serial ROM such as serial flash memory and has an SPI compatible interface. The QSPI controls the XIP mode for serial flash using serial data signals. Thus it is possible to run the code from external QSPI flash memory using XIP mode. The attached reference example code builds on voice-ra6e1 kit, this board is equipped with AT25SF64 QSPI flash memory and connected to MCU QSPI interface as below  To configure the board for QSPI flash memory, the jumper setting needs to be selected as mentioned above. The reference sample application performs initial configuration for the AT25SF64 and enables the QSPI XIP mode, and subsequently runs the blinkyfun function which is placed in QSPI section "".qspiflash"" of external flash memory. After loading the application into the MCU via e2studio, you can also confirm the QSPI external flash area through the memory view window of e2studio as below  Environment details of sample project Board Voice-ra6e1 kit FSP v5.5.0 or later IDE e2studio - 2024-07 (24.7.0) or later Compiler GCC - 12.2.1.arm-12-mpacbti-34 or later Suitable Products RA6E1 Japanese","['The image presents a technical diagram, likely related to computer hardware or electronics, featuring a combination of text and symbols. The diagram is divided into two main sections: a larger section on the left and a smaller section on the right.\n\n**Left Section:**\n\n*   The left section contains a complex circuit diagram with various components, including resistors (R), capacitors (C), and integrated circuits (ICs).\n*   The diagram includes labels and annotations in red and blue text, providing additional information about the components and their connections.\n*   The background of the left section is white, with a black border around the edges.\n\n**Right Section:**\n\n*   The right section features a smaller diagram with a yellow background and a black border.\n*   This diagram appears to be a simplified representation of the larger circuit diagram on the left, focusing on specific components and their connections.\n*   The right section also includes labels and annotations in red and blue text, similar to the left section.\n\n**Overall:**\n\n*   The image suggests that it is a technical document or presentation related to computer hardware or electronics.\n*   The use of complex circuit diagrams and technical terminology implies that the image is intended for an audience with a strong background in electronics or computer engineering.\n*   The inclusion of labels and annotations in red and blue text adds an extra layer of detail and clarity to the diagrams, making it easier for viewers to understand the technical information presented.', 'The image displays a line of code in a programming language, likely C#. The code reads: ""void BSP_PLACE_IN_SECTION("".qspi_flash"") blinky_fun(void);"". This line defines a function named ""blinky_fun"" that is placed in the "".qspi_flash"" section. The function is declared as taking no arguments and returning no value. The code is written in a style consistent with C# programming, with the use of the ""void"" keyword to indicate that the function does not return a value, and the use of parentheses to enclose the function name and argument list. The code is likely part of a larger program or project, and is intended to be compiled and executed on a specific platform or device.', 'The image shows a screenshot of a computer program, likely a debugger or memory viewer, displaying a list of hexadecimal addresses and their corresponding values. The top-left corner has a menu bar with options such as ""Monitors"" and ""New Renderrings..."". Below this is a table with four columns: ""Address"", ""0 - 3"", ""4 - 7"", and ""8 - B"". The ""Address"" column lists a series of hexadecimal addresses, while the other columns display the corresponding values for each address.\n\nThe values in the columns are represented in hexadecimal format, with each column showing a different range of bits (0-3, 4-7, 8-B). The values are displayed in a grid-like pattern, with each row representing a single address and its corresponding values.\n\nIn the top-right corner, there is a button labeled ""New Renderrings..."" which suggests that the user can create new renderings or views of the data. The background of the image is a light gray color, with a darker gray border around the edges.\n\nOverall, the image appears to be a screenshot of a computer program used for debugging or analyzing memory data. The program allows users to view and manipulate hexadecimal addresses and their corresponding values, making it a useful tool for developers and programmers.']"
f740f948e991648be77e7da74c03781d,"Question:
The user program (such as the hal_entcy function) does not execute because the R_BSP_Init_RTC function called from the FSP initialization function SystemInit does not complete.
Answer:
The RTC registers are not initialized by reset. In order to prevent unintentional counting operations, initialization processing in software is required even when the RTC is not used. If the Subclock Populated parameter is set to Populated in the BSP tab properties of the FSP Configurator, the R_BSP_Init_RTC function executes the RTC software reset process using the subclock oscillator as the clock source and waits for the process to complete. If no subclocks are populated, the process does not terminate.
If you do not want to use a subclock oscillator, set Subclock Populated to Not Populated.
For details on the initialization procedure when the RTC is not used, refer to RTC > Usage Notes > Initialization Procedure When the RTC Is Not to Be Used in the Hardware User's Manual of the MCU device.
Suitable Products
RA Family
The user program (such as the hal_entcy function) does not execute because the R_BSP_Init_RTC function called from the FSP initialization function SystemInit does not complete.
The user program (such as the hal_entcy function) does not execute because the R_BSP_Init_RTC function called from the FSP initialization function SystemInit does not complete.
Answer:
The RTC registers are not initialized by reset. In order to prevent unintentional counting operations, initialization processing in software is required even when the RTC is not used. If the Subclock Populated parameter is set to Populated in the BSP tab properties of the FSP Configurator, the R_BSP_Init_RTC function executes the RTC software reset process using the subclock oscillator as the clock source and waits for the process to complete. If no subclocks are populated, the process does not terminate.
If you do not want to use a subclock oscillator, set Subclock Populated to Not Populated.
For details on the initialization procedure when the RTC is not used, refer to RTC > Usage Notes > Initialization Procedure When the RTC Is Not to Be Used in the Hardware User's Manual of the MCU device.
Suitable Products
RA Family
The RTC registers are not initialized by reset. In order to prevent unintentional counting operations, initialization processing in software is required even when the RTC is not used. If the Subclock Populated parameter is set to Populated in the BSP tab properties of the FSP Configurator, the R_BSP_Init_RTC function executes the RTC software reset process using the subclock oscillator as the clock source and waits for the process to complete. If no subclocks are populated, the process does not terminate.
If you do not want to use a subclock oscillator, set Subclock Populated to Not Populated.
For details on the initialization procedure when the RTC is not used, refer to RTC > Usage Notes > Initialization Procedure When the RTC Is Not to Be Used in the Hardware User's Manual of the MCU device.
The RTC registers are not initialized by reset. In order to prevent unintentional counting operations, initialization processing in software is required even when the RTC is not used. If the Subclock Populated parameter is set to Populated in the BSP tab properties of the FSP Configurator, the R_BSP_Init_RTC function executes the RTC software reset process using the subclock oscillator as the clock source and waits for the process to complete. If no subclocks are populated, the process does not terminate.
If you do not want to use a subclock oscillator, set Subclock Populated to Not Populated.
For details on the initialization procedure when the RTC is not used, refer to RTC > Usage Notes > Initialization Procedure When the RTC Is Not to Be Used in the Hardware User's Manual of the MCU device.
Suitable Products
RA Family
日本語
日本語",['data/categories/ra_family/rafsp_knowledge_base/f740f948e991648be77e7da74c03781d/images/d40e5b590b2429225ee30d42781b81eb.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: FSP initialization R_BSP_Init_RTC function does not finish and user program does not run', 'url': 'https://en-support.renesas.com/knowledgeBase/21715562', 'last_updated': '2024-10-12', 'extracted_at': '2025-03-08T23:22:36.505997'}","Question The user program (such as the halentcy function) does not execute because the RBSPInitRTC function called from the FSP initialization function SystemInit does not complete. Answer The RTC registers are not initialized by reset. In order to prevent unintentional counting operations, initialization processing in software is required even when the RTC is not used. If the Subclock Populated parameter is set to Populated in the BSP tab properties of the FSP Configurator, the RBSPInitRTC function executes the RTC software reset process using the subclock oscillator as the clock source and waits for the process to complete. If no subclocks are populated, the process does not terminate. If you do not want to use a subclock oscillator, set Subclock Populated to Not Populated. For details on the initialization procedure when the RTC is not used, refer to RTC  Usage Notes  Initialization Procedure When the RTC Is Not to Be Used in the Hardware User's Manual of the MCU device. Suitable Products RA Family ","['The image presents a table with two columns and four rows, providing information about the main oscillator clock source and crystal or resonator. The table is divided into two sections: ""Main Oscillator Clock Source"" and ""Crystal or Resonator."" Each section has two rows, with the first row labeled ""Subclock Populated"" and the second row labeled ""Subclock Drive (Drive capacitance availability varies by MCU)."" The table also includes a row for ""Subclock Stabilization Time (ms)"" with a value of 1000.\n\n**Main Oscillator Clock Source**\n\n*   **Subclock Populated**: This row indicates that the subclock is populated.\n*   **Subclock Drive (Drive capacitance availability varies by MCU)**: This row provides information about the subclock drive, which varies depending on the MCU (Microcontroller Unit).\n\n**Crystal or Resonator**\n\n*   **Not Populated**: This row indicates that the crystal or resonator is not populated.\n*   **Subclock Stabilization Time (ms)**: This row provides information about the subclock stabilization time, which is 1000 milliseconds.\n\nIn summary, the table provides information about the main oscillator clock source and crystal or resonator, including whether they are populated, the subclock drive, and the subclock stabilization time. The table highlights the differences between the two sections, with the main oscillator clock source being populated and the crystal or resonator not being populated.']"
8b406254447d6294eb0bf458a27d70db,"Note that this article was written for FSP 1.1.0, but the process still works for FSP 3.7.0 and above.
Introduction
This article describes steps for creating a new custom Board Support Pack (BSP) for Renesas RA Flexible Software Package (FSP).
Required Resources
A PC running Microsoft® Windows® 10 with the following Renesas software installed:
Board Support Packs in FSP
The Board Support Pack (BSP) is a subset of the Flexible Software Package (FSP), and provides an interface for setting up FSP to work with selected MCUs and specific board HW designs. It is both MCU and board specific. The BSPs for the Renesas RA Evaluation kits are included in FSP packs, but users must create new BSPs for implementing their final products.
FSP is CMSIS-compliant and is based on the CMSIS-core. Therefore, the board pack file structure is organized into folders containing the MCU and board specific CMSIS information and is represented as an XML-based pack description (PDSC) file as defined in the CMSIS standard (Keil, 2016). All these files are packed in a ZIP format (.zip).
BSP Contents in FSP
The contents of the BSP are as follows:
For example, the Renesas.RA_board_ra6m3_ek.1.0.0.pack has files as shown below in Figure 1.
Creating a Pack Based on an Existing Pack in FSP
The steps for creating a custom board pack from an existing RA board pack are given below.
Note: All the steps are described for BSP version 1.0.0. To create a BSP of a different versions, replace ‘1.0.0’ in all the steps to the ‘Major.Minor.Patch’ version.
1. Navigate to the \internal\projectgen\ra\Packs folder in the installed e2 studio or smart configurator (sc) as shown below. e2 studio and sc are installed in the RA folder by default. Board packs are listed in the packs folder as shown in Figure 1 above.
2. Find a pack with the same or similar device as the targeted MCU, such as ra6m1_ek, Renesas.RA_board_ra6m1_ek.1.0.0.pack.
3. Pick a board name for the new custom board, such as ra6m1_custom_board. Make sure to use the same name throughout the process.
4. Copy the board pack from step 3 and rename it with the new custom board name, such as ‘Renesas.RA_board_ra6m1_custom_board.1.0.0.pack’.
5. Extract the contents of this new pack file from a file archive utility, such as 7zip.
6. Replace the ‘RA6M1-EK.pincfg’ file with the new board name, ‘ra6m1_custom_board.pincfg’.
7. In the \.module_descriptions folder, rename the XML files with the custom board name.
8. Modify the contents of XML files to replace all instances of the old board name with the new custom board name. Change ‘RA6M1-EK.pincfg’ in Renesas##BSP##Board##ra6m1_custom_board####1.0.0##configuration.xml file to ‘ra6m1_custom_board.pincfg’.
9. Change all instances of ‘ra6m1ek’ to ‘custom_board’ in Renesas##BSP##Board##ra6m1_custom_board####1.0.0.xml file. Also, change the ‘device’ attribute from ‘R7FA6M1AD3CFP’ to new targeted device.
10. In \ra\board folder, rename the ra6m1_ek folder to ra6m1_custom_board. Add the custom BSP files, such as board.h, board_init.c, and board_init.h to the folder.
11. Rename the *.pdsc file in the root directory to the match the name of the BSP, ‘Renesas.RA_board_ra6m1_custom_board.1.0.0.pdsc’.
Note: The name of the .pdsc file must be the same as the .pack file for the pack to be detected by the configurator.
12. Modify the contents of the PDSC file:
• Replace the board name with the new board name
• Make sure there is a <file> element in the <component> for each file to be delivered as part of this pack.
13. Modify the contents of toolingSupport.xml. Rename all instances of ra6m1_ek to ra6m1_custom_board and RA6M1-EK.pincfg to ra6m1_custom_board.pincfg.
14. Select all files and folders, right click and create a zip file Renesas.RA_board_ra6m1_custom_board.1.0.0.zip
15. Rename the .zip file to Renesas.RA_board_ra6m1_ custom_board.1.0.0.pack.
Suitable Products
FSP
RA
Suitable Products
FSP
RA
Suitable Products
Suitable Products
FSP
RA","['data/categories/ra_family/rafsp_knowledge_base/8b406254447d6294eb0bf458a27d70db/images/dcee3dfea82ff061e5ae7bb86a413eb6.png', 'data/categories/ra_family/rafsp_knowledge_base/8b406254447d6294eb0bf458a27d70db/images/64bdc742c0ccdec6ed21a86506420b5a.png', 'data/categories/ra_family/rafsp_knowledge_base/8b406254447d6294eb0bf458a27d70db/images/0f9a3479af7c9c1ab854d98fb4b35fa7.png', 'data/categories/ra_family/rafsp_knowledge_base/8b406254447d6294eb0bf458a27d70db/images/827ca2fe9e3392c7c33d892c18f1816c.png']",[],['|  |\n|  |\n| FSP |\n| RA |'],"{'title': 'RA Family: Creating a Custom Board Support Package (BSP) for FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/19427072', 'last_updated': None, 'extracted_at': '2025-03-08T23:21:09.388484'}","Note that this article was written for FSP 1.1.0, but the process still works for FSP 3.7.0 and above. Introduction This article describes steps for creating a new custom Board Support Pack (BSP) for Renesas RA Flexible Software Package (FSP). Required Resources A PC running Microsoft Windows 10 with the following Renesas software installed Board Support Packs in FSP The Board Support Pack (BSP) is a subset of the Flexible Software Package (FSP), and provides an interface for setting up FSP to work with selected MCUs and specific board HW designs. It is both MCU and board specific. The BSPs for the Renesas RA Evaluation kits are included in FSP packs, but users must create new BSPs for implementing their final products. FSP is CMSIS-compliant and is based on the CMSIS-core. Therefore, the board pack file structure is organized into folders containing the MCU and board specific CMSIS information and is represented as an XML-based pack description (PDSC) file as defined in the CMSIS standard (Keil, 2016). All these files are packed in a ZIP format (.zip). BSP Contents in FSP The contents of the BSP are as follows For example, the Renesas.RAboardra6m3ek.1.0.0.pack has files as shown below in Figure 1. Creating a Pack Based on an Existing Pack in FSP The steps for creating a custom board pack from an existing RA board pack are given below. Note All the steps are described for BSP version 1.0.0. To create a BSP of a different versions, replace 1.0.0 in all the steps to the Major.Minor.Patch version. 1. Navigate to the internalprojectgenraPacks folder in the installed e2 studio or smart configurator (sc) as shown below. e2 studio and sc are installed in the RA folder by default. Board packs are listed in the packs folder as shown in Figure 1 above. 2. Find a pack with the same or similar device as the targeted MCU, such as ra6m1ek, Renesas.RAboardra6m1ek.1.0.0.pack. 3. Pick a board name for the new custom board, such as ra6m1customboard. Make sure to use the same name throughout the process. 4. Copy the board pack from step 3 and rename it with the new custom board name, such as Renesas.RAboardra6m1customboard.1.0.0.pack. 5. Extract the contents of this new pack file from a file archive utility, such as 7zip. 6. Replace the RA6M1-EK.pincfg file with the new board name, ra6m1customboard.pincfg. 7. In the .moduledescriptions folder, rename the XML files with the custom board name. 8. Modify the contents of XML files to replace all instances of the old board name with the new custom board name. Change RA6M1-EK.pincfg in RenesasBSPBoardra6m1customboard1.0.0configuration.xml file to ra6m1customboard.pincfg. 9. Change all instances of ra6m1ek to customboard in RenesasBSPBoardra6m1customboard1.0.0.xml file. Also, change the device attribute from R7FA6M1AD3CFP to new targeted device. 10. In raboard folder, rename the ra6m1ek folder to ra6m1customboard. Add the custom BSP files, such as board.h, boardinit.c, and boardinit.h to the folder. 11. Rename the .pdsc file in the root directory to the match the name of the BSP, Renesas.RAboardra6m1customboard.1.0.0.pdsc. Note The name of the .pdsc file must be the same as the .pack file for the pack to be detected by the configurator. 12. Modify the contents of the PDSC file  Replace the board name with the new board name  Make sure there is a file element in the component for each file to be delivered as part of this pack. 13. Modify the contents of toolingSupport.xml. Rename all instances of ra6m1ek to ra6m1customboard and RA6M1-EK.pincfg to ra6m1customboard.pincfg. 14. Select all files and folders, right click and create a zip file Renesas.RAboardra6m1customboard.1.0.0.zip 15. Rename the .zip file to Renesas.RAboardra6m1 customboard.1.0.0.pack. Suitable Products FSP RA","['The image presents a flowchart illustrating the process of creating a Renesas RA6M3 EK board. The flowchart is divided into several sections, each representing a different step in the process.\n\n*   **Step 1: Renesas.RA_board_ra6m3_ek.1.0.0**\n    *   This section is the starting point of the flowchart and represents the initial step in creating the Renesas RA6M3 EK board.\n    *   It includes a list of files and folders, including .mcu, .module_descriptions, and toolingSupport.xml.\n*   **Step 2: Renesas.RA_board_ra6m3_ek.1.0.0 > .mcu > .pinconfig**\n    *   This section represents the next step in the process, where the .mcu file is used to configure the pin settings for the board.\n    *   The .pinconfig file is created based on the information in the .mcu file.\n*   **Step 3: Renesas.RA_board_ra6m3_ek.1.0.0 > .module_descriptions**\n    *   This section represents the step where the module descriptions are created for the board.\n    *   The .module_descriptions file is used to provide information about the modules available on the board.\n*   **Step 4: Renesas.RA_board_ra6m3_ek.1.0.0 > .module_descriptions > .module_descriptions**\n    *   This section represents the step where the module descriptions are further refined and detailed.\n    *   The .module_descriptions file is updated with additional information about the modules.\n*   **Step 5: Renesas.RA_board_ra6m3_ek.1.0.0 > ra > board > ra6m3_ek**\n    *   This section represents the final step in the process, where the board configuration is completed.\n    *   The ra6m3_ek file is created, which contains the final configuration settings for the board.\n\nIn summary, the flowchart illustrates the step-by-step process of creating a Renesas RA6M3 EK board, from the initial setup to the final configuration. Each section represents a different step in the process, and the flowchart provides a clear and concise overview of the entire process.', 'The image shows a screenshot of a file explorer window, with the title bar at the top displaying the path ""Renesas > RA > e2studio_v7.8.0_fsp_v1.0.0 > internal > projectgen > ra"". The window is open to a folder named ""packs"", which is highlighted in red. Below the title bar, there are two folders: ""modules"" and ""1.0"". The ""modules"" folder is empty, while the ""1.0"" folder contains the ""packs"" folder.\n\nThe background of the window is white, and the text is black. The overall appearance suggests that this is a screenshot from a computer program or software, possibly used for managing files and folders.', 'The image shows a screenshot of a file explorer window with a red box highlighting a specific file. The file is located in a folder named ""Renesas.RA_board_ra6m1_custom_board.1.0.0"" and has the name ""ra6m1_custom_board.pincfg"".\n\n*   The file explorer window is open, displaying the contents of the folder.\n*   The folder name is displayed at the top of the window, followed by a list of files and subfolders.\n*   The highlighted file is located in the middle of the list, with its name and extension clearly visible.\n*   The file name is ""ra6m1_custom_board.pincfg"", which suggests that it may be a configuration file for a custom board.\n*   The red box around the file indicates that it is the focus of attention, possibly because it is the file being edited or modified.\n\nOverall, the image appears to be a screenshot of a file explorer window, with a specific file highlighted in a red box. The file name and extension suggest that it may be a configuration file for a custom board.', 'The image shows a screenshot of a computer screen displaying a file explorer window. The window is open on a white background, with a red box highlighting two files in the list.\n\n*   The top of the window has a title bar with the text ""Renesas.RA_board_ra6m1_custom_board.1.0.0"" and a dropdown menu labeled "".module_descriptions"".\n*   Below the title bar, there is a list of files and folders, with the two highlighted files being:\n    *   ""Renesas##BSP##Board##ra6m1_custom_board####1.0.0##configuration.xml""\n    *   ""Renesas##BSP##Board##ra6m1_custom_board####1.0.0.xml""\n*   The background of the window is white, with a red box highlighting the two files in the list.\n\nOverall, the image appears to be a screenshot of a file explorer window, showing a list of files and folders with a red box highlighting two specific files.']"
26e99d82d80f5b7e37a867cc08724ba0,"Question:
If the finger contacts with the touch electrode at the time of power-on, the touch judgment will not be performed as expected afterwards. Why does this happen?
Answer:
In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of R_CSTU_ScanStart() and R_CTSU_DataGet() or　several repetitions of RM_TOUCH_ScanStart() and RM_TOUCH_DataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards. 
In initial offset tuning, the amount of offset current is adjusted so that the measured count value without contact approaches the target value. This offset current is intended to control the count value due to the parasitic capacitance. The measured count value at the time of completion of the initial offset tuning is set as a reference value, and the touch ON/OFF is determined by the amount of change from this reference value.
If you touch the electrode during initial offset tuning, the offset current is adjusted so that the increase in capacitance caused by the finger contact is removed, and the measured count value with contact is set as the reference value. Since the measured count value required to be judged to be touch ON is higher with theself-capacitance method and lower with the mutual capacitance method by a threshold value than this reference value, if the reference value is set to the measured count value with contact, the amount of change from the reference value exceeds this threshold even if the finger connected the electrodes.
Since the reference value is readjusted by the drift correction function at intervals specified at the time of touch OFF judgment, touch ON/OFF judgment may be possible after a certain period of time has elapsed.
For details on offset current and drift correction, refer to the application note ""Capacitive Sensor Microcontrollers CTSU Capacitive Touch Introduction Guide"" (R30AN0424).
https://www.renesas.com/en/document/apn/capacitive-sensor-microcontrollers-ctsu-capacitive-touch-introduction-guide
Suitable Products
RA Family
If the finger contacts with the touch electrode at the time of power-on, the touch judgment will not be performed as expected afterwards. Why does this happen?
If the finger contacts with the touch electrode at the time of power-on, the touch judgment will not be performed as expected afterwards. Why does this happen?
Answer:
In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of R_CSTU_ScanStart() and R_CTSU_DataGet() or　several repetitions of RM_TOUCH_ScanStart() and RM_TOUCH_DataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards. 
In initial offset tuning, the amount of offset current is adjusted so that the measured count value without contact approaches the target value. This offset current is intended to control the count value due to the parasitic capacitance. The measured count value at the time of completion of the initial offset tuning is set as a reference value, and the touch ON/OFF is determined by the amount of change from this reference value.
If you touch the electrode during initial offset tuning, the offset current is adjusted so that the increase in capacitance caused by the finger contact is removed, and the measured count value with contact is set as the reference value. Since the measured count value required to be judged to be touch ON is higher with theself-capacitance method and lower with the mutual capacitance method by a threshold value than this reference value, if the reference value is set to the measured count value with contact, the amount of change from the reference value exceeds this threshold even if the finger connected the electrodes.
Since the reference value is readjusted by the drift correction function at intervals specified at the time of touch OFF judgment, touch ON/OFF judgment may be possible after a certain period of time has elapsed.
For details on offset current and drift correction, refer to the application note ""Capacitive Sensor Microcontrollers CTSU Capacitive Touch Introduction Guide"" (R30AN0424).
https://www.renesas.com/en/document/apn/capacitive-sensor-microcontrollers-ctsu-capacitive-touch-introduction-guide
Suitable Products
RA Family
In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of R_CSTU_ScanStart() and R_CTSU_DataGet() or　several repetitions of RM_TOUCH_ScanStart() and RM_TOUCH_DataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards. 
In initial offset tuning, the amount of offset current is adjusted so that the measured count value without contact approaches the target value. This offset current is intended to control the count value due to the parasitic capacitance. The measured count value at the time of completion of the initial offset tuning is set as a reference value, and the touch ON/OFF is determined by the amount of change from this reference value.
If you touch the electrode during initial offset tuning, the offset current is adjusted so that the increase in capacitance caused by the finger contact is removed, and the measured count value with contact is set as the reference value. Since the measured count value required to be judged to be touch ON is higher with theself-capacitance method and lower with the mutual capacitance method by a threshold value than this reference value, if the reference value is set to the measured count value with contact, the amount of change from the reference value exceeds this threshold even if the finger connected the electrodes.
Since the reference value is readjusted by the drift correction function at intervals specified at the time of touch OFF judgment, touch ON/OFF judgment may be possible after a certain period of time has elapsed.
For details on offset current and drift correction, refer to the application note ""Capacitive Sensor Microcontrollers CTSU Capacitive Touch Introduction Guide"" (R30AN0424).
https://www.renesas.com/en/document/apn/capacitive-sensor-microcontrollers-ctsu-capacitive-touch-introduction-guide
In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of R_CSTU_ScanStart() and R_CTSU_DataGet() or　several repetitions of RM_TOUCH_ScanStart() and RM_TOUCH_DataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards.
In initial offset tuning, the amount of offset current is adjusted so that the measured count value without contact approaches the target value. This offset current is intended to control the count value due to the parasitic capacitance. The measured count value at the time of completion of the initial offset tuning is set as a reference value, and the touch ON/OFF is determined by the amount of change from this reference value.
If you touch the electrode during initial offset tuning, the offset current is adjusted so that the increase in capacitance caused by the finger contact is removed, and the measured count value with contact is set as the reference value. Since the measured count value required to be judged to be touch ON is higher with theself-capacitance method and lower with the mutual capacitance method by a threshold value than this reference value, if the reference value is set to the measured count value with contact, the amount of change from the reference value exceeds this threshold even if the finger connected the electrodes.
Since the reference value is readjusted by the drift correction function at intervals specified at the time of touch OFF judgment, touch ON/OFF judgment may be possible after a certain period of time has elapsed.
For details on offset current and drift correction, refer to the application note ""Capacitive Sensor Microcontrollers CTSU Capacitive Touch Introduction Guide"" (R30AN0424).
https://www.renesas.com/en/document/apn/capacitive-sensor-microcontrollers-ctsu-capacitive-touch-introduction-guide
Suitable Products
RA Family
Japanese
Japanese",['data/categories/ra_family/capacitive_touch/26e99d82d80f5b7e37a867cc08724ba0/images/2c67f540edc8a2bebd924a5ae2ff41bc.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: If the finger contacts with the touch electrode at the time of power-on, the touch judgment will not be performed as expected afterwards.', 'url': 'https://en-support.renesas.com/knowledgeBase/21810980', 'last_updated': None, 'extracted_at': '2025-03-08T23:34:36.153583'}","Question If the finger contacts with the touch electrode at the time of power-on, the touch judgment will not be performed as expected afterwards. Why does this happen? Answer In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of RCSTUScanStart() and RCTSUDataGet() or several repetitions of RMTOUCHScanStart() and RMTOUCHDataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards. In initial offset tuning, the amount of offset current is adjusted so that the measured count value without contact approaches the target value. This offset current is intended to control the count value due to the parasitic capacitance. The measured count value at the time of completion of the initial offset tuning is set as a reference value, and the touch ON/OFF is determined by the amount of change from this reference value. If you touch the electrode during initial offset tuning, the offset current is adjusted so that the increase in capacitance caused by the finger contact is removed, and the measured count value with contact is set as the reference value. Since the measured count value required to be judged to be touch ON is higher with theself-capacitance method and lower with the mutual capacitance method by a threshold value than this reference value, if the reference value is set to the measured count value with contact, the amount of change from the reference value exceeds this threshold even if the finger connected the electrodes. Since the reference value is readjusted by the drift correction function at intervals specified at the time of touch OFF judgment, touch ON/OFF judgment may be possible after a certain period of time has elapsed. For details on offset current and drift correction, refer to the application note ""Capacitive Sensor Microcontrollers CTSU Capacitive Touch Introduction Guide"" (R30AN0424). https//www.renesas.com/en/document/apn/capacitive-sensor-microcontrollers-ctsu-capacitive-touch-introduction-guide Suitable Products RA Family In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of RCSTUScanStart() and RCTSUDataGet() or several repetitions of RMTOUCHScanStart() and RMTOUCHDataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards. Japanese","['The image presents a detailed comparison of two distinct methods for resetting a Microcontroller Unit (MCU) without and with finger contact, respectively. The visual representation is divided into two main sections, each illustrating the process of MCU reset using a self-capacitance method.\n\n**MCU Reset without Finger Contact (Self-Capacitance Method)**\n\n*   **Before Initial Offset Tuning**\n    *   The image on the left side of the first section depicts the initial state of the MCU reset without finger contact.\n    *   It features a purple rectangle labeled ""Non-contact"" and a blue rectangle labeled ""Cp,"" which represents the parasitic capacitance.\n    *   A black arrow points to the target value, indicating the desired outcome.\n    *   A dotted line connects the Cp rectangle to the threshold value, highlighting the relationship between the two.\n*   **After Initial Offset Tuning**\n    *   The image on the right side of the first section shows the result of the initial offset tuning.\n    *   The purple rectangle remains unchanged, but the blue rectangle is now labeled ""Cf,"" representing the capacitance between the finger and touch electrode.\n    *   A black arrow points to the touch OFF judgment, indicating the outcome of the process.\n    *   A dotted line connects the Cf rectangle to the threshold reference value, illustrating the relationship between the two.\n\n**MCU Reset with Finger Contact (Self-Capacitance Method)**\n\n*   **Before Initial Offset Tuning**\n    *   The image on the left side of the second section illustrates the initial state of the MCU reset with finger contact.\n    *   It features a green rectangle labeled ""Non-contact"" and a blue rectangle labeled ""Cp,"" which represents the parasitic capacitance.\n    *   A black arrow points to the target value, indicating the desired outcome.\n    *   A dotted line connects the Cp rectangle to the threshold value, highlighting the relationship between the two.\n*   **After Initial Offset Tuning**\n    *   The image on the right side of the second section shows the result of the initial offset tuning.\n    *   The green rectangle remains unchanged, but the blue rectangle is now labeled ""Cf,"" representing the capacitance between the finger and touch electrode.\n    *   A black arrow points to the touch OFF judgment, indicating the outcome of the process.\n    *   A dotted line connects the Cf rectangle to the threshold reference value, illustrating the relationship between the two.\n\nIn summary, the image effectively compares the two methods of MCU reset, highlighting the differences in the initial offset tuning process and the resulting outcomes. The use of distinct colors and labels enhances the clarity of the visual representation, making it easier to understand the complex concepts involved.']"
bf7caff33b899d2bc42a5e175ce36cc9,"Question:
I am trying to perform the serial communication monitor that is provided by QE for Capacitive Touch. I wrote a capacitive touch application for the RA MCU and executed it, but the error message ""Failed to connect to the serial port."" is displayed and monitoring cannot be started. Are there any possible causes?
Answer:
1. In the program's configurator settings, the serial connection monitor is disabled.
Check if the Touch Middleware (rm_touch) properties > Common > ""Support for QE monitoring using UART"" is set to ""Enabled"".
2. In the program's configurator settings, the UART driver module for QE monitoring is not set properly.
Check if the UART driver module (r_sci_uart) is added under the Touch middleware block.
Check the Pins tab to see if any pins are assigned to the UART function pins used in the UART driver (g_uart_qe). It is possible to check the allocation status of the UART driver (g_uart_qe) properties > Pins > TXDn/RXDn.
Check if the baud rate set in the UART driver (g_uart_qe) properties > Module g_uart_qe UART (r_sci_uart) > Baud > Baud Rate and the Baud rate set in the CapTouch workflow in QE for Capacitive Touch match.
3. The program written to the MCU stopped.
This may be due to the state of the previous debug connection. After physically disconnecting the debugger, power cycle the evaluation board, then check if the serial connection is successful.
The program may not be executed as expected due to software implementation errors. Use the debugger to see where the program stops and fix the problem.
Suitable Products
RA Family
I am trying to perform the serial communication monitor that is provided by QE for Capacitive Touch. I wrote a capacitive touch application for the RA MCU and executed it, but the error message ""Failed to connect to the serial port."" is displayed and monitoring cannot be started. Are there any possible causes?
I am trying to perform the serial communication monitor that is provided by QE for Capacitive Touch. I wrote a capacitive touch application for the RA MCU and executed it, but the error message ""Failed to connect to the serial port."" is displayed and monitoring cannot be started. Are there any possible causes?
Answer:
1. In the program's configurator settings, the serial connection monitor is disabled.
Check if the Touch Middleware (rm_touch) properties > Common > ""Support for QE monitoring using UART"" is set to ""Enabled"".
2. In the program's configurator settings, the UART driver module for QE monitoring is not set properly.
Check if the UART driver module (r_sci_uart) is added under the Touch middleware block.
Check the Pins tab to see if any pins are assigned to the UART function pins used in the UART driver (g_uart_qe). It is possible to check the allocation status of the UART driver (g_uart_qe) properties > Pins > TXDn/RXDn.
Check if the baud rate set in the UART driver (g_uart_qe) properties > Module g_uart_qe UART (r_sci_uart) > Baud > Baud Rate and the Baud rate set in the CapTouch workflow in QE for Capacitive Touch match.
3. The program written to the MCU stopped.
This may be due to the state of the previous debug connection. After physically disconnecting the debugger, power cycle the evaluation board, then check if the serial connection is successful.
The program may not be executed as expected due to software implementation errors. Use the debugger to see where the program stops and fix the problem.
Suitable Products
RA Family
1. In the program's configurator settings, the serial connection monitor is disabled.
Check if the Touch Middleware (rm_touch) properties > Common > ""Support for QE monitoring using UART"" is set to ""Enabled"".
2. In the program's configurator settings, the UART driver module for QE monitoring is not set properly.
Check if the UART driver module (r_sci_uart) is added under the Touch middleware block.
Check the Pins tab to see if any pins are assigned to the UART function pins used in the UART driver (g_uart_qe). It is possible to check the allocation status of the UART driver (g_uart_qe) properties > Pins > TXDn/RXDn.
Check if the baud rate set in the UART driver (g_uart_qe) properties > Module g_uart_qe UART (r_sci_uart) > Baud > Baud Rate and the Baud rate set in the CapTouch workflow in QE for Capacitive Touch match.
3. The program written to the MCU stopped.
This may be due to the state of the previous debug connection. After physically disconnecting the debugger, power cycle the evaluation board, then check if the serial connection is successful.
The program may not be executed as expected due to software implementation errors. Use the debugger to see where the program stops and fix the problem.
1. In the program's configurator settings, the serial connection monitor is disabled.
2. In the program's configurator settings, the UART driver module for QE monitoring is not set properly.
3. The program written to the MCU stopped.
Suitable Products
RA Family
Japanese
Japanese","['data/categories/ra_family/capacitive_touch/bf7caff33b899d2bc42a5e175ce36cc9/images/726184cc9c92dcf112663f9a14ce352f.png', 'data/categories/ra_family/capacitive_touch/bf7caff33b899d2bc42a5e175ce36cc9/images/d68004df3def89855c39b641341bf6f1.png', 'data/categories/ra_family/capacitive_touch/bf7caff33b899d2bc42a5e175ce36cc9/images/1a8c7caeeb656cea0d17ee318247b685.png', 'data/categories/ra_family/capacitive_touch/bf7caff33b899d2bc42a5e175ce36cc9/images/d7abdd49f019a654bfe3ecee256cbae9.png']",[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: The serial communication monitor that is provided by QE for Capacitive Touch, Development Assistance Tool for Capacitive Touch sensors, fails to start.', 'url': 'https://en-support.renesas.com/knowledgeBase/21810981', 'last_updated': None, 'extracted_at': '2025-03-08T23:34:44.725145'}","Question I am trying to perform the serial communication monitor that is provided by QE for Capacitive Touch. I wrote a capacitive touch application for the RA MCU and executed it, but the error message ""Failed to connect to the serial port."" is displayed and monitoring cannot be started. Are there any possible causes? Answer 1. In the program's configurator settings, the serial connection monitor is disabled. Check if the Touch Middleware (rmtouch) properties  Common  ""Support for QE monitoring using UART"" is set to ""Enabled"". 2. In the program's configurator settings, the UART driver module for QE monitoring is not set properly. Check if the UART driver module (rsciuart) is added under the Touch middleware block. Check the Pins tab to see if any pins are assigned to the UART function pins used in the UART driver (guartqe). It is possible to check the allocation status of the UART driver (guartqe) properties  Pins  TXDn/RXDn. Check if the baud rate set in the UART driver (guartqe) properties  Module guartqe UART (rsciuart)  Baud  Baud Rate and the Baud rate set in the CapTouch workflow in QE for Capacitive Touch match. 3. The program written to the MCU stopped. This may be due to the state of the previous debug connection. After physically disconnecting the debugger, power cycle the evaluation board, then check if the serial connection is successful. The program may not be executed as expected due to software implementation errors. Use the debugger to see where the program stops and fix the problem. Suitable Products RA Family Japanese","['The image shows a screenshot of a computer window with a list of settings for a program or application. The window is titled ""Touch (rm_touch)"" and has a gray background with black text.\n\n*   **Title Bar**\n    *   The title bar at the top of the window reads ""Touch (rm_touch)"" in black text.\n    *   There are several icons on the left side of the title bar, including a red circle with a white ""X"" inside, a blue circle with a white ""i"" inside, and a green circle with a white ""?"" inside.\n*   **Settings Menu**\n    *   Below the title bar is a menu labeled ""Settings"" with several options listed underneath.\n    *   The options include ""Property"", ""Common"", ""Parameter Checking"", ""Default (BSP) enabled"", ""Support for QE monitoring using UART"", ""Support for QE Tuning using UART"", and ""Type of chattering suppression"".\n    *   The ""Property"" option is selected, and the ""Common"" option is highlighted in gray.\n*   **Value Column**\n    *   To the right of the settings menu is a column labeled ""Value"".\n    *   The values for each setting are listed in this column, including ""Common"", ""Parameter Checking"", ""Default (BSP) enabled"", ""Support for QE monitoring using UART"", ""Support for QE Tuning using UART"", and ""Type of chattering suppression"".\n    *   The value for ""Property"" is not visible in this column.\n*   **API Info**\n    *   At the bottom of the window is a section labeled ""API Info"".\n    *   This section contains additional information about the API, including the type of chattering suppression and the counter of exceed threshold.\n\nOverall, the image shows a screenshot of a computer window with a list of settings for a program or application. The settings menu is organized into categories, and each setting has a corresponding value listed in the ""Value"" column. The ""API Info"" section provides additional information about the API.', 'The image depicts a screenshot of a computer program, specifically a diagram of HAL/ Common Stacks. The diagram is divided into several sections, each representing a different component or stack.\n\n*   **g_ioport I/O Port (r_ioport)**\n    *   This section is located in the top-left corner of the diagram.\n    *   It contains a single box with the label ""g_ioport I/O Port (r_ioport)"".\n    *   There are no connections or arrows pointing to or from this section.\n*   **Touch (rm_touch)**\n    *   This section is located in the top-center of the diagram.\n    *   It contains a single box with the label ""Touch (rm_touch)"".\n    *   There are no connections or arrows pointing to or from this section.\n*   **CTSU (r_ctsu)**\n    *   This section is located in the center-left of the diagram.\n    *   It contains a single box with the label ""CTSU (r_ctsu)"".\n    *   There are no connections or arrows pointing to or from this section.\n*   **g_uart_qe UART (r_sci_uart)**\n    *   This section is located in the center-right of the diagram.\n    *   It contains a single box with the label ""g_uart_qe UART (r_sci_uart)"".\n    *   There are no connections or arrows pointing to or from this section.\n*   **Add DTC Driver for Transmission [Recommended but optional]**\n    *   This section is located in the bottom-left corner of the diagram.\n    *   It contains a single box with the label ""Add DTC Driver for Transmission [Recommended but optional]"".\n    *   There are no connections or arrows pointing to or from this section.\n*   **Add DTC Driver for Reception [Recommended but optional]**\n    *   This section is located in the bottom-center of the diagram.\n    *   It contains a single box with the label ""Add DTC Driver for Reception [Recommended but optional]"".\n    *   There are no connections or arrows pointing to or from this section.\n*   **Add DTC Driver for Reception [Not recommended]**\n    *   This section is located in the bottom-right corner of the diagram.\n    *   It contains a single box with the label ""Add DTC Driver for Reception [Not recommended]"".\n    *   There are no connections or arrows pointing to or from this section.\n\nIn summary, the diagram shows a collection of components or stacks, each with its own label and no connections or arrows pointing to or from them. The components are arranged in a grid-like pattern, with some sections overlapping or adjacent to each other. Overall, the diagram appears to be a visual representation of a system or architecture, but without additional context or information, it is difficult to determine the specific purpose or functionality of the diagram.', 'The image shows a screenshot of a computer program with a list of settings and pins. The title of the program is ""g_uart_qe UART (r_sci_uart)"".\n\n*   **Settings**\n    *   Property: Common\n        *   Parameter Checking: Default (BSP)\n        *   FIFO Support: Disable\n        *   DTC Support: Disable\n        *   Flow Control Support: Disable\n        *   RS-485 Support: Disable\n        *   IrDA Support: Disabled\n    *   Module g_uart_qe UART (r_sci_uart)\n        *   General\n        *   Baud\n        *   Flow Control\n        *   Extra\n        *   Interrupts\n*   **Pins**\n    *   TXD9: P203\n    *   RXD9: P202\n\nThe program appears to be a configuration tool for a UART (Universal Asynchronous Receiver-Transmitter) module, which is a type of serial communication interface. The settings and pins listed in the image suggest that the program is used to configure the UART module\'s parameters, such as baud rate, flow control, and interrupt settings, as well as its pin assignments.', 'The image presents a screenshot of two windows, each displaying a distinct set of settings. The left window is titled ""Property of UART driver"" and features a list of settings, with the ""Baud Rate"" setting highlighted in red. The right window is titled ""Setting of CapTouch Workflow"" and includes a dropdown menu for selecting the ""Start Monitoring (Emulator)"" option, with the ""Baud rate"" field set to 115200.\n\n**Key Features:**\n\n* **Left Window:**\n\t+ Title: ""Property of UART driver""\n\t+ List of settings\n\t+ ""Baud Rate"" setting highlighted in red\n* **Right Window:**\n\t+ Title: ""Setting of CapTouch Workflow""\n\t+ Dropdown menu for selecting ""Start Monitoring (Emulator)""\n\t+ ""Baud rate"" field set to 115200\n\n**Summary:**\n\nThe image displays two windows with different settings, with the ""Baud Rate"" setting highlighted in red in the left window and the ""Baud rate"" field set to 115200 in the right window. The image appears to be related to configuring settings for a UART driver and CapTouch workflow.']"
40375ca0f5a008a568e9fa5b7f1bccbd,"Last updated: 22/03/2024
Why are UART channel 1 pins P212 and P213 not working ?
The pins P212 and P213 are used as external clock oscillator pins (XTAL/EXTAL pins) so they cannot be used from SCI UART channel 1 in the same time. If you want to use them as SCI channel 1 pins, you need to have a clock source different than XTAL. Please change accordingly on Clocks tab (you can change PLL source or clock source itself):
A new blank project by default is using XTAL as clock source which is already on the EK-RA6M2.",['data/categories/ra_family/serial_communications_interface_(sci)/40375ca0f5a008a568e9fa5b7f1bccbd/images/4394c1e6fb557a06c886fa6c3937a557.png'],[],[],"{'title': 'RA Family: Why are UART channel 1 pins P212 and P213 not working ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21287506', 'last_updated': None, 'extracted_at': '2025-03-08T23:38:24.206366'}","Last updated 22/03/2024 Why are UART channel 1 pins P212 and P213 not working ? The pins P212 and P213 are used as external clock oscillator pins (XTAL/EXTAL pins) so they cannot be used from SCI UART channel 1 in the same time. If you want to use them as SCI channel 1 pins, you need to have a clock source different than XTAL. Please change accordingly on Clocks tab (you can change PLL source or clock source itself) A new blank project by default is using XTAL as clock source which is already on the EK-RA6M2.","['The image depicts a screenshot of a computer program, specifically a configuration interface for clocks. The title ""Clocks Configuration"" is prominently displayed in the top-left corner, accompanied by a green play button and the text ""Generate Project Content"" in the top-right corner.\n\nThe main content of the image is a flowchart that outlines the various clock configurations available. The flowchart is divided into two main sections: the left side, which lists the different clock sources, and the right side, which displays the corresponding clock configurations. The clock sources are listed in a vertical column, with each source having a checkbox next to it. The clock configurations are arranged in a horizontal row, with each configuration having a checkbox next to it.\n\nThe clock sources include:\n\n* PLL Src: XTAL\n* PLL Div /1\n* PLL Mul x20.0\n* PLL 240MHz\n* HOCO 20MHz\n* LOCO 32768Hz\n* MOCO 8MHz\n* SUBCLK 32768Hz\n\nThe clock configurations include:\n\n* ICLK Div /2\n* PCLKA Div /2\n* PCLKB Div /4\n* PCLKC Div /4\n* PCLKD Div /2\n* SDCLK Enabled\n* BCLK Div /2\n* EBCLK Div /2\n* UCLK Div /5\n* FCLK Div /4\n* CLKOUT Disabled\n* CLKOUT Div /1\n\nEach clock configuration has a checkbox next to it, allowing the user to select or deselect the configuration. The flowchart also includes several buttons and menus at the bottom of the screen, including ""Summary"", ""BSP"", ""Clocks"", ""Pins"", ""Interrupts"", ""Event Links"", ""Stacks"", and ""Components"".\n\nOverall, the image provides a clear and organized interface for configuring clocks in a computer program. The flowchart makes it easy to navigate and select the desired clock configurations, and the buttons and menus at the bottom of the screen provide additional options for customizing the clock settings.']"
ec8377046d706760bccb9769c339b0b2,"Question:
In the RA MCU User’s Manual: Hardware, the following explanation of capacitor connection is required. If the ADC or DAC in the RA MCU is not used, is it necessary to connect capacitors to the following pins?
(1) Analog power pins: between AVCC0 and AVSS0
(2) Analog reference voltage pins: between VREFH0 and VREFL0
(3) Analog reference voltage pins: between VREFH and VREFL
Answer:
If you don’t utilize the ADCs and DACs inside the RA MCU, you don’t need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
between AVCC0 and AVSS0
A 0.1μF capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors shown as *1 in the above figure are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry.
between VREFH0 and VREFL0
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 0) is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU
between VREFH and VREFL
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 1) or DAC is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU.
Suitable Products
RA Family
In the RA MCU User’s Manual: Hardware, the following explanation of capacitor connection is required. If the ADC or DAC in the RA MCU is not used, is it necessary to connect capacitors to the following pins?
(1) Analog power pins: between AVCC0 and AVSS0
(2) Analog reference voltage pins: between VREFH0 and VREFL0
(3) Analog reference voltage pins: between VREFH and VREFL
In the RA MCU User’s Manual: Hardware, the following explanation of capacitor connection is required. If the ADC or DAC in the RA MCU is not used, is it necessary to connect capacitors to the following pins?
(1) Analog power pins: between AVCC0 and AVSS0
(1) Analog power pins: between AVCC0 and AVSS0
(1) Analog power pins: between
AVCC0
and
AVSS0
(2) Analog reference voltage pins: between VREFH0 and VREFL0
(2) Analog reference voltage pins: between VREFH0 and VREFL0
(2) Analog reference voltage pins: between
VREFH0
and
VREFL0
(3) Analog reference voltage pins: between VREFH and VREFL
(3) Analog reference voltage pins: between VREFH and VREFL
(3)
Analog reference voltage pins: between
VREFH
and
VREFL
Answer:
If you don’t utilize the ADCs and DACs inside the RA MCU, you don’t need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
between AVCC0 and AVSS0
A 0.1μF capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors shown as *1 in the above figure are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry.
between VREFH0 and VREFL0
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 0) is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU
between VREFH and VREFL
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 1) or DAC is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU.
Suitable Products
RA Family
If you don’t utilize the ADCs and DACs inside the RA MCU, you don’t need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
between AVCC0 and AVSS0
A 0.1μF capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors shown as *1 in the above figure are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry.
between VREFH0 and VREFL0
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 0) is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU
between VREFH and VREFL
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 1) or DAC is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU.
If you don’t utilize the ADCs and DACs inside the RA MCU, you don’t need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
If you don’t utilize the ADCs and DACs inside the RA MCU, you don’t need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
If you don’t utilize the ADCs and DACs inside the RA MCU, you don’t need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
between AVCC0 and AVSS0
A 0.1μF capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors shown as *1 in the above figure are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry.
between
AVCC0
and
AVSS0
μ
F capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors
*
are not required
if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry.
between VREFH0 and VREFL0
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 0) is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU
between
VREFH0
and
VREFL0
between VREFH and VREFL
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 1) or DAC is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU.
between
VREFH
and
VREFL
Suitable Products
RA Family
日本語
日本語",['data/categories/ra_family/ad_converter/ec8377046d706760bccb9769c339b0b2/images/11951266f8acbc9564a59338c81a8045.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: Necessity of connecting capacitors for analog power supplies and reference voltage pins', 'url': 'https://en-support.renesas.com/knowledgeBase/21727829', 'last_updated': None, 'extracted_at': '2025-03-08T23:34:03.982410'}","Question In the RA MCU Users Manual Hardware, the following explanation of capacitor connection is required. If the ADC or DAC in the RA MCU is not used, is it necessary to connect capacitors to the following pins? (1) Analog power pins between AVCC0 and AVSS0 (2) Analog reference voltage pins between VREFH0 and VREFL0 (3) Analog reference voltage pins between VREFH and VREFL Answer If you dont utilize the ADCs and DACs inside the RA MCU, you dont need some of the bypass capacitors specified for the analog power pins. The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary. between AVCC0 and AVSS0 A 0.1F capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors shown as 1 in the above figure are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry. between VREFH0 and VREFL0 The capacitor shown as 1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 0) is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU between VREFH and VREFL The capacitor shown as 1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 1) or DAC is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU. Suitable Products RA Family (1) Analog power pins between AVCC0 and AVSS0 (2) Analog reference voltage pins between VREFH0 VREFL0 (3) Analog reference voltage pins between VREFH VREFL between  F capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors  are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry. ","['The image presents a technical diagram illustrating the connection of various components, including resistors, capacitors, and voltage sources. The diagram is divided into two sections: the top section shows the connections between the components, while the bottom section provides a detailed view of the connections.\n\n**Top Section:**\n\n*   The top section of the diagram displays the connections between the components, including:\n    *   A red line representing a voltage source (AVCC0)\n    *   A yellow line representing a reference power supply pin (VREFH0, VREFH)\n    *   A blue line representing an analog input pin (AVSS0)\n    *   A light blue line representing a reference ground pin (VREFL0, VREFL)\n\n**Bottom Section:**\n\n*   The bottom section of the diagram provides a detailed view of the connections between the components, including:\n    *   A resistor (Rin) connected to the reference power supply pin (VREFH0, VREFH)\n    *   A capacitor (Cin) connected to the analog input pin (AVSS0)\n    *   A voltage source (AVCC0) connected to the reference ground pin (VREFL0, VREFL)\n\n**Note:**\n\n*   The diagram includes two notes:\n    *   Note 1: The values shown here are reference values.\n    *   Note 2: Rin: Signal source impedance\n\nIn summary, the diagram illustrates the connection of various components, including resistors, capacitors, and voltage sources, to form a circuit. The diagram provides a detailed view of the connections between the components, including the reference power supply pin, analog input pin, and reference ground pin.']"
cb2f721cbff9e33e23869ed649dcce87,"This post applies to AC 6.17. Refer to the companion post for AC 6.16 and earlier here: https://en-support.renesas.com/knowledgeBase/19375553
1) Arm Compiler v6.17 will not be automatically detected when attempting to register the toolchain with e2 studio 2021-10 and earlier. Earlier Arm Compiler v6 versions are recognized.
2) When creating a new project the commands related to the compiler, assembler and linker are missing by default in the project settings.
1) Registration Issue
When attempting to register an error like the one below will be shown.
Workaround
The toolchain can be registered in the same dialog by manually entering in the information. Click Next from the dialog shown in the image above. On the next screen enter the information as shown in the image below. When done click Finish. e2 studio will request to be restarted. Once restarted, you will be able to create projects using the newly registered toolchain.
2) Compiler, Assembler and Linker Issue
When a user creates a new project with Arm compiler 6.17 and E2 studio, the commands related to the compiler, assembler are linker are missing by default in project settings.
This is resulting in failure to create binary with following error, please refer below image.
Workaround:
Add the compiler, assembler and linker commands in the project settings command window as listed below.
Example for the Compiler is shown below. Add the commands for Assembler and Linker too.
Suitable Products
e2studio and ARM Compiler for RA
  https://github.com/renesas/fsp/issues/154
Suitable Products
e2studio and ARM Compiler for RA
  https://github.com/renesas/fsp/issues/154
Suitable Products
e2studio and ARM Compiler for RA
  https://github.com/renesas/fsp/issues/154
Suitable Products
e2studio and ARM Compiler for RA
  https://github.com/renesas/fsp/issues/154
https://github.com/renesas/fsp/issues/154","['data/categories/ra_family/ra_and_fsp_technical_articles/cb2f721cbff9e33e23869ed649dcce87/images/b8599d7cb5f511020372f9bf11099e36.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/cb2f721cbff9e33e23869ed649dcce87/images/9569f85960de9aaeb39419cc51b727b2.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/cb2f721cbff9e33e23869ed649dcce87/images/cbc20504c966eb8f46f4c3d644403b37.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/cb2f721cbff9e33e23869ed649dcce87/images/87be0c4e6c38b041fc1d502b074869bc.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/cb2f721cbff9e33e23869ed649dcce87/images/bd478401771475c8f45b56e4cca4fb8f.png']",[],['|  |\n|  |\n| e2studio and ARM Compiler for RA |'],"{'title': 'Creating an RA Project with ARM Compiler 6.17 in e2 studio', 'url': 'https://en-support.renesas.com/knowledgeBase/20370421', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:23.201892'}","This post applies to AC 6.17. Refer to the companion post for AC 6.16 and earlier here https//en-support.renesas.com/knowledgeBase/19375553 1) Arm Compiler v6.17 will not be automatically detected when attempting to register the toolchain with e2 studio 2021-10 and earlier. Earlier Arm Compiler v6 versions are recognized. 2) When creating a new project the commands related to the compiler, assembler and linker are missing by default in the project settings. 1) Registration Issue When attempting to register an error like the one below will be shown. Workaround The toolchain can be registered in the same dialog by manually entering in the information. Click Next from the dialog shown in the image above. On the next screen enter the information as shown in the image below. When done click Finish. e2 studio will request to be restarted. Once restarted, you will be able to create projects using the newly registered toolchain. 2) Compiler, Assembler and Linker Issue When a user creates a new project with Arm compiler 6.17 and E2 studio, the commands related to the compiler, assembler are linker are missing by default in project settings. This is resulting in failure to create binary with following error, please refer below image. Workaround Add the compiler, assembler and linker commands in the project settings command window as listed below. Example for the Compiler is shown below. Add the commands for Assembler and Linker too. Suitable Products e2studio and ARM Compiler for RA https//github.com/renesas/fsp/issues/154 https//github.com/renesas/fsp/issues/154","['The image shows a screenshot of a computer window with the title ""Discovered Toolchain Information"" at the top. The window is divided into two sections: the top section contains the title and a message, while the bottom section has buttons for navigation.\n\n*   **Title and Message**\n    *   The title ""Discovered Toolchain Information"" is displayed in black text at the top of the window.\n    *   Below the title, there is a message that reads, ""Unable to detect toolchain information from \'/opt/arm_compiler_6.17\'. If you are sure this path is correct, click Next to manually fill in the toolchain information. Otherwise, click Back to correct the path.""\n*   **Buttons**\n    *   There are three buttons at the bottom of the window: ""Back"", ""Next"", and ""Cancel"".\n    *   The ""Back"" button is on the left, the ""Next"" button is in the middle, and the ""Cancel"" button is on the right.\n*   **Background**\n    *   The background of the window is white, with a light blue bar at the top.\n    *   The overall design of the window is clean and simple, with clear labels and easy-to-use buttons.\n\nIn summary, the image shows a computer window with a title and message, as well as buttons for navigation. The window is designed to be easy to use and understand, with clear labels and simple graphics.', 'The image shows a screenshot of a computer program, specifically a toolchain editor. The title at the top reads ""Edit toolchain info"" in black text.\n\nBelow the title, there are several fields for inputting information about the toolchain. These fields include:\n\n* Family: ARM Compiler 6\n* Version (major): 6\n* Version (minor): 17\n* Version (patch/update): \n* Version (build): \n* Compiler: armclang\n* Assembler: armasm\n* Linker: armlink\n* Archiver: armar\n* Image Converter: fromelf\n\nAt the bottom of the window, there are buttons labeled ""< Back"", ""Next >"", and ""Cancel"". A blue button labeled ""Finish"" is also present.\n\nThe background of the window is white, with a light blue bar at the top. The overall design of the window suggests that it is part of a larger software development environment, possibly a compiler or build tool.', 'The image shows a screenshot of the ""Settings"" window in Visual Studio, with the ""ARM C Compiler 6.17"" tab selected. The window is divided into two main sections: the left side lists various settings categories, and the right side displays the settings for the selected category.\n\n**Left Side:**\n\n*   **Resource**\n*   **Builders**\n*   **C/C++ Build**\n*   **Build Variables**\n*   **Environment**\n*   **Logging**\n*   **Settings**\n*   **Tool Chain Editor**\n*   **C/C++ General**\n*   **Project Natures**\n*   **Project References**\n*   **Renesas QE**\n*   **Run/Debug Settings**\n*   **Task Tags**\n*   **Validation**\n\n**Right Side:**\n\n*   **ARM C Compiler 6.17**\n    *   **Target**\n        *   **Preprocessor**\n        *   **Includes**\n        *   **Source Language**\n        *   **Optimizations**\n        *   **Debugging**\n        *   **Warnings and Errors**\n        *   **Miscellaneous**\n    *   **ARM Assembler 6.17**\n        *   **Target**\n        *   **Preprocessor**\n        *   **Includes**\n        *   **Debugging**\n        *   **Warnings and Errors**\n        *   **Miscellaneous**\n    *   **ARM Linker 6.17**\n        *   **Target**\n        *   **Image Layout**\n        *   **Libraries**\n        *   **Optimizations**\n        *   **Additional Information**\n        *   **Warnings and Errors**\n        *   **Miscellaneous**\n\nThe image provides a clear view of the settings available for the ARM C Compiler 6.17, allowing users to customize their build process and optimize their code for specific targets.', ""The image shows a screenshot of a computer screen displaying a text-based error message. The error message is in a monospaced font and is displayed in a window with a gray background.\n\nThe error message is a C++ compiler error message, indicating that there is an error in the code being compiled. The message includes the line number and column number where the error occurred, as well as a description of the error.\n\nThe error message is:\n\n`C:\\Users\\username\\Documents\\Project\\main.cpp|15|error: expected ';' before '}' token`\n\nThis indicates that there is an error on line 15 of the file `main.cpp`, where the compiler is expecting a semicolon before the closing curly bracket `}`.\n\nThe error message also includes some additional information, such as the file name and line number where the error occurred, as well as the type of error (in this case, a syntax error).\n\nOverall, the image suggests that the user is trying to compile a C++ program, but there is an error in the code that needs to be fixed before the program can be successfully compiled."", 'The image shows a screenshot of the ""Settings"" window in Visual Studio, with the ""Build Steps"" tab selected. The window is divided into two main sections: the left side lists various settings, and the right side displays the current settings for the selected tab.\n\n*   **Left Side:**\n    *   The left side of the window is a list of settings, including:\n        *   Resource\n        *   Builders\n        *   C/C++ Build\n        *   Build Variables\n        *   Environment\n        *   Logging\n        *   Settings\n        *   Tool Chain Editor\n        *   C/C++ General\n        *   Project Natures\n        *   Project References\n        *   Refactoring History\n        *   Renesas QE\n        *   Run/Debug Settings\n        *   Task Tags\n        *   Validation\n*   **Right Side:**\n    *   The right side of the window displays the current settings for the selected tab, which is ""Build Steps"".\n    *   The ""Command"" field is highlighted in red, indicating that it is the current focus.\n    *   The ""armclang.exe"" command is displayed in the ""Command"" field.\n    *   Below the ""Command"" field, there are several options for customizing the build process, including:\n        *   All options\n        *   Expert settings\n        *   Command line pattern\n*   **Bottom Section:**\n    *   The bottom section of the window contains buttons for applying and closing the settings window.\n    *   The ""Apply and Close"" button is highlighted in blue, indicating that it is the default action.\n\nOverall, the image shows a screenshot of the ""Settings"" window in Visual Studio, with the ""Build Steps"" tab selected and the ""Command"" field highlighted. The window allows users to customize the build process by selecting different commands and options.']"
c565d516b95fcb0d4d8e89daf02b17b3,"Question:
How do I find the right crystals for RA MCUs?
Question:
How do I find the right crystals for RA MCUs?
How do I find the right crystals for RA MCUs?
Answer:
You can find the crystals you need for the sub-clock resonators on RA MCUs from the crystal manufacturer’s web site here:
https://global.kyocera.com/prdct/electro/product/crystal-device/xtal/  
Simply click on the search tool:
  And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page.
See below for RA2 series other than RA2A1.
https://www.sii.co.jp/en/quartz/news/topics/2021/12/06/1678/
Suitable Products
Answer:
You can find the crystals you need for the sub-clock resonators on RA MCUs from the crystal manufacturer’s web site here:
https://global.kyocera.com/prdct/electro/product/crystal-device/xtal/  
Simply click on the search tool:
  And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page.
See below for RA2 series other than RA2A1.
https://www.sii.co.jp/en/quartz/news/topics/2021/12/06/1678/
Suitable Products
You can find the crystals you need for the sub-clock resonators on RA MCUs from the crystal manufacturer’s web site here:
https://global.kyocera.com/prdct/electro/product/crystal-device/xtal/
You can find the crystals you need for the sub-clock resonators on RA MCUs from the crystal manufacturer’s web site here:
https://global.kyocera.com/prdct/electro/product/crystal-device/xtal/
Simply click on the search tool:
Simply click on the search tool:
And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page.
And then
using a search with
Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page.
See below for RA2 series other than RA2A1.
https://www.sii.co.jp/en/quartz/news/topics/2021/12/06/1678/
Suitable Products
RA2 Series
RA4 Series
RA6 Series",['data/categories/ra_family/ra_and_fsp_technical_articles/c565d516b95fcb0d4d8e89daf02b17b3/images/95b01bd0387d8a076515fa62281af95f.png'],[],['|  |\n|  |\n| RA2 Series\nRA4 Series\nRA6 Series |'],"{'title': 'Finding the right crystals for RA MCUs', 'url': 'https://en-support.renesas.com/knowledgeBase/19558422', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:37.432764'}",Question How do I find the right crystals for RA MCUs? Answer You can find the crystals you need for the sub-clock resonators on RA MCUs from the crystal manufacturers web site here https//global.kyocera.com/prdct/electro/product/crystal-device/xtal/ Simply click on the search tool And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page. See below for RA2 series other than RA2A1. https//www.sii.co.jp/en/quartz/news/topics/2021/12/06/1678/ Suitable Products https//global.kyocera.com/prdct/electro/product/crystal-device/xtal/ And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page. And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page. RA2 Series RA4 Series RA6 Series,"['The image presents a screenshot of a search bar within a webpage, featuring a light blue background with a white rectangle containing the search bar. The search bar is titled ""Design Tools"" in black text at the top, followed by a white rectangle with a magnifying glass icon and the text ""Crystal Units vs. IC Matching Search"" in black.\n\n**Key Features:**\n\n* **Search Bar:** The search bar is prominently displayed within the white rectangle, accompanied by a magnifying glass icon.\n* **Title:** The title ""Design Tools"" is written in black text at the top of the image.\n* **Background:** The background of the image is a light blue color, providing a clean and neutral backdrop for the search bar.\n* **Icon:** A magnifying glass icon is situated next to the search bar, indicating the functionality of the search feature.\n* **Text:** The text ""Crystal Units vs. IC Matching Search"" is written in black within the white rectangle, providing context for the search bar.\n\n**Overall Impression:**\n\nThe image effectively conveys the purpose of the search bar, which is to facilitate a search for specific information related to crystal units and IC matching. The use of a magnifying glass icon and clear text makes it easy for users to understand the functionality of the search bar.']"
a4d0626f190549bfa06956a8362711c3,"Issue
Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run. 
Example of copy command failing:
Solution:
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
    e2studio
FSP
Source: RAP-1819
Issue
Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run. 
Example of copy command failing:
Solution:
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
    e2studio
FSP
Source: RAP-1819
Issue
Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run.
Issue
Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run.
Example of copy command failing:
Example of copy command failing:
Solution:
Solution:
Solution:
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
e2studio
FSP
Source: RAP-1819
Source: RAP-1819",['data/categories/ra_family/ra_and_fsp_technical_articles/a4d0626f190549bfa06956a8362711c3/images/62d3c1926a2e9d408c6c6bf3ffe992a9.png'],[],['|  |\n|  |\n| e2studio |\n| FSP |'],"{'title': 'RA Family: Windows System Commands Fail to Run from e2studio from the Build Steps Option in FSP 3.7.0 and Later', 'url': 'https://en-support.renesas.com/knowledgeBase/20554960', 'last_updated': '2022-10-06', 'extracted_at': '2025-03-08T23:11:55.741946'}","Issue Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run. Example of copy command failing Solution Use Linux commands instead. For example, Changing del  rm, and copy  cp should allow the build to complete without these error messages from the pre-build step. e2studio FSP Source RAP-1819 Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run. e2studio","['The image shows a screenshot of a computer screen displaying a text-based interface for a build process. The top-left corner has a small icon of a person, and the top-right corner has a small icon of a gear. The top menu bar has several options, including ""Pin Conflicts"", ""Console"", and ""Debug"". The main content area displays a series of lines of text in blue and black, which appear to be error messages or output from a build process. The text is written in a programming language, possibly C# or Java, and includes variables, functions, and error messages. The background of the image is a light gray color.\n\nOverall, the image suggests that the user is working on a software development project and is using a build tool to compile and test their code. The error messages and warnings indicate that there may be issues with the code that need to be addressed before the build can be completed successfully.']"
552055185b9e9f12bcf6895e2ab92511,"Issues
1) Even though the Ethernet Link is up successfully, the RA6E1/M4/M5 device may not respond to the ICMP echo request (PING). 
2) Even though the Ethernet Link is up successfully, no signal is output through MII/RMII TXDs pins of MCU.
  Description:
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the User’s Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error. 
  Solution:
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customer’s board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the user’s external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
      Figure 1 - Snippet code from the fsp.ld file 
    Figure 2 - Snippet code from the ra_gen/common_data.c 
 
   Figure 3 – Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
 
  Figure 4 – Setup TrustZone Partition via RFP- Boundary Settings
  EDMAC
FSP
Issues
1) Even though the Ethernet Link is up successfully, the RA6E1/M4/M5 device may not respond to the ICMP echo request (PING). 
2) Even though the Ethernet Link is up successfully, no signal is output through MII/RMII TXDs pins of MCU.
  Description:
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the User’s Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error. 
  Solution:
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customer’s board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the user’s external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
      Figure 1 - Snippet code from the fsp.ld file 
    Figure 2 - Snippet code from the ra_gen/common_data.c 
 
   Figure 3 – Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
 
  Figure 4 – Setup TrustZone Partition via RFP- Boundary Settings
  EDMAC
FSP
Issues
1) Even though the Ethernet Link is up successfully, the RA6E1/M4/M5 device may not respond to the ICMP echo request (PING). 
2) Even though the Ethernet Link is up successfully, no signal is output through MII/RMII TXDs pins of MCU.
Issues
1) Even though the Ethernet Link is up successfully, the RA6E1/M4/M5 device may not respond to the ICMP echo request (PING). 
2) Even though the Ethernet Link is up successfully, no signal is output through MII/RMII TXDs pins of MCU.
Description:
Description:
Description:
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the User’s Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error.
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the User’s Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error.
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the User’s Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error.
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the User’s Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error.
receive frame counter overflow (EESR.RFCOF = 1)
receive frame counter overflow (EESR.RFCOF = 1)
receive frame counter overflow (EESR.RFCOF = 1)
transmit buffer full
transmit buffer full
transmit buffer full
Solution:
Solution:
Solution:
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customer’s board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customer’s board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customer’s board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customer’s board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the user’s external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the user’s external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the user’s external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the user’s external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
Figure 1 - Snippet code from the fsp.ld file
Figure 1 - Snippet code from the fsp.ld file
Figure 1 - Snippet code from the fsp.ld file
Figure 1 - Snippet code from the
fsp.ld
file
Figure 2 - Snippet code from the ra_gen/common_data.c
Figure 2 - Snippet code from the ra_gen/common_data.c
Figure 2 - Snippet code from the ra_gen/common_data.c
Figure 2 - Snippet code from the
ra_gen
/
common_data.c
Figure 3 – Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
Figure 3 – Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
Figure 3 – Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
Figure 3 – Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
Figure 4 – Setup TrustZone Partition via RFP- Boundary Settings
Figure 4 – Setup TrustZone Partition via RFP- Boundary Settings
Figure 4 – Setup TrustZone Partition via RFP- Boundary Settings
Figure 4 –
Setup
TrustZone Partition
via RFP- Boundary Settings
EDMAC
FSP","['data/categories/ra_family/ra_and_fsp_technical_articles/552055185b9e9f12bcf6895e2ab92511/images/cc80e2638fda428468acd962f5837319.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/552055185b9e9f12bcf6895e2ab92511/images/cf1a104003a42ffa58d4fd192578ab52.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/552055185b9e9f12bcf6895e2ab92511/images/ec75bac187c5db1c36be76ae6a27618d.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/552055185b9e9f12bcf6895e2ab92511/images/3fb8645eaba201fccd554a58753fd051.png']",[],['|  |\n|  |\n| EDMAC |\n| FSP |'],"{'title': 'EDMAC operation issue possible on custom RA6E1/M4/M5 board', 'url': 'https://en-support.renesas.com/knowledgeBase/20540134', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:11.022517'}","Issues 1) Even though the Ethernet Link is up successfully, the RA6E1/M4/M5 device may not respond to the ICMP echo request (PING). 2) Even though the Ethernet Link is up successfully, no signal is output through MII/RMII TXDs pins of MCU. Description The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the Users Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area. Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF  1) error of will be received. For Ethernet frame transmission, the operation FSP RETHERWrite() will return the transmit buffer full error. Solution In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a nsbuffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customers board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3). For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the users external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example). Figure 1 - Snippet code from the fsp.ld file Figure 2 - Snippet code from the ragen/commondata.c Figure 3  Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes Figure 4  Setup TrustZone Partition via RFP- Boundary Settings EDMAC FSP Description The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the Users Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area. Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF  1) error of will be received. For Ethernet frame transmission, the operation FSP RETHERWrite() will return the transmit buffer full error. receive frame counter overflow (EESR.RFCOF  1) transmit buffer full Solution Figure 1 - Snippet code from the fsp.ld file Figure 1 - Snippet code from the fsp.ld file Figure 2 - Snippet code from the ragen/commondata.c Figure 2 - Snippet code from the ragen / commondata.c Figure 3  Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes Figure 4  Setup TrustZone Partition via RFP- Boundary Settings Figure 4  Setup TrustZone Partition via RFP- Boundary Settings EDMAC","['The image displays a code snippet in a programming language, likely C or C++. The code is written in a monospaced font and is presented on a white background.\n\nThe code begins with a comment that reads: /* Non-secure buffers must be in non-secure RAM. This is primarily used for the EDMAC in flat projects. */. Below this comment, there is another comment that states: /* The EDMAC is a non-secure bus master and can only access non-secure RAM. */. \n\nThe code then defines a function called .ns_buffer (NOLOAD):, which allocates RAM on a 32-byte boundary to help with the placement of Ethernet buffers. The function takes two arguments: _RESERVE_NS_RAM and ABSOLUTE(RAM_NS_BUFFER_START & 0xFFFFFE0). The function returns a pointer to the allocated RAM.\n\nBelow the function definition, there is a line of code that reads: > RAM (*(.ns_buffer*));. This line appears to be a macro or a function call that is used to reserve non-secure RAM for the .ns_buffer function.\n\nOverall, the code snippet appears to be related to the allocation of non-secure RAM for use with the EDMAC (Ethernet DMA Controller) in a flat project. The code defines a function that allocates RAM on a 32-byte boundary and provides a way to reserve non-secure RAM for use with this function.', 'The image shows a code snippet in a programming language, likely C++ or C#, with a focus on buffer management. The code is written in a monospaced font and is displayed on a white background.\n\nThe code snippet appears to be a part of a larger program that handles buffer operations. It includes several lines of code that define and initialize buffers, as well as lines that perform operations on these buffers. The code also includes comments and labels to help explain its purpose and functionality.\n\nThe code snippet is likely part of a larger program that is designed to manage and process data in a specific way. The use of buffers and the focus on memory management suggest that the program may be handling large amounts of data or performing complex computations.\n\nOverall, the image provides a glimpse into the inner workings of a programming language and the techniques used to manage and process data. It highlights the importance of attention to detail and the need for clear and concise code in order to ensure that programs function correctly and efficiently.', 'The image shows a screenshot of a computer program with a white background and black text. The program is titled ""Debug Configurations"" and has a menu bar at the top with options such as ""File,"" ""Edit,"" ""View,"" and ""Help."" \n\n*   The main window of the program is divided into two sections: a left-hand column and a right-hand column.\n    *   The left-hand column contains a list of items, including ""type filter text,"" ""C/C++ Application,"" ""C/C++ Remote Application,"" ""EASE Script,"" ""GDB Hardware Debugging,"" ""GDB OpenOCD Debugging,"" ""GDB Simulator Debugging,"" ""Java Applet,"" ""Java Application,"" ""Launch Group,"" ""Remote Java Application,"" ""Renesas GDB Hardware Debugging,"" ""Renesas Simulator Debugging,"" and ""ethernet_ek_ra6m4_ep Debug.""\n        *   Each item in the list has a checkbox next to it, and some items have additional sub-items or options.\n    *   The right-hand column contains a table with several columns, including ""Name,"" ""Main,"" ""Startup,"" ""Source,"" and ""Common.""\n        *   The table appears to be displaying information about a specific debug configuration, with columns for the name, main settings, startup settings, source settings, and common settings.\n*   At the bottom of the window, there are several buttons, including ""Debug,"" ""Close,"" and ""Apply.""\n    *   The ""Debug"" button is highlighted in blue, indicating that it is the currently selected option.\n*   In the top-right corner of the window, there is a small icon of a green bug.\n    *   The bug icon may be a logo or branding element for the program or company that created it.\n\nOverall, the image suggests that the program is a debugging tool for software developers, allowing them to create and manage debug configurations for their projects. The program appears to be user-friendly and easy to navigate, with clear labels and intuitive controls.', 'The image shows a screenshot of the Renesas Flash Programmer software, which is a tool used to program and debug microcontrollers. The software is open on a computer screen, with the main window displaying various options and settings.\n\n*   **File Menu**\n    *   The File menu is located at the top left corner of the window and contains options such as ""Open,"" ""Save,"" ""Save As,"" and ""Exit.""\n*   **Operation Menu**\n    *   The Operation menu is located below the File menu and contains options such as ""Set Option,"" ""Target State,"" ""DLM Keys,"" and ""Boundary.""\n*   **Flash Options Tab**\n    *   The Flash Options tab is located below the Operation menu and contains options such as ""Do Nothing,"" ""SSD,"" ""Set Option,"" ""Encrypted SECDBG Key,"" ""Encrypted NONSECDBG Key,"" and ""Encrypted RMA Key.""\n*   **Boundary Tab**\n    *   The Boundary tab is located below the Flash Options tab and contains options such as ""Set Option,"" ""Use Renesas Partition Data File,"" and ""Renesas Partition Data File.""\n*   **Security Tab**\n    *   The Security tab is located below the Boundary tab and contains options such as ""Set Option"" and ""Yes.""\n*   **Project Name**\n    *   The project name is displayed at the bottom of the window and is set to ""<Project Name>\\Debug\\http_server_ek_ra6m5.rpd.""\n\nOverall, the image shows a screenshot of the Renesas Flash Programmer software, which is used to program and debug microcontrollers. The software has various options and settings that can be customized to suit specific needs.']"
d5835ab1490b2c4dd0539f7090b90aff,"Issue:
AppWizard is the Segger emWin provided PC software that makes GUI building and embedded software programming easier for developers. Sometimes, what you want to achieve cannot be all done by AppWizard, so changes need to be made at the source code level with emWin API.
Description:
There are two types of emWin APIs, one is AppWizard APIs and the other is conventional emWin APIs. AppWizard APIs and conventional emWin APIs generally work the same but AppWizard APIs are a more general form that can be used all across the objects. Since some AppWizard APIs are still undocumented, we will use conventional emWin API in this document.
AppWizard APIs are listed in “AppWizard.h”
Core emWin APIs are listed in “GUI.h” and “WM.h”
Widget’s emWin APIs are listed in each widget header files like “TEXT.h”, “BUTTON.h”, “ROTARY.h”, and so on.
Answers:
Change TEXT when button is pressed (TEXT moves along when screen swipe)
If you have a TEXT widget that does not know what to print out at build time but make up a word or sentence at runtime when BUTTON is pressed, then the text in TEXT widget can be changed dynamically with the following code. The figures below show that the text of TEXT changes when the button is pressed, and the position of TEXT also changes when the screen is swiped.
           If you have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, ID_TEXT_00);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
default:
      //WM_DefaultProc(); --> ”Screen” callback MUST not have default function handler
      break;  }
}
  If you don’t have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
        hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->hWin, WM_CF_SHOW, 0, GUI_ID_TEXT0, ""HI"");
      break;
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
    default:
      //WM_DefaultProc(); --> ”Screen” callback MUST not have default function handler
      break;
  }
}
  GUI user interface
There is no direct user interface APIs, for example, for a BUTTON widget to change from unpressed to pressed state. The only way to change the BUTTON to the pressed state is to deliver a keyboard or PID message to the BUTTON, and the message to be processed in a callback function. Keyboard input is delivered in GUI_StoreKeyMsg(), and PID input is delivered in GUI_PID_StoreState(). The example below shows how to make a push button IRQ interrupt act like the “Enter” key was pressed on BUTTON. Please note that BUTTON widget reacts to keyboard input differently than PID input. For example, keyboard “Enter” press on BUTTON widget generates both press and release messages in turn at once.
void external_irq_callback (void)
{
WM_HWIN hWin;
WM_HWIN hItem;
    hWin = WM_GetActiveWindow();
  hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);
  WIDGET_SetFocusable(hItem,1);
  WM_SetFocus(hItem);
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 1); /* Pressed */
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 0); /* Release */
}
      It would be also possible to make a button press act like touch/mouse swipe.
GUI_PID_STATE swipe_state;
void external_irq_callback (void)
{
swipe_state.x = x_position;
swipe_state.y = y_position;
swipe_state.Pressed = 1;
  GUI_PID_StoreState(&swipe_state);
  x_position += x_position_increment;
  if(x_position >= x_position_max){
    swipe_state.Pressed = 0;
    GUI_PID_StoreState(&swipe_state);
}
}
  Custom drawing on top
If you need to do some custom drawing on top and stay on top, you can make a child window of WM_HBKWIN and set the StayOnTop flag. A window is created with the given x, y coordinate and size, and a custom user callback function pointer. In the callback function, WM_PAINT is where the user is allowed to do some custom drawing. MEMDEV is a temporary drawing place used for anti-flicker, image decompression, scaling & rotating, animation, and so on. For more details on MEMDEV, please refer to the emWin manual. The example below draws one line from (0,0) to (100,100) and stays on top during/after screen swiping.
static void _cbTopWin(WM_MESSAGE * pMsg) {
GUI_MEMDEV_Handle hMem;
    switch (pMsg->MsgId) {
    case WM_PAINT:
      hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);
      GUI_MEMDEV_Select(hMem);
      GUI_SetColor(GUI_BLACK);
      for(uint32_t i=0; i<100; i++){
        GUI_DrawPixel(i, i);
      }
      GUI_MEMDEV_CopyToLCD(hMem);
      GUI_MEMDEV_Delete(hMem);
      GUI_MEMDEV_Select(0);
      break;
    default:
      WM_DefaultProc(pMsg);
      break;
  }
}
  void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
      hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);
      WM_SetStayOnTop(hWin, 1);
      break;
}
}
  To learn more about emWin and AppWizard, please find the links below.
https://www.youtube.com/@SeggerMicro/videos
https://www.segger.com/downloads/emwin/UM03001
Suitable Products
RA Family
AppWizard is the Segger emWin provided PC software that makes GUI building and embedded software programming easier for developers. Sometimes, what you want to achieve cannot be all done by AppWizard, so changes need to be made at the source code level with emWin API.
AppWizard is the Segger emWin provided PC software that makes GUI building and embedded software programming easier for developers. Sometimes, what you want to achieve cannot be all done by AppWizard, so changes need to be made at the source code level with emWin API.
There are two types of emWin APIs, one is AppWizard APIs and the other is conventional emWin APIs. AppWizard APIs and conventional emWin APIs generally work the same but AppWizard APIs are a more general form that can be used all across the objects. Since some AppWizard APIs are still undocumented, we will use conventional emWin API in this document.
AppWizard APIs are listed in “AppWizard.h”
Core emWin APIs are listed in “GUI.h” and “WM.h”
Widget’s emWin APIs are listed in each widget header files like “TEXT.h”, “BUTTON.h”, “ROTARY.h”, and so on.
There are two types of emWin APIs, one is AppWizard APIs and the other is conventional emWin APIs. AppWizard APIs and conventional emWin APIs generally work the same but AppWizard APIs are a more general form that can be used all across the objects. Since some AppWizard APIs are still undocumented, we will use conventional emWin API in this document.
Answers:
Change TEXT when button is pressed (TEXT moves along when screen swipe)
If you have a TEXT widget that does not know what to print out at build time but make up a word or sentence at runtime when BUTTON is pressed, then the text in TEXT widget can be changed dynamically with the following code. The figures below show that the text of TEXT changes when the button is pressed, and the position of TEXT also changes when the screen is swiped.
           If you have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, ID_TEXT_00);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
default:
      //WM_DefaultProc(); --> ”Screen” callback MUST not have default function handler
      break;  }
}
  If you don’t have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
        hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->hWin, WM_CF_SHOW, 0, GUI_ID_TEXT0, ""HI"");
      break;
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
    default:
      //WM_DefaultProc(); --> ”Screen” callback MUST not have default function handler
      break;
  }
}
  GUI user interface
There is no direct user interface APIs, for example, for a BUTTON widget to change from unpressed to pressed state. The only way to change the BUTTON to the pressed state is to deliver a keyboard or PID message to the BUTTON, and the message to be processed in a callback function. Keyboard input is delivered in GUI_StoreKeyMsg(), and PID input is delivered in GUI_PID_StoreState(). The example below shows how to make a push button IRQ interrupt act like the “Enter” key was pressed on BUTTON. Please note that BUTTON widget reacts to keyboard input differently than PID input. For example, keyboard “Enter” press on BUTTON widget generates both press and release messages in turn at once.
void external_irq_callback (void)
{
WM_HWIN hWin;
WM_HWIN hItem;
    hWin = WM_GetActiveWindow();
  hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);
  WIDGET_SetFocusable(hItem,1);
  WM_SetFocus(hItem);
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 1); /* Pressed */
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 0); /* Release */
}
      It would be also possible to make a button press act like touch/mouse swipe.
GUI_PID_STATE swipe_state;
void external_irq_callback (void)
{
swipe_state.x = x_position;
swipe_state.y = y_position;
swipe_state.Pressed = 1;
  GUI_PID_StoreState(&swipe_state);
  x_position += x_position_increment;
  if(x_position >= x_position_max){
    swipe_state.Pressed = 0;
    GUI_PID_StoreState(&swipe_state);
}
}
  Custom drawing on top
If you need to do some custom drawing on top and stay on top, you can make a child window of WM_HBKWIN and set the StayOnTop flag. A window is created with the given x, y coordinate and size, and a custom user callback function pointer. In the callback function, WM_PAINT is where the user is allowed to do some custom drawing. MEMDEV is a temporary drawing place used for anti-flicker, image decompression, scaling & rotating, animation, and so on. For more details on MEMDEV, please refer to the emWin manual. The example below draws one line from (0,0) to (100,100) and stays on top during/after screen swiping.
static void _cbTopWin(WM_MESSAGE * pMsg) {
GUI_MEMDEV_Handle hMem;
    switch (pMsg->MsgId) {
    case WM_PAINT:
      hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);
      GUI_MEMDEV_Select(hMem);
      GUI_SetColor(GUI_BLACK);
      for(uint32_t i=0; i<100; i++){
        GUI_DrawPixel(i, i);
      }
      GUI_MEMDEV_CopyToLCD(hMem);
      GUI_MEMDEV_Delete(hMem);
      GUI_MEMDEV_Select(0);
      break;
    default:
      WM_DefaultProc(pMsg);
      break;
  }
}
  void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
      hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);
      WM_SetStayOnTop(hWin, 1);
      break;
}
}
  To learn more about emWin and AppWizard, please find the links below.
https://www.youtube.com/@SeggerMicro/videos
https://www.segger.com/downloads/emwin/UM03001
Suitable Products
RA Family
Change TEXT when button is pressed (TEXT moves along when screen swipe)
If you have a TEXT widget that does not know what to print out at build time but make up a word or sentence at runtime when BUTTON is pressed, then the text in TEXT widget can be changed dynamically with the following code. The figures below show that the text of TEXT changes when the button is pressed, and the position of TEXT also changes when the screen is swiped.
           If you have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, ID_TEXT_00);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
default:
      //WM_DefaultProc(); --> ”Screen” callback MUST not have default function handler
      break;  }
}
  If you don’t have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
        hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->hWin, WM_CF_SHOW, 0, GUI_ID_TEXT0, ""HI"");
      break;
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
    default:
      //WM_DefaultProc(); --> ”Screen” callback MUST not have default function handler
      break;
  }
}
  GUI user interface
There is no direct user interface APIs, for example, for a BUTTON widget to change from unpressed to pressed state. The only way to change the BUTTON to the pressed state is to deliver a keyboard or PID message to the BUTTON, and the message to be processed in a callback function. Keyboard input is delivered in GUI_StoreKeyMsg(), and PID input is delivered in GUI_PID_StoreState(). The example below shows how to make a push button IRQ interrupt act like the “Enter” key was pressed on BUTTON. Please note that BUTTON widget reacts to keyboard input differently than PID input. For example, keyboard “Enter” press on BUTTON widget generates both press and release messages in turn at once.
void external_irq_callback (void)
{
WM_HWIN hWin;
WM_HWIN hItem;
    hWin = WM_GetActiveWindow();
  hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);
  WIDGET_SetFocusable(hItem,1);
  WM_SetFocus(hItem);
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 1); /* Pressed */
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 0); /* Release */
}
      It would be also possible to make a button press act like touch/mouse swipe.
GUI_PID_STATE swipe_state;
void external_irq_callback (void)
{
swipe_state.x = x_position;
swipe_state.y = y_position;
swipe_state.Pressed = 1;
  GUI_PID_StoreState(&swipe_state);
  x_position += x_position_increment;
  if(x_position >= x_position_max){
    swipe_state.Pressed = 0;
    GUI_PID_StoreState(&swipe_state);
}
}
  Custom drawing on top
If you need to do some custom drawing on top and stay on top, you can make a child window of WM_HBKWIN and set the StayOnTop flag. A window is created with the given x, y coordinate and size, and a custom user callback function pointer. In the callback function, WM_PAINT is where the user is allowed to do some custom drawing. MEMDEV is a temporary drawing place used for anti-flicker, image decompression, scaling & rotating, animation, and so on. For more details on MEMDEV, please refer to the emWin manual. The example below draws one line from (0,0) to (100,100) and stays on top during/after screen swiping.
static void _cbTopWin(WM_MESSAGE * pMsg) {
GUI_MEMDEV_Handle hMem;
    switch (pMsg->MsgId) {
    case WM_PAINT:
      hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);
      GUI_MEMDEV_Select(hMem);
      GUI_SetColor(GUI_BLACK);
      for(uint32_t i=0; i<100; i++){
        GUI_DrawPixel(i, i);
      }
      GUI_MEMDEV_CopyToLCD(hMem);
      GUI_MEMDEV_Delete(hMem);
      GUI_MEMDEV_Select(0);
      break;
    default:
      WM_DefaultProc(pMsg);
      break;
  }
}
  void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
      hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);
      WM_SetStayOnTop(hWin, 1);
      break;
}
}
  To learn more about emWin and AppWizard, please find the links below.
https://www.youtube.com/@SeggerMicro/videos
https://www.segger.com/downloads/emwin/UM03001
Change TEXT when button is pressed (TEXT moves along when screen swipe)
If you have a TEXT widget that does not know what to print out at build time but make up a word or sentence at runtime when BUTTON is pressed, then the text in TEXT widget can be changed dynamically with the following code. The figures below show that the text of TEXT changes when the button is pressed, and the position of TEXT also changes when the screen is swiped.
If you have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
void
cbID_SCREEN_00(
WM_MESSAGE
* pMsg) {
WM_HWIN  hWin;
WM_HWIN  hWin;
int      Id, NCode;
int
Id, NCode;
switch (pMsg->MsgId) {
switch
(pMsg->
MsgId
) {
case WM_NOTIFY_PARENT:
case
WM_NOTIFY_PARENT:
Id = WM_GetId(pMsg->hWinSrc);
Id = WM_GetId(pMsg->
hWinSrc
);
NCode = pMsg->Data.v;
NCode = pMsg->
Data
.
v
;
switch(Id) {
switch
(Id) {
case ID_BUTTON_00:
case
ID_BUTTON_00:
switch(NCode){
switch
(NCode){
case WM_NOTIFICATION_CLICKED:
case
WM_NOTIFICATION_CLICKED:
hWin = WM_GetDialogItem(pMsg->hWin, ID_TEXT_00);
hWin = WM_GetDialogItem(pMsg->
hWin
, ID_TEXT_00);
TEXT_SetText(hWin, ""Success"");
TEXT_SetText(hWin,
""Success""
);
break;
break
;
}
}
break;
break
;
}
}
break;
break
;
default:
default
:
//WM_DefaultProc(); --> ”Screen” callback MUST not have default function handler
//WM_DefaultProc(); -->
”Screen” callback MUST not have default function handler
break;  }
break
;  }
}
}
If you don’t have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
void
cbID_SCREEN_00(
WM_MESSAGE
* pMsg) {
WM_HWIN  hWin;
WM_HWIN  hWin;
int      Id, NCode;
int
Id, NCode;
switch (pMsg->MsgId) {
switch
(pMsg->
MsgId
) {
case WM_INIT_DIALOG:
case
WM_INIT_DIALOG:
hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->hWin, WM_CF_SHOW, 0, GUI_ID_TEXT0, ""HI"");
hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->
hWin
, WM_CF_SHOW, 0, GUI_ID_TEXT0,
""HI""
);
break;
break
;
case WM_NOTIFY_PARENT:
case
WM_NOTIFY_PARENT:
Id = WM_GetId(pMsg->hWinSrc);
Id = WM_GetId(pMsg->
hWinSrc
);
NCode = pMsg->Data.v;
NCode = pMsg->
Data
.
v
;
switch(Id) {
switch
(Id) {
case ID_BUTTON_00:
case
ID_BUTTON_00:
switch(NCode){
switch
(NCode){
case WM_NOTIFICATION_CLICKED:
case
WM_NOTIFICATION_CLICKED:
hWin = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
hWin = WM_GetDialogItem(pMsg->
hWin
, GUI_ID_TEXT0);
TEXT_SetText(hWin, ""Success"");
TEXT_SetText(hWin,
""Success""
);
break;
break
;
}
}
break;
break
;
}
}
break;
break
;
default:
default
:
//WM_DefaultProc(); --> ”Screen” callback MUST not have default function handler
//WM_DefaultProc(); -->
”Screen” callback MUST not have default function handler
break;
break
;
}
}
}
}
GUI user interface
There is no direct user interface APIs, for example, for a BUTTON widget to change from unpressed to pressed state. The only way to change the BUTTON to the pressed state is to deliver a keyboard or PID message to the BUTTON, and the message to be processed in a callback function. Keyboard input is delivered in GUI_StoreKeyMsg(), and PID input is delivered in GUI_PID_StoreState(). The example below shows how to make a push button IRQ interrupt act like the “Enter” key was pressed on BUTTON. Please note that BUTTON widget reacts to keyboard input differently than PID input. For example, keyboard “Enter” press on BUTTON widget generates both press and release messages in turn at once.
void external_irq_callback (void)
void
external_irq_callback (
void
)
{
{
WM_HWIN hWin;
WM_HWIN hWin;
WM_HWIN hItem;
WM_HWIN hItem;
hWin = WM_GetActiveWindow();
hWin = WM_GetActiveWindow();
hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);
hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);
WIDGET_SetFocusable(hItem,1);
WIDGET_SetFocusable(hItem,1);
WM_SetFocus(hItem);
WM_SetFocus(hItem);
GUI_StoreKeyMsg(GUI_KEY_ENTER, 1); /* Pressed */
GUI_StoreKeyMsg(GUI_KEY_ENTER, 1);
/* Pressed */
GUI_StoreKeyMsg(GUI_KEY_ENTER, 0); /* Release */
GUI_StoreKeyMsg(GUI_KEY_ENTER, 0);
/* Release */
}
}
It would be also possible to make a button press act like touch/mouse swipe.
GUI_PID_STATE swipe_state;
GUI_PID_STATE
swipe_state;
void external_irq_callback (void)
void
external_irq_callback (
void
)
{
{
swipe_state.x = x_position;
swipe_state.
x
= x_position;
swipe_state.y = y_position;
swipe_state.
y
= y_position;
swipe_state.Pressed = 1;
swipe_state.
Pressed
= 1;
GUI_PID_StoreState(&swipe_state);
GUI_PID_StoreState(&swipe_state);
x_position += x_position_increment;
x_position += x_position_increment;
if(x_position >= x_position_max){
if
(x_position >= x_position_max){
swipe_state.Pressed = 0;
swipe_state.
Pressed
= 0;
GUI_PID_StoreState(&swipe_state);
GUI_PID_StoreState(&swipe_state);
}
}
}
}
Custom drawing on top
If you need to do some custom drawing on top and stay on top, you can make a child window of WM_HBKWIN and set the StayOnTop flag. A window is created with the given x, y coordinate and size, and a custom user callback function pointer. In the callback function, WM_PAINT is where the user is allowed to do some custom drawing. MEMDEV is a temporary drawing place used for anti-flicker, image decompression, scaling & rotating, animation, and so on. For more details on MEMDEV, please refer to the emWin manual. The example below draws one line from (0,0) to (100,100) and stays on top during/after screen swiping.
static void _cbTopWin(WM_MESSAGE * pMsg) {
static
void
_cbTopWin(
WM_MESSAGE
* pMsg) {
GUI_MEMDEV_Handle hMem;
GUI_MEMDEV_Handle
hMem;
switch (pMsg->MsgId) {
switch
(pMsg->
MsgId
) {
case WM_PAINT:
case
WM_PAINT:
hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);
hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);
GUI_MEMDEV_Select(hMem);
GUI_MEMDEV_Select(hMem);
GUI_SetColor(GUI_BLACK);
GUI_SetColor(GUI_BLACK);
for(uint32_t i=0; i<100; i++){
for
(
uint32_t
i=0; i<100; i++){
GUI_DrawPixel(i, i);
GUI_DrawPixel(i, i);
}
}
GUI_MEMDEV_CopyToLCD(hMem);
GUI_MEMDEV_CopyToLCD(hMem);
GUI_MEMDEV_Delete(hMem);
GUI_MEMDEV_Delete(hMem);
GUI_MEMDEV_Select(0);
GUI_MEMDEV_Select(0);
break;
break
;
default:
default
:
WM_DefaultProc(pMsg);
WM_DefaultProc(pMsg);
break;
break
;
}
}
}
}
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
void
cbID_SCREEN_00(
WM_MESSAGE
* pMsg) {
WM_HWIN  hWin;
WM_HWIN  hWin;
switch (pMsg->MsgId) {
switch
(pMsg->
MsgId
) {
case WM_INIT_DIALOG:
case
WM_INIT_DIALOG:
hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);
hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);
WM_SetStayOnTop(hWin, 1);
WM_SetStayOnTop(hWin, 1);
break;
break
;
}
}
}
}
To learn more about emWin and AppWizard, please find the links below.
https://www.youtube.com/@SeggerMicro/videos
https://www.segger.com/downloads/emwin/UM03001
Suitable Products
RA Family
Go to Japanese
Go to Japanese","['data/categories/ra_family/ra_and_fsp_technical_articles/d5835ab1490b2c4dd0539f7090b90aff/images/6c24640ee16991f913ed6e286d29d184.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d5835ab1490b2c4dd0539f7090b90aff/images/81cda652f39c36b27687d99fc0800879.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d5835ab1490b2c4dd0539f7090b90aff/images/a5f61e62dd68924d032f0d24306e41e6.jpg']",[],"['|  |\n|  |\n| void cbID_SCREEN_00(WM_MESSAGE * pMsg) {\n  WM_HWIN  hWin;\n  int      Id, NCode;\n    switch (pMsg->MsgId) {\n      case WM_NOTIFY_PARENT:\n      Id = WM_GetId(pMsg->hWinSrc);\n      NCode = pMsg->Data.v;\n        switch(Id) {\n        case ID_BUTTON_00:\n            switch(NCode){\n              case WM_NOTIFICATION_CLICKED:\n                hWin = WM_GetDialogItem(pMsg->hWin, ID_TEXT_00);\n                TEXT_SetText(hWin, ""Success"");\n              break;\n            }\n            break;\n      }\n      break;\ndefault:\n      //WM_DefaultProc(); --> ”Screen” callback MUST not have default function handler\n      break;  }\n} |', '|  |\n|  |\n| void cbID_SCREEN_00(WM_MESSAGE * pMsg) {\n  WM_HWIN  hWin;\n  int      Id, NCode;\n    switch (pMsg->MsgId) {\n    case WM_INIT_DIALOG:\n        hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->hWin, WM_CF_SHOW, 0, GUI_ID_TEXT0, ""HI"");\n      break;\n      case WM_NOTIFY_PARENT:\n      Id = WM_GetId(pMsg->hWinSrc);\n      NCode = pMsg->Data.v;\n        switch(Id) {\n        case ID_BUTTON_00:\n            switch(NCode){\n              case WM_NOTIFICATION_CLICKED:\n                hWin = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);\n                TEXT_SetText(hWin, ""Success"");\n              break;\n            }\n            break;\n      }\n      break;\n    default:\n      //WM_DefaultProc(); --> ”Screen” callback MUST not have default function handler\n      break;\n  }\n} |', '|  |\n|  |\n| void external_irq_callback (void)\n{\nWM_HWIN hWin;\nWM_HWIN hItem;\n    hWin = WM_GetActiveWindow();\n  hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);\n  WIDGET_SetFocusable(hItem,1);\n  WM_SetFocus(hItem);\n  GUI_StoreKeyMsg(GUI_KEY_ENTER, 1); /* Pressed */\n  GUI_StoreKeyMsg(GUI_KEY_ENTER, 0); /* Release */\n} |', '|  |\n|  |\n| GUI_PID_STATE swipe_state;\nvoid external_irq_callback (void)\n{\nswipe_state.x = x_position;\nswipe_state.y = y_position;\nswipe_state.Pressed = 1;\n  GUI_PID_StoreState(&swipe_state);\n  x_position += x_position_increment;\n  if(x_position >= x_position_max){\n    swipe_state.Pressed = 0;\n    GUI_PID_StoreState(&swipe_state);\n}\n} |', '|  |\n|  |\n| static void _cbTopWin(WM_MESSAGE * pMsg) {\nGUI_MEMDEV_Handle hMem;\n    switch (pMsg->MsgId) {\n    case WM_PAINT:\n      hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);\n      GUI_MEMDEV_Select(hMem);\n      GUI_SetColor(GUI_BLACK);\n      for(uint32_t i=0; i<100; i++){\n        GUI_DrawPixel(i, i);\n      }\n      GUI_MEMDEV_CopyToLCD(hMem);\n      GUI_MEMDEV_Delete(hMem);\n      GUI_MEMDEV_Select(0);\n      break;\n    default:\n      WM_DefaultProc(pMsg);\n      break;\n  }\n}\n  void cbID_SCREEN_00(WM_MESSAGE * pMsg) {\n  WM_HWIN  hWin;\n    switch (pMsg->MsgId) {\n    case WM_INIT_DIALOG:\n      hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);\n      WM_SetStayOnTop(hWin, 1);\n      break;\n}\n} |', '|  |\n|  |\n| RA Family |']","{'title': 'RA Family : Custom user code integration in AppWizard emWin project', 'url': 'https://en-support.renesas.com/knowledgeBase/20775903', 'last_updated': '2022-06-12', 'extracted_at': '2025-03-08T23:12:56.643610'}","Issue AppWizard is the Segger emWin provided PC software that makes GUI building and embedded software programming easier for developers. Sometimes, what you want to achieve cannot be all done by AppWizard, so changes need to be made at the source code level with emWin API. Description There are two types of emWin APIs, one is AppWizard APIs and the other is conventional emWin APIs. AppWizard APIs and conventional emWin APIs generally work the same but AppWizard APIs are a more general form that can be used all across the objects. Since some AppWizard APIs are still undocumented, we will use conventional emWin API in this document. AppWizard APIs are listed in AppWizard.h Core emWin APIs are listed in GUI.h and WM.h Widgets emWin APIs are listed in each widget header files like TEXT.h, BUTTON.h, ROTARY.h, and so on. Answers Change TEXT when button is pressed (TEXT moves along when screen swipe) If you have a TEXT widget that does not know what to print out at build time but make up a word or sentence at runtime when BUTTON is pressed, then the text in TEXT widget can be changed dynamically with the following code. The figures below show that the text of TEXT changes when the button is pressed, and the position of TEXT also changes when the screen is swiped. If you have TEXT widget made by AppWizard. void cbIDSCREEN00(WMMESSAGE  pMsg)  WMHWIN hWin; int Id, NCode; switch (pMsg-MsgId)  case WMNOTIFYPARENT Id  WMGetId(pMsg-hWinSrc); NCode  pMsg-Data.v; switch(Id)  case IDBUTTON00 switch(NCode) case WMNOTIFICATIONCLICKED hWin  WMGetDialogItem(pMsg-hWin, IDTEXT00); TEXTSetText(hWin, ""Success""); break;  break;  break; default //WMDefaultProc(); -- Screen callback MUST not have default function handler break;   If you dont have TEXT widget made by AppWizard. case WMINITDIALOG hWin  TEXTCreateEx(5, 5, 100, 100, pMsg-hWin, WMCFSHOW, 0, GUIIDTEXT0, ""HI""); hWin  WMGetDialogItem(pMsg-hWin, GUIIDTEXT0); default  GUI user interface There is no direct user interface APIs, for example, for a BUTTON widget to change from unpressed to pressed state. The only way to change the BUTTON to the pressed state is to deliver a keyboard or PID message to the BUTTON, and the message to be processed in a callback function. Keyboard input is delivered in GUIStoreKeyMsg(), and PID input is delivered in GUIPIDStoreState(). The example below shows how to make a push button IRQ interrupt act like the Enter key was pressed on BUTTON. Please note that BUTTON widget reacts to keyboard input differently than PID input. For example, keyboard Enter press on BUTTON widget generates both press and release messages in turn at once. void externalirqcallback (void)  WMHWIN hWin; WMHWIN hItem; hWin  WMGetActiveWindow(); hItem  WMGetDialogItem(hWin, IDBUTTON00); WIDGETSetFocusable(hItem,1); WMSetFocus(hItem); GUIStoreKeyMsg(GUIKEYENTER, 1); / Pressed / GUIStoreKeyMsg(GUIKEYENTER, 0); / Release / It would be also possible to make a button press act like touch/mouse swipe. GUIPIDSTATE swipestate; swipestate.x  xposition; swipestate.y  yposition; swipestate.Pressed  1; GUIPIDStoreState(swipestate); xposition  xpositionincrement; if(xposition  xpositionmax) swipestate.Pressed  0; GUIPIDStoreState(swipestate); Custom drawing on top If you need to do some custom drawing on top and stay on top, you can make a child window of WMHBKWIN and set the StayOnTop flag. A window is created with the given x, y coordinate and size, and a custom user callback function pointer. In the callback function, WMPAINT is where the user is allowed to do some custom drawing. MEMDEV is a temporary drawing place used for anti-flicker, image decompression, scaling  rotating, animation, and so on. For more details on MEMDEV, please refer to the emWin manual. The example below draws one line from (0,0) to (100,100) and stays on top during/after screen swiping. static void cbTopWin(WMMESSAGE  pMsg)  GUIMEMDEVHandle hMem; case WMPAINT hMem  GUIMEMDEVCreateFixed(0, 0, 100, 100, GUIMEMDEVHASTRANS, GUIMEMDEVAPILIST32, GUICOLORCONV888); GUIMEMDEVSelect(hMem); GUISetColor(GUIBLACK); for(uint32t i0; i100; i) GUIDrawPixel(i, i); GUIMEMDEVCopyToLCD(hMem); GUIMEMDEVDelete(hMem); GUIMEMDEVSelect(0); WMDefaultProc(pMsg); void cbIDSCREEN00(WMMESSAGE  pMsg)  hWin  WMCreateWindowAsChild(0, 0, 100, 100, WMHBKWIN, (WMCFHASTRANSWMCFSHOW), cbTopWin, 0); WMSetStayOnTop(hWin, 1); To learn more about emWin and AppWizard, please find the links below. https//www.youtube.com/SeggerMicro/videos https//www.segger.com/downloads/emwin/UM03001 Suitable Products RA Family If you have TEXT widget made by AppWizard. void cbIDSCREEN00( WMMESSAGE  pMsg)  WMHWIN hWin; int Id, NCode; int Id, NCode; switch (pMsg-MsgId)  switch (pMsg- MsgId )  case WMNOTIFYPARENT case WMNOTIFYPARENT Id  WMGetId(pMsg-hWinSrc); Id  WMGetId(pMsg- hWinSrc ); NCode  pMsg-Data.v; NCode  pMsg- Data . v ; switch(Id)  (Id)  case IDBUTTON00 IDBUTTON00 switch(NCode) (NCode) case WMNOTIFICATIONCLICKED WMNOTIFICATIONCLICKED hWin  WMGetDialogItem(pMsg-hWin, IDTEXT00); hWin  WMGetDialogItem(pMsg- hWin , IDTEXT00); TEXTSetText(hWin, ""Success""); TEXTSetText(hWin, ""Success"" break; break default  //WMDefaultProc(); -- Screen callback MUST not have default function handler //WMDefaultProc(); -- Screen callback MUST not have default function handler break;  ;  If you dont have TEXT widget made by AppWizard. case WMINITDIALOG WMINITDIALOG hWin  TEXTCreateEx(5, 5, 100, 100, pMsg-hWin, WMCFSHOW, 0, GUIIDTEXT0, ""HI""); hWin  TEXTCreateEx(5, 5, 100, 100, pMsg- , WMCFSHOW, 0, GUIIDTEXT0, ""HI"" hWin  WMGetDialogItem(pMsg-hWin, GUIIDTEXT0); , GUIIDTEXT0); GUI user interface externalirqcallback ( ) hWin  WMGetActiveWindow(); hItem  WMGetDialogItem(hWin, IDBUTTON00); WIDGETSetFocusable(hItem,1); WMSetFocus(hItem); GUIStoreKeyMsg(GUIKEYENTER, 1); / Pressed / GUIStoreKeyMsg(GUIKEYENTER, 1); / Pressed / GUIStoreKeyMsg(GUIKEYENTER, 0); / Release / GUIStoreKeyMsg(GUIKEYENTER, 0); / Release / It would be also possible to make a button press act like touch/mouse swipe. GUIPIDSTATE swipestate; swipestate. x  xposition; y  yposition; Pressed  1; GUIPIDStoreState(swipestate); xposition  xpositionincrement; if(xposition  xpositionmax) if (xposition  xpositionmax) swipestate.Pressed  0;  0; Custom drawing on top static cbTopWin( GUIMEMDEVHandle hMem; case WMPAINT WMPAINT hMem  GUIMEMDEVCreateFixed(0, 0, 100, 100, GUIMEMDEVHASTRANS, GUIMEMDEVAPILIST32, GUICOLORCONV888); GUIMEMDEVSelect(hMem); GUISetColor(GUIBLACK); for(uint32t i0; i100; i) for ( uint32t i0; i100; i) GUIDrawPixel(i, i); GUIMEMDEVCopyToLCD(hMem); GUIMEMDEVDelete(hMem); GUIMEMDEVSelect(0); WMDefaultProc(pMsg); hWin  WMCreateWindowAsChild(0, 0, 100, 100, WMHBKWIN, (WMCFHASTRANSWMCFSHOW), cbTopWin, 0); WMSetStayOnTop(hWin, 1); To learn more about emWin and AppWizard, please find the links below. Go to Japanese","['The image presents a sequence of three screenshots from an application, each with a red arrow pointing to the next one. The screenshots are labeled ""AppWizard"" and feature a green background with a water droplet and a button.\n\n*   **First Screenshot:**\n    *   The first screenshot displays a green background with a water droplet and a button.\n    *   The button is labeled ""Test"" and has a gray color.\n    *   There is no text or other elements in the screenshot.\n*   **Second Screenshot:**\n    *   The second screenshot shows the same green background with a water droplet and a button.\n    *   The button is now labeled ""Success"" and has a gray color.\n    *   There is no text or other elements in the screenshot.\n*   **Third Screenshot:**\n    *   The third screenshot displays the same green background with a water droplet and a button.\n    *   The button is still labeled ""Success"" and has a gray color.\n    *   There is no text or other elements in the screenshot.\n\nIn summary, the image shows a sequence of three screenshots from an application, each with a red arrow pointing to the next one. The screenshots feature a green background with a water droplet and a button, with the button\'s label changing from ""Test"" to ""Success"" between the first and second screenshots.', 'The image displays a table with two columns and three rows, titled ""6.2.5.4 Keyboard reaction"" in black text at the top. The first column is labeled ""Key"" and the second column is labeled ""Reaction"". \n\nThe first row of the table contains the key ""GUI_KEY_ENTER"" and the reaction ""If the key is pressed, the BUTTON reacts as it has been pressed and immediately released."" The second row contains the key ""GUI_KEY_SPACE"" and the reaction ""If the key is pressed, the BUTTON state changes to pressed. If the keys is released, the BUTTON state changes to unpressed.""\n\nThe background of the image is white, with a thin black border around the table. The overall design suggests that this is a screenshot from a technical manual or instructional guide, likely used to explain how a specific keyboard reaction works.']"
d28631ef91309bdcdab1f7dd0b4a008c,"The below description applies to AC 6.16 and earlier. Refer to the companion post for AC 6.17 here: https://en-support.renesas.com/knowledgeBase/20370421
e2 studio does not include the ARM Compiler 6 (AC6) toolchain by default.
Below are the steps for integrating AC6 into e2 studio and creating an RA project with the toolchain.
Note:
Steps 1 through 8 describe the process for integrating ARM Compiler 6 into e2 studio.
9. When creating a new RA C/C++ project, select ARM Compiler 6 included in the Toolchains section.","['data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/232ddb68ddc5fe243d3439f6e84bed45.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/0f2b051816dad05fe9785a26b8d466f7.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/9df5102781467045e2a2847ba4b6a0ea.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/bf7123f9a9bd52008ba75969136ddbb4.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/bdbe3da6ef764cad9bc33441f64c3fe9.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/5b34313a8ed1a3089b78a13673ac61cd.png']",[],[],"{'title': 'Creating an RA Project with ARM Compiler 6.16 and earlier in e2 studio', 'url': 'https://en-support.renesas.com/knowledgeBase/19375553', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:19.126301'}","The below description applies to AC 6.16 and earlier. Refer to the companion post for AC 6.17 here https//en-support.renesas.com/knowledgeBase/20370421 e2 studio does not include the ARM Compiler 6 (AC6) toolchain by default. Below are the steps for integrating AC6 into e2 studio and creating an RA project with the toolchain. Note Steps 1 through 8 describe the process for integrating ARM Compiler 6 into e2 studio. 9. When creating a new RA C/C project, select ARM Compiler 6 included in the Toolchains section.","['The image shows a screenshot of a computer window with a list of options on the left and a text box on the right. The window is titled ""Preferences"" and has a blue logo in the top-left corner.\n\n*   **Left Side:**\n    *   A list of options is displayed, including:\n        *   Library Hover\n        *   LinkerScript\n        *   MCU\n        *   Mylyn\n        *   Oomph\n        *   Remote Development\n        *   Renesas QE\n        *   Run/Debug\n        *   Scripting\n        *   Team\n        *   Terminal\n        *   Toolchains\n        *   Tracing\n        *   Validation\n        *   XML\n*   **Right Side:**\n    *   A text box is displayed with the title ""Toolchains"" and a subheading ""Add/Remove toolchains"".\n    *   A button labeled ""Add..."" is highlighted in red, indicating that it is the current focus.\n    *   A text box below the button is labeled ""Name:"" and has a placeholder text ""No Toolchain Selected"".\n    *   A button labeled ""Apply"" is located at the bottom of the window.\n*   **Bottom:**\n    *   A row of buttons is displayed, including:\n        *   Apply and Close\n        *   Cancel\n\nThe image appears to be a screenshot of a computer window for managing toolchains in an Integrated Development Environment (IDE). The user is currently focused on adding a new toolchain, as indicated by the highlighted ""Add..."" button.', 'The image shows a screenshot of a computer window with the title ""Add a new Toolchain"" at the top. The window is divided into two sections: the top section contains text and buttons, while the bottom section has a large white space.\n\n*   **Top Section:**\n    *   The title ""Add a new Toolchain"" is displayed in black text at the top of the window.\n    *   Below the title, there is a message that reads, ""Select Toolchain Path."" This message is followed by a text box where users can enter the path to the toolchain\'s binaries directory.\n    *   To the right of the text box, there is a button labeled ""Browse..."" in blue text. This button allows users to navigate to the desired directory and select it.\n    *   Below the text box, there is a link that says, ""Download toolchains from ds.arm.com"" in blue text. This link provides an alternative way for users to obtain the toolchain.\n*   **Bottom Section:**\n    *   The bottom section of the window contains three buttons: ""Back,"" ""Next,"" and ""Finish.""\n    *   The ""Back"" button is located on the left side of the window and is gray with a white arrow pointing to the left.\n    *   The ""Next"" button is located in the middle of the window and is red with a white arrow pointing to the right.\n    *   The ""Finish"" button is located on the right side of the window and is gray with a white checkmark.\n\nOverall, the image shows a window that guides users through the process of adding a new toolchain to their system. The window provides a clear and concise interface for users to select the path to the toolchain\'s binaries directory and download the toolchain if needed.', 'The image shows a screenshot of a Windows dialog box titled ""Discovered Toolchain Information"". The dialog box is divided into two sections: the top section displays the title and a list of toolchain components, while the bottom section contains buttons for navigating through the dialog box.\n\n**Top Section:**\n\n*   **Title:** ""Discovered Toolchain Information""\n*   **List of Toolchain Components:**\n    *   **Compiler:** armclang.exe\n    *   **Assembler:** armasm.exe\n    *   **Linker:** armlink.exe\n    *   **Archiver:** armar.exe\n    *   **Image Converter:** fromelf.exe\n\n**Bottom Section:**\n\n*   **Buttons:**\n    *   **Back:** A blue button with a left-pointing arrow\n    *   **Next:** A gray button with a right-pointing arrow\n    *   **Finish:** A red button with the word ""Finish"" in black text\n\nThe dialog box appears to be part of a larger process, possibly related to setting up a development environment or configuring a toolchain. The user is prompted to review the discovered toolchain information and either click ""Finish"" to complete the process or navigate back to make changes.', 'The image shows a screenshot of a computer window with a list of options on the left side and a text box on the right side. The window is titled ""Preferences"" and has a blue logo in the top-left corner.\n\n*   **Left Side:**\n    *   A list of options is displayed on the left side of the window.\n    *   The options are:\n        *   Library Hover\n        *   LinkerScript\n        *   MCU\n        *   Mylyn\n        *   Oomph\n        *   Remote Development\n        *   Renesas QE\n        *   Run/Debug\n        *   Scripting\n        *   Team\n        *   Terminal\n        *   Toolchains\n        *   Tracing\n        *   Validation\n        *   XML\n*   **Right Side:**\n    *   A text box is displayed on the right side of the window.\n    *   The text box has a label that says ""Add/Remove toolchains"".\n    *   There is a dropdown menu below the label with the following options:\n        *   Name\n        *   ARM Compiler 6.14\n    *   Below the dropdown menu, there is a text box where you can enter a name for the toolchain.\n    *   Next to the text box, there is a button that says ""Apply and Close"".\n*   **Bottom of the Window:**\n    *   There are two buttons at the bottom of the window: ""Apply"" and ""Cancel"".\n\nThe image shows a window with a list of options on the left side and a text box on the right side. The user can select an option from the list and enter a name for the toolchain in the text box. The user can then click the ""Apply and Close"" button to apply the changes and close the window.', 'The image shows a pop-up window with the title ""Confirm Restart Eclipse"" and a question mark icon in the top-left corner. The window has a gray background and black text.\n\n*   **Title and Icon**\n    *   The title is ""Confirm Restart Eclipse"" and is displayed in black text at the top of the window.\n    *   A question mark icon is located in the top-left corner of the window.\n*   **Message**\n    *   The message reads, ""Eclipse must be restarted in order for the changes to be visible.""\n    *   It is displayed in black text below the title and icon.\n*   **Buttons**\n    *   There are two buttons at the bottom of the window: ""Restart Eclipse"" and ""Not Now.""\n    *   The ""Restart Eclipse"" button is highlighted in red, indicating that it is the default action.\n    *   The ""Not Now"" button is grayed out, suggesting that it is not the recommended option.\n*   **Background**\n    *   The background of the window is a light gray color.\n\nOverall, the image appears to be a confirmation prompt for restarting the Eclipse IDE, which is a popular integrated development environment (IDE) for Java developers. The prompt indicates that changes made to the project will not be visible until the IDE is restarted.', 'The image shows a screenshot of a project configuration window in an Integrated Development Environment (IDE). The window is titled ""e2 studio - Project Configuration (RA C Executable Project)"" and has a white background with black text.\n\n*   **Title**\n    *   The title of the window is ""e2 studio - Project Configuration (RA C Executable Project)"".\n*   **Project Name**\n    *   The project name is ""ARM_Compile_Test"".\n*   **Toolchains**\n    *   The toolchain selected is ""GNU ARM Embedded ARM Compiler 6.14"".\n*   **Use Default Location**\n    *   The checkbox for ""Use default location"" is unchecked.\n\nThe window appears to be a configuration window for a project in an IDE, where the user can specify the project name, toolchain, and other settings. The selected toolchain is GNU ARM Embedded ARM Compiler 6.14, which suggests that the project is related to embedded systems development using ARM processors.']"
4d6dbe65e1eb7337da226e43afacc605,"The schematics for the EK-RA2L1 is missing some connections, inserted below in red and green. The connections are on the board, juts not included in the schematic. These will be updated in the next revision of the schematic.
The schematics for the EK-RA2L1 is missing some connections, inserted below in red and green. The connections are on the board, juts not included in the schematic. These will be updated in the next revision of the schematic.
The schematics for the EK-RA2L1 is missing some connections, inserted below in red and green. The connections are on the board, juts not included in the schematic. These will be updated in the next revision of the schematic.
Suitable Products
Suitable Products
RA/FSP
Source:   Ticket 349162",['data/categories/ra_family/ra_and_fsp_technical_articles/4d6dbe65e1eb7337da226e43afacc605/images/083c4e170953cc97124aa6a22dbfa4fa.png'],[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'EK-RA2L1 Schematic Missing Connections', 'url': 'https://en-support.renesas.com/knowledgeBase/20474167', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:34.765892'}","The schematics for the EK-RA2L1 is missing some connections, inserted below in red and green. The connections are on the board, juts not included in the schematic. These will be updated in the next revision of the schematic. Suitable Products RA/FSP Source Ticket 349162","['The image depicts a technical diagram for a JTAG connector, which is a standard interface used for debugging and testing electronic devices. The diagram is presented in black and white, with various components and connections labeled with numbers and abbreviations.\n\n**Key Components:**\n\n*   **JTAG Connector:** The central component of the diagram, representing the JTAG connector.\n*   **GND Detect:** A section of the diagram that appears to be related to ground detection or signal processing.\n*   **Jumpers Trace Cut:** A section of the diagram that shows jumpers and trace cuts, which are used to connect or disconnect specific signals or paths.\n*   **Exposed Pad:** A section of the diagram that shows the exposed pad, which is a metal pad on the bottom of the device that provides a ground connection.\n*   **5V USB DBG:** A section of the diagram that shows the 5V USB debugging interface, which is used to connect the device to a computer for debugging purposes.\n*   **Yellow LED5:** A section of the diagram that shows the yellow LED5, which is likely used for indicating specific states or conditions.\n\n**Connections and Signals:**\n\n*   **3.3V:** A power supply voltage of 3.3V is connected to various components in the diagram.\n*   **GND:** Ground connections are shown throughout the diagram, indicating that the device is connected to a common ground reference.\n*   **R23:** A resistor labeled R23 is connected to the exposed pad and the 5V USB debugging interface.\n*   **C57:** A capacitor labeled C57 is connected to the exposed pad and the 5V USB debugging interface.\n*   **P110:** A pin labeled P110 is connected to the JTAG connector and the GND detect section.\n*   **P109:** A pin labeled P109 is connected to the JTAG connector and the GND detect section.\n*   **P108:** A pin labeled P108 is connected to the JTAG connector and the GND detect section.\n*   **P107:** A pin labeled P107 is connected to the JTAG connector and the GND detect section.\n*   **P106:** A pin labeled P106 is connected to the JTAG connector and the GND detect section.\n*   **P105:** A pin labeled P105 is connected to the JTAG connector and the GND detect section.\n*   **P104:** A pin labeled P104 is connected to the JTAG connector and the GND detect section.\n*   **P103:** A pin labeled P103 is connected to the JTAG connector and the GND detect section.\n*   **P102:** A pin labeled P102 is connected to the JTAG connector and the GND detect section.\n*   **P101:** A pin labeled P101 is connected to the JTAG connector and the GND detect section.\n*   **P100:** A pin labeled P100 is connected to the JTAG connector and the GND detect section.\n*   **P99:** A pin labeled P99 is connected to the JTAG connector and the GND detect section.\n*   **P98:** A pin labeled P98 is connected to the JTAG connector and the GND detect section.\n*   **P97:** A pin labeled P97 is connected to the JTAG connector and the GND detect section.\n*   **P96:** A pin labeled P96 is connected to the JTAG connector and the GND detect section.\n*   **P95:** A pin labeled P95 is connected to the JTAG connector and the GND detect section.\n*   **P94:** A pin labeled P94 is connected to the JTAG connector and the GND detect section.\n*   **P93:** A pin labeled P93 is connected to the JTAG connector and the GND detect section.\n*   **P92:** A pin labeled P92 is connected to the JTAG connector and the GND detect section.\n*   **P91:** A pin labeled P91 is connected to the JTAG connector and the GND detect section.\n*   **P90:** A pin labeled P90 is connected to the JTAG connector and the GND detect section.\n*   **P89:** A pin labeled P89 is connected to the JTAG connector and the GND detect section.\n*   **P88:** A pin labeled P88 is connected to the JTAG connector and the GND detect section.\n*   **P87:** A pin labeled P87 is connected to the JTAG connector and the GND detect section.\n*   **P86:** A pin labeled P86 is connected to the JTAG connector and the GND detect section.\n*   **P85:** A pin labeled P85 is connected to the JTAG connector and the GND detect section.\n*   **P84:** A pin labeled P84 is connected to the JTAG connector and the GND detect section.\n*   **P83:** A pin labeled P83 is connected to the JTAG connector and the GND detect section.\n*   **P82:** A pin labeled P82 is connected to the JTAG connector and the GND detect section.\n*   **P81:** A pin labeled P81 is connected to the JTAG connector and the GND detect section.\n*   **P80:** A pin labeled P80 is connected to the JTAG connector and the GND detect section.\n*   **P79:** A pin labeled P79 is connected to the JTAG connector and the GND detect section.\n*   **P78:** A pin labeled P78 is connected to the JTAG connector and the GND detect section.\n*   **P77:** A pin labeled P77 is connected to the JTAG connector and the GND detect section.\n*   **P76:** A pin labeled P76 is connected to the JTAG connector and the GND detect section.\n*   **P75:** A pin labeled P75 is connected to the JTAG connector and the GND detect section.\n*   **P74:** A pin labeled P74 is connected to the JTAG connector and the GND detect section.\n*   **P73:** A pin labeled P73 is connected to the JTAG connector and the GND detect section.\n*   **P72:** A pin labeled P72 is connected to the JTAG connector and the GND detect section.\n*   **P71:** A pin labeled P71 is connected to the JTAG connector and the GND detect section.\n*   **P70:** A pin labeled P70 is connected to the JTAG connector and the GND detect section.\n*   **P69:** A pin labeled P69 is connected to the JTAG connector and the GND detect section.\n*   **P68:** A pin labeled P68 is connected to the JTAG connector and the GND detect section.\n*   **P67:** A pin labeled P67 is connected to the JTAG connector and the GND detect section.\n*   **P66:** A pin labeled P66 is connected to the JTAG connector and the GND detect section.\n*   **P65:** A pin labeled P65 is connected to the JTAG connector and the GND detect section.\n*   **P64:** A pin labeled P64 is connected to the JTAG connector and the GND detect section.\n*   **P63:** A pin labeled P63 is connected to the JTAG connector and the GND detect section.\n*   **P62:** A pin labeled P62 is connected to the JTAG connector and the GND detect section.\n*   **P61:** A pin labeled P61 is connected to the JTAG connector and the GND detect section.\n*   **P60:** A pin labeled P60 is connected to the JTAG connector and the GND detect section.\n*   **P59:** A pin labeled P59 is connected to the JTAG connector and the GND detect section.\n*   **P58:** A pin labeled P58 is connected to the JTAG connector and the GND detect section.\n*   **P57:** A pin labeled P57 is connected to the JTAG connector and the GND detect section.\n*   **P56:** A pin labeled P56 is connected to the JTAG connector and the GND detect section.\n*   **P55:** A pin labeled P55 is connected to the JTAG connector and the GND detect section.\n*   **P54:** A pin labeled P54 is connected to the JTAG connector and the GND detect section.\n*   **P53:** A pin labeled P53 is connected to the JTAG connector and the GND detect section.\n*   **P52:** A pin labeled P52 is connected to the JTAG connector and the GND detect section.\n*   **P51:** A pin labeled P51 is connected to the JTAG connector and the GND detect section.\n*   **P50:** A pin labeled P50 is connected to the JTAG connector and the GND detect section.\n*   **P49:** A pin labeled P49 is connected to the JTAG connector and the GND detect section.\n*   **P48:** A pin labeled P48 is connected to the JTAG connector and the GND detect section.\n*   **P47:** A pin labeled P47 is connected to the JTAG connector and the GND detect section.\n*   **P46:** A pin labeled P46 is connected to the JTAG connector and the GND detect section.\n*   **P45:** A pin labeled P45 is connected to the JTAG connector and the GND detect section.\n*   **P44:** A pin labeled P44 is connected to the JTAG connector and the GND detect section.\n*   **P43:** A pin labeled P43 is connected to the JTAG connector and the GND detect section.\n*   **P42:** A pin labeled P42 is connected to the JTAG connector and the GND detect section.\n*   **P41:** A pin labeled P41 is connected to the JTAG connector and the GND detect section.\n*   **P40:** A pin labeled P40 is connected to the JTAG connector and the GND detect section.\n*   **P39:** A pin labeled P39 is connected to the JTAG connector and the GND detect section.\n*   **P38:** A pin labeled P38 is connected to the JTAG connector and the GND detect section.\n*   **P37:** A pin labeled P37 is connected to the JTAG connector and the GND detect section.\n*   **P36:** A pin labeled P36 is connected to the JTAG connector and the GND detect section.\n*   **P35:** A pin labeled P35 is connected to the JTAG connector and the GND detect section.\n*   **P34:** A pin labeled P34 is connected to the JTAG connector and the GND detect section.\n*   **P33:** A pin labeled P33 is connected to the JTAG connector and the GND detect section.\n*   **P32:** A pin labeled P32 is connected to the JTAG connector and the GND detect section.\n*   **P31:** A pin labeled P31 is connected to the JTAG connector and the GND detect section.\n*   **P30:** A pin labeled P30 is connected to the JTAG connector and the GND detect section.\n*   **P29:** A pin labeled P29 is connected to the JTAG connector and the GND detect section.\n*   **P28:** A pin labeled P28 is connected to the JTAG connector and the GND detect section.\n*   **P27:** A pin labeled P27 is connected to the JTAG connector and the GND detect section.\n*   **P26:** A pin labeled P26 is connected to the JTAG connector and the GND detect section.\n*   **P25:** A pin labeled P25 is connected to the JTAG connector and the GND detect section.\n*   **P24:** A pin labeled P24 is connected to the JTAG connector and the GND detect section.\n*   **P23:** A pin labeled P23 is connected to the JTAG connector and the GND detect section.\n*   **P22:** A pin labeled P22 is connected to the JTAG connector and the GND detect section.\n*   **P21:** A pin labeled P21 is connected to the JTAG connector and the GND detect section.\n*   **P20:** A pin labeled P20 is connected to the JTAG connector and the GND detect section.\n*   **P19:** A pin labeled P19 is connected to the JTAG connector and the GND detect section.\n*   **P18:** A pin labeled P18 is connected to the JTAG connector and the GND detect section.\n*   **P17:** A pin labeled P17 is connected to the JTAG connector and the GND detect section.\n*   **P16:** A pin labeled P16 is connected to the JTAG connector and the GND detect section.\n*   **P15:** A pin labeled P15 is connected to the JTAG connector and the GND detect section.\n*   **P14:** A pin labeled P14 is connected to the JTAG connector and the GND detect section.\n*   **P13:** A pin labeled P13 is connected to the JTAG connector and the GND detect section.\n*   **P12:** A pin labeled P12 is connected to the JTAG connector and the GND detect section.\n*   **P11:** A pin labeled P11 is connected to the JTAG connector and the GND detect section.\n*   **P10:** A pin labeled P10 is connected to the JTAG connector and the GND detect section.\n*   **P9:** A pin labeled P9 is connected to the JTAG connector and the GND detect section.\n*   **P8:** A pin labeled P8 is connected to the JTAG connector and the GND detect section.\n*   **P7:** A pin labeled P7 is connected to the JTAG connector and the GND detect section.\n*   **P6:** A pin labeled P6 is connected to the JTAG connector and the GND detect section.\n*   **P5:** A pin labeled P5 is connected to the JTAG connector and the GND detect section.\n*   **P4:** A pin labeled P4 is connected to the JTAG connector and the GND detect section.\n*   **P3:** A pin labeled P3 is connected to the JTAG connector and the GND detect section.\n*   **P2:** A pin labeled P2 is connected to the JTAG connector and the GND detect section.\n*   **P1:** A pin labeled P1 is connected to the JTAG connector and the GND detect section.\n*   **P0:** A pin labeled P0 is connected to the JTAG connector and the GND detect section.\n\n**Summary:**\n\nThe diagram shows a complex electronic circuit with various components and connections. The JTAG connector is the central component, and it is connected to several other components, including the GND detect section, jumpers, and trace cuts. The diagram also shows several power supply voltages, including 3.3V and 5V, as well as ground connections. The exposed pad is also shown, which provides a ground connection. The diagram appears to be a technical drawing for a specific electronic device or system, and it provides detailed information about the connections and components of the device.']"
936810f8e8d29da37300067c752b12ac,"It is probably best to disable the JLink from caching the dataflash when trying to work with flash debugging. With the debug session terminated, in the .jlink file in the top level directory of the e2studio project change:
CacheExcludeSize = 0
CacheExcludeAddr = 0
to
CacheExcludeSize = 0x2000
CacheExcludeAddr = 0x40100000
then save the file, and then start the debug session.
As an example, for the RA2L1 the data flash on the RA2L1 is not enabled at power on of the device, and isn't enabled until this line of code:
Before it is enabled, a read to the dataflash region will return 0 (as can be seen in the image above), after the dataflash is enabled, the actual contents will be visible:
Suitable Products
FSP
Suitable Products
FSP
Suitable Products
FSP
Source:   (19) Trouble reading values from data flash, reads all 0s - Forum - RA MCU - Renesas Community","['data/categories/ra_family/ra_and_fsp_technical_articles/936810f8e8d29da37300067c752b12ac/images/b28435b1d599d3a90c6d61a7e3a2ff01.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/936810f8e8d29da37300067c752b12ac/images/a4c210d2d1eda2a5d6505df5593cf115.png']",[],['|  |\n|  |\n| FSP |'],"{'title': 'RA Family: Disable J-Link Caching When Debugging Flash Issues in FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/20197204', 'last_updated': None, 'extracted_at': '2025-03-08T23:12:28.211890'}","It is probably best to disable the JLink from caching the dataflash when trying to work with flash debugging. With the debug session terminated, in the .jlink file in the top level directory of the e2studio project change CacheExcludeSize  0 CacheExcludeAddr  0 to CacheExcludeSize  0x2000 CacheExcludeAddr  0x40100000 then save the file, and then start the debug session. As an example, for the RA2L1 the data flash on the RA2L1 is not enabled at power on of the device, and isn't enabled until this line of code Before it is enabled, a read to the dataflash region will return 0 (as can be seen in the image above), after the dataflash is enabled, the actual contents will be visible Suitable Products FSP Source (19) Trouble reading values from data flash, reads all 0s - Forum - RA MCU - Renesas Community","['The image shows a screenshot of a computer program in a code editor, with a large window displaying lines of code in various colors. The code appears to be written in C# and is part of a larger project.\n\n*   **Code Editor Window**\n    *   The code editor window is the main focus of the image.\n    *   It displays a large amount of code in various colors, including blue, red, green, and black.\n    *   The code is organized into sections, with each section having its own set of comments and variables.\n    *   The code appears to be part of a larger project, with many different classes and methods.\n*   **Menu Bar**\n    *   The menu bar is located at the top of the image and contains several options for navigating the code.\n    *   The options include ""File"", ""Edit"", ""View"", ""Debug"", and ""Help"".\n    *   Each option has a dropdown menu with additional sub-options.\n*   **Toolbar**\n    *   The toolbar is located below the menu bar and contains several icons for common actions.\n    *   The icons include a ""New"" button, a ""Save"" button, a ""Compile"" button, and a ""Run"" button.\n    *   Each icon has a tooltip that describes its function.\n*   **Code Snippet**\n    *   The code snippet is a small section of code that is highlighted in the image.\n    *   It appears to be a method definition, with a return type and parameter list.\n    *   The code is written in a clear and concise manner, with proper indentation and spacing.\n*   **Console Output**\n    *   The console output is located at the bottom of the image and displays the results of running the code.\n    *   The output is a list of numbers and strings, which appear to be the result of a mathematical calculation.\n    *   The output is displayed in a fixed-width font, with each line of output separated by a newline character.\n\nOverall, the image shows a screenshot of a computer program in a code editor, with a large window displaying lines of code in various colors. The code appears to be part of a larger project, with many different classes and methods. The image also includes a menu bar, toolbar, code snippet, and console output, which provide additional context and information about the code.', 'The image shows a screenshot of a computer program in a code editor, with a large window displaying lines of code and a smaller window at the bottom showing a list of memory addresses and their corresponding values.\n\n*   The main window is divided into two sections: the top section displays the code, and the bottom section displays the memory addresses and their values.\n    *   The code is written in C++ and appears to be part of a larger program.\n    *   The code includes several functions, including `R_BSP_WarmStart`, `if (BSP_WARM_START_RESET == event)`, and `if (BSP_WARM_START_POST_C == event)`.\n    *   The code also includes several variables, such as `BSP_FEATURE_FLASH_LP_VERSION` and `R_FACI_LP->DFLCTL`.\n    *   The code uses various operators, including `if`, `else`, `for`, and `while`.\n*   The smaller window at the bottom of the screen displays a list of memory addresses and their corresponding values.\n    *   The memory addresses are listed in hexadecimal format, ranging from `0x40100000` to `0x40100050`.\n    *   The values associated with each memory address are also listed in hexadecimal format.\n    *   The values appear to be a mix of integers and strings.\n*   The background of the image is a light gray color, which helps to make the code and memory addresses stand out.\n*   The overall layout of the image is clean and organized, making it easy to read and understand the code and memory addresses.\n\nIn summary, the image shows a screenshot of a computer program in a code editor, with a large window displaying lines of code and a smaller window at the bottom showing a list of memory addresses and their corresponding values. The code appears to be part of a larger program and includes several functions and variables. The memory addresses and their values are listed in hexadecimal format, and the background of the image is a light gray color.']"
1f395323acb85fc02d0067c02e2ffdcd,"You can use FreeRTOS+FAT without FreeRTOS by following the below setup steps, which are also well described in RA FSP Documentation.
1.    Copy “ra/fsp/src/rm_freertos_plus_fat/FreeRTOSConfigMinimal.h” to one of your project include paths and rename it “FreeRTOSConfig.h”.
2.    Update the Malloc function to malloc and the Free function to free in the Common configuration of FreeRTOS+FAT as seen below.
 
3.    Implement the detection of media insertion because the media must be inserted before calling the RM_FREERTOS_PLUS_FAT_MediaInit(). 
a.    If the Block Media USB is used in the Bare Metal, the low-level USB driver does not pass the USB event to the block media framework through the internal “rm_block_media_usb_callback”. Therefore, user application needs to poll the R_USB_EventGet() function to obtain the status of USB media insertion.
b.    If the Block Media SDMMC is used, the media insertion event will be notified through the preassigned callback function of FreeRTOS+FAT Port. Therefore, user application can just wait for the event of RM_FREERTOS_PLUS_FAT_EVENT_MEDIA_INSERTED notified by the callback before starting the media initialization.
Sample Project – using FreeRTOS+FAT with Block Media on USB in a Bare Metal project
FSP version: 3.8.0
Used Kit: EK-RA6M3
Setup: Connect USB pendrive to J11, Connect J12 Pin1-Pin2, Remove jumper from J15.
   Suitable Products
You can use FreeRTOS+FAT without FreeRTOS by following the below setup steps, which are also well described in RA FSP Documentation.
1.    Copy “ra/fsp/src/rm_freertos_plus_fat/FreeRTOSConfigMinimal.h” to one of your project include paths and rename it “FreeRTOSConfig.h”.
2.    Update the Malloc function to malloc and the Free function to free in the Common configuration of FreeRTOS+FAT as seen below.
 
3.    Implement the detection of media insertion because the media must be inserted before calling the RM_FREERTOS_PLUS_FAT_MediaInit(). 
a.    If the Block Media USB is used in the Bare Metal, the low-level USB driver does not pass the USB event to the block media framework through the internal “rm_block_media_usb_callback”. Therefore, user application needs to poll the R_USB_EventGet() function to obtain the status of USB media insertion.
b.    If the Block Media SDMMC is used, the media insertion event will be notified through the preassigned callback function of FreeRTOS+FAT Port. Therefore, user application can just wait for the event of RM_FREERTOS_PLUS_FAT_EVENT_MEDIA_INSERTED notified by the callback before starting the media initialization.
RA FSP Documentation.
Sample Project – using FreeRTOS+FAT with Block Media on USB in a Bare Metal project
FSP version: 3.8.0
Used Kit: EK-RA6M3
Setup: Connect USB pendrive to J11, Connect J12 Pin1-Pin2, Remove jumper from J15.
Suitable Products
RA/FSP
Go to Japanese
Go to Japanese
Source:",['data/categories/ra_family/ra_and_fsp_technical_articles/1f395323acb85fc02d0067c02e2ffdcd/images/bd5f82dccf6a2eb827c53ee34f68d8a3.png'],[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'RA Family: Using FreeRTOS+FAT on a Bare Metal Project', 'url': 'https://en-support.renesas.com/knowledgeBase/20641575', 'last_updated': '2022-10-08', 'extracted_at': '2025-03-08T23:12:01.547413'}","You can use FreeRTOSFAT without FreeRTOS by following the below setup steps, which are also well described in RA FSP Documentation. 1. Copy ra/fsp/src/rmfreertosplusfat/FreeRTOSConfigMinimal.h to one of your project include paths and rename it FreeRTOSConfig.h. 2. Update the Malloc function to malloc and the Free function to free in the Common configuration of FreeRTOSFAT as seen below. 3. Implement the detection of media insertion because the media must be inserted before calling the RMFREERTOSPLUSFATMediaInit(). a. If the Block Media USB is used in the Bare Metal, the low-level USB driver does not pass the USB event to the block media framework through the internal rmblockmediausbcallback. Therefore, user application needs to poll the RUSBEventGet() function to obtain the status of USB media insertion. b. If the Block Media SDMMC is used, the media insertion event will be notified through the preassigned callback function of FreeRTOSFAT Port. Therefore, user application can just wait for the event of RMFREERTOSPLUSFATEVENTMEDIAINSERTED notified by the callback before starting the media initialization. Sample Project  using FreeRTOSFAT with Block Media on USB in a Bare Metal project FSP version 3.8.0 Used Kit EK-RA6M3 Setup Connect USB pendrive to J11, Connect J12 Pin1-Pin2, Remove jumper from J15. Suitable Products RA FSP Documentation. Suitable Products RA/FSP Go to Japanese Source","['The image shows a screenshot of a computer program\'s settings menu, with the title ""FreeRTOS+FAT"" at the top. The menu is organized into sections, including ""Property"", ""Common"", ""Memory Allocation"", and ""Logging"". Each section has a list of options, such as ""General"", ""Long Function Names"", ""Extra Options"", ""Malloc"", ""Free"", and ""Logging"".\n\nThe background of the image is a light gray color, with a darker gray bar at the top that contains the title and other navigation buttons. The overall design of the menu is clean and simple, with clear headings and concise descriptions for each option.\n\nThe image appears to be a screenshot of a software application that allows users to configure various settings for their system or device. The menu is likely used to customize the behavior of the application or device, and the options listed are specific to the FreeRTOS+FAT system.']"
4060b1f194bbcfc0aabe1abddc00c1ec,"Overview:
Some RA MCUs support both a Linear Mode and a Dual Bank mode. This feature is switchable by an option memory setting. The Dual Bank flash mode is the preferred choice when user firmware A in Bank0 and user firmware B in Bank1 must be built identically to run from the same flash memory address, or when a user firmware update (including a user bootloader) must be safely completed even in the event of a power failure, while a firmware update is underway. In addition, the Dual Bank mode supports BGO (Background operation, or so called RWW), allowing flash memory to be read/executed from the current bank even when a firmware update on the other bank is in progress.
The example provided below is a simple way to implement a firmware update in Dual Bank mode using Xmodem. Once all the firmware updates are complete, the ""Bank Swap"" function is used to swap the current running bank with the newly downloaded bank.
Hardware configuration
- EK-RA6M4 board (1MB flash MCU)
- Your own USB-UART adapter (TX: P411, RX: P410)
Flash memory configuration
- Dual bank mode (512 KB x 2 banks) is used.
- Each bank (Bank0, 1) is divided into user bootloader area and user application area as below.
- The user bootloader is always built at address 0 regardless of the bank number to download.
- The user application is always built at address 0x8000 (bootloader size = e.g., 32 Kbytes) regardless of the bank number to download.
- The size and location of user bootloader and application can be changed as user needs.
- Whether or not to have a user bootloader is user's choice.
Bank 0 (Block 0 to 21) memory in 1MB product
Bank 1 (Block 70 to 91) memory in 1MB product
Linker script configuration (both bootloader and application)
- In the linker script, two user-defined sections (.verinfo, .sizeinfo) are added immediately after the application interrupt vector (.application_vectors), so they are always placed at a fixed address locations regardless of user code modification.
- The size of the application interrupt vector (g_Vector_table[BSP_ICU_VECTOR_MAX_ENTRIES]) depends on the MCU series used, so please ensure that both the bootloader project and application project are built on the same MCU series.
- During the user application firmware post-build process, CRC32 is padded to the end of the user application firmware binary, and its (CRC32) location is pointed by “.sizeinfo”.
Caution with “bin” firmware and option memory
User firmware can be converted to .hex, .srec, or .bin file type format in e2 studio. However, when creating a bin file, care must be taken to ensure that the option memory is not unintentionally filled with garbage values or zero values. This is because some settings in option memory cannot be permanently changed once set. e2 studio's default linker script has many memory sections (e.g. .text, .data, option_setting_x, .data_flash, qspi_flash, etc.) spread over a wide address range. Therefore, the user binary output file will be over 1 Mbyte in size, but only user code/data sections are required unless you download it new to a virgin MCU. This can be easily achieved by checking only those two check boxes in e2 studio.
Please don't forget to program the MCU with .srec or .hex at least once with the option memory settings to change Linear Mode to Dual Bank mode.
Append CRC32 to end of “bin” file
As an example of the firmware integrity verification process, the “application_postbuild.bat” and “srec_cat.exe” files are added in the application project folder. The ""srec_cat.exe"" is free software available on the Internet that allows you to rearrange, reformat, and relocate input files into output file as well as CRC32 calculation. Current version of e2 studio “Post-build steps” runs before the “GNU Arm Cross Create Flash Image” which creates a .bin file, so the “Append CRC32” builder was added as an alternative. If all the build processes are completed successfully, another .bin file will be created that ends with “<original bin file>_crc.bin”, which is 4 bytes (CRC32) larger than the original .bin file.
Operation flow of the example projects
User bootloader
1. Program the board with the bootloader project. Use .srec (.hex) for option memory update.
2. The bootloader toggles the LED1 (Blue) on the board a number of times equal to the user bootloader’s own version.
3. When the S2 button is pressed, the bootloader checks the CRC32 of the user application firmware, and if the CRC32 is correct, it jumps to the user application as shown below.
4. If CRC32 is incorrect or an error occurs, the bootloader starts Xmodem task as shown below.
4-1. Press 1 and download the user bootloader .bin file to the opposite bank.
4-2. Press 2 and download the user application _crc.bin file to the opposite bank.
4-3. Press 0 to swap the banks.
4-4. Press 3 to reset the board.
User application
1. The application toggles the LED3 (Red) on the board a number of times equal to the user application’s own version.
2. When the S1 button is pressed, the application starts Xmodem task to download a new bootloader and application to the opposite bank.
3. After the Xmodem download is complete, the user can determine the bank swap and reset the MCU.
Tera Term setting
115200, 8bit, parity none, 1 stop bit, no hardware flow control.
To view the text properly, New-line setting for reception should be CR+LF as follows:
Suitable Products
RA
Some RA MCUs support both a Linear Mode and a Dual Bank mode. This feature is switchable by an option memory setting. The Dual Bank flash mode is the preferred choice when user firmware A in Bank0 and user firmware B in Bank1 must be built identically to run from the same flash memory address, or when a user firmware update (including a user bootloader) must be safely completed even in the event of a power failure, while a firmware update is underway. In addition, the Dual Bank mode supports BGO (Background operation, or so called RWW), allowing flash memory to be read/executed from the current bank even when a firmware update on the other bank is in progress.
The example provided below is a simple way to implement a firmware update in Dual Bank mode using Xmodem. Once all the firmware updates are complete, the ""Bank Swap"" function is used to swap the current running bank with the newly downloaded bank.
Hardware configuration
- EK-RA6M4 board (1MB flash MCU)
- Your own USB-UART adapter (TX: P411, RX: P410)
Flash memory configuration
- Dual bank mode (512 KB x 2 banks) is used.
- Each bank (Bank0, 1) is divided into user bootloader area and user application area as below.
- The user bootloader is always built at address 0 regardless of the bank number to download.
- The user application is always built at address 0x8000 (bootloader size = e.g., 32 Kbytes) regardless of the bank number to download.
- The size and location of user bootloader and application can be changed as user needs.
- Whether or not to have a user bootloader is user's choice.
Bank 0 (Block 0 to 21) memory in 1MB product
Bank 1 (Block 70 to 91) memory in 1MB product
Linker script configuration (both bootloader and application)
- In the linker script, two user-defined sections (.verinfo, .sizeinfo) are added immediately after the application interrupt vector (.application_vectors), so they are always placed at a fixed address locations regardless of user code modification.
- The size of the application interrupt vector (g_Vector_table[BSP_ICU_VECTOR_MAX_ENTRIES]) depends on the MCU series used, so please ensure that both the bootloader project and application project are built on the same MCU series.
- During the user application firmware post-build process, CRC32 is padded to the end of the user application firmware binary, and its (CRC32) location is pointed by “.sizeinfo”.
Caution with “bin” firmware and option memory
User firmware can be converted to .hex, .srec, or .bin file type format in e2 studio. However, when creating a bin file, care must be taken to ensure that the option memory is not unintentionally filled with garbage values or zero values. This is because some settings in option memory cannot be permanently changed once set. e2 studio's default linker script has many memory sections (e.g. .text, .data, option_setting_x, .data_flash, qspi_flash, etc.) spread over a wide address range. Therefore, the user binary output file will be over 1 Mbyte in size, but only user code/data sections are required unless you download it new to a virgin MCU. This can be easily achieved by checking only those two check boxes in e2 studio.
Please don't forget to program the MCU with .srec or .hex at least once with the option memory settings to change Linear Mode to Dual Bank mode.
Append CRC32 to end of “bin” file
As an example of the firmware integrity verification process, the “application_postbuild.bat” and “srec_cat.exe” files are added in the application project folder. The ""srec_cat.exe"" is free software available on the Internet that allows you to rearrange, reformat, and relocate input files into output file as well as CRC32 calculation. Current version of e2 studio “Post-build steps” runs before the “GNU Arm Cross Create Flash Image” which creates a .bin file, so the “Append CRC32” builder was added as an alternative. If all the build processes are completed successfully, another .bin file will be created that ends with “<original bin file>_crc.bin”, which is 4 bytes (CRC32) larger than the original .bin file.
Operation flow of the example projects
User bootloader
1. Program the board with the bootloader project. Use .srec (.hex) for option memory update.
2. The bootloader toggles the LED1 (Blue) on the board a number of times equal to the user bootloader’s own version.
3. When the S2 button is pressed, the bootloader checks the CRC32 of the user application firmware, and if the CRC32 is correct, it jumps to the user application as shown below.
4. If CRC32 is incorrect or an error occurs, the bootloader starts Xmodem task as shown below.
4-1. Press 1 and download the user bootloader .bin file to the opposite bank.
4-2. Press 2 and download the user application _crc.bin file to the opposite bank.
4-3. Press 0 to swap the banks.
4-4. Press 3 to reset the board.
User application
1. The application toggles the LED3 (Red) on the board a number of times equal to the user application’s own version.
2. When the S1 button is pressed, the application starts Xmodem task to download a new bootloader and application to the opposite bank.
3. After the Xmodem download is complete, the user can determine the bank swap and reset the MCU.
Tera Term setting
115200, 8bit, parity none, 1 stop bit, no hardware flow control.
To view the text properly, New-line setting for reception should be CR+LF as follows:
Some RA MCUs support both a Linear Mode and a Dual Bank mode. This feature is switchable by an option memory setting. The Dual Bank flash mode is the preferred choice when user firmware A in Bank0 and user firmware B in Bank1 must be built identically to run from the same flash memory address, or when a user firmware update (including a user bootloader) must be safely completed even in the event of a power failure, while a firmware update is underway. In addition, the Dual Bank mode supports BGO (Background operation, or so called RWW), allowing flash memory to be read/executed from the current bank even when a firmware update on the other bank is in progress.
The example provided below is a simple way to implement a firmware update in Dual Bank mode using Xmodem. Once all the firmware updates are complete, the ""Bank Swap"" function is used to swap the current running bank with the newly downloaded bank.
Hardware configuration
- EK-RA6M4 board (1MB flash MCU)
- Your own USB-UART adapter (TX: P411, RX: P410)
Flash memory configuration
- Dual bank mode (512 KB x 2 banks) is used.
- Each bank (Bank0, 1) is divided into user bootloader area and user application area as below.
- The user bootloader is always built at address 0 regardless of the bank number to download.
- The user application is always built at address 0x8000 (bootloader size = e.g., 32 Kbytes) regardless of the bank number to download.
- The size and location of user bootloader and application can be changed as user needs.
- Whether or not to have a user bootloader is user's choice.
Bank 0 (Block 0 to 21) memory in 1MB product
Bank 1 (Block 70 to 91) memory in 1MB product
Linker script configuration (both bootloader and application)
- In the linker script, two user-defined sections (.verinfo, .sizeinfo) are added immediately after the application interrupt vector (.application_vectors), so they are always placed at a fixed address locations regardless of user code modification.
- The size of the application interrupt vector (g_Vector_table[BSP_ICU_VECTOR_MAX_ENTRIES]) depends on the MCU series used, so please ensure that both the bootloader project and application project are built on the same MCU series.
- During the user application firmware post-build process, CRC32 is padded to the end of the user application firmware binary, and its (CRC32) location is pointed by “.sizeinfo”.
Caution with “bin” firmware and option memory
Caution with “bin” firmware and option memory
User firmware can be converted to .hex, .srec, or .bin file type format in e2 studio. However, when creating a bin file, care must be taken to ensure that the option memory is not unintentionally filled with garbage values or zero values. This is because some settings in option memory cannot be permanently changed once set. e2 studio's default linker script has many memory sections (e.g. .text, .data, option_setting_x, .data_flash, qspi_flash, etc.) spread over a wide address range. Therefore, the user binary output file will be over 1 Mbyte in size, but only user code/data sections are required unless you download it new to a virgin MCU. This can be easily achieved by checking only those two check boxes in e2 studio.
Please don't forget to program the MCU with .srec or .hex at least once with the option memory settings to change Linear Mode to Dual Bank mode.
Append CRC32 to end of “bin” file
Append CRC32 to end of “bin” file
As an example of the firmware integrity verification process, the “application_postbuild.bat” and “srec_cat.exe” files are added in the application project folder. The ""srec_cat.exe"" is free software available on the Internet that allows you to rearrange, reformat, and relocate input files into output file as well as CRC32 calculation. Current version of e2 studio “Post-build steps” runs before the “GNU Arm Cross Create Flash Image” which creates a .bin file, so the “Append CRC32” builder was added as an alternative. If all the build processes are completed successfully, another .bin file will be created that ends with “<original bin file>_crc.bin”, which is 4 bytes (CRC32) larger than the original .bin file.
Operation flow of the example projects
Operation flow of the example projects
User bootloader
1. Program the board with the bootloader project. Use .srec (.hex) for option memory update.
2. The bootloader toggles the LED1 (Blue) on the board a number of times equal to the user bootloader’s own version.
3. When the S2 button is pressed, the bootloader checks the CRC32 of the user application firmware, and if the CRC32 is correct, it jumps to the user application as shown below.
4. If CRC32 is incorrect or an error occurs, the bootloader starts Xmodem task as shown below.
4-1. Press 1 and download the user bootloader .bin file to the opposite bank.
4-2. Press 2 and download the user application _crc.bin file to the opposite bank.
opposite
opposite
4-3. Press 0 to swap the banks.
4-4. Press 3 to reset the board.
swap the banks
User application
1. The application toggles the LED3 (Red) on the board a number of times equal to the user application’s own version.
2. When the S1 button is pressed, the application starts Xmodem task to download a new bootloader and application to the opposite bank.
3. After the Xmodem download is complete, the user can determine the bank swap and reset the MCU.
opposite
Tera Term setting
115200, 8bit, parity none, 1 stop bit, no hardware flow control.
To view the text properly, New-line setting for reception should be CR+LF as follows:
Suitable Products
RA
Suitable Products
RA","['data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/87e9e983cec7aef987cedc8838701d7f.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/81386aa1d109719bd5edd30b1d853787.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/852d51c16952b0363b3ffe3105428c28.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/1f46c535d3a62bcbb67e1873232808ac.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/6d155f5077b60f3f573ebc741a58cab5.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/34856018334af7bf447121dcc1d31579.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/ab432ee5ccf993eb4c260cab60135cd0.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/5aff6b191903590f29299de89211e103.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/aa3cfb0d7c447951b809025a1983d51c.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'RA Family: Simple dual bank flash swap example for firmware A/B update', 'url': 'https://en-support.renesas.com/knowledgeBase/21546612', 'last_updated': '2024-03-09', 'extracted_at': '2025-03-08T23:12:33.227699'}","Overview Some RA MCUs support both a Linear Mode and a Dual Bank mode. This feature is switchable by an option memory setting. The Dual Bank flash mode is the preferred choice when user firmware A in Bank0 and user firmware B in Bank1 must be built identically to run from the same flash memory address, or when a user firmware update (including a user bootloader) must be safely completed even in the event of a power failure, while a firmware update is underway. In addition, the Dual Bank mode supports BGO (Background operation, or so called RWW), allowing flash memory to be read/executed from the current bank even when a firmware update on the other bank is in progress. The example provided below is a simple way to implement a firmware update in Dual Bank mode using Xmodem. Once all the firmware updates are complete, the ""Bank Swap"" function is used to swap the current running bank with the newly downloaded bank. Hardware configuration - EK-RA6M4 board (1MB flash MCU) - Your own USB-UART adapter (TX P411, RX P410) Flash memory configuration - Dual bank mode (512 KB x 2 banks) is used. - Each bank (Bank0, 1) is divided into user bootloader area and user application area as below. - The user bootloader is always built at address 0 regardless of the bank number to download. - The user application is always built at address 0x8000 (bootloader size  e.g., 32 Kbytes) regardless of the bank number to download. - The size and location of user bootloader and application can be changed as user needs. - Whether or not to have a user bootloader is user's choice. Bank 0 (Block 0 to 21) memory in 1MB product Bank 1 (Block 70 to 91) memory in 1MB product Linker script configuration (both bootloader and application) - In the linker script, two user-defined sections (.verinfo, .sizeinfo) are added immediately after the application interrupt vector (.applicationvectors), so they are always placed at a fixed address locations regardless of user code modification. - The size of the application interrupt vector (gVectortableBSPICUVECTORMAXENTRIES) depends on the MCU series used, so please ensure that both the bootloader project and application project are built on the same MCU series. - During the user application firmware post-build process, CRC32 is padded to the end of the user application firmware binary, and its (CRC32) location is pointed by .sizeinfo. Caution with bin firmware and option memory User firmware can be converted to .hex, .srec, or .bin file type format in e2 studio. However, when creating a bin file, care must be taken to ensure that the option memory is not unintentionally filled with garbage values or zero values. This is because some settings in option memory cannot be permanently changed once set. e2 studio's default linker script has many memory sections (e.g. .text, .data, optionsettingx, .dataflash, qspiflash, etc.) spread over a wide address range. Therefore, the user binary output file will be over 1 Mbyte in size, but only user code/data sections are required unless you download it new to a virgin MCU. This can be easily achieved by checking only those two check boxes in e2 studio. Please don't forget to program the MCU with .srec or .hex at least once with the option memory settings to change Linear Mode to Dual Bank mode. Append CRC32 to end of bin file As an example of the firmware integrity verification process, the applicationpostbuild.bat and sreccat.exe files are added in the application project folder. The ""sreccat.exe"" is free software available on the Internet that allows you to rearrange, reformat, and relocate input files into output file as well as CRC32 calculation. Current version of e2 studio Post-build steps runs before the GNU Arm Cross Create Flash Image which creates a .bin file, so the Append CRC32 builder was added as an alternative. If all the build processes are completed successfully, another .bin file will be created that ends with original bin filecrc.bin, which is 4 bytes (CRC32) larger than the original .bin file. Operation flow of the example projects User bootloader 1. Program the board with the bootloader project. Use .srec (.hex) for option memory update. 2. The bootloader toggles the LED1 (Blue) on the board a number of times equal to the user bootloaders own version. 3. When the S2 button is pressed, the bootloader checks the CRC32 of the user application firmware, and if the CRC32 is correct, it jumps to the user application as shown below. 4. If CRC32 is incorrect or an error occurs, the bootloader starts Xmodem task as shown below. 4-1. Press 1 and download the user bootloader .bin file to the opposite bank. 4-2. Press 2 and download the user application crc.bin file to the opposite bank. 4-3. Press 0 to swap the banks. 4-4. Press 3 to reset the board. User application 1. The application toggles the LED3 (Red) on the board a number of times equal to the user applications own version. 2. When the S1 button is pressed, the application starts Xmodem task to download a new bootloader and application to the opposite bank. 3. After the Xmodem download is complete, the user can determine the bank swap and reset the MCU. Tera Term setting 115200, 8bit, parity none, 1 stop bit, no hardware flow control. To view the text properly, New-line setting for reception should be CRLF as follows Suitable Products RA opposite swap the banks","['The image presents a table with two columns and ten rows, displaying information about the flash memory of a device. The table is divided into two sections: the left section contains the flash memory information, while the right section provides additional details.\n\n**Left Section:**\n\n*   **Block 21:** 32 Kbytes\n*   **Block 9:** 32 Kbytes\n*   **Block 8:** 32 Kbytes\n*   **Block 7:** 8 Kbytes\n*   **Block 4:** 8 Kbytes\n*   **Block 3:** 8 Kbytes\n*   **Block 2:** 8 Kbytes\n*   **Block 1:** 8 Kbytes\n*   **Block 0:** 8 Kbytes\n\n**Right Section:**\n\n*   **User firmware A:** \n*   **User bootloader Y (32 KB):** \n\nThe table provides a clear and organized overview of the flash memory information, making it easy to compare and analyze the data.', 'The image presents a table with two columns and nine rows, displaying information about the flash memory of a device. The table is divided into two sections: the top section contains the column headers, while the bottom section lists the data.\n\n**Column Headers:**\n\n*   **Block 91**\n*   **Block 79**\n*   **Block 78**\n*   **Block 77**\n*   **Block 74**\n*   **Block 73**\n*   **Block 72**\n*   **Block 71**\n*   **Block 70**\n\n**Data:**\n\n*   **Block 91:** 32 Kbytes - 0x00278000 - 0x0027FFFF\n*   **Block 79:** 32 Kbytes - 0x00218000 - 0x0021FFFF\n*   **Block 78:** 32 Kbytes - 0x00210000 - 0x00217FFF\n*   **Block 77:** 8 Kbytes - 0x0020E000 - 0x0020FFFF\n*   **Block 74:** 8 Kbytes - 0x00208000 - 0x00209FFF\n*   **Block 73:** 8 Kbytes - 0x00206000 - 0x00207FFF\n*   **Block 72:** 8 Kbytes - 0x00204000 - 0x00205FFF\n*   **Block 71:** 8 Kbytes - 0x00202000 - 0x00203FFF\n*   **Block 70:** 8 Kbytes - 0x00200000 - 0x00201FFF\n\n**Additional Information:**\n\n*   **User Bootloader Z (32 KB)**\n*   **User Firmware B**\n\nThe table provides a detailed breakdown of the flash memory, including the size of each block, the starting and ending addresses, and the type of data stored in each block. The additional information section highlights the user bootloader and firmware versions.', ""The image presents a table with six columns and seven rows, providing a detailed breakdown of the code's structure and components. The columns are labeled as follows:\n\n*   **section**: This column lists the different sections of the code, including the text, variable, and code sections.\n*   **Address**: This column displays the memory addresses associated with each section.\n*   **Size**: This column shows the size of each section in bytes.\n*   **Flash**: This column indicates whether each section is stored in flash memory (0x38) or not.\n*   **Remark**: This column provides additional comments or notes about each section.\n\nThe table is divided into two main sections: the top section contains the text, variable, and code sections, while the bottom section focuses on the application vectors and fixed vectors.\n\n**Top Section:**\n\n*   **text**: This section contains the main code, with an address of 0x000081C4 and a size of 0x000081C7.\n*   **variable**: This section is empty, indicating that there are no variables defined in this code.\n*   **code**: This section contains the code, with an address of 0x000081C0 and a size of 0x000081C3.\n\n**Bottom Section:**\n\n*   **application_vectors**: This section contains the application vectors, with an address of 0x00008040 and a size of 0x00008040.\n*   **fixed_vectors**: This section contains the fixed vectors, with an address of 0x00008000 and a size of 0x00008040.\n\nOverall, the table provides a clear and organized view of the code's structure and components, making it easier to understand and navigate the code."", 'The image shows a screenshot of a computer program, specifically the ""Settings"" window for a project in Visual Studio. The window is divided into two main sections: the left side lists various settings options, and the right side displays the current settings for the selected option.\n\n*   **Left Side:**\n    *   The left side of the window is a list of settings options, including:\n        *   Resource Builders\n        *   Build Variables\n        *   Environment\n        *   Logging\n        *   Settings\n        *   Tool Chain Editor\n        *   C/C++ General\n        *   Project Natures\n        *   Project References\n        *   Refactoring History\n        *   Renesas QE\n        *   Run/Debug Settings\n        *   Task Tags\n        *   Validation\n*   **Right Side:**\n    *   The right side of the window displays the current settings for the selected option, which is ""Output file format (-O)"". The selected option is highlighted in red, and the current setting is ""Section:-j .text"".\n    *   Below the selected option, there are two checkboxes:\n        *   Section:-j .text\n        *   Section:-j .data\n    *   At the bottom of the window, there is a text box labeled ""Other sections (-)"" where additional settings can be entered.\n\nOverall, the image shows a user configuring the output file format for a project in Visual Studio. The user has selected the ""Output file format (-O)"" option and is currently setting the format to ""Section:-j .text"". The user can also add additional settings in the ""Other sections (-)"" text box.', 'The image shows a screenshot of a computer window with a list of options on the left side and a larger area on the right side. The window is titled ""Properties for application_refmd_dual_bank"" and has a gray background.\n\nOn the left side of the window, there is a list of options in a column. The top option is ""Builders,"" which is highlighted in blue. Below this are several other options, including ""C/C++ Build,"" ""Build Variables,"" ""Environment,"" ""Logging,"" ""Settings,"" ""Tool Chain Editor,"" ""C/C++ General,"" ""Project Nature,"" ""Project References,"" ""Renesas QE,"" ""Run/Debug Settings,"" ""Task Tags,"" and ""Validation."" Some of these options have sub-options or additional information displayed below them.\n\nOn the right side of the window, there is a larger area that appears to be a text box or a list of items. The top of this area has a heading that reads ""Configure the builders for the project:"" followed by a list of options. The first option is ""DOSC Builder,"" which is highlighted in red. Below this are several other options, including ""CDT Builder,"" ""Scanner Configuration Builder,"" ""DOSC Bundle Builder,"" and ""Append CRC32."" Each of these options has a checkbox next to it, and the ""DOSC Bundle Builder"" option has a red circle with a line through it next to it.\n\nAt the bottom of the window, there are two buttons: ""Apply and Close"" and ""Cancel."" The ""Apply and Close"" button is highlighted in blue, indicating that it is the default action.\n\nOverall, the image appears to be a screenshot of a computer window that allows users to configure the builders for a project. The window has a list of options on the left side and a larger area on the right side that displays additional information and allows users to select options.', 'The image shows a screenshot of a computer terminal window displaying a series of commands and their outputs. The terminal window is open on a white background, with a black border around it. The title bar at the top of the window reads ""COM7 - Tera Term VT"" in black text, with a yellow icon to the left of the text.\n\nBelow the title bar, there are several lines of text that appear to be commands and their outputs. The commands are written in black text, while the outputs are displayed in white text. The commands include:\n\n* `Bootloader #NNNN`\n* `Boot> F/# Version 0x1`\n* `Boot> DUALSEL 0xffffffff8`\n* `Boot> BANKSEL 0xffffffff8`\n* `Boot> Dual bank mode (#1)`\n* `Boot> Press S2 button to jump to application`\n* `Boot> CRC32 stored 0x507a9b97, Calculated inverted 0x507a9b97`\n\nAt the bottom of the window, there is a line of text that reads ""Application #NNNN"" in black text, followed by several lines of text that appear to be application-specific commands and outputs. These include:\n\n* `App> F/# Version 0x1`\n* `App> BANKSEL 0xffffffff8`\n* `App> Press S1 button to enter Xaodem menu`\n\nOverall, the image suggests that the user is interacting with a device or system using a terminal emulator, and is executing a series of commands to configure and test the device. The output of each command is displayed in the terminal window, allowing the user to monitor the progress of the commands and troubleshoot any issues that may arise.', 'The image shows a screenshot of a terminal window with a list of commands and their corresponding outputs. The terminal window is open on a computer, and the commands are related to booting a device or system.\n\n*   The first line of the terminal window shows the command ""Bootloader #!!!!"" followed by a series of numbers and letters.\n*   The second line shows the command ""Boot> F/W Version 0x1"" followed by the output ""DUALSEL 0xffffffff8"".\n*   The third line shows the command ""Boot> BANKSEL 0xffffffff"" followed by the output ""Dual bank mode (#0)"".\n*   The fourth line shows the command ""Boot> Press S2 button to jump to application"" followed by the output ""Boot> Application size error -1"".\n*   The fifth line shows the command ""Boot> Application size error -1"" followed by the output ""Swap bank"".\n*   The sixth line shows the command ""1 - Download new bootloader image (XModem)"" followed by the output ""2 - Download new application image (XModem)"".\n*   The seventh line shows the command ""3 - Reboot"" followed by the output ""Reboot"".\n\nOverall, the image suggests that the user is trying to boot a device or system using a bootloader, but is encountering an error with the application size. The user is then prompted to choose between downloading a new bootloader or application image, or rebooting the system.', 'The image shows a screenshot of a computer screen displaying a terminal window with a command prompt and a list of commands. The terminal window is open on a white background, with a gray bar at the top containing various menu options such as ""File,"" ""Edit,"" ""Setup,"" ""Control,"" ""Window,"" and ""Help."" \n\n*   The command prompt is highlighted in blue and reads ""bootloader_ra6m4_dua.""\n*   Below the command prompt, there is a list of commands that have been executed, including:\n    *   ""boot>"": This is the default command prompt for the bootloader.\n    *   ""Protocol: XMODEM (checksum)"": This indicates that the bootloader is using the XMODEM protocol with checksum verification.\n    *   ""Packet#: 93"": This shows the packet number that is currently being transferred.\n    *   ""Bytes transferred: 11904"": This displays the total number of bytes that have been transferred so far.\n    *   ""Elapsed time: 0:07 (1.70KB/s)"": This shows the elapsed time since the transfer started and the average transfer rate.\n    *   ""Cancel"": This button allows the user to cancel the transfer process.\n*   At the bottom of the window, there are additional commands that can be executed, including:\n    *   ""Download new bootloader image (XModem)"": This command allows the user to download a new bootloader image using the XMODEM protocol.\n    *   ""Download new application image (XModem)"": This command allows the user to download a new application image using the XMODEM protocol.\n    *   ""Reboot"": This command restarts the system.\n    *   ""Blank checking the other bank bootloader..."": This command checks the other bank bootloader for any issues.\n    *   ""The other bank blocks are empty"": This message indicates that the other bank blocks are empty and ready for use.\n    *   ""Start Xmodem transfer..."": This command starts the XMODEM transfer process.\n\nOverall, the image shows a terminal window with a command prompt and a list of commands related to bootloader and application image transfers using the XMODEM protocol. The user can execute various commands to manage the transfer process and troubleshoot any issues.', 'The image depicts a screenshot of a computer program, specifically a terminal setup window. The window is titled ""Tera Term: Terminal setup"" and features a white background with black text.\n\n**Terminal Size**\nThe terminal size is set to 160x52, with a checkbox labeled ""Term size = win size"" checked. This suggests that the terminal size is being set to match the size of the window.\n\n**New-line**\nThe new-line option is set to ""Receive: CR+LF"", which indicates that the terminal will receive new-line characters as a combination of carriage return (CR) and line feed (LF).\n\n**Terminal ID**\nThe terminal ID is set to ""VT100"", which is a common terminal type.\n\n**Answerback**\nThe answerback option is set to ""Auto switch (VT <-> TEK)"", which suggests that the terminal will automatically switch between VT and TEK modes.\n\n**Coding**\nThe coding option is set to ""UTF-8"", which is a widely used character encoding standard.\n\n**OK and Cancel Buttons**\nThe window features two buttons: ""OK"" and ""Cancel"". The ""OK"" button is highlighted in blue, indicating that it is the default button. The ""Cancel"" button is highlighted in gray, indicating that it is the secondary button.\n\nOverall, the image suggests that the user is configuring a terminal setup for a specific application or device. The settings appear to be tailored for a VT100 terminal with UTF-8 encoding, and the user has chosen to receive new-line characters as a combination of CR and LF.']"
53dfb41c0a87368066a2be97a9245fe6,"Question:
How to I connect the VCL pin on RA4M2 MCUs?
Question:
How to I connect the VCL pin on RA4M2 MCUs?
How to I connect the VCL pin on RA4M2 MCUs?
Answer:
You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says: 
""Connect this pin to the VSS pin by the smoothing capacitor used to stabilize the internal power supply"", you might think that you connect VCL to Vss right next to the main decoupling capacitor. This would be incorrect.
The Hardware User Manual, section 45 shows more clearly what to do- connect VCL to a capacitor that then connects to VSS- as seen in the right side of the below diagram.
Answer:
You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says: 
""Connect this pin to the VSS pin by the smoothing capacitor used to stabilize the internal power supply"", you might think that you connect VCL to Vss right next to the main decoupling capacitor. This would be incorrect.
The Hardware User Manual, section 45 shows more clearly what to do- connect VCL to a capacitor that then connects to VSS- as seen in the right side of the below diagram.
You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says:
You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says:
""Connect this pin to the VSS pin by the smoothing capacitor used to stabilize the internal power supply"", you might think that you connect VCL to Vss right next to the main decoupling capacitor. This would be incorrect.
The Hardware User Manual, section 45 shows more clearly what to do- connect VCL to a capacitor that then connects to VSS- as seen in the right side of the below diagram.
Suitable Products
RA4 Series",['data/categories/ra_family/ra_and_fsp_technical_articles/53dfb41c0a87368066a2be97a9245fe6/images/1a84e7b92f46b6b0888fd7ca9ed9b7df.png'],[],['|  |\n|  |\n| RA4 Series |'],"{'title': 'Correct Connections for VCL pin on RA4M2 MCUs', 'url': 'https://en-support.renesas.com/knowledgeBase/20344994', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:13.657895'}","Question How to I connect the VCL pin on RA4M2 MCUs? Answer You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says ""Connect this pin to the VSS pin by the smoothing capacitor used to stabilize the internal power supply"", you might think that you connect VCL to Vss right next to the main decoupling capacitor. This would be incorrect. The Hardware User Manual, section 45 shows more clearly what to do- connect VCL to a capacitor that then connects to VSS- as seen in the right side of the below diagram. You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says Suitable Products RA4 Series","['The image depicts a page from a user\'s manual for a RA4M2 microcontroller, specifically focusing on the internal voltage regulator (LDO). The page is divided into three sections: ""45. Internal Voltage Regulator,"" ""45.1 Overview,"" and ""45.2 Operation.""\n\n**Section 45.1 Overview**\n\nThis section provides a brief introduction to the LDO, highlighting its role as a linear regulator that supplies voltage to all internal circuits and memory, except for I/O, analog, USB, and battery backup power domains.\n\n**Section 45.2 Operation**\n\nThis section explains how the LDO operates, stating that it lists the LDO mode pin settings and shows the LDO mode settings. In LDO mode, the internal voltage is generated from VCC.\n\n**Table 45.1 LDO mode pin**\n\nThis table outlines the settings for the LDO mode pin, including:\n\n* Pins: All VCC\n* Setting descriptions:\n\t+ Connect each pin to the system power supply.\n\t+ Connect each pin to VSS through a 0.1-μF multilayer ceramic capacitor. Place the capacitor close to the pin.\n\t+ Connect the each pin to VSS through a 0.22-μF multilayer ceramic capacitor. Place the capacitor close to the pin.\n\n**Figure 45.1 LDO mode settings**\n\nThis figure illustrates the LDO mode settings, showing the connections between the LDO, VCC, VSS, and external power supply. The figure includes labels for each component, making it easy to understand the configuration.\n\nOverall, the page provides a clear and concise overview of the LDO\'s operation and settings, making it a useful resource for users of the RA4M2 microcontroller.']"
715bc382a76f4e386a2c65056d73e6d4,"This article details how to use the RA6T2 16-bit ADC to apply the sample-and-hold function for AD sampling in hybrid mode, as well as the specific application of the background function. In this article, we use FSP to build an application project, explain in detail how to set the operation time of each part of the ADC module according to the data sheet, and show the measured results. The application uses FSP4.0.0 to generate the main code framework, which is easily portable.
1. Introduction to Hybrid mode
1.1 The RA6T2 16-bit ADC can operate in both Oversampling and Hybrid modes, but the ADC conversion process is slower when the oversampling single sweep function is used. Therefore, when the ADC conversion time is required to be fast, it is recommended that the Scan Mode be set to Continuous Scan and the Conversion Method be set to Hybrid Mode as shown below.
1.2 In this example, AN003, AN005, AN007, and AN008 are selected as the signal acquisition ports.
See the RA6T2 data sheet, ADC Channel Affiliation and Functional Design:
AN003 and AN005 of the ADC0 unit and AN007 and AN008 of the ADC1 unit can be set to sample-and-hold
For specific FSP settings, please refer to the picture and pay attention to the settings of virtual2 and virtual5.
For the specific group mode FSP, please see the below properties windows.
    According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below.
  According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below.
1) Start by setting the tAD_SPL time
  2) Set the tSH_D time
  3) Set the tAD_CNV time
  4) Set the sample-and-hold function time
  After the above settings are completed, the project is established.
1.3 The following is the actual measurement of the AD sampling process, confirmed as per Figure 36.56 on page 1559 of the data sheet.
  In this mode, the processing time of each AD conversion is as follows:
tSH_D +（tSH_SPL+ tSH_HLD）+（tAD_SPL+ tAD_CNV）* 2+ tADDP
=2 +（25+4）+（7+11）* 2 + 9 + 5=81 (ADCLK),
When we selected a 60MHz clock, the time was around 1.35us.
In the actual test, we measured the ADC conversion time by flipping the I/O port in the ADC End Transition Interrupt adc_b_adi0_isr. As shown in the figure below, the port rollover time is 1.44us.
The additional test is 0.084us for the individual rollover port time, that is, the actual ADC conversion time is (1.44us-0.084us =) 1.356us. This result shows that the data sheet is consistent with the FSP actual engineering test results.

2. Explanation of the specific application of the background mode function in hybrid mode
The background mode can be set to trigger at a specific moment to output the current AD sampling result.
2.1 Set the ADC Conversion Method to Hybrid Mode and Scan Mode to Background Continuous Scan (Hybrid Conversion Method Only)
This test was conducted using the official Renesas model MCK-RA6T2, please refer to the MCK-RA6T2 User's Manual (renesas.com) for details. The experiment was designed based on 4 ADC channels and divided into two groups. And enable the end interrupt of ADC0 and output an I/O signal to test the end time of the ADC.
  Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4.
When a comparison match occurs, set the GTIOC4A output signal to assist in confirming the ADC time.
  In the GPT4 Comparison Match interrupt program, we make the PE11 output high,
  void gpt_capture_a_isr (void)
{
  .....
  g_ioport.p_api->pinWrite(g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_HIGH);
  .....
}
  In the ADC0 end interrupt, we make the PE11 output low
  void adc_b_adi0_isr (void)
{
.....
g_ioport.p_api->pinWrite (g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_LOW);
.....
}
  Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output.
The working principle of Hybrid background mode is shown in the following figure:
  As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below.
Total elapsed time = (trigger duration) + (data output time) = tD_ADST + tADD= tD_TRG + tD_ITRG + tD_SYOP = (1+3+1+3+0+9) * ADCLK+5* PCLKA= 0.283+0.042=0.322us.
Thus the theoretical calculations are basically consistent with the actual test results.
  Suitable Products
RA6T2
This article details how to use the RA6T2 16-bit ADC to apply the sample-and-hold function for AD sampling in hybrid mode, as well as the specific application of the background function. In this article, we use FSP to build an application project, explain in detail how to set the operation time of each part of the ADC module according to the data sheet, and show the measured results. The application uses FSP4.0.0 to generate the main code framework, which is easily portable.
1. Introduction to Hybrid mode
1.1 The RA6T2 16-bit ADC can operate in both Oversampling and Hybrid modes, but the ADC conversion process is slower when the oversampling single sweep function is used. Therefore, when the ADC conversion time is required to be fast, it is recommended that the Scan Mode be set to Continuous Scan and the Conversion Method be set to Hybrid Mode as shown below.
1.2 In this example, AN003, AN005, AN007, and AN008 are selected as the signal acquisition ports.
See the RA6T2 data sheet, ADC Channel Affiliation and Functional Design:
AN003 and AN005 of the ADC0 unit and AN007 and AN008 of the ADC1 unit can be set to sample-and-hold
For specific FSP settings, please refer to the picture and pay attention to the settings of virtual2 and virtual5.
For the specific group mode FSP, please see the below properties windows.
    According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below.
  According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below.
1) Start by setting the tAD_SPL time
  2) Set the tSH_D time
  3) Set the tAD_CNV time
  4) Set the sample-and-hold function time
  After the above settings are completed, the project is established.
1.3 The following is the actual measurement of the AD sampling process, confirmed as per Figure 36.56 on page 1559 of the data sheet.
  In this mode, the processing time of each AD conversion is as follows:
tSH_D +（tSH_SPL+ tSH_HLD）+（tAD_SPL+ tAD_CNV）* 2+ tADDP
=2 +（25+4）+（7+11）* 2 + 9 + 5=81 (ADCLK),
When we selected a 60MHz clock, the time was around 1.35us.
In the actual test, we measured the ADC conversion time by flipping the I/O port in the ADC End Transition Interrupt adc_b_adi0_isr. As shown in the figure below, the port rollover time is 1.44us.
The additional test is 0.084us for the individual rollover port time, that is, the actual ADC conversion time is (1.44us-0.084us =) 1.356us. This result shows that the data sheet is consistent with the FSP actual engineering test results.

2. Explanation of the specific application of the background mode function in hybrid mode
The background mode can be set to trigger at a specific moment to output the current AD sampling result.
2.1 Set the ADC Conversion Method to Hybrid Mode and Scan Mode to Background Continuous Scan (Hybrid Conversion Method Only)
This test was conducted using the official Renesas model MCK-RA6T2, please refer to the MCK-RA6T2 User's Manual (renesas.com) for details. The experiment was designed based on 4 ADC channels and divided into two groups. And enable the end interrupt of ADC0 and output an I/O signal to test the end time of the ADC.
  Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4.
When a comparison match occurs, set the GTIOC4A output signal to assist in confirming the ADC time.
  In the GPT4 Comparison Match interrupt program, we make the PE11 output high,
  void gpt_capture_a_isr (void)
{
  .....
  g_ioport.p_api->pinWrite(g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_HIGH);
  .....
}
  In the ADC0 end interrupt, we make the PE11 output low
  void adc_b_adi0_isr (void)
{
.....
g_ioport.p_api->pinWrite (g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_LOW);
.....
}
  Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output.
The working principle of Hybrid background mode is shown in the following figure:
  As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below.
Total elapsed time = (trigger duration) + (data output time) = tD_ADST + tADD= tD_TRG + tD_ITRG + tD_SYOP = (1+3+1+3+0+9) * ADCLK+5* PCLKA= 0.283+0.042=0.322us.
Thus the theoretical calculations are basically consistent with the actual test results.
  Suitable Products
RA6T2
This article details how to use the RA6T2 16-bit ADC to apply the sample-and-hold function for AD sampling in hybrid mode, as well as the specific application of the background function. In this article, we use FSP to build an application project, explain in detail how to set the operation time of each part of the ADC module according to the data sheet, and show the measured results. The application uses FSP4.0.0 to generate the main code framework, which is easily portable.
1. Introduction to Hybrid mode
1.1 The RA6T2 16-bit ADC can operate in both Oversampling and Hybrid modes, but the ADC conversion process is slower when the oversampling single sweep function is used. Therefore, when the ADC conversion time is required to be fast, it is recommended that the Scan Mode be set to Continuous Scan and the Conversion Method be set to Hybrid Mode as shown below.
1.2 In this example, AN003, AN005, AN007, and AN008 are selected as the signal acquisition ports.
See the RA6T2 data sheet, ADC Channel Affiliation and Functional Design:
AN003 and AN005 of the ADC0 unit and AN007 and AN008 of the ADC1 unit can be set to sample-and-hold
For specific FSP settings, please refer to the picture and pay attention to the settings of virtual2 and virtual5.
For the specific group mode FSP, please see the below properties windows.
    According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below.
  According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below.
1) Start by setting the tAD_SPL time
  2) Set the tSH_D time
  3) Set the tAD_CNV time
  4) Set the sample-and-hold function time
  After the above settings are completed, the project is established.
1.3 The following is the actual measurement of the AD sampling process, confirmed as per Figure 36.56 on page 1559 of the data sheet.
  In this mode, the processing time of each AD conversion is as follows:
tSH_D +（tSH_SPL+ tSH_HLD）+（tAD_SPL+ tAD_CNV）* 2+ tADDP
=2 +（25+4）+（7+11）* 2 + 9 + 5=81 (ADCLK),
When we selected a 60MHz clock, the time was around 1.35us.
In the actual test, we measured the ADC conversion time by flipping the I/O port in the ADC End Transition Interrupt adc_b_adi0_isr. As shown in the figure below, the port rollover time is 1.44us.
The additional test is 0.084us for the individual rollover port time, that is, the actual ADC conversion time is (1.44us-0.084us =) 1.356us. This result shows that the data sheet is consistent with the FSP actual engineering test results.

2. Explanation of the specific application of the background mode function in hybrid mode
The background mode can be set to trigger at a specific moment to output the current AD sampling result.
2.1 Set the ADC Conversion Method to Hybrid Mode and Scan Mode to Background Continuous Scan (Hybrid Conversion Method Only)
This test was conducted using the official Renesas model MCK-RA6T2, please refer to the MCK-RA6T2 User's Manual (renesas.com) for details. The experiment was designed based on 4 ADC channels and divided into two groups. And enable the end interrupt of ADC0 and output an I/O signal to test the end time of the ADC.
  Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4.
When a comparison match occurs, set the GTIOC4A output signal to assist in confirming the ADC time.
  In the GPT4 Comparison Match interrupt program, we make the PE11 output high,
  void gpt_capture_a_isr (void)
{
  .....
  g_ioport.p_api->pinWrite(g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_HIGH);
  .....
}
  In the ADC0 end interrupt, we make the PE11 output low
  void adc_b_adi0_isr (void)
{
.....
g_ioport.p_api->pinWrite (g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_LOW);
.....
}
  Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output.
The working principle of Hybrid background mode is shown in the following figure:
  As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below.
Total elapsed time = (trigger duration) + (data output time) = tD_ADST + tADD= tD_TRG + tD_ITRG + tD_SYOP = (1+3+1+3+0+9) * ADCLK+5* PCLKA= 0.283+0.042=0.322us.
Thus the theoretical calculations are basically consistent with the actual test results.
This article details how to use the RA6T2 16-bit ADC to apply the sample-and-hold function for AD sampling in hybrid mode, as well as the specific application of the background function. In this article, we use FSP to build an application project, explain in detail how to set the operation time of each part of the ADC module according to the data sheet, and show the measured results. The application uses FSP4.0.0 to generate the main code framework, which is easily portable.
1. Introduction to Hybrid mode
1.1 The RA6T2 16-bit ADC can operate in both Oversampling and Hybrid modes, but the ADC conversion process is slower when the oversampling single sweep function is used. Therefore, when the ADC conversion time is required to be fast, it is recommended that the Scan Mode be set to Continuous Scan and the Conversion Method be set to Hybrid Mode as shown below.
1.2 In this example, AN003, AN005, AN007, and AN008 are selected as the signal acquisition ports.
See the RA6T2 data sheet, ADC Channel Affiliation and Functional Design:
AN003 and AN005 of the ADC0 unit and AN007 and AN008 of the ADC1 unit can be set to sample-and-hold
For specific FSP settings, please refer to the picture and pay attention to the settings of virtual2 and virtual5.
For the specific group mode FSP, please see the below properties windows.
According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below.
According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below.
1) Start by setting the tAD_SPL time
2) Set the tSH_D time
3) Set the tAD_CNV time
4) Set the sample-and-hold function time
After the above settings are completed, the project is established.
1.3 The following is the actual measurement of the AD sampling process, confirmed as per Figure 36.56 on page 1559 of the data sheet.
In this mode, the processing time of each AD conversion is as follows:
tSH_D +（tSH_SPL+ tSH_HLD）+（tAD_SPL+ tAD_CNV）* 2+ tADDP
=2 +（25+4）+（7+11）* 2 + 9 + 5=81 (ADCLK),
When we selected a 60MHz clock, the time was around 1.35us.
In the actual test, we measured the ADC conversion time by flipping the I/O port in the ADC End Transition Interrupt adc_b_adi0_isr. As shown in the figure below, the port rollover time is 1.44us.
The additional test is 0.084us for the individual rollover port time, that is, the actual ADC conversion time is (1.44us-0.084us =) 1.356us. This result shows that the data sheet is consistent with the FSP actual engineering test results.
2. Explanation of the specific application of the background mode function in hybrid mode
The background mode can be set to trigger at a specific moment to output the current AD sampling result.
2.1 Set the ADC Conversion Method to Hybrid Mode and Scan Mode to Background Continuous Scan (Hybrid Conversion Method Only)
This test was conducted using the official Renesas model MCK-RA6T2, please refer to the MCK-RA6T2 User's Manual (renesas.com) for details. The experiment was designed based on 4 ADC channels and divided into two groups. And enable the end interrupt of ADC0 and output an I/O signal to test the end time of the ADC.
Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4.
When a comparison match occurs, set the GTIOC4A output signal to assist in confirming the ADC time.
In the GPT4 Comparison Match interrupt program, we make the PE11 output high,
void gpt_capture_a_isr (void)
{
  .....
  g_ioport.p_api->pinWrite(g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_HIGH);
  .....
}
In the ADC0 end interrupt, we make the PE11 output low
void adc_b_adi0_isr (void)
{
.....
g_ioport.p_api->pinWrite (g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_LOW);
.....
}
Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output.
The working principle of Hybrid background mode is shown in the following figure:
As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below.
Total elapsed time = (trigger duration) + (data output time) = tD_ADST + tADD= tD_TRG + tD_ITRG + tD_SYOP = (1+3+1+3+0+9) * ADCLK+5* PCLKA= 0.283+0.042=0.322us.
Thus the theoretical calculations are basically consistent with the actual test results.
Suitable Products
RA6T2
中文
中文","['data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/3a0957dd56a5f4dc4affb67f432e4a87.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/3165e2cd0e4182abe24cd8c7ae647814.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/82ef6aef27dbcc20a92fcd2d2390ba7d.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/bd4eddd03b2c9e050b276ab93d6f4824.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/9fbf744eb425c124a74a6959fec81c2e.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/679fbca67a3ecb13fcf07da80bffb057.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/47418356fe8422c99be03a03f4e0719b.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/b10c35dc45bbc07bd796b22cbebaf25a.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/c69d29b39791acc278dd502c16dbff24.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/21e6552802c7c66f368ac74e8cae646a.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/52b2e1200bb78bb57a5665a0d595d97d.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/8e6afa1e2d8534d1a946bd53e4336bee.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/75b401d624183a94fcbaade4f4f53128.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/4453e16fe59b8d21f42b48378c37c5a7.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/ea710b319ae163c8a423fc272022b5cf.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/9f87324aa9c332bba068b36de422a6e5.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/609aad12438d56dfe72118510d8564ac.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/43b9e9242d92f26bf334f52ff7e3c67a.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/c3b50e708f05622eb841a5ef3a872369.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/61398bb02ec2ed3ab223381996c79f13.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/d25daaef161876f30cde09a115929e13.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/cb01fa7ac9ba0544f30b2a813585606c.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/ebd19128a51e02f4fb3ca4fb2366528b.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/b9182bccfd7a4e088e77fac8070e909c.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/c85bbb3987d6504f57c0ea141686cd50.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/a8edf34e1f6a98a46bf06ea22e7c88f5.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/d752eeb5eb3e86ddaaad51725c0258ad.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/73f64e14e80b9c156461508582d8aa77.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/e5b7edbe75dec852083d62c135102459.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/0f3f650492498ad8d2b313c9127361ac.png']",[],"['|  |\n|  |\n| void gpt_capture_a_isr (void)\n{\n  .....\n  g_ioport.p_api->pinWrite(g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_HIGH);\n  .....\n} |', '|  |\n|  |\n| void adc_b_adi0_isr (void)\n{\n.....\ng_ioport.p_api->pinWrite (g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_LOW);\n.....\n} |', '|  |\n|  |\n| RA6T2 |']","{'title': 'A detailed explanation of the RA6T2 16-bit ADC mixed sampling mode application', 'url': 'https://en-support.renesas.com/knowledgeBase/21246525', 'last_updated': None, 'extracted_at': '2025-03-08T23:12:45.052299'}","This article details how to use the RA6T2 16-bit ADC to apply the sample-and-hold function for AD sampling in hybrid mode, as well as the specific application of the background function. In this article, we use FSP to build an application project, explain in detail how to set the operation time of each part of the ADC module according to the data sheet, and show the measured results. The application uses FSP4.0.0 to generate the main code framework, which is easily portable. 1. Introduction to Hybrid mode 1.1 The RA6T2 16-bit ADC can operate in both Oversampling and Hybrid modes, but the ADC conversion process is slower when the oversampling single sweep function is used. Therefore, when the ADC conversion time is required to be fast, it is recommended that the Scan Mode be set to Continuous Scan and the Conversion Method be set to Hybrid Mode as shown below. 1.2 In this example, AN003, AN005, AN007, and AN008 are selected as the signal acquisition ports. See the RA6T2 data sheet, ADC Channel Affiliation and Functional Design AN003 and AN005 of the ADC0 unit and AN007 and AN008 of the ADC1 unit can be set to sample-and-hold For specific FSP settings, please refer to the picture and pay attention to the settings of virtual2 and virtual5. For the specific group mode FSP, please see the below properties windows. According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below. According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below. 1) Start by setting the tADSPL time 2) Set the tSHD time 3) Set the tADCNV time 4) Set the sample-and-hold function time After the above settings are completed, the project is established. 1.3 The following is the actual measurement of the AD sampling process, confirmed as per Figure 36.56 on page 1559 of the data sheet. In this mode, the processing time of each AD conversion is as follows tSHD tSHSPL tSHHLDtADSPL tADCNV 2 tADDP 2 254711 2  9  581 (ADCLK), When we selected a 60MHz clock, the time was around 1.35us. In the actual test, we measured the ADC conversion time by flipping the I/O port in the ADC End Transition Interrupt adcbadi0isr. As shown in the figure below, the port rollover time is 1.44us. The additional test is 0.084us for the individual rollover port time, that is, the actual ADC conversion time is (1.44us-0.084us ) 1.356us. This result shows that the data sheet is consistent with the FSP actual engineering test results. 2. Explanation of the specific application of the background mode function in hybrid mode The background mode can be set to trigger at a specific moment to output the current AD sampling result. 2.1 Set the ADC Conversion Method to Hybrid Mode and Scan Mode to Background Continuous Scan (Hybrid Conversion Method Only) This test was conducted using the official Renesas model MCK-RA6T2, please refer to the MCK-RA6T2 User's Manual (renesas.com) for details. The experiment was designed based on 4 ADC channels and divided into two groups. And enable the end interrupt of ADC0 and output an I/O signal to test the end time of the ADC. Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4. When a comparison match occurs, set the GTIOC4A output signal to assist in confirming the ADC time. In the GPT4 Comparison Match interrupt program, we make the PE11 output high, void gptcaptureaisr (void)  ..... gioport.papi-pinWrite(gioport.pctrl,BSPIOPORT14PIN11,BSPIOLEVELHIGH);  In the ADC0 end interrupt, we make the PE11 output low void adcbadi0isr (void) ..... gioport.papi-pinWrite (gioport.pctrl,BSPIOPORT14PIN11,BSPIOLEVELLOW); Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output. The working principle of Hybrid background mode is shown in the following figure As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below. Total elapsed time  (trigger duration)  (data output time)  tDADST  tADD tDTRG  tDITRG  tDSYOP  (131309)  ADCLK5 PCLKA 0.2830.0420.322us. Thus the theoretical calculations are basically consistent with the actual test results. Suitable Products RA6T2 According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below. According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below. 2) Set the tSHD time 3) Set the tADCNV time 4) Set the sample-and-hold function time After the above settings are completed, the project is established. In this mode, the processing time of each AD conversion is as follows Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4. In the GPT4 Comparison Match interrupt program, we make the PE11 output high, void gptcaptureaisr (void) In the ADC0 end interrupt, we make the PE11 output low void adcbadi0isr (void) Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output. As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below. Suitable Products ","['The image shows a screenshot of a computer program\'s settings menu, specifically the ""g_adc0 ADC Driver on r_adc_b"" section. The menu is organized into two columns: ""Settings"" and ""API Info"". The ""Settings"" column lists various options, including ""Property"", ""Common"", ""Parameter Checking"", ""Module g_adc0 ADC Driver on r_adc_b"", ""General"", ""Operation"", ""ADC 0"", ""Conversion Method"", ""Scan Mode"", and ""ADC 1"". The ""API Info"" column provides additional information about each option, such as ""Value"" and ""Default (BSP)"".\n\nThe menu appears to be part of a larger program or system, possibly related to data acquisition or measurement. The options listed suggest that the program is designed to work with ADC (Analog-to-Digital Converter) devices, and the ""Scan Mode"" option implies that the program can perform continuous or hybrid scanning.\n\nOverall, the image provides a glimpse into the configuration options available in this specific program, which may be useful for users who need to customize the program\'s behavior or troubleshoot issues.', 'The image presents a technical diagram featuring a series of lines, symbols, and text. The diagram is divided into two main sections: the left side, which contains a list of abbreviations and acronyms, and the right side, which displays a complex network of lines and symbols.\n\n**Left Side:**\n\n*   The left side of the image lists various abbreviations and acronyms, including:\n    *   AGND\n    *   RT3\n    *   SINP_O\n    *   OR\n    *   MCU_AVCC\n    *   COSP_K\n    *   SINN_O\n    *   COSN_K\n    *   COSP_O\n    *   COSN_O\n    *   PB01\n    *   CM8100NF\n    *   MCU_VLC\n    *   MCU_VCC\n\n**Right Side:**\n\n*   The right side of the image features a complex network of lines and symbols, including:\n    *   A series of red lines with numbers and letters attached to them\n    *   A blue line with a circle at the end\n    *   Various symbols, such as triangles, squares, and circles, connected by lines\n    *   A series of abbreviations and acronyms, including:\n        *   PA03/AN003\n        *   AVSS0\n        *   AVCC0\n        *   PA04/AN004\n        *   PA05/AN005\n        *   PA06/AN006\n        *   PA07/AN007\n        *   PB00/AN008\n        *   PB01/AN009\n        *   VCL\n        *   VSS23\n        *   VCC34\n        *   RA6T2_QFN48PIN\n\n**Overall:**\n\n*   The image appears to be a technical diagram, possibly related to electronics or engineering\n*   The use of abbreviations and acronyms suggests that the diagram is intended for a specialized audience\n*   The complex network of lines and symbols on the right side of the image may represent a circuit or system, while the list of abbreviations and acronyms on the left side provides context and explanation for the symbols and lines.', 'The image presents a table titled ""ADC channel configuration of the analog inputs"" in black text at the top. The table is divided into two columns and 12 rows, with the first column labeled ""Analog channel number"" and the second column labeled ""Source of analog signal."" The table contains the following information:\n\n*   **Analog Channel Number:** The first column lists the analog channel numbers from 0 to 11.\n*   **Source of Analog Signal:** The second column provides the source of the analog signal for each channel, including:\n    *   Programmable Gain Amplifier (PGA)\n    *   Channel-dedicated Sample-and-hold Circuit (S&H)\n    *   A/D converter unit 0\n    *   A/D converter unit 1\n\nThe table also includes additional columns for each channel, which are not fully populated. The columns are labeled as follows:\n\n*   **Single-ended input**\n*   **Differential input**\n*   **Single-ended input**\n*   **Differential input**\n\nThe table appears to be a configuration table for an analog-to-digital converter (ADC) system, showing the source of the analog signal for each channel and the configuration of the ADC channels.', 'The image shows a screenshot of a computer program with a white background and black text. The title at the top reads ""g_adc0 ADC Driver on r_adc_b"" in black text.\n\nBelow the title, there are two columns of text. The left column is labeled ""Settings"" in blue text, and the right column is labeled ""API Info"" in blue text. The left column has several lines of text, including ""Property"", ""Callback"", ""Sample and Hold"", and ""Enable Unit"". Each of these lines has a checkbox next to it, except for ""Property"", which has a dropdown menu instead.\n\nThe right column has several lines of text, including ""Value"", ""Unit 0"", ""Unit 1"", ""Unit 2"", ""Unit 4"", ""Unit 5"", and ""Unit 6"". Each of these lines has a checkbox next to it, except for ""Value"", which has a dropdown menu instead.\n\nThe background of the image is white, with a light blue border around the edges. Overall, the image appears to be a screenshot of a computer program used for configuring or testing an ADC driver.', 'The image displays a list of settings for a digital video camera, with each setting accompanied by a checkbox and a brief description. The settings are organized into categories, such as ""Virtual Channels"" and ""Scan Group,"" and include options like ""Channel Select,"" ""Sampling State Table ID,"" and ""Limit Clip Table ID."" The checkboxes allow the user to select or deselect each setting, and the descriptions provide more information about what each setting does.\n\nThe background of the image is a light gray color, which helps to make the text and checkboxes stand out. Overall, the image appears to be a screenshot of a computer program or software interface, possibly used for configuring the settings of a digital video camera.', 'The image shows a screenshot of a computer program\'s settings menu, specifically the ""g_adc0 ADC Driver on r_adc_b"" section. The menu is organized into two columns: ""Property"" and ""Value"". The ""Property"" column lists various settings, while the ""Value"" column displays the corresponding values for each setting.\n\n**Settings Menu**\n\n*   **Property**: Lists various settings, including:\n    *   Virtual Channels\n    *   Scan Groups\n    *   Scan Group 0\n    *   Scan Group 1\n    *   Self Diagnosis\n    *   External Trigger Enable\n    *   ELC Trigger Enable\n    *   GPT Trigger Enable\n    *   Converter Selection\n    *   Start Trigger Delay\n    *   Scan End Interrupt Enable\n    *   Limit Clip Interrupt Enable\n    *   FIFO Enable\n    *   FIFO Interrupt Enable\n    *   FIFO Interrupt Generation Level\n\n*   **Value**: Displays the corresponding values for each setting, including:\n    *   Scan Group 0: Scan Group 1\n    *   Scan Group 1: Self Diagnosis\n    *   External Trigger Enable: ELC Trigger Enable\n    *   ELC Trigger Enable: ELC Trigger Input 0 Enable\n    *   ELC Trigger Input 0 Enable: ELC Trigger Input 1 Enable\n    *   ELC Trigger Input 1 Enable: ELC Trigger Input 2 Enable\n    *   ELC Trigger Input 2 Enable: ELC Trigger Input 3 Enable\n    *   ELC Trigger Input 3 Enable: ELC Trigger Input 4 Enable\n    *   ELC Trigger Input 4 Enable: ELC Trigger Input 5 Enable\n    *   GPT Trigger Enable: Enable\n    *   Converter Selection: ADC 1\n    *   Start Trigger Delay: 0\n    *   Scan End Interrupt Enable: Enable\n    *   Limit Clip Interrupt Enable: Disable\n    *   FIFO Enable: Disable\n    *   FIFO Interrupt Enable: Disable\n    *   FIFO Interrupt Generation Level: 0\n\n**Summary**\n\nThe image shows a screenshot of a computer program\'s settings menu, specifically the ""g_adc0 ADC Driver on r_adc_b"" section. The menu is organized into two columns: ""Property"" and ""Value"". The ""Property"" column lists various settings, while the ""Value"" column displays the corresponding values for each setting. The settings include virtual channels, scan groups, self diagnosis, external trigger enable, ELC trigger enable, GPT trigger enable, converter selection, start trigger delay, scan end interrupt enable, limit clip interrupt enable, FIFO enable, FIFO interrupt enable, and FIFO interrupt generation level. The values for each setting are also displayed in the ""Value"" column.', 'The image shows a screenshot of a computer program with a list of settings. The title at the top reads ""g_adc0 ADC Driver on r_adc_b"" in black text. Below the title, there are two columns: ""Settings"" and ""API Info"". The ""Settings"" column has a dropdown menu with the following options:\n\n*   Property\n*   Scan Groups\n*   Scan Group 0\n*   Self Diagnosis\n*   External Trigger Enable\n*   ELC Trigger Enable\n*   GPT Trigger Enable\n*   Converter Selection\n*   Start Trigger Delay\n*   Scan End Interrupt Enable\n*   Limit Clip Interrupt Enable\n*   FIFO Enable\n*   FIFO Interrupt Enable\n*   FIFO Interrupt Generation Level\n\nThe ""API Info"" column is empty. The background of the image is white, with a light gray border around the edges. The overall design of the image suggests that it is a screenshot of a computer program used for configuring settings related to ADC drivers.', 'The image presents a table with two columns and six rows, accompanied by a yellow highlighted section in the middle. The table is divided into two main sections: the left column, labeled ""Total scan start processing time,"" and the right column, labeled ""Table 36.55."" The left column contains the following entries:\n\n*   tD_ADST\n*   tD_TRG\n*   tD_ITRG\n*   tD_SYOP\n*   tSH_SPL\n*   tSH_HLD\n*   tSH_D\n*   tDDA\n*   tAD_SPL\n*   tAD_CNV\n*   tADDP\n\nThe right column contains the following entries:\n\n*   Table 36.55\n*   Table 36.56\n*   Figure 36.56\n\nThe yellow highlighted section spans from the second row to the fifth row, covering the following entries:\n\n*   tSH_SPL\n*   tSH_HLD\n*   tSH_D\n*   tDDA\n\nThe table\'s background is white, providing a clean and clear visual representation of the data. Overall, the image appears to be a technical diagram or chart, likely used in a specific field or industry.', 'The image shows a screenshot of a computer screen with a table and a settings window. The table is titled ""A/D conversion characteristics (Common) (1 of 2)"" and has several columns, including ""Parameter"", ""Min"", ""Typ"", ""Max"", ""Unit"", and ""Test conditions"". The table contains data for various parameters, such as ""A/D conversion clock frequency(ADCLK)"" and ""Successive approximation time"".\n\nBelow the table, there is a settings window with the title ""g_adc0 ADC Driver on r_adc_b"". This window has several options, including ""Property"", ""Common"", ""Module g_adc0 ADC Driver on r_adc_b"", ""General"", ""Operation"", and ""ADC Successive Approximation Time"". The ""ADC Successive Approximation Time"" option is highlighted in red, indicating that it is the current setting.\n\nTo the right of the settings window, there is a large blue arrow pointing to the highlighted option. This suggests that the user is currently adjusting this setting.\n\nOverall, the image appears to be a screenshot of a computer program or software that is used to configure and adjust settings for an ADC (Analog-to-Digital Converter) driver. The user is likely using this program to fine-tune the settings for optimal performance.', 'The image shows a screenshot of a computer program with a table and text. The table is titled ""ADSYCR: A/D Converter Synchronous Operation Control Register"" and has several columns, including ""Bit position"", ""Bit field"", ""Value after reset"", and ""Bit field"". The table appears to be used to configure the settings for an A/D converter.\n\n*   **Table**\n    *   The table has 16 rows, each representing a different bit position in the register.\n    *   The ""Bit position"" column lists the bit positions from 0 to 15.\n    *   The ""Bit field"" column lists the corresponding bit fields for each bit position.\n    *   The ""Value after reset"" column lists the default values for each bit field after a reset.\n    *   The ""Bit field"" column lists the bit fields that can be set or cleared by the user.\n*   **Text**\n    *   Below the table, there is a section of text that explains the purpose of the register and how it is used.\n    *   The text also provides information on how to use the table to configure the settings for the A/D converter.\n*   **Button**\n    *   There is a button labeled ""Disable"" with a red box around it.\n    *   The button is located at the bottom right of the image and appears to be used to disable the A/D converter.\n*   **Arrow**\n    *   There is a gray arrow pointing to the right, which appears to be used to highlight the button.\n    *   The arrow is located at the top right of the image and points to the button.\n\nOverall, the image appears to be a screenshot of a computer program used to configure the settings for an A/D converter. The table provides a clear and organized way to view and modify the settings, and the text provides additional information on how to use the table. The button and arrow are used to draw attention to the disable function and provide a clear call to action.', 'The image shows a screenshot of a computer screen displaying a table and a list of settings. The table is titled ""A/D conversion characteristics (Common) (2 of 2)"" and has several columns, including ""Parameter"", ""Min"", ""Typ"", ""Max"", ""Unit"", and ""Test conditions"". The table appears to be a technical specification for an analog-to-digital (A/D) converter.\n\nBelow the table, there is a list of settings with the title ""g_adc0 ADC Driver on r_adc_b"". The list includes several options, such as ""Property"", ""Module g_adc0 ADC Driver on r_adc_b"", ""General"", ""Operation"", ""ADC Successive Approximation Time"", ""Synchronous Operation"", ""Calibration"", and ""Sampling State Table"". The list is likely used to configure the A/D converter.\n\nIn the bottom-right corner of the image, there is a red box with the number ""11"" inside it. This may indicate a specific setting or value that is being highlighted or emphasized.\n\nOverall, the image appears to be a technical document or configuration page for an A/D converter, with a table and list of settings that can be used to customize its behavior.', 'The image shows a table with a red box around the number 400, and a red box around the number 25.4. The table has several columns, including ""Channel dedicated sample and hold circuits"", ""Sampling time"", ""Self-calibration"", ""A/D conversion"", ""Hold mode switching time"", and ""Hold time"". The row with the red box around the number 400 is labeled ""1 x ADCyc + 400"", and the row with the red box around the number 25.4 is labeled ""Analog Channels 0-5"".\n\nThe table appears to be a technical specification or datasheet for an analog-to-digital converter (ADC) or a similar device. The numbers in the table likely represent various parameters or settings for the device, such as sampling time, self-calibration time, and hold time.\n\nThe red boxes around the numbers 400 and 25.4 may indicate that these values are important or critical for the device\'s operation. They could also represent a specific range or tolerance for these parameters.\n\nOverall, the image suggests that the table is providing detailed information about the technical specifications of an ADC or similar device, and the red boxes highlight key values that are relevant to its operation.', 'The image depicts a technical diagram illustrating the A/D conversion processing time for a hybrid mode with a channel-dedicated sample-and-hold circuit. The diagram is divided into two main sections: the left side, which shows the A/D conversion process, and the right side, which displays the channel-dedicated sample-and-hold circuit operation.\n\n**A/D Conversion Process (Left Side)**\n\n*   The A/D conversion process is represented by a series of boxes and arrows, indicating the flow of data through the system.\n*   The process begins with the start trigger, which initiates the conversion process.\n*   The data is then sampled and held, followed by the conversion process.\n*   The converted data is then output and stored in the ANI data buffer.\n\n**Channel-Dedicated Sample-and-Hold Circuit Operation (Right Side)**\n\n*   The channel-dedicated sample-and-hold circuit operation is represented by a series of boxes and arrows, indicating the flow of data through the system.\n*   The circuit operates in a hybrid mode, where it can be used in both sampling and hold modes.\n*   The circuit has multiple channels, each with its own sampling and hold capabilities.\n*   The data is sampled and held in each channel, and then converted and output.\n\n**Key Features**\n\n*   The diagram highlights the key features of the A/D conversion process and the channel-dedicated sample-and-hold circuit operation.\n*   The use of a hybrid mode allows for flexibility in the operation of the circuit.\n*   The multiple channels provide for simultaneous sampling and holding of data.\n\n**Conclusion**\n\nIn conclusion, the image provides a detailed diagram of the A/D conversion processing time for a hybrid mode with a channel-dedicated sample-and-hold circuit. The diagram highlights the key features of the process and the circuit operation, providing a clear understanding of how the system works.', 'The image shows a computer screen displaying an oscilloscope reading. The oscilloscope is a tool used to measure and visualize electrical signals, and the reading on the screen appears to be a waveform or signal pattern.\n\n*   **Oscilloscope Screen:**\n    *   The oscilloscope screen is black with white and pink lines and symbols.\n    *   There are several lines and symbols on the screen, including a horizontal line at the top, a vertical line on the left, and various symbols and markings throughout.\n    *   The screen also displays a grid pattern, which is used to measure and analyze the signal.\n*   **Menu Bar:**\n    *   The menu bar is located at the top of the screen and contains several options, including ""Display"", ""Type"", ""Trace"", ""Setup"", and ""Remote"".\n    *   Each option has a corresponding icon or symbol next to it, which indicates the function or feature associated with that option.\n*   **Buttons:**\n    *   There are several buttons located below the menu bar, including ""OFF"", ""UN"", ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""0"", and ""Enter"".\n    *   These buttons are used to interact with the oscilloscope and perform various functions, such as turning the device on or off, selecting a measurement mode, or entering a value.\n*   **Background:**\n    *   The background of the image is a plain gray color, which helps to focus attention on the oscilloscope screen and its contents.\n\nOverall, the image provides a clear view of an oscilloscope screen and its various components, including the menu bar, buttons, and background. The image suggests that the oscilloscope is being used to measure and analyze an electrical signal, and the various options and features available on the device are being utilized to achieve this goal.', 'The image shows a computer screen displaying an oscilloscope, which is a tool used to visualize and measure the waveform of electrical signals. The oscilloscope is set to display a waveform with a frequency of 1.25 MHz, as indicated by the label ""1.25 MHz"" at the top of the screen.\n\nThe waveform is displayed on a grid, with the x-axis representing time and the y-axis representing voltage. The waveform is a sinusoidal signal, with a peak-to-peak amplitude of approximately 2 volts. The signal is also modulated, with a frequency of 500 kHz.\n\nThe oscilloscope has several controls and settings that can be adjusted to customize the display. These include the ""Zoom"" button, which allows the user to zoom in on a specific portion of the waveform, and the ""Cursor"" button, which allows the user to place a cursor on the waveform to measure its characteristics.\n\nOverall, the image suggests that the oscilloscope is being used to analyze and measure the characteristics of an electrical signal, possibly in a laboratory or testing environment.', 'The image shows a screenshot of a computer program\'s settings menu, specifically the ""API Info"" section. The title at the top reads ""g_adc0 ADC Driver on r_adc_b"". \n\n*   **Settings Menu**\n    *   The menu is divided into two columns: ""Property"" and ""Value"".\n    *   The ""Property"" column lists various settings, such as ""Common"", ""Parameter Checking"", ""Module g_adc0 ADC Driver on r_adc_b"", ""General"", ""Operation"", ""ADC 0"", ""Conversion Method"", ""Scan Mode"", ""ADC 1"", and ""Conversion Method"".\n    *   The ""Value"" column displays the corresponding values for each setting, including ""Default (BSP)"", ""Hybrid Mode"", ""Background Continuous Scan (Hybrid Conversion Method Only)"", and ""Scan Mode"".\n*   **API Info Section**\n    *   The ""API Info"" section is highlighted in blue, indicating that it is the current selection.\n    *   The section includes a dropdown menu with options for ""Common"", ""Parameter Checking"", ""Module g_adc0 ADC Driver on r_adc_b"", ""General"", ""Operation"", ""ADC 0"", ""Conversion Method"", ""Scan Mode"", ""ADC 1"", and ""Conversion Method"".\n*   **Background**\n    *   The background of the image is white, providing a clean and neutral backdrop for the settings menu.\n\nOverall, the image shows a detailed view of a computer program\'s settings menu, with various options and values displayed in a clear and organized manner.', 'The image shows a list of settings for a computer program, with the majority of the settings highlighted in red. The highlighted settings are:\n\n* Channel Select\n* Sampling State Table ID\n* Channel Gain Table\n* Channel Offset Table\n* Add/Average Mode\n* Add/Average Count\n* Limit Clip Table ID\n* Conversion Resolution Format Select\n* Digital Filter Selection\n* Virtual Channel 2\n* Scan Group\n* Sampling State Entry 0\n* Disabled\n* 1-time conversion (Normal Conversion)\n* Disabled\n* 16-bit Data Format\n* Sync3 (Over Sampling Rate = 8)\n* None\n\nThe remaining settings are not highlighted and appear to be default or standard settings. The image suggests that the highlighted settings are specific to a particular application or use case, and may require customization or adjustment to achieve the desired results.', 'The image shows a table with two columns and 14 rows. The first column is labeled ""Property"" and the second column is labeled ""Value"". The table appears to be a list of properties and their corresponding values.\n\nHere are the details of the table:\n\n*   **Scan Groups**\n    *   Scan Group 0\n    *   Self Diagnosis\n    *   External Trigger Enable\n    *   ELC Trigger Enable\n    *   GPT Trigger Enable\n*   **Enable**\n    *   Enable\n    *   Converter Selection\n    *   Start Trigger Delay\n    *   Scan End Interrupt Enable\n    *   Limit Clip Interrupt Enable\n    *   FIFO Enable\n    *   FIFO Interrupt Enable\n    *   FIFO Interrupt Generation Level\n*   **ADC 0**\n    *   Enable\n\nThe table suggests that the properties are related to the configuration of a device or system, and the values represent the current settings or status of these properties.', 'The image shows a screenshot of a computer program\'s settings menu, specifically the ""API Info"" section. The title at the top reads ""g_adc0 ADC Driver on r_adc_b"". \n\nBelow the title, there are two columns: ""Property"" and ""Value"". The ""Property"" column lists various settings, such as ""Scan Group 0"", ""Scan Group 1"", ""Self Diagnosis"", ""External Trigger Enable"", ""ELC Trigger Enable"", ""GPT Trigger Enable"", ""Converter Selection"", ""Start Trigger Delay"", ""Scan End Interrupt Enable"", ""Limit Clip Interrupt Enable"", ""FIFO Enable"", ""FIFO Interrupt Enable"", and ""FIFO Interrupt Generation Level"". \n\nThe ""Value"" column shows the corresponding values for each setting, which are all set to ""Enable"" or ""Disable"". The background of the image is white, with a light blue bar at the top. Overall, the image appears to be a screenshot of a computer program\'s settings menu, likely used for configuring the settings of an ADC (Analog-to-Digital Converter) driver.', 'The image shows a screenshot of a computer program, specifically a user event consumption window. The window is titled ""User Events Consumed"" and has two columns: ""Peripheral Function"" and ""Event"". \n\n*   The ""Peripheral Function"" column lists the following events:\n    *   ADC12AO\n    *   GPT4 CAPTURE COMPARE A (Compare match A)\n*   The ""Event"" column lists the following events:\n    *   Event\n    *   GPT4 CAPTURE COMPARE A (Compare match A)\n\nThe window also has buttons at the top for ""New User Event"" and ""Remove"". The background of the window is light blue, with a darker gray bar at the bottom. Overall, the image appears to be a screenshot of a computer program used to manage user events.', 'The image shows a screenshot of a computer program with a dropdown menu and checkboxes. The dropdown menu is titled ""Scan Group 0"" and has several options, including ""Self Diagnosis"", ""External Trigger Enable"", and ""ELC Trigger Enable"". The ""ELC Trigger Enable"" option is selected, and a checkbox next to it is checked.\n\nBelow the dropdown menu, there are several checkboxes with the text ""ELC Trigger Input 0 Enable"", ""ELC Trigger Input 1 Enable"", ""ELC Trigger Input 2 Enable"", ""ELC Trigger Input 3 Enable"", ""ELC Trigger Input 4 Enable"", and ""ELC Trigger Input 5 Enable"". All of these checkboxes are unchecked except for the first one, which is checked.\n\nThe background of the image is white, with a light blue bar behind the dropdown menu and checkboxes. The overall appearance of the image suggests that it is a screenshot of a computer program used for configuring or troubleshooting a device or system.', 'The image shows a screenshot of a computer program with a dropdown menu and checkboxes. The dropdown menu is titled ""Scan Group 1"" and has several options, including ""Self Diagnosis"", ""External Trigger Enable"", and ""ELC Trigger Enable"". The ""ELC Trigger Enable"" option is selected, and a checkbox next to it is checked.\n\nBelow the dropdown menu, there are several checkboxes with the text ""ELC Trigger Input 0 Enable"", ""ELC Trigger Input 1 Enable"", ""ELC Trigger Input 2 Enable"", ""ELC Trigger Input 3 Enable"", ""ELC Trigger Input 4 Enable"", and ""ELC Trigger Input 5 Enable"". All of these checkboxes are unchecked except for the first one, which is checked.\n\nThe background of the image is white, with a light blue bar behind the dropdown menu and checkboxes. The overall appearance of the image suggests that it is a screenshot of a computer program used for configuring or testing some kind of device or system.', 'The image shows a screenshot of a computer program with a list of settings. The title at the top reads ""g_timer1 Timer, General PWM (r_gpt)"" in black text. Below the title, there is a gray bar with the word ""Settings"" in blue text on the left side and ""API Info"" in blue text on the right side.\n\nBelow the gray bar, there is a list of settings with their corresponding values. The settings are listed in a table format with two columns: ""Property"" and ""Value"". The ""Property"" column lists various settings such as ""Parameter Checking"", ""Pin Output Support"", ""Write Protect Enable"", ""Clock Source"", ""Module g_timer1 Timer, General PWM (r_gpt)"", ""General"", ""Name"", ""Channel"", ""Mode"", ""Period"", ""Period Unit"", ""Output"", ""Custom Waveform"", ""GTIOA"", ""Initial Output Level"", ""Cycle End Output Level"", ""Compare Match Output Level"", ""Retain Output Level at Count Stop"", and ""GTIOB"". The ""Value"" column lists the corresponding values for each setting, such as ""Default (BSP)"", ""Enabled"", ""Disabled"", ""PCLKD"", ""g_timer1"", ""4"", ""Periodic"", ""15"", ""Microseconds"", ""Pin Level Low"", ""Pin Level Low"", ""Pin Level High"", ""Disabled"", and ""Enabled"".\n\nThe background of the image is white, with a gray bar at the top and a gray border around the edges. Overall, the image appears to be a screenshot of a computer program used for configuring settings related to a timer or pulse width modulation (PWM) module.', 'The image shows a screenshot of a computer program\'s settings menu, specifically the ""g_timer1 Timer, General PWM (r_gpt)"" section. The menu is organized into two columns: ""Settings"" and ""API Info"". The ""Settings"" column lists various options, including ""Property"", ""Common"", ""Module g_timer1 Timer, General PWM (r_gpt)"", ""General"", ""Output"", ""Input"", ""Interrupts"", ""Callback"", ""Overflow/Crest Interrupt Priority"", ""Capture A Interrupt Priority"", ""Capture B Interrupt Priority"", and ""Underflow/Trough Interrupt Priority"". The ""API Info"" column provides additional information about each option.\n\nThe ""Priority 11"" option is highlighted in red, indicating that it is the current setting. The background of the image is white, with a gray bar at the top containing the title ""g_timer1 Timer, General PWM (r_gpt)"". Overall, the image appears to be a screenshot of a computer program\'s settings menu, specifically the ""g_timer1 Timer, General PWM (r_gpt)"" section.', 'The image shows a screenshot of a computer program\'s settings menu, with the title ""g_adc0 ADC Driver on r_adc_b"" at the top. The menu is organized into two columns: ""Settings"" and ""API Info"". The ""Settings"" column has several options, including ""Property"", ""Clock Configuration"", ""Interrupts"", ""Limiter Clip Priority"", ""Conversion Error Priority"", ""Overflow Priority"", ""Calibration End Priority"", ""ADC 0"", ""ADC 1"", ""Scan End Priority"", ""FIFO Priorities"", and ""Callback"". The ""API Info"" column has only one option, ""adc_callback"".\n\nThe ""Priority 12"" option is highlighted in red, indicating that it is the current setting. The background of the image is white, with a gray bar at the top containing the title and a blue bar on the left side with the word ""Settings"" in blue text.\n\nOverall, the image appears to be a screenshot of a computer program\'s settings menu, specifically the ""g_adc0 ADC Driver on r_adc_b"" driver. The highlighted ""Priority 12"" option suggests that this is the current setting for the driver.', 'The image shows a screen displaying a graph with multiple lines, likely from an oscilloscope. The graph has a black background with white grid lines and various colored lines representing different signals. The top of the screen has a blue bar with white text that reads ""YOKOGAWA"" and ""2022/12/01 18:21:42"". Below this, there are several buttons and menus, including ""Normal"", ""Edge CH3"", and ""Auto"". The main part of the screen displays the graph, with the x-axis labeled ""Time"" and the y-axis labeled ""Voltage"". There are several lines on the graph, each representing a different signal, and they appear to be oscillating or pulsing. The overall appearance of the image suggests that it is a screenshot of an oscilloscope display, possibly used for testing or debugging electronic circuits.', 'The image presents a detailed diagram of an A/D converter operation, showcasing the various stages involved in the process. The diagram is divided into several sections, each representing a different stage of the operation.\n\n*   **Start Trigger**\n    *   The start trigger is the initial signal that initiates the A/D converter operation.\n    *   It is represented by a vertical line on the left side of the diagram.\n*   **Initial Scanning Operation**\n    *   The initial scanning operation involves the selection of the first channel (AN000) for conversion.\n    *   This is represented by a horizontal line that extends from the start trigger to the first channel.\n*   **A/D Converter Operation**\n    *   The A/D converter operation involves the conversion of the selected channel (AN000) into a digital signal.\n    *   This is represented by a series of horizontal lines that extend from the initial scanning operation to the A/D converter operation.\n*   **Scan End Interrupt**\n    *   The scan end interrupt is the signal that indicates the end of the scanning operation.\n    *   It is represented by a vertical line on the right side of the diagram.\n*   **A/D Conversion Result of AN000**\n    *   The A/D conversion result of AN000 is the digital signal that represents the converted value of the first channel.\n    *   This is represented by a horizontal line that extends from the A/D converter operation to the A/D conversion result of AN000.\n*   **A/D Conversion Result of AN002**\n    *   The A/D conversion result of AN002 is the digital signal that represents the converted value of the second channel.\n    *   This is represented by a horizontal line that extends from the A/D converter operation to the A/D conversion result of AN002.\n*   **A/D Conversion Result of AN004**\n    *   The A/D conversion result of AN004 is the digital signal that represents the converted value of the fourth channel.\n    *   This is represented by a horizontal line that extends from the A/D converter operation to the A/D conversion result of AN004.\n\nIn summary, the diagram provides a detailed overview of the A/D converter operation, highlighting the various stages involved in the process. The diagram shows how the start trigger initiates the operation, and how the initial scanning operation selects the first channel for conversion. The A/D converter operation then converts the selected channel into a digital signal, which is represented by the A/D conversion result of AN000, AN002, and AN004. The scan end interrupt signal indicates the end of the scanning operation.']"
0b441b2f3da18a0e27fe2a3d466172f7,"Issue:
Some Renesas Cortex-M33 MCUs are equipped with two caches to improve performance. The c-cache is on the instruction bus and the s-cache is on the data bus, between the Cortex-M33 and AHB bus matrix. When the s-cache is enabled, users may experience communication failures with such as:
External QSPI memory
External OSPI memory
Shared memory with CPU in SRAM (Ethernet, Segger RTT viewer)
Answers:
There are two ways to solve this issue:
Use the s-cache flush (invalidate/clean) command.
Use the MPU (Memory protection unit).
For more information about s-cache flush usage, cache coherency issues with DMA/DTC, and MPU, please refer to the links below.
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the “Description” at the bottom of this article for details on each MPU setting. 
The following defines are to be commonly used in all 3 cases to be explained.
#define CTRL_PV 1
#define CTRL_HN 1
#define ARM_MPU_CTRL(PV, HN) \
  (((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \
  ((HN) << MPU_CTRL_HFNMIENA_Pos))
  #define MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04
#define MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0
#define MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA
#define MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1
#define MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF
#define MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3

(1) External QSPI memory
Use the code below to disable the s-cache on QSPI memory locations. If your MCU has a different address map for QSPI, please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
0x6000 0000 - 0x63FF FFFF : External SPI device
0x6400 0000 - 0x67FF FFFF : QSPI I/O registers
const ARM_MPU_Region_t mpuTable[2] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                        LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
      //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }
};
  void mpu_config_quadspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_quadspi();
enable_s_cache();
  qspi_init();
    while(1)
  {
  (2) External OSPI memory
Use the code below to disable the s-cache on OSPI area. If your MCU has a different address map for OSPI, please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
0x6800 0000 - 0x6FFF FFFF : CS0
0x7000 0000 - 0x7FFF FFFF : CS1
void mpu_config_octaspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_octaspi();
enable_s_cache();
  ospi_init();
    while(1)
  {
  (3) Shared memory with CPU in SRAM
Ethernet (EDMAC)
Use the code below to disable the s-cache on the EDMAC descriptors and buffers area. The default linker script of the e2 studio project places the EDMAC descriptors and buffers in the "".ns_buffer.eth"" section, and these addresses are likely to change with code changes. Therefore, change the addresses of “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly, or place the EDMAC descriptors and buffers in a section with fixed address.
Figure.1 Memory map file snippet (EDMAC)
With the given memory map file snippet example above, the memory area covering EDMAC descriptors and buffers will be:
Start address: 0x2003 CF80
End address: 0x2003 FFFF (0x2003CF80 + 0x3080 – 1)
Please note that MPU addresses should be aligned in multiples of 32-byte.
const ARM_MPU_Region_t mpuTable[1] = {
    //                       BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                       LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_eth(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_eth();
enable_s_cache();
    while(1)
  {
  Segger RTT Viewer
Use the code below to disable the s-cache on the Segger RTT area. The Segger RTT uses some of user SRAM to output debug information, and receive input from the user. The start and end addresses for the 3 regions below can be found in the memory map file after compilation of your project, so please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
.bss._SEGGER_RTT
.bss._acUpBuffer
.bss._acDownBuffer
Figure.2 Memory map file snippet (Segger RTT Viewer)
With the given memory map file snippet example above, the memory area covering all 3 regions will be:
Start address: 0x2000 01D4
End address: 0x2000 128B
MPU addresses should be aligned in multiples of 32-byte, so
Start address: 0x2000 01C0
End address: 0x2000 129F
const ARM_MPU_Region_t mpuTable[1] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_rtt(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_rtt();
enable_s_cache();
  SEGGER_RTT_printf(“HELLO”);
    while(1)
  {
  Arm Cortex-M33 Processor Technical Reference Manual
https://documentation-service.arm.com/static/5f15c42420b7cf4bc5247f3a
Armv8-M Architecture Reference Manual
https://documentation-service.arm.com/static/5f8efe85f86e16515cdbe596
Guidelines for Using the S Cache on the System Bus
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
Suitable Products
RA Family
Some Renesas Cortex-M33 MCUs are equipped with two caches to improve performance. The c-cache is on the instruction bus and the s-cache is on the data bus, between the Cortex-M33 and AHB bus matrix. When the s-cache is enabled, users may experience communication failures with such as:
Answers:
There are two ways to solve this issue:
Use the s-cache flush (invalidate/clean) command.
Use the MPU (Memory protection unit).
For more information about s-cache flush usage, cache coherency issues with DMA/DTC, and MPU, please refer to the links below.
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the “Description” at the bottom of this article for details on each MPU setting. 
The following defines are to be commonly used in all 3 cases to be explained.
#define CTRL_PV 1
#define CTRL_HN 1
#define ARM_MPU_CTRL(PV, HN) \
  (((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \
  ((HN) << MPU_CTRL_HFNMIENA_Pos))
  #define MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04
#define MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0
#define MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA
#define MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1
#define MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF
#define MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3

(1) External QSPI memory
Use the code below to disable the s-cache on QSPI memory locations. If your MCU has a different address map for QSPI, please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
0x6000 0000 - 0x63FF FFFF : External SPI device
0x6400 0000 - 0x67FF FFFF : QSPI I/O registers
const ARM_MPU_Region_t mpuTable[2] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                        LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
      //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }
};
  void mpu_config_quadspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_quadspi();
enable_s_cache();
  qspi_init();
    while(1)
  {
  (2) External OSPI memory
Use the code below to disable the s-cache on OSPI area. If your MCU has a different address map for OSPI, please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
0x6800 0000 - 0x6FFF FFFF : CS0
0x7000 0000 - 0x7FFF FFFF : CS1
void mpu_config_octaspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_octaspi();
enable_s_cache();
  ospi_init();
    while(1)
  {
  (3) Shared memory with CPU in SRAM
Ethernet (EDMAC)
Use the code below to disable the s-cache on the EDMAC descriptors and buffers area. The default linker script of the e2 studio project places the EDMAC descriptors and buffers in the "".ns_buffer.eth"" section, and these addresses are likely to change with code changes. Therefore, change the addresses of “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly, or place the EDMAC descriptors and buffers in a section with fixed address.
Figure.1 Memory map file snippet (EDMAC)
With the given memory map file snippet example above, the memory area covering EDMAC descriptors and buffers will be:
Start address: 0x2003 CF80
End address: 0x2003 FFFF (0x2003CF80 + 0x3080 – 1)
Please note that MPU addresses should be aligned in multiples of 32-byte.
const ARM_MPU_Region_t mpuTable[1] = {
    //                       BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                       LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_eth(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_eth();
enable_s_cache();
    while(1)
  {
  Segger RTT Viewer
Use the code below to disable the s-cache on the Segger RTT area. The Segger RTT uses some of user SRAM to output debug information, and receive input from the user. The start and end addresses for the 3 regions below can be found in the memory map file after compilation of your project, so please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
.bss._SEGGER_RTT
.bss._acUpBuffer
.bss._acDownBuffer
Figure.2 Memory map file snippet (Segger RTT Viewer)
With the given memory map file snippet example above, the memory area covering all 3 regions will be:
Start address: 0x2000 01D4
End address: 0x2000 128B
MPU addresses should be aligned in multiples of 32-byte, so
Start address: 0x2000 01C0
End address: 0x2000 129F
const ARM_MPU_Region_t mpuTable[1] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_rtt(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_rtt();
enable_s_cache();
  SEGGER_RTT_printf(“HELLO”);
    while(1)
  {
  Arm Cortex-M33 Processor Technical Reference Manual
https://documentation-service.arm.com/static/5f15c42420b7cf4bc5247f3a
Armv8-M Architecture Reference Manual
https://documentation-service.arm.com/static/5f8efe85f86e16515cdbe596
Guidelines for Using the S Cache on the System Bus
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
Suitable Products
RA Family
There are two ways to solve this issue:
Use the s-cache flush (invalidate/clean) command.
Use the MPU (Memory protection unit).
For more information about s-cache flush usage, cache coherency issues with DMA/DTC, and MPU, please refer to the links below.
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the “Description” at the bottom of this article for details on each MPU setting. 
The following defines are to be commonly used in all 3 cases to be explained.
#define CTRL_PV 1
#define CTRL_HN 1
#define ARM_MPU_CTRL(PV, HN) \
  (((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \
  ((HN) << MPU_CTRL_HFNMIENA_Pos))
  #define MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04
#define MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0
#define MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA
#define MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1
#define MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF
#define MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3

(1) External QSPI memory
Use the code below to disable the s-cache on QSPI memory locations. If your MCU has a different address map for QSPI, please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
0x6000 0000 - 0x63FF FFFF : External SPI device
0x6400 0000 - 0x67FF FFFF : QSPI I/O registers
const ARM_MPU_Region_t mpuTable[2] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                        LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
      //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }
};
  void mpu_config_quadspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_quadspi();
enable_s_cache();
  qspi_init();
    while(1)
  {
  (2) External OSPI memory
Use the code below to disable the s-cache on OSPI area. If your MCU has a different address map for OSPI, please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
0x6800 0000 - 0x6FFF FFFF : CS0
0x7000 0000 - 0x7FFF FFFF : CS1
void mpu_config_octaspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_octaspi();
enable_s_cache();
  ospi_init();
    while(1)
  {
  (3) Shared memory with CPU in SRAM
Ethernet (EDMAC)
Use the code below to disable the s-cache on the EDMAC descriptors and buffers area. The default linker script of the e2 studio project places the EDMAC descriptors and buffers in the "".ns_buffer.eth"" section, and these addresses are likely to change with code changes. Therefore, change the addresses of “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly, or place the EDMAC descriptors and buffers in a section with fixed address.
Figure.1 Memory map file snippet (EDMAC)
With the given memory map file snippet example above, the memory area covering EDMAC descriptors and buffers will be:
Start address: 0x2003 CF80
End address: 0x2003 FFFF (0x2003CF80 + 0x3080 – 1)
Please note that MPU addresses should be aligned in multiples of 32-byte.
const ARM_MPU_Region_t mpuTable[1] = {
    //                       BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                       LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_eth(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_eth();
enable_s_cache();
    while(1)
  {
  Segger RTT Viewer
Use the code below to disable the s-cache on the Segger RTT area. The Segger RTT uses some of user SRAM to output debug information, and receive input from the user. The start and end addresses for the 3 regions below can be found in the memory map file after compilation of your project, so please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
.bss._SEGGER_RTT
.bss._acUpBuffer
.bss._acDownBuffer
Figure.2 Memory map file snippet (Segger RTT Viewer)
With the given memory map file snippet example above, the memory area covering all 3 regions will be:
Start address: 0x2000 01D4
End address: 0x2000 128B
MPU addresses should be aligned in multiples of 32-byte, so
Start address: 0x2000 01C0
End address: 0x2000 129F
const ARM_MPU_Region_t mpuTable[1] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_rtt(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_rtt();
enable_s_cache();
  SEGGER_RTT_printf(“HELLO”);
    while(1)
  {
  Arm Cortex-M33 Processor Technical Reference Manual
https://documentation-service.arm.com/static/5f15c42420b7cf4bc5247f3a
Armv8-M Architecture Reference Manual
https://documentation-service.arm.com/static/5f8efe85f86e16515cdbe596
Guidelines for Using the S Cache on the System Bus
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
There are two ways to solve this issue:
For more information about s-cache flush usage, cache coherency issues with DMA/DTC, and MPU, please refer to the links below.
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the “Description” at the bottom of this article for details on each MPU setting.
The following defines are to be commonly used in all 3 cases to be explained.
#define CTRL_PV 1
#define
CTRL_PV 1
#define CTRL_HN 1
#define
CTRL_HN 1
#define ARM_MPU_CTRL(PV, HN) \
#define
ARM_MPU_CTRL(PV, HN) \
(((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \
(((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \
((HN) << MPU_CTRL_HFNMIENA_Pos))
((HN) << MPU_CTRL_HFNMIENA_Pos))
#define MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04
#define
MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04
#define MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0
#define
MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0
#define MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA
#define
MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA
#define MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1
#define
MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1
#define MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF
#define
MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF
#define MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2
#define
MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44
#define
MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3
#define
MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3
(1) External QSPI memory
Use the code below to disable the s-cache on QSPI memory locations. If your MCU has a different address map for QSPI, please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
0x6000 0000 - 0x63FF FFFF : External SPI device
0x6400 0000 - 0x67FF FFFF : QSPI I/O registers
const ARM_MPU_Region_t mpuTable[2] = {
const
ARM_MPU_Region_t
mpuTable[2] = {
//                         BASE          SH              RO   NP   XN
//                         BASE          SH              RO   NP   XN
{ .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
{ .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
//                        LIMIT         ATTR
//                        LIMIT         ATTR
.RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
.RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
//                         BASE          SH              RO   NP   XN
//                         BASE          SH              RO   NP   XN
{ .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
{ .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
//                         LIMIT         ATTR
//                         LIMIT         ATTR
.RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }
.RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }
};
};
void mpu_config_quadspi(void)
void
mpu_config_quadspi(
void
)
{
{
ARM_MPU_Disable();
ARM_MPU_Disable();
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_Load(0, mpuTable, 2);
ARM_MPU_Load(0, mpuTable, 2);
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
}
void hal_entry(void)
void
hal_entry(
void
)
{
{
mpu_config_quadspi();
mpu_config_quadspi();
enable_s_cache();
enable_s_cache();
qspi_init();
qspi_init();
while(1)
while
(1)
{
(2) External OSPI memory
Use the code below to disable the s-cache on OSPI area. If your MCU has a different address map for OSPI, please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
0x6800 0000 - 0x6FFF FFFF : CS0
0x7000 0000 - 0x7FFF FFFF : CS1
void mpu_config_octaspi(void)
void
mpu_config_octaspi(
void
)
{
{
ARM_MPU_Disable();
ARM_MPU_Disable();
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_Load(0, mpuTable, 2);
ARM_MPU_Load(0, mpuTable, 2);
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
}
void hal_entry(void)
void
hal_entry(
void
)
{
{
mpu_config_octaspi();
mpu_config_octaspi();
enable_s_cache();
enable_s_cache();
ospi_init();
ospi_init();
while(1)
while
(1)
{
(3) Shared memory with CPU in SRAM
Ethernet (EDMAC)
Use the code below to disable the s-cache on the EDMAC descriptors and buffers area. The default linker script of the e2 studio project places the EDMAC descriptors and buffers in the "".ns_buffer.eth"" section, and these addresses are likely to change with code changes. Therefore, change the addresses of “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly, or place the EDMAC descriptors and buffers in a section with fixed address.
Figure.1 Memory map file snippet (EDMAC)
With the given memory map file snippet example above, the memory area covering EDMAC descriptors and buffers will be:
Start address: 0x2003 CF80
End address: 0x2003 FFFF (0x2003CF80 + 0x3080 – 1)
Please note that MPU addresses should be aligned in multiples of 32-byte.
const ARM_MPU_Region_t mpuTable[1] = {
const
ARM_MPU_Region_t
mpuTable[1] = {
//                       BASE          SH              RO   NP   XN
//                       BASE          SH              RO   NP   XN
{ .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
{ .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
//                       LIMIT         ATTR
//                       LIMIT         ATTR
.RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
.RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
};
void mpu_config_eth(void)
void
mpu_config_eth(
void
)
{
{
ARM_MPU_Disable();
ARM_MPU_Disable();
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_Load(0, mpuTable, 1);
ARM_MPU_Load(0, mpuTable, 1);
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
}
void hal_entry(void)
void
hal_entry(
void
)
{
{
mpu_config_eth();
mpu_config_eth();
enable_s_cache();
enable_s_cache();
while(1)
while
(1)
{
Segger RTT Viewer
Use the code below to disable the s-cache on the Segger RTT area. The Segger RTT uses some of user SRAM to output debug information, and receive input from the user. The start and end addresses for the 3 regions below can be found in the memory map file after compilation of your project, so please change addresses in “ARM_MPU_RBAR” and “ARM_MPU_RLAR” accordingly.
.bss._SEGGER_RTT
.bss._acUpBuffer
.bss._acDownBuffer
Figure.2 Memory map file snippet (Segger RTT Viewer)
With the given memory map file snippet example above, the memory area covering all 3 regions will be:
Start address: 0x2000 01D4
End address: 0x2000 128B
MPU addresses should be aligned in multiples of 32-byte, so
Start address: 0x2000 01C0
End address: 0x2000 129F
const ARM_MPU_Region_t mpuTable[1] = {
const
ARM_MPU_Region_t
mpuTable[1] = {
//                         BASE          SH              RO   NP   XN
//                         BASE          SH              RO   NP   XN
{ .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
{ .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
//                         LIMIT         ATTR
//                         LIMIT         ATTR
.RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
.RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
};
void mpu_config_rtt(void)
void
mpu_config_rtt(
void
)
{
{
ARM_MPU_Disable();
ARM_MPU_Disable();
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_Load(0, mpuTable, 1);
ARM_MPU_Load(0, mpuTable, 1);
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
}
void hal_entry(void)
void
hal_entry(
void
)
{
{
mpu_config_rtt();
mpu_config_rtt();
enable_s_cache();
enable_s_cache();
SEGGER_RTT_printf(“HELLO”);
SEGGER_RTT_printf(
“HELLO”
);
while(1)
while
(1)
{
Arm Cortex-M33 Processor Technical Reference Manual
https://documentation-service.arm.com/static/5f15c42420b7cf4bc5247f3a
Armv8-M Architecture Reference Manual
https://documentation-service.arm.com/static/5f8efe85f86e16515cdbe596
Guidelines for Using the S Cache on the System Bus
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
Suitable Products
RA Family","['data/categories/ra_family/ra_and_fsp_technical_articles/0b441b2f3da18a0e27fe2a3d466172f7/images/79980aa685ea1d6d72e111c70c00cf46.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/0b441b2f3da18a0e27fe2a3d466172f7/images/7c3091d22fb397d570ab025366582248.png']",[],"['|  |\n|  |\n| #define CTRL_PV 1\n#define CTRL_HN 1\n#define ARM_MPU_CTRL(PV, HN) \\\n  (((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \\\n  ((HN) << MPU_CTRL_HFNMIENA_Pos))\n  #define MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04\n#define MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0\n#define MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA\n#define MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1\n#define MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF\n#define MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2\n#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44\n#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3 |', '|  |\n|  |\n| const ARM_MPU_Region_t mpuTable[2] = {\n    //                         BASE          SH              RO   NP   XN\n    { .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),\n    //                        LIMIT         ATTR\n      .RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },\n      //                         BASE          SH              RO   NP   XN\n    { .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),\n    //                         LIMIT         ATTR\n      .RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }\n};\n  void mpu_config_quadspi(void)\n{\nARM_MPU_Disable();\n    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);\n    ARM_MPU_Load(0, mpuTable, 2);\n    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));\n}\n  void hal_entry(void)\n{\n  mpu_config_quadspi();\nenable_s_cache();\n  qspi_init();\n    while(1)\n  { |', '|  |\n|  |\n| void mpu_config_octaspi(void)\n{\nARM_MPU_Disable();\n    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);\n    ARM_MPU_Load(0, mpuTable, 2);\n    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));\n}\n  void hal_entry(void)\n{\n  mpu_config_octaspi();\nenable_s_cache();\n  ospi_init();\n    while(1)\n  { |', '|  |\n|  |\n| const ARM_MPU_Region_t mpuTable[1] = {\n    //                       BASE          SH              RO   NP   XN\n    { .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),\n    //                       LIMIT         ATTR\n      .RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },\n};\n  void mpu_config_eth(void)\n{\nARM_MPU_Disable();\n    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);\n    ARM_MPU_Load(0, mpuTable, 1);\n    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));\n}\n  void hal_entry(void)\n{\n  mpu_config_eth();\nenable_s_cache();\n    while(1)\n  { |', '|  |\n|  |\n| const ARM_MPU_Region_t mpuTable[1] = {\n    //                         BASE          SH              RO   NP   XN\n    { .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),\n    //                         LIMIT         ATTR\n      .RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },\n};\n  void mpu_config_rtt(void)\n{\nARM_MPU_Disable();\n    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);\n    ARM_MPU_Load(0, mpuTable, 1);\n    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));\n}\n  void hal_entry(void)\n{\n  mpu_config_rtt();\nenable_s_cache();\n  SEGGER_RTT_printf(“HELLO”);\n    while(1)\n  { |', '|  |\n|  |\n| RA Family |']","{'title': 'RA Family: Potential Issues when s-cache is enabled without MPU configuration in Cortex-M33 MCU', 'url': 'https://en-support.renesas.com/knowledgeBase/20892495', 'last_updated': None, 'extracted_at': '2025-03-08T23:12:51.120380'}","Issue Some Renesas Cortex-M33 MCUs are equipped with two caches to improve performance. The c-cache is on the instruction bus and the s-cache is on the data bus, between the Cortex-M33 and AHB bus matrix. When the s-cache is enabled, users may experience communication failures with such as External QSPI memory External OSPI memory Shared memory with CPU in SRAM (Ethernet, Segger RTT viewer) Answers There are two ways to solve this issue Use the s-cache flush (invalidate/clean) command. Use the MPU (Memory protection unit). For more information about s-cache flush usage, cache coherency issues with DMA/DTC, and MPU, please refer to the links below. https//www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the Description at the bottom of this article for details on each MPU setting. The following defines are to be commonly used in all 3 cases to be explained. define CTRLPV 1 define CTRLHN 1 define ARMMPUCTRL(PV, HN)  (((PV)  MPUCTRLPRIVDEFENAPos)   ((HN)  MPUCTRLHFNMIENAPos)) define MPUARMV8MMAIRATTRDEVICEVAL 0x04 define MPUARMV8MMAIRATTRDEVICEIDX 0 define MPUARMV8MMAIRATTRCODEVAL 0xAA define MPUARMV8MMAIRATTRCODEIDX 1 define MPUARMV8MMAIRATTRDATAVAL 0xFF define MPUARMV8MMAIRATTRDATAIDX 2 define MPUARMV8MMAIRATTRDATANOCACHEVAL 0x44 define MPUARMV8MMAIRATTRDATANOCACHEIDX 3 (1) External QSPI memory Use the code below to disable the s-cache on QSPI memory locations. If your MCU has a different address map for QSPI, please change addresses in ARMMPURBAR and ARMMPURLAR accordingly. 0x6000 0000 - 0x63FF FFFF  External SPI device 0x6400 0000 - 0x67FF FFFF  QSPI I/O registers const ARMMPURegiont mpuTable2   // BASE SH RO NP XN  .RBAR  ARMMPURBAR(0x60000000UL, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x63FFFFFFUL, MPUARMV8MMAIRATTRDATANOCACHEIDX) , // BASE SH RO NP XN  .RBAR  ARMMPURBAR(0x64000000UL, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x67FFFFFFUL, MPUARMV8MMAIRATTRDEVICEIDX)  ; void mpuconfigquadspi(void)  ARMMPUDisable(); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDEVICEIDX, MPUARMV8MMAIRATTRDEVICEVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRCODEIDX, MPUARMV8MMAIRATTRCODEVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDATAIDX, MPUARMV8MMAIRATTRDATAVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDATANOCACHEIDX, MPUARMV8MMAIRATTRDATANOCACHEVAL); ARMMPULoad(0, mpuTable, 2); ARMMPUEnable(ARMMPUCTRL(CTRLPV, CTRLHN));  void halentry(void) mpuconfigquadspi(); enablescache(); qspiinit(); while(1)  (2) External OSPI memory Use the code below to disable the s-cache on OSPI area. If your MCU has a different address map for OSPI, please change addresses in ARMMPURBAR and ARMMPURLAR accordingly. 0x6800 0000 - 0x6FFF FFFF  CS0 0x7000 0000 - 0x7FFF FFFF  CS1 void mpuconfigoctaspi(void) mpuconfigoctaspi(); ospiinit(); (3) Shared memory with CPU in SRAM Ethernet (EDMAC) Use the code below to disable the s-cache on the EDMAC descriptors and buffers area. The default linker script of the e2 studio project places the EDMAC descriptors and buffers in the "".nsbuffer.eth"" section, and these addresses are likely to change with code changes. Therefore, change the addresses of ARMMPURBAR and ARMMPURLAR accordingly, or place the EDMAC descriptors and buffers in a section with fixed address. Figure.1 Memory map file snippet (EDMAC) With the given memory map file snippet example above, the memory area covering EDMAC descriptors and buffers will be Start address 0x2003 CF80 End address 0x2003 FFFF (0x2003CF80  0x3080  1) Please note that MPU addresses should be aligned in multiples of 32-byte. const ARMMPURegiont mpuTable1   // BASE SH RO NP XN  .RBAR  ARMMPURBAR(0x2003CF80, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x2003FFFF, MPUARMV8MMAIRATTRDATANOCACHEIDX) , void mpuconfigeth(void) ARMMPULoad(0, mpuTable, 1); mpuconfigeth(); Segger RTT Viewer Use the code below to disable the s-cache on the Segger RTT area. The Segger RTT uses some of user SRAM to output debug information, and receive input from the user. The start and end addresses for the 3 regions below can be found in the memory map file after compilation of your project, so please change addresses in ARMMPURBAR and ARMMPURLAR accordingly. .bss.SEGGERRTT .bss.acUpBuffer .bss.acDownBuffer Figure.2 Memory map file snippet (Segger RTT Viewer) With the given memory map file snippet example above, the memory area covering all 3 regions will be Start address 0x2000 01D4 End address 0x2000 128B MPU addresses should be aligned in multiples of 32-byte, so Start address 0x2000 01C0 End address 0x2000 129F  .RBAR  ARMMPURBAR(0x200001C0UL, ARMMPUSHNON, 0UL, 1UL, 1UL), .RLAR  ARMMPURLAR(0x2000129FUL, MPUARMV8MMAIRATTRDATANOCACHEIDX) , void mpuconfigrtt(void) mpuconfigrtt(); SEGGERRTTprintf(HELLO); Arm Cortex-M33 Processor Technical Reference Manual https//documentation-service.arm.com/static/5f15c42420b7cf4bc5247f3a Armv8-M Architecture Reference Manual https//documentation-service.arm.com/static/5f8efe85f86e16515cdbe596 Guidelines for Using the S Cache on the System Bus Suitable Products RA Family The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the Description at the bottom of this article for details on each MPU setting. define CTRLPV 1 CTRLHN 1 ARMMPUCTRL(PV, HN)  (((PV)  MPUCTRLPRIVDEFENAPos)   ((HN)  MPUCTRLHFNMIENAPos)) define MPUARMV8MMAIRATTRDEVICEVAL 0x04 MPUARMV8MMAIRATTRDEVICEVAL 0x04 MPUARMV8MMAIRATTRDEVICEIDX 0 MPUARMV8MMAIRATTRCODEVAL 0xAA MPUARMV8MMAIRATTRCODEIDX 1 MPUARMV8MMAIRATTRDATAVAL 0xFF MPUARMV8MMAIRATTRDATAIDX 2 MPUARMV8MMAIRATTRDATANOCACHEVAL 0x44 MPUARMV8MMAIRATTRDATANOCACHEIDX 3 const ARMMPURegiont mpuTable2   // BASE SH RO NP XN  .RBAR  ARMMPURBAR(0x60000000UL, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x63FFFFFFUL, MPUARMV8MMAIRATTRDATANOCACHEIDX) ,  .RBAR  ARMMPURBAR(0x64000000UL, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x67FFFFFFUL, MPUARMV8MMAIRATTRDEVICEIDX)  void mpuconfigquadspi(void) void mpuconfigquadspi( ) ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDEVICEIDX, MPUARMV8MMAIRATTRDEVICEVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRCODEIDX, MPUARMV8MMAIRATTRCODEVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDATAIDX, MPUARMV8MMAIRATTRDATAVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDATANOCACHEIDX, MPUARMV8MMAIRATTRDATANOCACHEVAL); ARMMPULoad(0, mpuTable, 2); ARMMPUEnable(ARMMPUCTRL(CTRLPV, CTRLHN)); void halentry(void) halentry( mpuconfigquadspi(); qspiinit(); while(1) while (1) (2) External OSPI memory mpuconfigoctaspi( mpuconfigoctaspi(); ospiinit(); (3) Shared memory with CPU in SRAM mpuTable1   // BASE SH RO NP XN  .RBAR  ARMMPURBAR(0x2003CF80, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x2003FFFF, MPUARMV8MMAIRATTRDATANOCACHEIDX) , void mpuconfigeth(void) mpuconfigeth( ARMMPULoad(0, mpuTable, 1); mpuconfigeth(); Segger RTT Viewer  .RBAR  ARMMPURBAR(0x200001C0UL, ARMMPUSHNON, 0UL, 1UL, 1UL), .RLAR  ARMMPURLAR(0x2000129FUL, MPUARMV8MMAIRATTRDATANOCACHEIDX) , void mpuconfigrtt(void) mpuconfigrtt( mpuconfigrtt(); SEGGERRTTprintf(HELLO); SEGGERRTTprintf( HELLO ); Arm Cortex-M33 Processor Technical Reference Manual","['The image shows a screenshot of a computer program, likely a code editor or IDE, with a large block of code in the center. The code is written in a programming language, possibly C++ or Java, and appears to be a complex algorithm or data structure.\n\nHere are the key features of the image:\n\n* **Code Block**: The main focus of the image is a large block of code that takes up most of the screen. The code is written in a monospaced font and is divided into several sections, each with its own set of variables, functions, and comments.\n\t+ The code is written in a programming language, possibly C++ or Java.\n\t+ The code appears to be a complex algorithm or data structure.\n\t+ The code includes several variables, functions, and comments.\n* **Red Box**: A red box surrounds a specific section of the code, highlighting it for emphasis.\n\t+ The red box is located in the center of the image, surrounding a section of the code.\n\t+ The red box is likely used to draw attention to a specific part of the code.\n* **Background**: The background of the image is a light gray color, which provides good contrast with the black text of the code.\n\t+ The background is a solid color, with no patterns or images.\n\t+ The background is likely a default setting for the code editor or IDE.\n* **Other Elements**: There are several other elements in the image, including a menu bar at the top and a status bar at the bottom.\n\t+ The menu bar includes options such as ""File"", ""Edit"", and ""View"".\n\t+ The status bar displays information about the current file, such as the file name and line number.\n\nOverall, the image appears to be a screenshot of a computer program, likely a code editor or IDE, with a large block of code in the center. The code is written in a programming language, possibly C++ or Java, and appears to be a complex algorithm or data structure. The red box highlights a specific section of the code, and the background is a light gray color.', ""The image shows a code snippet in C++ that is used to create a program that can read and write to a file. The code is written in a text editor and is displayed in a monospaced font.\n\nThe code is organized into several sections, each with its own set of functions and variables. The main function is called `main()` and it is responsible for reading and writing to the file. The code uses the `fstream` library to interact with the file.\n\nThe code includes several functions, including `readFile()`, `writeFile()`, and `displayFile()`. These functions are used to perform different operations on the file, such as reading its contents, writing new data to it, and displaying its contents on the screen.\n\nThe code also includes several variables, including `file`, `buffer`, and `size`. These variables are used to store the file's contents, the buffer that is used to read and write data, and the size of the file, respectively.\n\nOverall, the code is well-organized and easy to follow. It uses clear and concise variable names, and the functions are well-named and easy to understand. The code is also well-commented, which makes it easier to understand what each section of code is doing.\n\nHere is a summary of the code:\n\n*   The code is written in C++ and is used to create a program that can read and write to a file.\n*   The code uses the `fstream` library to interact with the file.\n*   The code includes several functions, including `readFile()`, `writeFile()`, and `displayFile()`.\n*   The code includes several variables, including `file`, `buffer`, and `size`.\n*   The code is well-organized and easy to follow.\n*   The code is well-commented, which makes it easier to understand what each section of code is doing.""]"
1d9a13eb4bdb064b0985c6fd7c73b1da,"Description
For MCUs with ARM® CoreSight ™ MTB (Micro Trace buffer) such as RA2E1, the MTB buffer may be mapped to the beginning of the SRAM area. When a user application uses the same SRAM area, it doesn’t work. To avoid this issue, the memory allocation of the MTB buffer can be changed as follows.
int ConfigTargetSettings(void)
int ConfigTargetSettings(void)
{
{
JLINK_ExecCommand(""CORESIGHT_SetMTBBufUseAddr=0x20007C00"");
JLINK_ExecCommand(""CORESIGHT_SetMTBBufUseAddr=0x20007C00"");
JLINK_ExecCommand(""CORESIGHT_SetMTBBufUsageSize=0x400"");
JLINK_ExecCommand(""CORESIGHT_SetMTBBufUsageSize=0x400"");
return 0;
return 0;
}
}
T4F68 003:353.246   MTB: Starting trace using 0x400 bytes buffer @ 0x20007C00
T4F68 003:353.246   MTB: Starting trace using 0x400 bytes buffer @ 0x20007C00
The file location of JLinkLogOverride.log can be confirmed on the J-Link Control Panel. For Windows machines, select the J-Link Control Panel from the Start Menu, and find the “Log file:” in the Settings menu.
Suitable Products
FSP, J-Link
RA
FSP, J-Link
RA
FSP, J-Link
RA
Source:","['data/categories/ra_family/ra_and_fsp_technical_articles/1d9a13eb4bdb064b0985c6fd7c73b1da/images/68b7b4380ddffb498fdc789aa5884c11.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/1d9a13eb4bdb064b0985c6fd7c73b1da/images/f10168b0924a154d3c1818010a711358.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/1d9a13eb4bdb064b0985c6fd7c73b1da/images/9aa5189bcd34a429292a73669fc6bdf6.png']",[],"['|  |\n|  |\n| int ConfigTargetSettings(void)\n{\nJLINK_ExecCommand(""CORESIGHT_SetMTBBufUseAddr=0x20007C00"");\nJLINK_ExecCommand(""CORESIGHT_SetMTBBufUsageSize=0x400"");\nreturn 0;\n} |', '|  |\n|  |\n| T4F68 003:353.246   MTB: Starting trace using 0x400 bytes buffer @ 0x20007C00 |', '|  |\n|  |\n| FSP, J-Link |\n| RA |']","{'title': 'RA Family: How to Change the MTB (Micro Trace Buffer) settings with J-Link', 'url': 'https://en-support.renesas.com/knowledgeBase/20628005', 'last_updated': None, 'extracted_at': '2025-03-08T23:12:23.205697'}","Description For MCUs with ARM CoreSight  MTB (Micro Trace buffer) such as RA2E1, the MTB buffer may be mapped to the beginning of the SRAM area. When a user application uses the same SRAM area, it doesnt work. To avoid this issue, the memory allocation of the MTB buffer can be changed as follows. int ConfigTargetSettings(void)  JLINKExecCommand(""CORESIGHTSetMTBBufUseAddr0x20007C00""); JLINKExecCommand(""CORESIGHTSetMTBBufUsageSize0x400""); return 0;  T4F68 003353.246 MTB Starting trace using 0x400 bytes buffer  0x20007C00 The file location of JLinkLogOverride.log can be confirmed on the J-Link Control Panel. For Windows machines, select the J-Link Control Panel from the Start Menu, and find the Log file in the Settings menu. Suitable Products FSP, J-Link RA Source","['The image shows a screenshot of a computer program, specifically the ""Debugger"" window in Visual Studio. The window is divided into several sections, each with its own set of options and settings.\n\n*   **Debug hardware:**\n    *   J-Link ARM\n    *   Target Device: R7FA2E1A9\n*   **GDB Settings:**\n    *   Connection Settings\n    *   Debug Tool Settings\n*   **J-Link:**\n    *   Type: USB\n    *   J-Link Serial: (Auto)\n    *   Settings File: ${workspace_loc:/ProjName}/${LaunchConfigName}.jlink\n    *   Script File: ${workspace_loc:/ProjName}/${ConfigTargetSettings}.jlinkScript\n*   **Interface:**\n    *   None\n\nThe Debugger window is used to configure and control the debugging process in Visual Studio. It allows users to set up the debugging hardware, select the target device, and configure the GDB settings. The J-Link section provides options for configuring the J-Link serial connection and script file. The Interface section is currently empty, indicating that no interface has been selected.\n\nOverall, the Debugger window provides a comprehensive set of tools for debugging and testing software in Visual Studio. By configuring the various settings and options, users can customize the debugging process to suit their specific needs and requirements.', 'The image displays a list of three software programs, each with its name and version number. The list is presented in a vertical column, with each item separated by a blue square containing the J-Link logo.\n\n*   **J-Link Configurator V7.64b**\n    *   The first item on the list is the J-Link Configurator, with a version number of V7.64b.\n*   **J-Link Control Panel V7.64b**\n    *   The second item on the list is the J-Link Control Panel, also with a version number of V7.64b.\n*   **J-Link DLL Updater V7.64b**\n    *   The third item on the list is the J-Link DLL Updater, again with a version number of V7.64b.\n\nOverall, the image provides a clear and concise overview of the three software programs and their version numbers.', 'The image shows a screenshot of the J-Link Web control panel, which is a software tool used for debugging and programming microcontrollers. The panel is divided into several sections, each with its own set of settings and options.\n\n*   **General**\n    *   This section contains general settings for the J-Link Web control panel.\n    *   It includes options such as the target power, SWV, RAW Trace, Trace, Flash, Commander, and Help.\n*   **Settings**\n    *   This section contains settings for the J-Link Web control panel.\n    *   It includes options such as Breakpoints, RTT, Log, CPU Regs, Target Power, SWV, RAW Trace, Trace, Flash, Commander, and Help.\n*   **Files**\n    *   This section contains files related to the J-Link Web control panel.\n    *   It includes options such as Log file, Settings file, and Script file.\n*   **RAM download**\n    *   This section contains options for downloading files to the RAM of the microcontroller.\n    *   It includes options such as Verify and Disabled.\n\nOverall, the J-Link Web control panel provides a comprehensive set of tools and options for debugging and programming microcontrollers. The panel is easy to use and provides a clear and intuitive interface for users to access and configure various settings and options.']"
7aceec3deee8e79eff81311622276878,"Overview:
This article describes how to improve the LOCO (Low-speed On-Chip Oscillator) clock accuracy (±15%) using the HOCO (High-speed On-Chip Oscillator) with ±1% accuracy as a reference clock along with the CAC (Clock Frequency Accuracy Measurement Circuit) peripheral module and the LOCO user trimming control register.
Description:
This solution uses the following hardware peripherals modules and is able to compensate the LOCO accuracy within around ±4% (Note: this does not mean absolute 4% is guaranteed. Please evaluate it with your actual board).
LOCO User Trimming Register (LOCOUTCR)
LOCOUTCR allows the user to change the LOCO frequency. In the case of RA2 MCUs, by adding ±1 to this register, the clock will be changed around ±4% (Note: 4% is not a guaranteed value. Please evaluate it with your actual board).
Clock Frequency Accuracy Measurement Circuit (CAC)
The CAC can count a clock source against a reference clock. This can be used to determine if the frequency deviation of the clock source is in an allowable range. The measurement target and reference clocks are selectable, and the division ratio can be set. In this solution, the LOCO is the clock source and the HOCO is the reference clock to determine the LOCO frequency deviation, but since the clock difference between HOCO and LOCO is large, so the following clock source selection will be used.
Target clock to be measured: LOCO divided by 32
Reference clock: HOCO divided by 32
CLKOUT (just for debugging purpose)
The CLKOUT of the CGC (Clock Generation Circuit) can be used for debugging purpose to check if this solution is effective in improving the LOCO accuracy.
Figure.1 Solution block diagram
Solution flowchart:
Figure.2 Flow of clock correction using CAC module
Key points:
The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by +1 or -1 depending on number comparison between the CAC counter value and predefined threshold values.
Demo Project:
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25°C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
The correction target clock can be set in loco_clock_correction.c.
LEDs indicate the application running state.
LED1: Blinks when the clock correction is completed.
LED3: Turns on when an API error occur.
Figure.4 The example of RTT viewer logs
  Suitable Products
RA2 MCUs
This article describes how to improve the LOCO (Low-speed On-Chip Oscillator) clock accuracy (±15%) using the HOCO (High-speed On-Chip Oscillator) with ±1% accuracy as a reference clock along with the CAC (Clock Frequency Accuracy Measurement Circuit) peripheral module and the LOCO user trimming control register.
Description:
This solution uses the following hardware peripherals modules and is able to compensate the LOCO accuracy within around ±4% (Note: this does not mean absolute 4% is guaranteed. Please evaluate it with your actual board).
LOCO User Trimming Register (LOCOUTCR)
LOCOUTCR allows the user to change the LOCO frequency. In the case of RA2 MCUs, by adding ±1 to this register, the clock will be changed around ±4% (Note: 4% is not a guaranteed value. Please evaluate it with your actual board).
Clock Frequency Accuracy Measurement Circuit (CAC)
The CAC can count a clock source against a reference clock. This can be used to determine if the frequency deviation of the clock source is in an allowable range. The measurement target and reference clocks are selectable, and the division ratio can be set. In this solution, the LOCO is the clock source and the HOCO is the reference clock to determine the LOCO frequency deviation, but since the clock difference between HOCO and LOCO is large, so the following clock source selection will be used.
Target clock to be measured: LOCO divided by 32
Reference clock: HOCO divided by 32
CLKOUT (just for debugging purpose)
The CLKOUT of the CGC (Clock Generation Circuit) can be used for debugging purpose to check if this solution is effective in improving the LOCO accuracy.
Figure.1 Solution block diagram
Solution flowchart:
Figure.2 Flow of clock correction using CAC module
Key points:
The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by +1 or -1 depending on number comparison between the CAC counter value and predefined threshold values.
Demo Project:
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25°C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
The correction target clock can be set in loco_clock_correction.c.
LEDs indicate the application running state.
LED1: Blinks when the clock correction is completed.
LED3: Turns on when an API error occur.
Figure.4 The example of RTT viewer logs
This article describes how to improve the LOCO (Low-speed On-Chip Oscillator) clock accuracy (±15%) using the HOCO (High-speed On-Chip Oscillator) with ±1% accuracy as a reference clock along with the CAC (Clock Frequency Accuracy Measurement Circuit) peripheral module and the LOCO user trimming control register.
This solution uses the following hardware peripherals modules and is able to compensate the LOCO accuracy within around ±4% (Note: this does not mean absolute 4% is guaranteed. Please evaluate it with your actual board).
LOCO User Trimming Register (LOCOUTCR)
LOCOUTCR allows the user to change the LOCO frequency. In the case of RA2 MCUs, by adding ±1 to this register, the clock will be changed around ±4% (Note: 4% is not a guaranteed value. Please evaluate it with your actual board).
Clock Frequency Accuracy Measurement Circuit (CAC)
The CAC can count a clock source against a reference clock. This can be used to determine if the frequency deviation of the clock source is in an allowable range. The measurement target and reference clocks are selectable, and the division ratio can be set. In this solution, the LOCO is the clock source and the HOCO is the reference clock to determine the LOCO frequency deviation, but since the clock difference between HOCO and LOCO is large, so the following clock source selection will be used.
Target clock to be measured: LOCO divided by 32
Reference clock: HOCO divided by 32
CLKOUT (just for debugging purpose)
The CLKOUT of the CGC (Clock Generation Circuit) can be used for debugging purpose to check if this solution is effective in improving the LOCO accuracy.
Figure.1 Solution block diagram
Solution flowchart:
Figure.2 Flow of clock correction using CAC module
Key points:
The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by +1 or -1 depending on number comparison between the CAC counter value and predefined threshold values.
Demo Project:
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25°C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
The correction target clock can be set in loco_clock_correction.c.
LEDs indicate the application running state.
LED1: Blinks when the clock correction is completed.
LED3: Turns on when an API error occur.
Figure.4 The example of RTT viewer logs
This solution uses the following hardware peripherals modules and is able to compensate the LOCO accuracy within around ±4% (Note: this does not mean absolute 4% is guaranteed. Please evaluate it with your actual board).
Figure.1 Solution block diagram
Figure.2 Flow of clock correction using CAC module
Key points:
The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by +1 or -1 depending on number comparison between the CAC counter value and predefined threshold values.
Demo Project:
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25°C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
The correction target clock can be set in loco_clock_correction.c.
LEDs indicate the application running state.
LED1: Blinks when the clock correction is completed.
LED3: Turns on when an API error occur.
Figure.4 The example of RTT viewer logs
Figure.2 Flow of clock correction using CAC module
Key points:
The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by +1 or -1 depending on number comparison between the CAC counter value and predefined threshold values.
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25°C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
The correction target clock can be set in loco_clock_correction.c.
LEDs indicate the application running state.
LED1: Blinks when the clock correction is completed.
LED3: Turns on when an API error occur.
Figure.4 The example of RTT viewer logs
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25°C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
Figure.4 The example of RTT viewer logs
Suitable Products
RA2 MCUs
Suitable Products
RA2 MCUs
Suitable Products
RA2 MCUs
Go to Japanese
Go to Japanese","['data/categories/ra_family/ra_and_fsp_technical_articles/7aceec3deee8e79eff81311622276878/images/d0e9633087841b3090316e79fe7ffd50.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/7aceec3deee8e79eff81311622276878/images/ed2b24bb9d41792ac5d3323855d696e8.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/7aceec3deee8e79eff81311622276878/images/3eb6c856b1a7aad30a11382338061c7e.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/7aceec3deee8e79eff81311622276878/images/7f9f15227d30668f9c051b22f623f8d7.png']",[],['|  |\n|  |\n| RA2 MCUs |'],"{'title': 'RA2 MCUs: How to improve the accuracy of LOCO frequency', 'url': 'https://en-support.renesas.com/knowledgeBase/20797532', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:00.159194'}","Overview This article describes how to improve the LOCO (Low-speed On-Chip Oscillator) clock accuracy (15) using the HOCO (High-speed On-Chip Oscillator) with 1 accuracy as a reference clock along with the CAC (Clock Frequency Accuracy Measurement Circuit) peripheral module and the LOCO user trimming control register. Description This solution uses the following hardware peripherals modules and is able to compensate the LOCO accuracy within around 4 (Note this does not mean absolute 4 is guaranteed. Please evaluate it with your actual board). LOCO User Trimming Register (LOCOUTCR) LOCOUTCR allows the user to change the LOCO frequency. In the case of RA2 MCUs, by adding 1 to this register, the clock will be changed around 4 (Note 4 is not a guaranteed value. Please evaluate it with your actual board). Clock Frequency Accuracy Measurement Circuit (CAC) The CAC can count a clock source against a reference clock. This can be used to determine if the frequency deviation of the clock source is in an allowable range. The measurement target and reference clocks are selectable, and the division ratio can be set. In this solution, the LOCO is the clock source and the HOCO is the reference clock to determine the LOCO frequency deviation, but since the clock difference between HOCO and LOCO is large, so the following clock source selection will be used. Target clock to be measured LOCO divided by 32 Reference clock HOCO divided by 32 CLKOUT (just for debugging purpose) The CLKOUT of the CGC (Clock Generation Circuit) can be used for debugging purpose to check if this solution is effective in improving the LOCO accuracy. Figure.1 Solution block diagram Solution flowchart Figure.2 Flow of clock correction using CAC module Key points The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by 1 or -1 depending on number comparison between the CAC counter value and predefined threshold values. Demo Project The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO. Figure.3 Demo application flowchart Note The correction target clock can be set in lococlockcorrection.c. LEDs indicate the application running state. LED1 Blinks when the clock correction is completed. LED3 Turns on when an API error occur. Figure.4 The example of RTT viewer logs Suitable Products RA2 MCUs Suitable Products Go to Japanese","['The image depicts a block diagram of a microcontroller unit (MCU) with various components and their connections. The MCU is represented by a large rectangle, with several smaller rectangles and lines indicating the different parts and their relationships.\n\nHere are the main components shown in the image:\n\n*   **MCU**: The central component of the diagram, representing the microcontroller unit.\n*   **CLKOUT pin**: A pin on the MCU that outputs a clock signal.\n*   **CLK**: A clock signal input to the MCU.\n*   **LOCO**: A local oscillator that generates a clock signal for the MCU.\n*   **HOCO**: A high-oscillator that generates a clock signal for the MCU.\n*   **CAC**: A clock accuracy controller that measures the accuracy of the clock signal.\n*   **Measurement reference clock**: A reference clock signal used by the CAC to measure the accuracy of the clock signal.\n*   **Result**: The output of the CAC, indicating the accuracy of the clock signal.\n*   **Update**: A signal that updates the clock signal based on the result from the CAC.\n*   **LOCOUTCR**: A register that stores the output of the LOCO.\n*   **CPU**: The central processing unit of the MCU.\n\nThe diagram shows the flow of signals between these components, including the clock signal, measurement reference clock, and result from the CAC. The update signal is used to adjust the clock signal based on the result from the CAC.\n\nOverall, the diagram provides a clear overview of the components and their relationships within the MCU, highlighting the importance of clock signal accuracy and the role of the CAC in ensuring accurate timing.', 'The image presents a flowchart illustrating the process of initializing and testing a CAC module. The flowchart is divided into several sections, each representing a distinct step in the process.\n\n*   **Start**\n    *   The flowchart begins with the ""Start"" section, which serves as the initial point of entry.\n*   **Initialize CAC module**\n    *   The next step is to initialize the CAC module, which involves setting up the necessary parameters and configurations for the module to function properly.\n*   **Run CAC test**\n    *   Following the initialization of the CAC module, the flowchart proceeds to the ""Run CAC test"" section, where the module is subjected to a series of tests to ensure its functionality and performance.\n*   **upper threshold < CAC result**\n    *   The flowchart then branches out to two possible outcomes based on the result of the CAC test:\n        *   If the upper threshold is less than the CAC result, the flowchart proceeds to the ""LOCOUTCR += 1"" section.\n        *   If the upper threshold is not less than the CAC result, the flowchart proceeds to the ""CAC result < lower threshold"" section.\n*   **CAC result < lower threshold**\n    *   In this section, the flowchart checks if the CAC result is less than the lower threshold. If it is, the flowchart proceeds to the ""LOCOUTCR += 1"" section.\n*   **LOCOUTCR += 1**\n    *   The ""LOCOUTCR += 1"" section increments the LOCOUTCR value by 1, indicating that the CAC test has been completed and the result has been recorded.\n*   **End**\n    *   Finally, the flowchart concludes with the ""End"" section, marking the completion of the CAC module initialization and testing process.\n\nIn summary, the flowchart provides a clear and concise visual representation of the steps involved in initializing and testing a CAC module. By following the flowchart, users can easily understand the process and identify potential issues or areas for improvement.', 'The image presents a flowchart illustrating the steps involved in initializing and running a clock correction application. The flowchart is structured as follows:\n\n*   **Start**: The flowchart begins with the ""Start"" label, indicating the initiation of the process.\n*   **Initialize ICU**: The first step is to initialize the ICU (Integrated Circuit Unit), which is a crucial component for clock management.\n*   **Wait for SW1 press**: The next step involves waiting for a specific input, denoted by SW1, to be pressed. This input is likely a switch or button that triggers the clock correction process.\n*   **Check clock source**: Once the input is received, the flowchart proceeds to check the clock source. This step ensures that the clock signal is stable and reliable.\n*   **Run clock correction app**: After verifying the clock source, the flowchart runs the clock correction application. This application is responsible for adjusting the clock frequency to ensure accurate timekeeping.\n*   **LED1 blinky**: The final step involves blinking an LED (Light Emitting Diode) labeled as LED1. This visual indicator provides feedback to the user that the clock correction process has been completed successfully.\n\nIn summary, the flowchart outlines the sequence of events required to initialize and run a clock correction application, from starting the process to verifying the clock source and running the application, ultimately culminating in the blinking of an LED indicator.', 'The image shows a screenshot of a computer program, specifically a terminal window with a black background and white text. The program appears to be a clock correction tool, as indicated by the title ""Renesas RA Sample Project for LOCO Clock Correction"" and the various commands and messages displayed in the window.\n\nHere are the key features of the image:\n\n* **Title Bar**: The title bar at the top of the window displays the program\'s name, ""J-Link RTT Viewer V7.80c"", along with various menu options such as ""File"", ""Terminals"", ""Input"", ""Logging"", and ""Help"".\n* **Menu Options**: The menu options in the title bar provide access to different features and functions within the program. For example, the ""File"" menu allows users to open or save files, while the ""Terminals"" menu enables users to connect to different terminals or devices.\n* **Terminal Window**: The main window of the program is a terminal window with a black background and white text. The terminal window displays a series of commands and messages related to clock correction, including the title ""Renesas RA Sample Project for LOCO Clock Correction"" and various error messages and warnings.\n* **Commands and Messages**: The terminal window displays a range of commands and messages related to clock correction, including:\n\t+ ""Press S1 button to add an offset to LOCOUTCR register to show the bad case""\n\t+ ""Changed the LOCOUTCR register value to 3""\n\t+ ""Press S1 button to start LOCO clock correction""\n\t+ ""Check if the cac clock sources are active""\n\t+ ""CAC Reference clock checking...""\n\t+ ""Clock is activated""\n\t+ ""CAC Measurement clock checking...""\n\t+ ""Clock is activated""\n\t+ ""CAC Clock sources are active""\n\t+ ""Correction Target: 0x59A < X < 0x5D5""\n\t+ ""LOCO Clock Correction started.""\n\t+ ""[LOG No.0] CAC result: 0x518, Action: LOCOUTCR - 1""\n\t+ ""[LOG No.1] CAC result: 0x54A, Action: LOCOUTCR - 1""\n\t+ ""[LOG No.2] CAC result: 0x585, Action: LOCOUTCR - 1""\n\t+ ""[LOG No.3] CAC result: 0x5BB, Clock Correction completed""\n\t+ ""Clock correction finished successfully""\n* **Error Messages**: The terminal window also displays several error messages, including:\n\t+ ""Press S1 button to add an offset to LOCOUTCR register to show the bad case""\n\t+ ""Changed the LOCOUTCR register value to 3""\n\t+ ""Press S1 button to start LOCO clock correction""\n\nOverall, the image suggests that the program is designed to help users correct clock errors in a specific system or device. The program provides a range of commands and messages to guide the user through the correction process, including error messages and warnings to alert the user to potential issues.']"
70027263d80c62bc902152d4d6bfe74c,"The below description assumes you are using GCC complier and e2studio and is demonstrated with the RA6M5.
  In the linker settings for the project, change the Other linker flags so the semihosted version of newlib is not used:
    In the BSP tab of the configurator, add some heap memory (printf() requires some heap):
    Override the low level write function of the C runtime library, with a version that will write the data to the ITM:
  
int _write(int file, char *ptr, int len)
{
  FSP_PARAMETER_NOT_USED(file);

  int32_t todo;

  /* If the debugger is connected */
  if (CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk)
  {
      /* Send the character */
        for (todo = 0; todo < len; todo++)
        {
            ITM_SendChar((uint32_t)*ptr);/* CMSIS call */
            ptr++;
        }
  }

  return len;
}
In your code, call printf().
 uint32_t count = 0;
    
    while(1)
    {
        printf(""FSP ITM printf %ld\r\n"", count++);
        R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
    }
 Build the project.
  In the debug configuration for the project, set the SWV Core clock:
    The frequency set in the SWV Core clock in the debug configuration is not actually the speed the CPU core is operating at, it is the speed of the trace clock (TRCLK). In the case of the RA6M5 the JLink will configure the TRCKCR register to 0x81, which will divide the system clock by 2 (PLL is the system clock by default in an FSP project), giving a trace clock speed of 100MHz. This results in the value of 100MHz for the core clock speed in the debug configuration.
  Open the Live Trace Console window (Window->Show View->Other ). In the setting for the Live Trace Console, enable ITM stimulus port 0:
    Then enable the Live Trace Console, and run the program, and you should see the output of the printf:
      Printf
FSP and RA
Sourced from: 346439
The below description assumes you are using GCC complier and e2studio and is demonstrated with the RA6M5.
  In the linker settings for the project, change the Other linker flags so the semihosted version of newlib is not used:
    In the BSP tab of the configurator, add some heap memory (printf() requires some heap):
    Override the low level write function of the C runtime library, with a version that will write the data to the ITM:
  
int _write(int file, char *ptr, int len)
{
  FSP_PARAMETER_NOT_USED(file);

  int32_t todo;

  /* If the debugger is connected */
  if (CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk)
  {
      /* Send the character */
        for (todo = 0; todo < len; todo++)
        {
            ITM_SendChar((uint32_t)*ptr);/* CMSIS call */
            ptr++;
        }
  }

  return len;
}
In your code, call printf().
 uint32_t count = 0;
    
    while(1)
    {
        printf(""FSP ITM printf %ld\r\n"", count++);
        R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
    }
 Build the project.
  In the debug configuration for the project, set the SWV Core clock:
    The frequency set in the SWV Core clock in the debug configuration is not actually the speed the CPU core is operating at, it is the speed of the trace clock (TRCLK). In the case of the RA6M5 the JLink will configure the TRCKCR register to 0x81, which will divide the system clock by 2 (PLL is the system clock by default in an FSP project), giving a trace clock speed of 100MHz. This results in the value of 100MHz for the core clock speed in the debug configuration.
  Open the Live Trace Console window (Window->Show View->Other ). In the setting for the Live Trace Console, enable ITM stimulus port 0:
    Then enable the Live Trace Console, and run the program, and you should see the output of the printf:
      Printf
FSP and RA
Sourced from: 346439
The below description assumes you are using GCC complier and e2studio and is demonstrated with the RA6M5.
RA6M5.
In the linker settings for the project, change the Other linker flags so the semihosted version of newlib is not used:
In the BSP tab of the configurator, add some heap memory (printf() requires some heap):
Override the low level write function of the C runtime library, with a version that will write the data to the ITM:
In your code, call printf().
Build the project.
In the debug configuration for the project, set the SWV Core clock:
The frequency set in the SWV Core clock in the debug configuration is not actually the speed the CPU core is operating at, it is the speed of the trace clock (TRCLK). In the case of the RA6M5 the JLink will configure the TRCKCR register to 0x81, which will divide the system clock by 2 (PLL is the system clock by default in an FSP project), giving a trace clock speed of 100MHz. This results in the value of 100MHz for the core clock speed in the debug configuration.
Open the Live Trace Console window (Window->Show View->Other ). In the setting for the Live Trace Console, enable ITM stimulus port 0:
Then enable the Live Trace Console, and run the program, and you should see the output of the printf:
Printf
FSP and RA
Sourced from: 346439
Sourced from: 346439","['data/categories/ra_family/ra_and_fsp_technical_articles/70027263d80c62bc902152d4d6bfe74c/images/8725ea5bd5841443b1813a7f69320889.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/70027263d80c62bc902152d4d6bfe74c/images/41ed6235aa6f5282c05791f598127ad3.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/70027263d80c62bc902152d4d6bfe74c/images/9974cbc88e1911a9edd00c6b6029151f.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/70027263d80c62bc902152d4d6bfe74c/images/b1f5e2367ec53ab5d8295d034d7de548.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/70027263d80c62bc902152d4d6bfe74c/images/f2be995af3d8bbe52df2ddc38cac0c53.png']",[],['|  |\n|  |\n| Printf |\n| FSP and RA |'],"{'title': 'Using Arm Cortex SWO with printf with RA and FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/20540919', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:27.514771'}","The below description assumes you are using GCC complier and e2studio and is demonstrated with the RA6M5. In the linker settings for the project, change the Other linker flags so the semihosted version of newlib is not used In the BSP tab of the configurator, add some heap memory (printf() requires some heap) Override the low level write function of the C runtime library, with a version that will write the data to the ITM int write(int file, char ptr, int len)  FSPPARAMETERNOTUSED(file); int32t todo; / If the debugger is connected / if (CoreDebug-DHCSR  CoreDebugDHCSRCDEBUGENMsk)  / Send the character / for (todo  0; todo  len; todo)  ITMSendChar((uint32t)ptr);/ CMSIS call / ptr;   return len;  In your code, call printf(). uint32t count  0; while(1)  printf(""FSP ITM printf ldrn"", count); RBSPSoftwareDelay(1000, BSPDELAYUNITSMILLISECONDS);  Build the project. In the debug configuration for the project, set the SWV Core clock The frequency set in the SWV Core clock in the debug configuration is not actually the speed the CPU core is operating at, it is the speed of the trace clock (TRCLK). In the case of the RA6M5 the JLink will configure the TRCKCR register to 0x81, which will divide the system clock by 2 (PLL is the system clock by default in an FSP project), giving a trace clock speed of 100MHz. This results in the value of 100MHz for the core clock speed in the debug configuration. Open the Live Trace Console window (Window-Show View-Other ). In the setting for the Live Trace Console, enable ITM stimulus port 0 Then enable the Live Trace Console, and run the program, and you should see the output of the printf Printf FSP and RA Sourced from 346439 RA6M5. In the linker settings for the project, change the Other linker flags so the semihosted version of newlib is not used In the BSP tab of the configurator, add some heap memory (printf() requires some heap) Override the low level write function of the C runtime library, with a version that will write the data to the ITM Build the project. In the debug configuration for the project, set the SWV Core clock The frequency set in the SWV Core clock in the debug configuration is not actually the speed the CPU core is operating at, it is the speed of the trace clock (TRCLK). In the case of the RA6M5 the JLink will configure the TRCKCR register to 0x81, which will divide the system clock by 2 (PLL is the system clock by default in an FSP project), giving a trace clock speed of 100MHz. This results in the value of 100MHz for the core clock speed in the debug configuration. Open the Live Trace Console window (Window-Show View-Other ). In the setting for the Live Trace Console, enable ITM stimulus port 0 Then enable the Live Trace Console, and run the program, and you should see the output of the printf Printf","['The image shows a screenshot of the ""Settings"" window in Visual Studio, with the ""Other linker flags"" section highlighted. The window is divided into two main sections: the left side lists various settings, and the right side displays the current settings for the selected option.\n\n*   **Left Side:**\n    *   The left side of the window is a list of settings, including:\n        *   Resource\n        *   Builders\n        *   C/C++ Build\n        *   Build Variables\n        *   Environment\n        *   Logging\n        *   Settings\n        *   Tool Chain Editor\n        *   C/C++ General\n        *   MCU\n        *   Project Natures\n        *   Project References\n        *   Renesas QE\n        *   Run/Debug Settings\n        *   Task Tags\n        *   Validation\n*   **Right Side:**\n    *   The right side of the window displays the current settings for the selected option, which is ""Other linker flags"". The current setting is ""-specs=nosys.specs"".\n    *   Below the current setting, there are several options for generating maps, including:\n        *   Cross reference (-Xlinker --cref)\n        *   Print link map (-Xlinker --print-map)\n        *   Use newlib-nano (--specs=nano.specs)\n        *   Use float with nano printf (-u _printf_float)\n        *   Use float with nano scanf (-u _scanf_float)\n        *   Do not use syscalls (--specs=nosys.specs)\n        *   Verbose (-v)\n*   **Highlighted Section:**\n    *   The ""Other linker flags"" section is highlighted in red, indicating that it is the current focus of the user\'s attention.\n\nOverall, the image shows a screenshot of the ""Settings"" window in Visual Studio, with the ""Other linker flags"" section highlighted. The user is currently configuring the linker flags for their project, and the highlighted section shows the current setting and available options.', 'The image shows a screenshot of a computer program, specifically the ""Properties"" window for a device or component. The window is titled ""EK-RA6M5"" and has a list of settings on the left side, with their corresponding values on the right side.\n\n*   **Title**\n    *   The title of the window is ""EK-RA6M5"".\n*   **Settings**\n    *   The settings are listed on the left side of the window, with their corresponding values on the right side.\n    *   The settings include:\n        *   Property\n        *   Clocks\n        *   Startup C-Cache Line Size\n        *   Dual Bank Mode\n        *   Main Oscillator Wait Time\n        *   RA Common\n        *   Main stack size (bytes)\n        *   Heap size (bytes)\n        *   MCU Vcc (mV)\n        *   Parameter checking\n        *   Assert Failures\n        *   Error Log\n        *   Clock Registers not Reset Values during Startup\n        *   Main Oscillator Populated\n        *   PFS Protect\n        *   C Runtime Initialization\n*   **Value**\n    *   The values for each setting are listed on the right side of the window.\n    *   The values include:\n        *   32 Bytes\n        *   Disabled\n        *   8163 cycles\n        *   0x400\n        *   0x1000\n        *   3300\n        *   Disabled\n        *   Return FSP_ERR_ASSERTION\n        *   No Error Log\n        *   Disabled\n        *   Populated\n        *   Enabled\n        *   Enabled\n\nOverall, the image shows a detailed list of settings and their corresponding values for a device or component, likely related to a microcontroller or embedded system.', 'The image shows a screenshot of a computer program, specifically the ""Debug Configurations"" window in Eclipse, a popular integrated development environment (IDE) for Java and other programming languages. The window is divided into two main sections: the left side, which lists various debugging configurations, and the right side, which displays the details of the selected configuration.\n\n**Left Side:**\n\n*   The left side of the window is a list of debugging configurations, each represented by a line with several columns of information.\n*   The columns include the name of the configuration, the type of debugging (e.g., ""J-Link""), and other relevant details.\n*   The list is sorted alphabetically by name, with the most recently used configurations at the top.\n\n**Right Side:**\n\n*   The right side of the window displays the details of the selected configuration.\n*   The top section shows the name of the configuration, ""EK_RA6M5_ITM_Printf_Debug_Flat"", and its type, ""J-Link"".\n*   Below this are several tabs, each representing a different aspect of the configuration:\n    *   **Main**: This tab displays general information about the configuration, such as the target device and the debug hardware.\n    *   **Debugger**: This tab shows the settings for the debugger, including the type of debugger and the connection settings.\n    *   **Interface**: This tab displays the interface settings, including the speed and the JTAG scan chain.\n    *   **Connection**: This tab shows the connection settings, including the register initialization and reset on connection.\n    *   **SWV**: This tab displays the SWV (Serial Wire Viewer) settings, including the core clock and trust zone.\n*   At the bottom of the window is a button labeled ""Debug"" and another labeled ""Close"".\n\n**Overall:**\n\n*   The image suggests that the user is configuring a debugging session for a specific project or application.\n*   The user has selected a configuration named ""EK_RA6M5_ITM_Printf_Debug_Flat"" and is viewing its details in the right side of the window.\n*   The user can navigate through the different tabs to adjust various settings, such as the debugger type, interface speed, and connection settings.\n*   Once the user is satisfied with the configuration, they can click the ""Debug"" button to start the debugging session.', 'The image shows a screenshot of the ""ARM CoreSight ITM Trace Settings"" window, which is a configuration interface for tracing events in an ARM CoreSight system. The window is divided into two main sections: the left side lists various settings, and the right side provides a list of trace events.\n\n*   **PC Sampling**\n    *   Enable: This checkbox allows or disables PC sampling.\n    *   Resolution (Cycle/sample): This dropdown menu allows the user to select the resolution of the trace events, with options ranging from 64 cycles per sample to 1 cycle per sample.\n*   **Trace Events**\n    *   CPI: Cycles per instruction\n    *   SLEEP: Sleep cycles\n    *   FOLD: Folded instruction\n    *   EXC: Exception overhead\n    *   LSU: Load store unit cycles\n    *   EXETRC: Trace Exceptions\n*   **ITM Stimulus Ports**\n    *   Enable ports: This dropdown menu allows the user to select which ports to enable for ITM stimulus.\n    *   Privilege: This dropdown menu allows the user to select the privilege level for the ITM stimulus ports.\n*   **Buttons**\n    *   OK: This button saves the changes made to the settings and closes the window.\n    *   Cancel: This button discards any changes made to the settings and closes the window.\n\nIn summary, the ARM CoreSight ITM Trace Settings window provides a comprehensive set of options for configuring tracing events in an ARM CoreSight system. The user can enable or disable PC sampling, select the resolution of the trace events, and choose which ports to enable for ITM stimulus. The window also includes buttons for saving and canceling changes.', 'The image shows a screenshot of a computer program, specifically the ""Live Trace Console"" window. The window is open on a Windows computer, as indicated by the blue Windows logo in the top-left corner.\n\nThe window has a gray title bar with the words ""Live Trace Console"" in black text. Below the title bar, there is a white search bar with a magnifying glass icon on the left side and a cancel button on the right side. The search bar is empty, indicating that no search query has been entered.\n\nBelow the search bar, there is a list of text in black font, which appears to be a list of network ports. The list includes the following entries:\n\n* Port 0\n* FSP ITM printf 0\n* FSP ITM printf 1\n* FSP ITM printf 2\n* FSP ITM printf 3\n* FSP ITM printf 4\n* FSP ITM printf 5\n* FSP ITM printf 6\n\nThe background of the window is white, providing a clean and simple visual interface for the user to interact with the program. Overall, the image suggests that the ""Live Trace Console"" is a tool for debugging and troubleshooting network issues, allowing users to monitor and analyze network traffic in real-time.']"
b5c043ca694caf48ad22adcac1ba8f3b,"Question:
I plan to connect external SRAM by using CS area controller (CSC) of the RA6 MCU.
What should I do with the following items when selecting Renesas' RMLV1616A (16Mbit) as the target memory,
a) How to connect the address lines between RA MCU and SRAM.
b) How to select “write access mode” (single-write strobe mode / byte strobe mode)  about CSCnMOD register in RA MCU.
Figure 1: Pin Assignment of RMLV1616A (48pin TSOP)
Answer:
The target SRAM is available in two bus widths: 1M words × 16 bits / 2M words × 8 bits.
(1) Data width is 16bits (Word mode):
BYTE# pin of the SRAM is pulled-up to H level to set it to word mode.
The address of RMLV1616 is a word (1 word = 16 bits) address which is 20 lines from A0 to A19.
On the other hand, RA MCU uses byte address. For this reason, the address lines of the two devices are connected with an offset.

RA MCU A20 — SRAM A19
RA MCU A19 — SRAM A18
        ...
RA MCU A2 — SRAM A1
RA MCU A1 — SRAM A0

In this configuration, the A-1 pin on the SRAM is not connected to the address signal of RA MCU. The A-1 pin is used as DQ15 on the 16-bit data bus.

The write access mode of RA MCU is selected as ""single-write strobe mode"".
Connect the BC0/BC1 pins of RA MCU to the byte selection pins LB#/UB# on the SRAM, respectively.
Figure 2: Word mode connection
(2) Data width is 8bits (Byte mode):
BYTE# pin of the SRAM is pulled-down to L level to set it to byte mode.
The address of RMLV1616 is a word (1 word = 16 bits) address which is 21 lines from A-1 to A19.
On the other hand, RA MCU uses byte address. For this reason, the address lines of the two devices are connected with an offset.

RA MCU A20 — SRAM A19
RA MCU A19 — SRAM A18
       ...
RA MCU A2 — SRAM A1
RA MCU A1 — SRAM A0
RA MCU A0 — SRAM A-1

In this configuration, the A-1 pin on the SRAM is connected to A0 pin of RA MCU.

The write access mode of RA MCU is selected as ""byte strobe mode"".
The BC0 pin of RA MCU is used as the address A0 pin.
BC1 pin and D[15-8] pins of the RA MCU are not used for this connection. These can be used as a pin for functions other than CSC.
LB#/UB# pins and DQ[14-8] pins of SRAM are not used for this connection. It is recommended to pull it up on the substrate.

Figure 3: Byte mode connection
Suitable Products
RA Family
I plan to connect external SRAM by using CS area controller (CSC) of the RA6 MCU.
What should I do with the following items when selecting Renesas' RMLV1616A (16Mbit) as the target memory,
a) How to connect the address lines between RA MCU and SRAM.
b) How to select “write access mode” (single-write strobe mode / byte strobe mode)  about CSCnMOD register in RA MCU.
Figure 1: Pin Assignment of RMLV1616A (48pin TSOP)
I plan to connect external SRAM by using CS area controller (CSC) of the RA6 MCU.
What should I do with the following items when selecting Renesas' RMLV1616A (16Mbit) as the target memory,
a) How to connect the address lines between RA MCU and SRAM.
b) How to select “write access mode” (single-write strobe mode / byte strobe mode)  about CSCnMOD register in RA MCU.
Figure 1: Pin Assignment of RMLV1616A (48pin TSOP)
Answer:
The target SRAM is available in two bus widths: 1M words × 16 bits / 2M words × 8 bits.
(1) Data width is 16bits (Word mode):
BYTE# pin of the SRAM is pulled-up to H level to set it to word mode.
The address of RMLV1616 is a word (1 word = 16 bits) address which is 20 lines from A0 to A19.
On the other hand, RA MCU uses byte address. For this reason, the address lines of the two devices are connected with an offset.

RA MCU A20 — SRAM A19
RA MCU A19 — SRAM A18
        ...
RA MCU A2 — SRAM A1
RA MCU A1 — SRAM A0

In this configuration, the A-1 pin on the SRAM is not connected to the address signal of RA MCU. The A-1 pin is used as DQ15 on the 16-bit data bus.

The write access mode of RA MCU is selected as ""single-write strobe mode"".
Connect the BC0/BC1 pins of RA MCU to the byte selection pins LB#/UB# on the SRAM, respectively.
Figure 2: Word mode connection
(2) Data width is 8bits (Byte mode):
BYTE# pin of the SRAM is pulled-down to L level to set it to byte mode.
The address of RMLV1616 is a word (1 word = 16 bits) address which is 21 lines from A-1 to A19.
On the other hand, RA MCU uses byte address. For this reason, the address lines of the two devices are connected with an offset.

RA MCU A20 — SRAM A19
RA MCU A19 — SRAM A18
       ...
RA MCU A2 — SRAM A1
RA MCU A1 — SRAM A0
RA MCU A0 — SRAM A-1

In this configuration, the A-1 pin on the SRAM is connected to A0 pin of RA MCU.

The write access mode of RA MCU is selected as ""byte strobe mode"".
The BC0 pin of RA MCU is used as the address A0 pin.
BC1 pin and D[15-8] pins of the RA MCU are not used for this connection. These can be used as a pin for functions other than CSC.
LB#/UB# pins and DQ[14-8] pins of SRAM are not used for this connection. It is recommended to pull it up on the substrate.

Figure 3: Byte mode connection
Suitable Products
RA Family
The target SRAM is available in two bus widths: 1M words × 16 bits / 2M words × 8 bits.
(1) Data width is 16bits (Word mode):
Figure 2: Word mode connection
(2) Data width is 8bits (Byte mode):
Figure 3: Byte mode connection
Suitable Products
RA Family
日本語
日本語","['data/categories/ra_family/external_bus/b5c043ca694caf48ad22adcac1ba8f3b/images/75594f616ee0e23434fa2e553830bae5.png', 'data/categories/ra_family/external_bus/b5c043ca694caf48ad22adcac1ba8f3b/images/c372b7c25b771bc307ac27decd6be46f.png', 'data/categories/ra_family/external_bus/b5c043ca694caf48ad22adcac1ba8f3b/images/1928f52af349ef0851525ebde8dd594f.png']",[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: How to connect external SRAM?', 'url': 'https://en-support.renesas.com/knowledgeBase/21727828', 'last_updated': None, 'extracted_at': '2025-03-08T23:35:47.570411'}","Question I plan to connect external SRAM by using CS area controller (CSC) of the RA6 MCU. What should I do with the following items when selecting Renesas' RMLV1616A (16Mbit) as the target memory, a) How to connect the address lines between RA MCU and SRAM. b) How to select write access mode (single-write strobe mode / byte strobe mode) about CSCnMOD register in RA MCU. Figure 1 Pin Assignment of RMLV1616A (48pin TSOP) Answer The target SRAM is available in two bus widths 1M words  16 bits / 2M words  8 bits. (1) Data width is 16bits (Word mode) BYTE pin of the SRAM is pulled-up to H level to set it to word mode. The address of RMLV1616 is a word (1 word  16 bits) address which is 20 lines from A0 to A19. On the other hand, RA MCU uses byte address. For this reason, the address lines of the two devices are connected with an offset. RA MCU A20  SRAM A19 RA MCU A19  SRAM A18 ... RA MCU A2  SRAM A1 RA MCU A1  SRAM A0 In this configuration, the A-1 pin on the SRAM is not connected to the address signal of RA MCU. The A-1 pin is used as DQ15 on the 16-bit data bus. The write access mode of RA MCU is selected as ""single-write strobe mode"". Connect the BC0/BC1 pins of RA MCU to the byte selection pins LB/UB on the SRAM, respectively. Figure 2 Word mode connection (2) Data width is 8bits (Byte mode) BYTE pin of the SRAM is pulled-down to L level to set it to byte mode. The address of RMLV1616 is a word (1 word  16 bits) address which is 21 lines from A-1 to A19. ... RA MCU A0  SRAM A-1 In this configuration, the A-1 pin on the SRAM is connected to A0 pin of RA MCU. The write access mode of RA MCU is selected as ""byte strobe mode"". The BC0 pin of RA MCU is used as the address A0 pin. BC1 pin and D15-8 pins of the RA MCU are not used for this connection. These can be used as a pin for functions other than CSC. LB/UB pins and DQ14-8 pins of SRAM are not used for this connection. It is recommended to pull it up on the substrate. Figure 3 Byte mode connection Suitable Products RA Family ","['The image depicts a technical diagram of a 48-pin TSOP (Thin Small Outline Package) integrated circuit (IC). The diagram is presented in black and white, with the IC\'s pins numbered from A0 to A19 on the left side and DQ0 to DQ15 on the right side. The top of the diagram features two labels: ""A0 to A19 Address input (word mode)"" and ""A-1 to A19 Address input (byte mode)"". A red box highlights the pin labeled ""DQ15/A-1"", which is situated at the top-right corner of the diagram.\n\nThe background of the image is white, providing a clean and clear visual representation of the IC\'s pin layout. Overall, the diagram appears to be a technical illustration used for educational or instructional purposes, likely in the context of computer hardware or electronics engineering.', 'The image presents a technical diagram, likely from a user manual or technical documentation, illustrating the connection between a microcontroller unit (MCU) and a memory chip. The diagram is divided into two main sections: the left side represents the MCU, and the right side represents the memory chip.\n\n**MCU Section:**\n\n*   **RA MCU:** This section lists various signals and their corresponding pin numbers on the MCU.\n*   **Byte address:** This section shows the byte address of the MCU, which is used to access specific bytes of data in the memory.\n*   **Data:** This section lists the data pins of the MCU, which are used to transfer data between the MCU and the memory chip.\n*   **Pull up on user board:** This section indicates that the pull-up resistors are connected to the user board, which is used to pull up the signals to a high logic level when they are not being driven by the MCU.\n\n**Memory Chip Section:**\n\n*   **SRAM: RMLV1616:** This section represents the memory chip, specifically a SRAM (Static Random Access Memory) chip with the part number RMLV1616.\n*   **Word address:** This section shows the word address of the memory chip, which is used to access specific words of data in the memory.\n*   **Data:** This section lists the data pins of the memory chip, which are used to transfer data between the memory chip and the MCU.\n*   **Pull up on user board:** This section indicates that the pull-up resistors are connected to the user board, which is used to pull up the signals to a high logic level when they are not being driven by the memory chip.\n\n**Connection between MCU and Memory Chip:**\n\n*   The diagram shows the connections between the MCU and the memory chip using lines and arrows.\n*   The connections are labeled with the signal names and pin numbers.\n*   The diagram also shows the direction of data flow between the MCU and the memory chip.\n\nIn summary, the image provides a detailed technical diagram of the connection between a microcontroller unit (MCU) and a memory chip. The diagram shows the various signals and their corresponding pin numbers on both the MCU and the memory chip, as well as the connections between them. The diagram is likely used in a user manual or technical documentation to help users understand how to connect the MCU and memory chip correctly.', 'The image presents a technical diagram illustrating the connections between two integrated circuits (ICs): the RA MCU and the SRAM: RMLV1616. The diagram is divided into two columns, with the left column dedicated to the RA MCU and the right column focused on the SRAM: RMLV1616.\n\n**RA MCU Column:**\n\n*   **Byte Address:** A20, A19-2, A1\n*   **Byte Address:** A0/BC0\n*   **Data:** D[15-8]*, D[7-0]\n*   **Pull-up on User Board:** Pull up on user board\n*   **CSn:** CSn\n*   **RD:** RD\n*   **WR:** WR\n*   **BC1:** BC1*\n*   ***These pins can be used as other functions.**\n\n**SRAM: RMLV1616 Column:**\n\n*   **Word Address:** Word address\n*   **Word Address:** Word address\n*   **Word Address:** Word address\n*   **Word Address:** Word address\n*   **D15/A-1:** D15/A-1\n*   **DQ[14-8]:** DQ[14-8]\n*   **DQ[7-0]:** DQ[7-0]\n*   **Pull up on User Board:** Pull up on user board\n*   **CS2:** CS2\n*   **CS1#:** CS1#\n*   **OE#:** OE#\n*   **WE#:** WE#\n*   **LB#:** LB#\n*   **UB#:** UB#\n*   **Pull Down on User Board:** Pull down on user board\n*   **BYTE#:** BYTE#\n\nThe diagram provides a clear visual representation of the connections between the RA MCU and the SRAM: RMLV1616, highlighting the specific pins and their functions. This information is crucial for understanding the communication between these two ICs and ensuring proper system operation.']"
c6a4d7a380e20427c73bafb0a02760ef,"Question:
I plan to connect a 16-bit wide SDRAM by using the SDRAM area controller (SDRAMC) of the RA MCU.
I am considering the following four types of Micron memory as target memory. Is it possible to use any one of these SDRAMs?
MT48LC4M16A2   –  64Mb ( 8MB)
MT48LC8M16A2   – 128Mb (16MB)
MT48LC16M16A2 – 256Mb (32MB)
MT48LC32M16A2 – 512Mb (64MB)
Answer:
Yes, it is possible to connect these SDRAM types.
If the user wants to connect the largest memory MT48LC32M16A2, Figure 1 shows the general connection method. On the other hand, as shown in Figure 2, all four types of memory can be used on the same PCB which is designed by replacing some of the wiring of the address line and bank address line.
In addition, the address pins of the RA MCU use byte addressing, and the address pins of the SDRAM use word addressing. For this reason, the address lines of the two devices are connected using an offset.
Figure 1.  General Connection
  Figure 2. Proposed Connection
  【Explanation】
Comparing the addressing specifications of the four types of SDRAM, they can be classified as shown in Table 1.
Table 1. The address specifications of each SDRAM
Part Numbers Density Bank address Row address Column address
MT48LC4M16A2 64Mb (8MB) BA[1:0] (2bit)
A[11:0] (12bits)
A[7:0] (8bits)
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits)
MT48LC16M16A2 256Mb (32MB) A[12:0] (13bits)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits)
The difference in column address can be managed by setting the register of the RA MCU. By changing the address multiplexing selection bits of the SDRAM address register (SDADR. MXC[1:0]) , the amount of shift in the row address is set and it does not directly affect the routing on the board.

Table 2. The setting of address multiplexing for each SDRAM
Part Numbers Density Column address SDADR.MXC[1:0]
MT48LC4M16A2 64Mb (8MB) A[7:0] (8bits) 0 0 : 8-bit shift
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits) 0 1 : 9-bit shift
MT48LC16M16A2 256Mb (32MB)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits) 1 0 : 10-bit shift
  On the other hand, the difference in Row address needs to be managed by H/W.
First, check the address specifications of the RA MCU. Table 3. shows the relationship between the RA MCU internal address and the RA MCU external pins for SDRAM address. As shown in this table, MT48LC16M16A2 (32 MB) and MT48LC32M16A2 (64 MB) require one more external pin A15.

Table 3. Relationship between RA MCU internal address and External address pins
a[31:0] : RA MCU Internal address
A[15:0] : RA MCU External pins for SDRAMC address signals
  Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC.
By connecting that pin36 (A12) to the A15 pin of the RA MCU and shifting the bank address, it is possible to realize a board which has the required specifications.
Figure 3. Pin assignment (MT48LC4M16A2 and MT48LC8M16A2)
    Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2)
    【Reference】
The relationship between each connection and their memory allocation when the MT48LC32M16A2 is selected as follows.
In the case of the proposed connection, the access in SDRAM is interleaved. As a result, data is stored in a different location in SDRAM compared to general connection, but there is no particular effect on the operation of the RA MCU.
Figure 5. Memory allocation (general connection)
  Figure 6. Memory allocation (proposed connection)
  Suitable Products
RA8M1, RA8D1, RA8T1, RA8E2, RA6M3, RA6M2
I plan to connect a 16-bit wide SDRAM by using the SDRAM area controller (SDRAMC) of the RA MCU.
I am considering the following four types of Micron memory as target memory. Is it possible to use any one of these SDRAMs?
MT48LC4M16A2   –  64Mb ( 8MB)
MT48LC8M16A2   – 128Mb (16MB)
MT48LC16M16A2 – 256Mb (32MB)
MT48LC32M16A2 – 512Mb (64MB)
I plan to connect a 16-bit wide SDRAM by using the SDRAM area controller (SDRAMC) of the RA MCU.
I am considering the following four types of Micron memory as target memory. Is it possible to use any one of these SDRAMs?
Answer:
Yes, it is possible to connect these SDRAM types.
If the user wants to connect the largest memory MT48LC32M16A2, Figure 1 shows the general connection method. On the other hand, as shown in Figure 2, all four types of memory can be used on the same PCB which is designed by replacing some of the wiring of the address line and bank address line.
In addition, the address pins of the RA MCU use byte addressing, and the address pins of the SDRAM use word addressing. For this reason, the address lines of the two devices are connected using an offset.
Figure 1.  General Connection
  Figure 2. Proposed Connection
  【Explanation】
Comparing the addressing specifications of the four types of SDRAM, they can be classified as shown in Table 1.
Table 1. The address specifications of each SDRAM
Part Numbers Density Bank address Row address Column address
MT48LC4M16A2 64Mb (8MB) BA[1:0] (2bit)
A[11:0] (12bits)
A[7:0] (8bits)
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits)
MT48LC16M16A2 256Mb (32MB) A[12:0] (13bits)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits)
The difference in column address can be managed by setting the register of the RA MCU. By changing the address multiplexing selection bits of the SDRAM address register (SDADR. MXC[1:0]) , the amount of shift in the row address is set and it does not directly affect the routing on the board.

Table 2. The setting of address multiplexing for each SDRAM
Part Numbers Density Column address SDADR.MXC[1:0]
MT48LC4M16A2 64Mb (8MB) A[7:0] (8bits) 0 0 : 8-bit shift
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits) 0 1 : 9-bit shift
MT48LC16M16A2 256Mb (32MB)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits) 1 0 : 10-bit shift
  On the other hand, the difference in Row address needs to be managed by H/W.
First, check the address specifications of the RA MCU. Table 3. shows the relationship between the RA MCU internal address and the RA MCU external pins for SDRAM address. As shown in this table, MT48LC16M16A2 (32 MB) and MT48LC32M16A2 (64 MB) require one more external pin A15.

Table 3. Relationship between RA MCU internal address and External address pins
a[31:0] : RA MCU Internal address
A[15:0] : RA MCU External pins for SDRAMC address signals
  Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC.
By connecting that pin36 (A12) to the A15 pin of the RA MCU and shifting the bank address, it is possible to realize a board which has the required specifications.
Figure 3. Pin assignment (MT48LC4M16A2 and MT48LC8M16A2)
    Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2)
    【Reference】
The relationship between each connection and their memory allocation when the MT48LC32M16A2 is selected as follows.
In the case of the proposed connection, the access in SDRAM is interleaved. As a result, data is stored in a different location in SDRAM compared to general connection, but there is no particular effect on the operation of the RA MCU.
Figure 5. Memory allocation (general connection)
  Figure 6. Memory allocation (proposed connection)
  Suitable Products
RA8M1, RA8D1, RA8T1, RA8E2, RA6M3, RA6M2
Yes, it is possible to connect these SDRAM types.
If the user wants to connect the largest memory MT48LC32M16A2, Figure 1 shows the general connection method. On the other hand, as shown in Figure 2, all four types of memory can be used on the same PCB which is designed by replacing some of the wiring of the address line and bank address line.
In addition, the address pins of the RA MCU use byte addressing, and the address pins of the SDRAM use word addressing. For this reason, the address lines of the two devices are connected using an offset.
Figure 1.  General Connection
  Figure 2. Proposed Connection
  【Explanation】
Comparing the addressing specifications of the four types of SDRAM, they can be classified as shown in Table 1.
Table 1. The address specifications of each SDRAM
Part Numbers Density Bank address Row address Column address
MT48LC4M16A2 64Mb (8MB) BA[1:0] (2bit)
A[11:0] (12bits)
A[7:0] (8bits)
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits)
MT48LC16M16A2 256Mb (32MB) A[12:0] (13bits)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits)
The difference in column address can be managed by setting the register of the RA MCU. By changing the address multiplexing selection bits of the SDRAM address register (SDADR. MXC[1:0]) , the amount of shift in the row address is set and it does not directly affect the routing on the board.

Table 2. The setting of address multiplexing for each SDRAM
Part Numbers Density Column address SDADR.MXC[1:0]
MT48LC4M16A2 64Mb (8MB) A[7:0] (8bits) 0 0 : 8-bit shift
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits) 0 1 : 9-bit shift
MT48LC16M16A2 256Mb (32MB)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits) 1 0 : 10-bit shift
  On the other hand, the difference in Row address needs to be managed by H/W.
First, check the address specifications of the RA MCU. Table 3. shows the relationship between the RA MCU internal address and the RA MCU external pins for SDRAM address. As shown in this table, MT48LC16M16A2 (32 MB) and MT48LC32M16A2 (64 MB) require one more external pin A15.

Table 3. Relationship between RA MCU internal address and External address pins
a[31:0] : RA MCU Internal address
A[15:0] : RA MCU External pins for SDRAMC address signals
  Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC.
By connecting that pin36 (A12) to the A15 pin of the RA MCU and shifting the bank address, it is possible to realize a board which has the required specifications.
Figure 3. Pin assignment (MT48LC4M16A2 and MT48LC8M16A2)
    Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2)
    【Reference】
The relationship between each connection and their memory allocation when the MT48LC32M16A2 is selected as follows.
In the case of the proposed connection, the access in SDRAM is interleaved. As a result, data is stored in a different location in SDRAM compared to general connection, but there is no particular effect on the operation of the RA MCU.
Figure 5. Memory allocation (general connection)
  Figure 6. Memory allocation (proposed connection)
  Suitable Products
Yes, it is possible to connect these SDRAM types.
If the user wants to connect the largest memory MT48LC32M16A2, Figure 1 shows the general connection method. On the other hand, as shown in Figure 2, all four types of memory can be used on the same PCB which is designed by replacing some of the wiring of the address line and bank address line.
In addition, the address pins of the RA MCU use byte addressing, and the address pins of the SDRAM use word addressing. For this reason, the address lines of the two devices are connected using an offset.
Figure 1.  General Connection
Figure 2. Proposed Connection
【Explanation】
Comparing the addressing specifications of the four types of SDRAM, they can be classified as shown in Table 1.
Table 1. The address specifications of each SDRAM
A[11:0] (12bits)
The difference in column address can be managed by setting the register of the RA MCU. By changing the address multiplexing selection bits of the SDRAM address register (SDADR. MXC[1:0]) , the amount of shift in the row address is set and it does not directly affect the routing on the board.
Table 2. The setting of address multiplexing for each SDRAM
On the other hand, the difference in Row address needs to be managed by H/W.
First, check the address specifications of the RA MCU. Table 3. shows the relationship between the RA MCU internal address and the RA MCU external pins for SDRAM address. As shown in this table, MT48LC16M16A2 (32 MB) and MT48LC32M16A2 (64 MB) require one more external pin A15.
Table 3. Relationship between RA MCU internal address and External address pins
a[31:0] : RA MCU Internal address
A[15:0] : RA MCU External pins for SDRAMC address signals
Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC.
By connecting that pin36 (A12) to the A15 pin of the RA MCU and shifting the bank address, it is possible to realize a board which has the required specifications.
Figure 3. Pin assignment (MT48LC4M16A2 and MT48LC8M16A2)
Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2)
【Reference】
The relationship between each connection and their memory allocation when the MT48LC32M16A2 is selected as follows.
In the case of the proposed connection, the access in SDRAM is interleaved. As a result, data is stored in a different location in SDRAM compared to general connection, but there is no particular effect on the operation of the RA MCU.
Figure 5. Memory allocation (general connection)
Figure 6. Memory allocation (proposed connection)
Suitable Products
RA8M1, RA8D1, RA8T1, RA8E2, RA6M3, RA6M2
Japanese
Japanese","['data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/4c303e20af5c11ada331a29cc1d9e024.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/80af3029d7bc0032a1bf868e2c832ee3.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/78abf77ad0677d25f5cfeecc0f956bcb.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/1d6ce4771fc1258e2b76554974a614ce.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/073bbfafdf13ff0625cd5775759cb475.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/72da270b198e18f9fdda958a980cd1bb.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/992a3ae603af962032c66bed8d6df848.png']",[],"['|  |\n|  |\n| Part Numbers | Density | Bank address | Row address | Column address |\n| MT48LC4M16A2 | 64Mb (8MB) | BA[1:0] (2bit) | A[11:0] (12bits) | A[7:0] (8bits) |\n| MT48LC8M16A2 | 128Mb (16MB) | A[8:0] (9bits) |\n| MT48LC16M16A2 | 256Mb (32MB) | A[12:0] (13bits) |\n| MT48LC32M16A2 | 512Mb (64MB) | A[9:0] (10bits) |', '|  |\n|  |\n| Part Numbers | Density | Column address | SDADR.MXC[1:0] |\n| MT48LC4M16A2 | 64Mb (8MB) | A[7:0] (8bits) | 0 0 : 8-bit shift |\n| MT48LC8M16A2 | 128Mb (16MB) | A[8:0] (9bits) | 0 1 : 9-bit shift |\n| MT48LC16M16A2 | 256Mb (32MB) |\n| MT48LC32M16A2 | 512Mb (64MB) | A[9:0] (10bits) | 1 0 : 10-bit shift |', '|  |\n|  |\n| RA8M1, RA8D1, RA8T1, RA8E2, RA6M3, RA6M2 |']","{'title': 'RA Family: How to connect external SDRAM', 'url': 'https://en-support.renesas.com/knowledgeBase/21810949', 'last_updated': None, 'extracted_at': '2025-03-08T23:35:32.172218'}","Question I plan to connect a 16-bit wide SDRAM by using the SDRAM area controller (SDRAMC) of the RA MCU. I am considering the following four types of Micron memory as target memory. Is it possible to use any one of these SDRAMs? MT48LC4M16A2  64Mb ( 8MB) MT48LC8M16A2  128Mb (16MB) MT48LC16M16A2  256Mb (32MB) MT48LC32M16A2  512Mb (64MB) Answer Yes, it is possible to connect these SDRAM types. If the user wants to connect the largest memory MT48LC32M16A2, Figure 1 shows the general connection method. On the other hand, as shown in Figure 2, all four types of memory can be used on the same PCB which is designed by replacing some of the wiring of the address line and bank address line. In addition, the address pins of the RA MCU use byte addressing, and the address pins of the SDRAM use word addressing. For this reason, the address lines of the two devices are connected using an offset. Figure 1. General Connection Figure 2. Proposed Connection Explanation Comparing the addressing specifications of the four types of SDRAM, they can be classified as shown in Table 1. Table 1. The address specifications of each SDRAM Part Numbers Density Bank address Row address Column address MT48LC4M16A2 64Mb (8MB) BA10 (2bit) A110 (12bits) A70 (8bits) MT48LC8M16A2 128Mb (16MB) A80 (9bits) MT48LC16M16A2 256Mb (32MB) A120 (13bits) MT48LC32M16A2 512Mb (64MB) A90 (10bits) The difference in column address can be managed by setting the register of the RA MCU. By changing the address multiplexing selection bits of the SDRAM address register (SDADR. MXC10) , the amount of shift in the row address is set and it does not directly affect the routing on the board. Table 2. The setting of address multiplexing for each SDRAM Part Numbers Density Column address SDADR.MXC10 MT48LC4M16A2 64Mb (8MB) A70 (8bits) 0 0  8-bit shift MT48LC8M16A2 128Mb (16MB) A80 (9bits) 0 1  9-bit shift MT48LC16M16A2 256Mb (32MB) MT48LC32M16A2 512Mb (64MB) A90 (10bits) 1 0  10-bit shift On the other hand, the difference in Row address needs to be managed by H/W. First, check the address specifications of the RA MCU. Table 3. shows the relationship between the RA MCU internal address and the RA MCU external pins for SDRAM address. As shown in this table, MT48LC16M16A2 (32 MB) and MT48LC32M16A2 (64 MB) require one more external pin A15. Table 3. Relationship between RA MCU internal address and External address pins a310  RA MCU Internal address A150  RA MCU External pins for SDRAMC address signals Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC. By connecting that pin36 (A12) to the A15 pin of the RA MCU and shifting the bank address, it is possible to realize a board which has the required specifications. Figure 3. Pin assignment (MT48LC4M16A2 and MT48LC8M16A2) Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2) Reference The relationship between each connection and their memory allocation when the MT48LC32M16A2 is selected as follows. In the case of the proposed connection, the access in SDRAM is interleaved. As a result, data is stored in a different location in SDRAM compared to general connection, but there is no particular effect on the operation of the RA MCU. Figure 5. Memory allocation (general connection) Figure 6. Memory allocation (proposed connection) Suitable Products RA8M1, RA8D1, RA8T1, RA8E2, RA6M3, RA6M2 Figure 2. Proposed Connection Explanation On the other hand, the difference in Row address needs to be managed by H/W. Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC. Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2) Reference Figure 6. Memory allocation (proposed connection) Suitable Products Japanese","['The image presents a detailed comparison of the RA MCU and SDRAM: MT48LC32M16A2, highlighting their respective byte addresses, data, and bank addresses. The image is divided into two columns, with the left column dedicated to the RA MCU and the right column focused on the SDRAM: MT48LC32M16A2.\n\n**RA MCU Column:**\n\n* **Byte Address:**\n\t+ A15\n\t+ A14\n\t+ A13\n\t+ A12-1\n* **Data:**\n\t+ DQ[15-0]\n\t+ DQM1\n\t+ DQM0\n\t+ SDCS\n\t+ RAS\n\t+ CAS\n\t+ WE\n\t+ CKE\n\t+ SDCLK\n* **Bank Address:**\n\t+ BA1\n\t+ BA0\n\t+ A12\n\t+ A11-0\n\n**SDRAM: MT48LC32M16A2 Column:**\n\n* **Byte Address:**\n\t+ BA1\n\t+ BA0\n\t+ A12\n\t+ A11-0\n* **Data:**\n\t+ DQ[15-0]\n\t+ DQM1\n\t+ DQM0\n\t+ DQML\n\t+ CS#\n\t+ RAS#\n\t+ CAS#\n\t+ WE#\n\t+ CKE\n\t+ CLK\n* **Bank Address:**\n\t+ Bank address\n\t+ Word address\n\t+ Word address\n\nThe image provides a clear and concise comparison of the RA MCU and SDRAM: MT48LC32M16A2, highlighting their differences in byte addresses, data, and bank addresses. This information is essential for understanding the functionality and operation of these components in electronic systems.', 'The image presents a detailed diagram of the SDRAM (Synchronous Dynamic Random Access Memory) memory interface, showcasing its various components and their connections. The diagram is divided into two main sections: the left side represents the RA MCU (Random Access Memory Controller Unit), while the right side represents the SDRAM.\n\n**RA MCU Section:**\n\n*   **Byte Address:** A15, A14, A13, A12-1\n*   **Data:** DQ[15-0], DQM1, DQM0, SDCS, RAS, CAS, WE, CKE, SDCLK\n\n**SDRAM Section:**\n\n*   **Bank Address:** BA1, BA0, A12\n*   **Word Address:** A[11-0]\n*   **Data:** DQ[15-0], DQM1, DQM0, DQML, CS#, RAS#, CAS#, WE#, CKE#, CLK\n\nThe diagram illustrates the connections between the RA MCU and the SDRAM, highlighting the various signals and their roles in the memory interface. The use of different colors and line styles helps to distinguish between the different types of signals and their connections.\n\nOverall, the diagram provides a clear and detailed representation of the SDRAM memory interface, making it easier to understand and analyze the complex interactions between the RA MCU and the SDRAM.', ""The image presents a table that illustrates the relationship between the internal address of a microcontroller's Random Access Memory (RAM) and the external address of the memory. The table is divided into several columns, each representing a different memory size: 8MB, 16MB, 32MB, and 64MB.\n\nThe first column lists the internal address of the RAM, ranging from 0x0000 to 0x3FFFF. The subsequent columns display the corresponding external addresses for each memory size. The external addresses are represented in hexadecimal format, with the most significant bit (MSB) on the left and the least significant bit (LSB) on the right.\n\nThe table also includes additional information, such as the row and column addresses for each memory size. The row addresses are listed in the second column, while the column addresses are shown in the third column. The table provides a clear and concise visual representation of the relationship between the internal and external addresses of the RAM, making it easier to understand and work with the memory layout.\n\nOverall, the table is a useful tool for developers and engineers who need to work with the memory architecture of a microcontroller. It provides a quick and easy way to look up the external address corresponding to a given internal address, and vice versa."", 'The image presents a detailed diagram of a microcontroller, specifically the ATmega328P, with its pinout and various components labeled. The diagram is divided into two main sections: the left side, which displays the pinout, and the right side, which shows the pinout with additional information.\n\n**Left Side: Pinout**\n\n*   The pinout is organized into two columns, with the first column listing the pin numbers (1-54) and the second column displaying the corresponding pin names.\n*   The pin names are color-coded, with blue indicating digital pins, green indicating analog pins, and red indicating special function pins.\n*   The pinout includes various symbols and abbreviations, such as ""VDD"" for the power supply voltage, ""VSS"" for the ground voltage, ""DQ0"" for the data output pin 0, and ""A0"" for the analog input pin 0.\n\n**Right Side: Pinout with Additional Information**\n\n*   The right side of the diagram provides additional information about each pin, including its function, voltage level, and current rating.\n*   The functions are listed in a table format, with columns for the pin number, pin name, function, voltage level, and current rating.\n*   The functions include digital input/output, analog input/output, timer/counter, serial communication, and more.\n*   The voltage levels are listed in millivolts (mV), ranging from 0 to 5V.\n*   The current ratings are listed in milliamps (mA), ranging from 0 to 40mA.\n\n**Bottom Section: Microcontroller Information**\n\n*   The bottom section of the diagram displays information about the microcontroller itself, including its name, model number, and manufacturer.\n*   The microcontroller is identified as the ATmega328P, which is a popular 8-bit microcontroller from Atmel (now part of Microchip Technology).\n*   The model number is listed as MT48LC8M16A2, which refers to the specific memory configuration of the microcontroller.\n*   The manufacturer is listed as Atmel, indicating that the microcontroller was designed and manufactured by this company.\n\nOverall, the diagram provides a comprehensive overview of the ATmega328P microcontroller\'s pinout, functions, and specifications, making it a useful resource for engineers, designers, and hobbyists working with this microcontroller.', ""The image presents a detailed diagram of a microcontroller's pinout, showcasing the various pins and their corresponding functions. The diagram is divided into two sections, with the left side displaying the pinout for a 16-pin microcontroller and the right side showing the pinout for a 32-pin microcontroller.\n\n**Key Features:**\n\n*   **Pinout Diagram:** The diagram illustrates the layout of the microcontroller's pins, including their names, functions, and pin numbers.\n*   **Pin Functions:** Each pin is labeled with its function, such as VDD (power supply), VSS (ground), DQ0-DQ15 (data output), A0-A12 (address pins), and others.\n*   **Pin Numbers:** The pins are numbered from 1 to 54, with the 16-pin microcontroller having pins 1-16 and the 32-pin microcontroller having pins 1-32.\n*   **Pinout Comparison:** The diagram allows for a direct comparison between the pinouts of the two microcontrollers, highlighting the differences in pin count and function.\n*   **Labels and Legends:** The diagram includes labels and legends to provide additional information about the pins and their functions.\n\n**Conclusion:**\n\nThe image provides a clear and detailed representation of the microcontroller's pinout, making it easier for users to understand the layout and functions of the pins. The comparison between the 16-pin and 32-pin microcontrollers allows users to identify the differences and similarities between the two devices."", 'The image presents a comparison between the memory allocation in RA MCU and SDRAM. The left side of the image displays a table with two columns, one for RA MCU and the other for SDRAM. The table lists various memory addresses, including byte addresses, word addresses, and data. The right side of the image features a diagram illustrating the memory allocation in both RA MCU and SDRAM.\n\n**RA MCU Memory Allocation:**\n\n*   The RA MCU memory allocation is depicted as a series of blocks, each representing a specific memory address.\n*   The blocks are labeled with their corresponding memory addresses, ranging from 0 to 7.\n*   The diagram shows that the RA MCU has a total of 8 MB of memory, divided into 8 blocks of 1 MB each.\n\n**SDRAM Memory Allocation:**\n\n*   The SDRAM memory allocation is also depicted as a series of blocks, each representing a specific memory address.\n*   The blocks are labeled with their corresponding memory addresses, ranging from 0 to 7.\n*   The diagram shows that the SDRAM has a total of 8 MB of memory, divided into 8 blocks of 1 MB each.\n\n**Comparison:**\n\n*   Both RA MCU and SDRAM have the same total memory capacity of 8 MB.\n*   Both have the same number of blocks, with each block representing 1 MB of memory.\n*   The memory addresses in both RA MCU and SDRAM are identical, ranging from 0 to 7.\n\nIn summary, the image provides a clear comparison of the memory allocation in RA MCU and SDRAM, highlighting their similarities and differences. Both have the same total memory capacity and block structure, but the image does not provide any additional information about the specific characteristics or features of each memory type.', 'The image presents a comparison between the memory allocation in RA MCU and SDRAM. The left side of the image displays a diagram illustrating the memory allocation in RA MCU, while the right side shows a similar diagram for SDRAM.\n\n**RA MCU Memory Allocation Diagram:**\n\n*   The diagram is divided into two sections: ""RA MCU"" and ""SDRAM: MT48LC32M16A2.""\n*   The ""RA MCU"" section features a table with three columns: ""Byte address,"" ""Byte address,"" and ""Byte address.""\n*   The ""SDRAM: MT48LC32M16A2"" section also has three columns: ""Bank address,"" ""Word address,"" and ""Word address.""\n*   The table contains various data points, including ""A15,"" ""A14,"" ""A13,"" ""A12-1,"" ""DQ[15-0],"" ""DQM1,"" ""DQM0,"" ""SDCS,"" ""RAS,"" ""CAS,"" ""WE,"" ""CKE,"" and ""SDCLK.""\n*   The diagram includes a key that explains the abbreviations used in the table.\n\n**SDRAM Memory Allocation Diagram:**\n\n*   The diagram is divided into two sections: ""Memory allocation in RA MCU"" and ""Memory allocation in SDRAM.""\n*   The ""Memory allocation in RA MCU"" section features a table with three columns: ""8MB,"" ""7,"" and ""6.""\n*   The ""Memory allocation in SDRAM"" section also has three columns: ""8MB,"" ""7,"" and ""6.""\n*   The table contains various data points, including ""8MB,"" ""7,"" ""6,"" ""5,"" ""4,"" ""3,"" ""2,"" ""1,"" and ""0.""\n*   The diagram includes a key that explains the abbreviations used in the table.\n\n**Comparison of RA MCU and SDRAM Memory Allocation:**\n\n*   The two diagrams show that the memory allocation in RA MCU and SDRAM is different.\n*   The RA MCU diagram has a more complex structure, with multiple columns and rows, while the SDRAM diagram is simpler, with only three columns.\n*   The data points in the two diagrams are also different, with the RA MCU diagram containing more specific information about the memory allocation.\n\nIn summary, the image provides a visual comparison of the memory allocation in RA MCU and SDRAM, highlighting the differences between the two systems. The RA MCU diagram is more complex and contains more specific information about the memory allocation, while the SDRAM diagram is simpler and more straightforward.']"
811bb5e293d798ab9432732a5358105f,"Question:
When an I2C slave executes a clock stretching action (holding the clock line SCL low to  wait for the master), RA family MCU (master) detects an unexpected start condition on the I2C bus.
Answer:
When a I2C slave executes a clock stretching and releases it, it outputs the data line signal for the next first clock, and then sets up a data input setup time specified by the electrical characteristics of the MCU (please refer to the MCU user's manual) and a data setup time specified by I2C bus specification (Standard mode: Min 250 ns, High-speed mode: Min 100 ns) before releasing the clock line low.
If the data setup time is not met, the master may detect an unexpected start condition (the data line SDA is falling during the clock line SCL is high).
Figure. Example of timing of I2C clock stretching
Suitable Products
RA MCU
When an I2C slave executes a clock stretching action (holding the clock line SCL low to  wait for the master), RA family MCU (master) detects an unexpected start condition on the I2C bus.
When an I2C slave executes a clock stretching action (holding the clock line SCL low to  wait for the master), RA family MCU (master) detects an unexpected start condition on the I2C bus.
Answer:
When a I2C slave executes a clock stretching and releases it, it outputs the data line signal for the next first clock, and then sets up a data input setup time specified by the electrical characteristics of the MCU (please refer to the MCU user's manual) and a data setup time specified by I2C bus specification (Standard mode: Min 250 ns, High-speed mode: Min 100 ns) before releasing the clock line low.
If the data setup time is not met, the master may detect an unexpected start condition (the data line SDA is falling during the clock line SCL is high).
Figure. Example of timing of I2C clock stretching
Suitable Products
RA MCU
When a I2C slave executes a clock stretching and releases it, it outputs the data line signal for the next first clock, and then sets up a data input setup time specified by the electrical characteristics of the MCU (please refer to the MCU user's manual) and a data setup time specified by I2C bus specification (Standard mode: Min 250 ns, High-speed mode: Min 100 ns) before releasing the clock line low.
If the data setup time is not met, the master may detect an unexpected start condition (the data line SDA is falling during the clock line SCL is high).
Figure. Example of timing of I2C clock stretching
When a I2C slave executes a clock stretching and releases it, it outputs the data line signal for the next first clock, and then sets up a data input setup time specified by the electrical characteristics of the MCU (please refer to the MCU user's manual) and a data setup time specified by I2C bus specification (Standard mode: Min 250 ns, High-speed mode: Min 100 ns) before releasing the clock line low.
If the data setup time is not met, the master may detect an unexpected start condition (the data line SDA is falling during the clock line SCL is high).
Figure. Example of timing of I2C clock stretching
Suitable Products
RA MCU",['data/categories/ra_family/i2c-bus_interface_(iic)/811bb5e293d798ab9432732a5358105f/images/837e223a822c744d3c7abe227137e351.png'],[],['|  |\n|  |\n| RA MCU |'],"{'title': 'RA Family: I2C-BUS could detect unexpected Start Condition and malfunction when a slave device executes clock stretching', 'url': 'https://en-support.renesas.com/knowledgeBase/21180394', 'last_updated': None, 'extracted_at': '2025-03-08T23:36:45.558284'}","Question When an I2C slave executes a clock stretching action (holding the clock line SCL low to wait for the master), RA family MCU (master) detects an unexpected start condition on the I2C bus. Answer When a I2C slave executes a clock stretching and releases it, it outputs the data line signal for the next first clock, and then sets up a data input setup time specified by the electrical characteristics of the MCU (please refer to the MCU user's manual) and a data setup time specified by I2C bus specification (Standard mode Min 250 ns, High-speed mode Min 100 ns) before releasing the clock line low. If the data setup time is not met, the master may detect an unexpected start condition (the data line SDA is falling during the clock line SCL is high). Figure. Example of timing of I2C clock stretching Suitable Products RA MCU","[""The image depicts a diagram of the I2C (Inter-Integrated Circuit) protocol, which is a communication protocol used for short-distance communication between integrated circuits. The diagram shows the sequence of events that occur during an I2C transaction.\n\n**Components of the Diagram:**\n\n*   **SCL (Serial Clock Line):** This line carries the clock signal that synchronizes the data transfer between devices.\n*   **SDA (Serial Data Line):** This line carries the data being transmitted between devices.\n*   **Slave Address:** This is the unique address assigned to each device on the I2C bus.\n*   **WACK (Write Acknowledge):** This is a signal sent by the slave device to acknowledge receipt of data.\n*   **Data:** This represents the data being transmitted between devices.\n\n**Sequence of Events:**\n\n1.  **Start Condition:** The master device initiates the transaction by sending a start condition on the SCL line.\n2.  **Slave Address:** The master device sends the slave address to the slave device.\n3.  **WACK:** The slave device sends a WACK signal to acknowledge receipt of the slave address.\n4.  **Data:** The master device sends data to the slave device.\n5.  **WACK:** The slave device sends a WACK signal to acknowledge receipt of the data.\n6.  **Stop Condition:** The master device terminates the transaction by sending a stop condition on the SCL line.\n\n**Key Points:**\n\n*   The I2C protocol uses a master-slave architecture, where one device acts as the master and controls the data transfer.\n*   The slave device responds to the master device's requests and sends data back to the master device.\n*   The I2C protocol uses a single data line (SDA) and a single clock line (SCL) to transmit data.\n*   The I2C protocol is widely used in embedded systems, consumer electronics, and industrial control systems.\n\n**Conclusion:**\n\nThe I2C protocol is a simple and efficient way to communicate between devices over short distances. Its use of a single data line and clock line makes it easy to implement and cost-effective. The protocol is widely used in many applications, including embedded systems, consumer electronics, and industrial control systems.""]"
ccacdef63f51d672e7af05bc2720fbc5,"Overview
This article explains how and when the CPU interrupt handler call is generated on each RSPI and DMAC interrupt when using an RSPI as slave and enabling full-duplex and DMAC transfer.
This article only covers three types of interrupts.
RSPI - SPRIx : Receive buffer full interrupt
RSPI - SPTIx : Transmit buffer empty interrupt
DMAC - DMACxI : Transfer end interrupt (1 channel for RSPI RX linked to SPRIx interrupt and 1 channel for RSPI TX linked to SPTIx interrupt)
At the end of this article, some related driver software settings are introduced for your reference.
Operation Result
The following capture image shows a signal waveform when the RSPI receives 10 bytes of data. At this time, the DMAC transfer is enabled and configured to do 10 bytes (1 byte x 10 times) transfer triggered by each RSIP interrupts. In the image, “SSL”, “CLK” and “MOSI” are actual SPI communication signals, following “RSPI RX”, “RSPI TX”, “DMA RX” and “DMA TX” show the timing of the CPU interrupt handler call occurrence. The test program was implemented so that the GPIO pin will go to low when the CPU interrupt handler is called.
As you can see in the picture below, the interrupt handlers are called in the following order. We will review how and why the interrupt occurred at this timing:
DMAC transfer end interrupt for RSPI Transmit
RSPI Transmit buffer empty interrupt
DMAC transfer end interrupt for RSPI Receive
RSPI Receive buffer full interrupt (Does not occur)


1. DMAC transfer end interrupt for RSPI Transmit
First you will get the DMA TX transfer end interrupt around two bytes earlier. The reason why it occurs two bytes earlier is due to the RSPI shift register and the SPTI interrupt timing. As soon as RSPI is enabled, if the shit register is empty, the RSPI issues “TX buffer empty” interrupt, that triggers DMAC’s first transfer (first byte) to the RSIP data register (SPDR). The data will move to the shift register soon, and then another “TX buffer empty” interrupt occurrs and the second DMAC transfer (second byte) will be transferred. These are done before receiving the clock signal from the connected device. After that, the remaining 8 bytes will be transferred by synchronizing with the SPI clock. Therefore, the DMAC Transfer end interrupt occurs 2 bytes earlier.
Please note that this is not a good place to put some user code like restarting the RSPI slave operation, since the RSPI clock is still coming in.
Refer to section “Serial Peripheral Interface” > “Operation” > “Communications Operating Mode” > “Full-Duplex Communications” in the hardware user manual of MCU device.
2. RSPI Transmit buffer empty interrupt
After the DMAC has completed its TX task with the provided transfer information (e.g. number of transfers), the interrupt request of the RSPI Transmit buffer empty is passed to the CPU when the RSPI TX buffer is empty, so the CPU interrupt handler for the RSPI Transmit buffer empty will be executed. There is no special operation to do here.
3. DMAC transfer end interrupt for RSPI Receive
The DMAC transfer occurs every RSIP Receive buffer full interrupt, and the CPU interrupt handler call for DMAC transfer end interrupt is executed when the 10 bytes (10 times) transfer complete.
4. RSPI RX buffer full interrupt (Does not occur)
You may be wondering why the CPU interrupt handler call of the RSPI Transmit empty interrupt is called. but for the RSPI RX interrupt is not. As explained in #3, the DMAC transfer happens every RSPI Receive buffer full interrupt, so if it received 10 bytes (1 byte x 10 times), 10 interrupt requests are generated. However, all the interrupt requests are passed to the DMAC, and the DMAC executes 10 data transfers. Therefore, in the case of the RSPI RX buffer full interrupt, the CPU interrupt handler call does not happen.
Please note that the RSPI RX buffer full interrupt handler is not a good place to put user code like restarting the RSPI slave operation, and instead it would be better to put it in the DMAC transfer end interrupt for the RSPI Receive handler.
Setting - RSPI slave interrupt generation and user callback code generation
To trigger the DMAC transfer by the RSPI, the RSPI should enable either the TX or TX/RX interrupts. The RSPI can enable the TX interrupt by setting RSPIx.SPCR.SPTIE=1 and the RX interrupt by setting RSPIx.SPCR.SPRIE=1. This allows the RSPI interrupt to arrive at the ICU.
In the CG driver setting on the smart configurator, you can find the “Callback function setting” field below. However, this field setting enables the generation of user callback function code to allow the user to put any code into the CPU interrupt handling. Even if you uncheck the boxes below, TX, RX, Error interrupt handlers will still be created by the smart configurator (code generator).
Please don’t confuse enabling RSPI interrupts and generating the user callback function code for RSPI interrupts.
Setting - ICU
The ICU is responsible for deciding whether to forward the RSPI generated interrupts to the CPU or to the DMA (DTC or DMAC). First, the ICU should be configured to receive the RSPI TX or the TX/RX interrupts by setting ICU.IERm.IENn. Then, the ICU needs to be configured to relay the RSPI TX or the RX interrupts to the respective DMAC channel (ICU.DMARSRm), not to the CPU in our example.
Setting - DMAC interrupt handling (generation)
Unlike the DTC, the DMAC can generate an interrupt (DMACxI) with its own interrupt generation sources, such as the DMAC transfer end event. Additionally, the DMAC can be configured (DMACm.DMCSL.DISEL) to pass every single interrupt to the CPU after it has processed them. However, this will increase unnecessary CPU/bus load, so keep the setting as follows. (“Clear interrupt flag of the activation source”)


Suitable Products
RX Family
Overview
Overview
This article explains how and when the CPU interrupt handler call is generated on each RSPI and DMAC interrupt when using an RSPI as slave and enabling full-duplex and DMAC transfer.
This article only covers three types of interrupts.
RSPI - SPRIx : Receive buffer full interrupt
RSPI - SPTIx : Transmit buffer empty interrupt
DMAC - DMACxI : Transfer end interrupt (1 channel for RSPI RX linked to SPRIx interrupt and 1 channel for RSPI TX linked to SPTIx interrupt)
At the end of this article, some related driver software settings are introduced for your reference.
This article explains how and when the CPU interrupt handler call is generated on each RSPI and DMAC interrupt when using an RSPI as slave and enabling full-duplex and DMAC transfer.
This article only covers three types of interrupts.
At the end of this article, some related driver software settings are introduced for your reference.
Operation Result
The following capture image shows a signal waveform when the RSPI receives 10 bytes of data. At this time, the DMAC transfer is enabled and configured to do 10 bytes (1 byte x 10 times) transfer triggered by each RSIP interrupts. In the image, “SSL”, “CLK” and “MOSI” are actual SPI communication signals, following “RSPI RX”, “RSPI TX”, “DMA RX” and “DMA TX” show the timing of the CPU interrupt handler call occurrence. The test program was implemented so that the GPIO pin will go to low when the CPU interrupt handler is called.
As you can see in the picture below, the interrupt handlers are called in the following order. We will review how and why the interrupt occurred at this timing:
DMAC transfer end interrupt for RSPI Transmit
RSPI Transmit buffer empty interrupt
DMAC transfer end interrupt for RSPI Receive
RSPI Receive buffer full interrupt (Does not occur)


1. DMAC transfer end interrupt for RSPI Transmit
First you will get the DMA TX transfer end interrupt around two bytes earlier. The reason why it occurs two bytes earlier is due to the RSPI shift register and the SPTI interrupt timing. As soon as RSPI is enabled, if the shit register is empty, the RSPI issues “TX buffer empty” interrupt, that triggers DMAC’s first transfer (first byte) to the RSIP data register (SPDR). The data will move to the shift register soon, and then another “TX buffer empty” interrupt occurrs and the second DMAC transfer (second byte) will be transferred. These are done before receiving the clock signal from the connected device. After that, the remaining 8 bytes will be transferred by synchronizing with the SPI clock. Therefore, the DMAC Transfer end interrupt occurs 2 bytes earlier.
Please note that this is not a good place to put some user code like restarting the RSPI slave operation, since the RSPI clock is still coming in.
Refer to section “Serial Peripheral Interface” > “Operation” > “Communications Operating Mode” > “Full-Duplex Communications” in the hardware user manual of MCU device.
2. RSPI Transmit buffer empty interrupt
After the DMAC has completed its TX task with the provided transfer information (e.g. number of transfers), the interrupt request of the RSPI Transmit buffer empty is passed to the CPU when the RSPI TX buffer is empty, so the CPU interrupt handler for the RSPI Transmit buffer empty will be executed. There is no special operation to do here.
3. DMAC transfer end interrupt for RSPI Receive
The DMAC transfer occurs every RSIP Receive buffer full interrupt, and the CPU interrupt handler call for DMAC transfer end interrupt is executed when the 10 bytes (10 times) transfer complete.
4. RSPI RX buffer full interrupt (Does not occur)
You may be wondering why the CPU interrupt handler call of the RSPI Transmit empty interrupt is called. but for the RSPI RX interrupt is not. As explained in #3, the DMAC transfer happens every RSPI Receive buffer full interrupt, so if it received 10 bytes (1 byte x 10 times), 10 interrupt requests are generated. However, all the interrupt requests are passed to the DMAC, and the DMAC executes 10 data transfers. Therefore, in the case of the RSPI RX buffer full interrupt, the CPU interrupt handler call does not happen.
Please note that the RSPI RX buffer full interrupt handler is not a good place to put user code like restarting the RSPI slave operation, and instead it would be better to put it in the DMAC transfer end interrupt for the RSPI Receive handler.
Setting - RSPI slave interrupt generation and user callback code generation
To trigger the DMAC transfer by the RSPI, the RSPI should enable either the TX or TX/RX interrupts. The RSPI can enable the TX interrupt by setting RSPIx.SPCR.SPTIE=1 and the RX interrupt by setting RSPIx.SPCR.SPRIE=1. This allows the RSPI interrupt to arrive at the ICU.
In the CG driver setting on the smart configurator, you can find the “Callback function setting” field below. However, this field setting enables the generation of user callback function code to allow the user to put any code into the CPU interrupt handling. Even if you uncheck the boxes below, TX, RX, Error interrupt handlers will still be created by the smart configurator (code generator).
Please don’t confuse enabling RSPI interrupts and generating the user callback function code for RSPI interrupts.
Setting - ICU
The ICU is responsible for deciding whether to forward the RSPI generated interrupts to the CPU or to the DMA (DTC or DMAC). First, the ICU should be configured to receive the RSPI TX or the TX/RX interrupts by setting ICU.IERm.IENn. Then, the ICU needs to be configured to relay the RSPI TX or the RX interrupts to the respective DMAC channel (ICU.DMARSRm), not to the CPU in our example.
Setting - DMAC interrupt handling (generation)
Unlike the DTC, the DMAC can generate an interrupt (DMACxI) with its own interrupt generation sources, such as the DMAC transfer end event. Additionally, the DMAC can be configured (DMACm.DMCSL.DISEL) to pass every single interrupt to the CPU after it has processed them. However, this will increase unnecessary CPU/bus load, so keep the setting as follows. (“Clear interrupt flag of the activation source”)


Suitable Products
RX Family
Operation Result
Operation Result
The following capture image shows a signal waveform when the RSPI receives 10 bytes of data. At this time, the DMAC transfer is enabled and configured to do 10 bytes (1 byte x 10 times) transfer triggered by each RSIP interrupts. In the image, “SSL”, “CLK” and “MOSI” are actual SPI communication signals, following “RSPI RX”, “RSPI TX”, “DMA RX” and “DMA TX” show the timing of the CPU interrupt handler call occurrence. The test program was implemented so that the GPIO pin will go to low when the CPU interrupt handler is called.
As you can see in the picture below, the interrupt handlers are called in the following order. We will review how and why the interrupt occurred at this timing:
DMAC transfer end interrupt for RSPI Transmit
RSPI Transmit buffer empty interrupt
DMAC transfer end interrupt for RSPI Receive
RSPI Receive buffer full interrupt (Does not occur)


1. DMAC transfer end interrupt for RSPI Transmit
First you will get the DMA TX transfer end interrupt around two bytes earlier. The reason why it occurs two bytes earlier is due to the RSPI shift register and the SPTI interrupt timing. As soon as RSPI is enabled, if the shit register is empty, the RSPI issues “TX buffer empty” interrupt, that triggers DMAC’s first transfer (first byte) to the RSIP data register (SPDR). The data will move to the shift register soon, and then another “TX buffer empty” interrupt occurrs and the second DMAC transfer (second byte) will be transferred. These are done before receiving the clock signal from the connected device. After that, the remaining 8 bytes will be transferred by synchronizing with the SPI clock. Therefore, the DMAC Transfer end interrupt occurs 2 bytes earlier.
Please note that this is not a good place to put some user code like restarting the RSPI slave operation, since the RSPI clock is still coming in.
Refer to section “Serial Peripheral Interface” > “Operation” > “Communications Operating Mode” > “Full-Duplex Communications” in the hardware user manual of MCU device.
2. RSPI Transmit buffer empty interrupt
After the DMAC has completed its TX task with the provided transfer information (e.g. number of transfers), the interrupt request of the RSPI Transmit buffer empty is passed to the CPU when the RSPI TX buffer is empty, so the CPU interrupt handler for the RSPI Transmit buffer empty will be executed. There is no special operation to do here.
3. DMAC transfer end interrupt for RSPI Receive
The DMAC transfer occurs every RSIP Receive buffer full interrupt, and the CPU interrupt handler call for DMAC transfer end interrupt is executed when the 10 bytes (10 times) transfer complete.
4. RSPI RX buffer full interrupt (Does not occur)
You may be wondering why the CPU interrupt handler call of the RSPI Transmit empty interrupt is called. but for the RSPI RX interrupt is not. As explained in #3, the DMAC transfer happens every RSPI Receive buffer full interrupt, so if it received 10 bytes (1 byte x 10 times), 10 interrupt requests are generated. However, all the interrupt requests are passed to the DMAC, and the DMAC executes 10 data transfers. Therefore, in the case of the RSPI RX buffer full interrupt, the CPU interrupt handler call does not happen.
Please note that the RSPI RX buffer full interrupt handler is not a good place to put user code like restarting the RSPI slave operation, and instead it would be better to put it in the DMAC transfer end interrupt for the RSPI Receive handler.
Setting - RSPI slave interrupt generation and user callback code generation
To trigger the DMAC transfer by the RSPI, the RSPI should enable either the TX or TX/RX interrupts. The RSPI can enable the TX interrupt by setting RSPIx.SPCR.SPTIE=1 and the RX interrupt by setting RSPIx.SPCR.SPRIE=1. This allows the RSPI interrupt to arrive at the ICU.
In the CG driver setting on the smart configurator, you can find the “Callback function setting” field below. However, this field setting enables the generation of user callback function code to allow the user to put any code into the CPU interrupt handling. Even if you uncheck the boxes below, TX, RX, Error interrupt handlers will still be created by the smart configurator (code generator).
Please don’t confuse enabling RSPI interrupts and generating the user callback function code for RSPI interrupts.
Setting - ICU
The ICU is responsible for deciding whether to forward the RSPI generated interrupts to the CPU or to the DMA (DTC or DMAC). First, the ICU should be configured to receive the RSPI TX or the TX/RX interrupts by setting ICU.IERm.IENn. Then, the ICU needs to be configured to relay the RSPI TX or the RX interrupts to the respective DMAC channel (ICU.DMARSRm), not to the CPU in our example.
Setting - DMAC interrupt handling (generation)
Unlike the DTC, the DMAC can generate an interrupt (DMACxI) with its own interrupt generation sources, such as the DMAC transfer end event. Additionally, the DMAC can be configured (DMACm.DMCSL.DISEL) to pass every single interrupt to the CPU after it has processed them. However, this will increase unnecessary CPU/bus load, so keep the setting as follows. (“Clear interrupt flag of the activation source”)
The following capture image shows a signal waveform when the RSPI receives 10 bytes of data. At this time, the DMAC transfer is enabled and configured to do 10 bytes (1 byte x 10 times) transfer triggered by each RSIP interrupts. In the image, “SSL”, “CLK” and “MOSI” are actual SPI communication signals, following “RSPI RX”, “RSPI TX”, “DMA RX” and “DMA TX” show the timing of the CPU interrupt handler call occurrence. The test program was implemented so that the GPIO pin will go to low when the CPU interrupt handler is called.
As you can see in the picture below, the interrupt handlers are called in the following order. We will review how and why the interrupt occurred at this timing:
1. DMAC transfer end interrupt for RSPI Transmit
First you will get the DMA TX transfer end interrupt around two bytes earlier. The reason why it occurs two bytes earlier is due to the RSPI shift register and the SPTI interrupt timing. As soon as RSPI is enabled, if the shit register is empty, the RSPI issues “TX buffer empty” interrupt, that triggers DMAC’s first transfer (first byte) to the RSIP data register (SPDR). The data will move to the shift register soon, and then another “TX buffer empty” interrupt occurrs and the second DMAC transfer (second byte) will be transferred. These are done before receiving the clock signal from the connected device. After that, the remaining 8 bytes will be transferred by synchronizing with the SPI clock. Therefore, the DMAC Transfer end interrupt occurs 2 bytes earlier.
Please note that this is not a good place to put some user code like restarting the RSPI slave operation, since the RSPI clock is still coming in.
Refer to section “Serial Peripheral Interface” > “Operation” > “Communications Operating Mode” > “Full-Duplex Communications” in the hardware user manual of MCU device.
2. RSPI Transmit buffer empty interrupt
After the DMAC has completed its TX task with the provided transfer information (e.g. number of transfers), the interrupt request of the RSPI Transmit buffer empty is passed to the CPU when the RSPI TX buffer is empty, so the CPU interrupt handler for the RSPI Transmit buffer empty will be executed. There is no special operation to do here.
3. DMAC transfer end interrupt for RSPI Receive
The DMAC transfer occurs every RSIP Receive buffer full interrupt, and the CPU interrupt handler call for DMAC transfer end interrupt is executed when the 10 bytes (10 times) transfer complete.
4. RSPI RX buffer full interrupt (Does not occur)
You may be wondering why the CPU interrupt handler call of the RSPI Transmit empty interrupt is called. but for the RSPI RX interrupt is not. As explained in #3, the DMAC transfer happens every RSPI Receive buffer full interrupt, so if it received 10 bytes (1 byte x 10 times), 10 interrupt requests are generated. However, all the interrupt requests are passed to the DMAC, and the DMAC executes 10 data transfers. Therefore, in the case of the RSPI RX buffer full interrupt, the CPU interrupt handler call does not happen.
Please note that the RSPI RX buffer full interrupt handler is not a good place to put user code like restarting the RSPI slave operation, and instead it would be better to put it in the DMAC transfer end interrupt for the RSPI Receive handler.
Setting - RSPI slave interrupt generation and user callback code generation
Setting - RSPI slave interrupt generation and user callback code generation
To trigger the DMAC transfer by the RSPI, the RSPI should enable either the TX or TX/RX interrupts. The RSPI can enable the TX interrupt by setting RSPIx.SPCR.SPTIE=1 and the RX interrupt by setting RSPIx.SPCR.SPRIE=1. This allows the RSPI interrupt to arrive at the ICU.
In the CG driver setting on the smart configurator, you can find the “Callback function setting” field below. However, this field setting enables the generation of user callback function code to allow the user to put any code into the CPU interrupt handling. Even if you uncheck the boxes below, TX, RX, Error interrupt handlers will still be created by the smart configurator (code generator).
Please don’t confuse enabling RSPI interrupts and generating the user callback function code for RSPI interrupts.
Setting - ICU
Setting - ICU
The ICU is responsible for deciding whether to forward the RSPI generated interrupts to the CPU or to the DMA (DTC or DMAC). First, the ICU should be configured to receive the RSPI TX or the TX/RX interrupts by setting ICU.IERm.IENn. Then, the ICU needs to be configured to relay the RSPI TX or the RX interrupts to the respective DMAC channel (ICU.DMARSRm), not to the CPU in our example.
Setting - DMAC interrupt handling (generation)
Setting - DMAC interrupt handling (generation)
Unlike the DTC, the DMAC can generate an interrupt (DMACxI) with its own interrupt generation sources, such as the DMAC transfer end event. Additionally, the DMAC can be configured (DMACm.DMCSL.DISEL) to pass every single interrupt to the CPU after it has processed them. However, this will increase unnecessary CPU/bus load, so keep the setting as follows. (“Clear interrupt flag of the activation source”)
Suitable Products
RX Family","['data/categories/rx_family/data_transfer_(dmac_dtc_others)/ccacdef63f51d672e7af05bc2720fbc5/images/cb1b5d9fc2c2cbd6d91e78ec24a3657b.png', 'data/categories/rx_family/data_transfer_(dmac_dtc_others)/ccacdef63f51d672e7af05bc2720fbc5/images/d2be9c6298b71f61194f009af54be269.png', 'data/categories/rx_family/data_transfer_(dmac_dtc_others)/ccacdef63f51d672e7af05bc2720fbc5/images/0c7713722f7189029a62a9b43e37a8d7.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'RX Family: Timing of CPU interrupt handler call during RSPI full-duplex slave operation with DMAC transfer enabled', 'url': 'https://en-support.renesas.com/knowledgeBase/21715565', 'last_updated': '2024-10-12', 'extracted_at': '2025-03-09T00:12:16.399083'}","Overview This article explains how and when the CPU interrupt handler call is generated on each RSPI and DMAC interrupt when using an RSPI as slave and enabling full-duplex and DMAC transfer. This article only covers three types of interrupts. RSPI - SPRIx  Receive buffer full interrupt RSPI - SPTIx  Transmit buffer empty interrupt DMAC - DMACxI  Transfer end interrupt (1 channel for RSPI RX linked to SPRIx interrupt and 1 channel for RSPI TX linked to SPTIx interrupt) At the end of this article, some related driver software settings are introduced for your reference. Operation Result The following capture image shows a signal waveform when the RSPI receives 10 bytes of data. At this time, the DMAC transfer is enabled and configured to do 10 bytes (1 byte x 10 times) transfer triggered by each RSIP interrupts. In the image, SSL, CLK and MOSI are actual SPI communication signals, following RSPI RX, RSPI TX, DMA RX and DMA TX show the timing of the CPU interrupt handler call occurrence. The test program was implemented so that the GPIO pin will go to low when the CPU interrupt handler is called. As you can see in the picture below, the interrupt handlers are called in the following order. We will review how and why the interrupt occurred at this timing DMAC transfer end interrupt for RSPI Transmit RSPI Transmit buffer empty interrupt DMAC transfer end interrupt for RSPI Receive RSPI Receive buffer full interrupt (Does not occur) 1. DMAC transfer end interrupt for RSPI Transmit First you will get the DMA TX transfer end interrupt around two bytes earlier. The reason why it occurs two bytes earlier is due to the RSPI shift register and the SPTI interrupt timing. As soon as RSPI is enabled, if the shit register is empty, the RSPI issues TX buffer empty interrupt, that triggers DMACs first transfer (first byte) to the RSIP data register (SPDR). The data will move to the shift register soon, and then another TX buffer empty interrupt occurrs and the second DMAC transfer (second byte) will be transferred. These are done before receiving the clock signal from the connected device. After that, the remaining 8 bytes will be transferred by synchronizing with the SPI clock. Therefore, the DMAC Transfer end interrupt occurs 2 bytes earlier. Please note that this is not a good place to put some user code like restarting the RSPI slave operation, since the RSPI clock is still coming in. Refer to section Serial Peripheral Interface  Operation  Communications Operating Mode  Full-Duplex Communications in the hardware user manual of MCU device. 2. RSPI Transmit buffer empty interrupt After the DMAC has completed its TX task with the provided transfer information (e.g. number of transfers), the interrupt request of the RSPI Transmit buffer empty is passed to the CPU when the RSPI TX buffer is empty, so the CPU interrupt handler for the RSPI Transmit buffer empty will be executed. There is no special operation to do here. 3. DMAC transfer end interrupt for RSPI Receive The DMAC transfer occurs every RSIP Receive buffer full interrupt, and the CPU interrupt handler call for DMAC transfer end interrupt is executed when the 10 bytes (10 times) transfer complete. 4. RSPI RX buffer full interrupt (Does not occur) You may be wondering why the CPU interrupt handler call of the RSPI Transmit empty interrupt is called. but for the RSPI RX interrupt is not. As explained in 3, the DMAC transfer happens every RSPI Receive buffer full interrupt, so if it received 10 bytes (1 byte x 10 times), 10 interrupt requests are generated. However, all the interrupt requests are passed to the DMAC, and the DMAC executes 10 data transfers. Therefore, in the case of the RSPI RX buffer full interrupt, the CPU interrupt handler call does not happen. Please note that the RSPI RX buffer full interrupt handler is not a good place to put user code like restarting the RSPI slave operation, and instead it would be better to put it in the DMAC transfer end interrupt for the RSPI Receive handler. Setting - RSPI slave interrupt generation and user callback code generation To trigger the DMAC transfer by the RSPI, the RSPI should enable either the TX or TX/RX interrupts. The RSPI can enable the TX interrupt by setting RSPIx.SPCR.SPTIE1 and the RX interrupt by setting RSPIx.SPCR.SPRIE1. This allows the RSPI interrupt to arrive at the ICU. In the CG driver setting on the smart configurator, you can find the Callback function setting field below. However, this field setting enables the generation of user callback function code to allow the user to put any code into the CPU interrupt handling. Even if you uncheck the boxes below, TX, RX, Error interrupt handlers will still be created by the smart configurator (code generator). Please dont confuse enabling RSPI interrupts and generating the user callback function code for RSPI interrupts. Setting - ICU The ICU is responsible for deciding whether to forward the RSPI generated interrupts to the CPU or to the DMA (DTC or DMAC). First, the ICU should be configured to receive the RSPI TX or the TX/RX interrupts by setting ICU.IERm.IENn. Then, the ICU needs to be configured to relay the RSPI TX or the RX interrupts to the respective DMAC channel (ICU.DMARSRm), not to the CPU in our example. Setting - DMAC interrupt handling (generation) Unlike the DTC, the DMAC can generate an interrupt (DMACxI) with its own interrupt generation sources, such as the DMAC transfer end event. Additionally, the DMAC can be configured (DMACm.DMCSL.DISEL) to pass every single interrupt to the CPU after it has processed them. However, this will increase unnecessary CPU/bus load, so keep the setting as follows. (Clear interrupt flag of the activation source) Suitable Products RX Family","[""The image presents a detailed diagram of a computer system's architecture, showcasing various components and their connections. The diagram is divided into several sections, each representing a different part of the system.\n\n*   **Top Section:**\n    *   The top section features a series of lines and symbols, including a clock signal (CLK), a reset signal (RST), and a number of data lines (D0-D7).\n    *   The clock signal is represented by a series of vertical lines, with a frequency of 60 MHz.\n    *   The reset signal is represented by a single horizontal line.\n    *   The data lines are represented by a series of horizontal lines, each labeled with a number from 0 to 7.\n*   **Middle Section:**\n    *   The middle section features a series of logic gates, including AND, OR, and NOT gates.\n    *   The logic gates are represented by a series of symbols, including ∧, ∨, and ¬.\n    *   The logic gates are connected to the data lines, with the output of each gate feeding into the next gate.\n*   **Bottom Section:**\n    *   The bottom section features a series of registers, including a program counter (PC), an accumulator (ACC), and a stack pointer (SP).\n    *   The registers are represented by a series of boxes, each labeled with a name and a value.\n    *   The registers are connected to the logic gates, with the output of each gate feeding into the corresponding register.\n*   **Connections:**\n    *   The diagram shows a number of connections between the different components, including:\n        *   The clock signal is connected to the logic gates and registers.\n        *   The reset signal is connected to the logic gates and registers.\n        *   The data lines are connected to the logic gates and registers.\n        *   The output of each logic gate is connected to the input of the next gate.\n        *   The output of each register is connected to the input of the next register.\n\nOverall, the diagram provides a detailed view of the computer system's architecture, showing how the different components interact with each other. It highlights the importance of the clock signal, reset signal, and data lines in controlling the flow of data through the system."", 'The image shows a screenshot of a computer program\'s settings menu, specifically the ""Communications"" section. The menu is divided into two columns: the left column lists the available options, and the right column displays the current settings for each option.\n\n**Left Column:**\n\n*   **Config_RSPI0**: This option is selected, indicating that it is the current configuration being displayed.\n\n**Right Column:**\n\n*   **Callback function setting**: This section has three checkboxes:\n    *   **Transmission end**: This checkbox is checked, indicating that transmission end is enabled.\n    *   **Reception end**: This checkbox is unchecked, indicating that reception end is disabled.\n    *   **Error detection**: This checkbox is unchecked, indicating that error detection is disabled.\n\nOverall, the image suggests that the user has configured the communications settings to enable transmission end and disable reception end and error detection.', 'The image shows a screenshot of a computer program with a dropdown menu. The dropdown menu is titled ""Transfer setting"" and has two options: ""Activation source"" and ""Activation source flag control"". The ""Activation source flag control"" option is selected, and a red box highlights the text ""Clear interrupt flag of the activation source"".\n\n*   **Transfer setting**\n    *   The dropdown menu is titled ""Transfer setting"".\n    *   It has two options: ""Activation source"" and ""Activation source flag control"".\n    *   The ""Activation source flag control"" option is selected.\n*   **Activation source flag control**\n    *   A red box highlights the text ""Clear interrupt flag of the activation source"".\n    *   The text is in a gray box with a red border.\n*   **Normal mode**\n    *   There is a gray box below the dropdown menu with the text ""Normal mode"".\n    *   The text is in a gray box with a red border.\n\nThe image appears to be a screenshot of a computer program used for configuring transfer settings. The selected option, ""Activation source flag control"", suggests that the program is used for managing flags related to activation sources. The highlighted text, ""Clear interrupt flag of the activation source"", indicates that the program allows users to clear interrupt flags associated with activation sources. Overall, the image provides a glimpse into the user interface of a computer program used for configuring transfer settings and managing flags related to activation sources.']"
392527ad99a936bafbcd9ecf8daf19f2,"Question:
How do I set up the Data Transfer Controller (DTC) for the several trigger sources by using code generator driver?
Answer:
To use DTC with multiple trigger sources, set up the DTC Code Generator driver as follows:
(1) Add as many DTC drivers to the “Component” tab of the Smart Configurator as the number of trigger sources.
Example: Select the two trigger sources

Note:
At this time, the default trigger source is selected.
Then each driver shows an error icon on the bottom left of the driver.
Please remove this error applying step 2 and 3.
(2) Select a different ""Activation source"" trigger source for each DTC driver and make other settings as needed.
(3) All the settings in “Base setting” tab must remain the same for all DTC driver instances.
If you change some settings on this ""Base setting"" tab, you will need to apply the same settings to the ""Base setting"" tabs of other DTC drivers as well.
Please refer to more information including use case from the following application note and sample code:
“RX Family How to Change Transfer Data Length During RSPI Communication Using a DTC Rev.1.00”
https://www.renesas.com/search?keywords=R01AN7238
Suitable Products
RX
How do I set up the Data Transfer Controller (DTC) for the several trigger sources by using code generator driver?
How do I set up the Data Transfer Controller (DTC) for the several trigger sources by using code generator driver?
Answer:
To use DTC with multiple trigger sources, set up the DTC Code Generator driver as follows:
(1) Add as many DTC drivers to the “Component” tab of the Smart Configurator as the number of trigger sources.
Example: Select the two trigger sources

Note:
At this time, the default trigger source is selected.
Then each driver shows an error icon on the bottom left of the driver.
Please remove this error applying step 2 and 3.
(2) Select a different ""Activation source"" trigger source for each DTC driver and make other settings as needed.
(3) All the settings in “Base setting” tab must remain the same for all DTC driver instances.
If you change some settings on this ""Base setting"" tab, you will need to apply the same settings to the ""Base setting"" tabs of other DTC drivers as well.
Please refer to more information including use case from the following application note and sample code:
“RX Family How to Change Transfer Data Length During RSPI Communication Using a DTC Rev.1.00”
https://www.renesas.com/search?keywords=R01AN7238
Suitable Products
RX
To use DTC with multiple trigger sources, set up the DTC Code Generator driver as follows:
(1) Add as many DTC drivers to the “Component” tab of the Smart Configurator as the number of trigger sources.
Example: Select the two trigger sources

Note:
At this time, the default trigger source is selected.
Then each driver shows an error icon on the bottom left of the driver.
Please remove this error applying step 2 and 3.
(2) Select a different ""Activation source"" trigger source for each DTC driver and make other settings as needed.
(3) All the settings in “Base setting” tab must remain the same for all DTC driver instances.
If you change some settings on this ""Base setting"" tab, you will need to apply the same settings to the ""Base setting"" tabs of other DTC drivers as well.
Please refer to more information including use case from the following application note and sample code:
“RX Family How to Change Transfer Data Length During RSPI Communication Using a DTC Rev.1.00”
https://www.renesas.com/search?keywords=R01AN7238
To use DTC with multiple trigger sources, set up the DTC Code Generator driver as follows:
(1) Add as many DTC drivers to the “Component” tab of the Smart Configurator as the number of trigger sources.
Example: Select the two trigger sources
Note:
At this time, the default trigger source is selected.
Then each driver shows an error icon on the bottom left of the driver.
Please remove this error applying step 2 and 3.
(2) Select a different ""Activation source"" trigger source for each DTC driver and make other settings as needed.
(3) All the settings in “Base setting” tab must remain the same for all DTC driver instances.
If you change some settings on this ""Base setting"" tab, you will need to apply the same settings to the ""Base setting"" tabs of other DTC drivers as well.
Please refer to more information including use case from the following application note and sample code:
“RX Family How to Change Transfer Data Length During RSPI Communication Using a DTC Rev.1.00”
https://www.renesas.com/search?keywords=R01AN7238
Suitable Products
RX
日本語
日本語","['data/categories/rx_family/data_transfer_(dmac_dtc_others)/392527ad99a936bafbcd9ecf8daf19f2/images/70ec38a11eacde77f39d4a2e9ab4a685.png', 'data/categories/rx_family/data_transfer_(dmac_dtc_others)/392527ad99a936bafbcd9ecf8daf19f2/images/8d9db0816448d6aef52e25a5a6440363.png', 'data/categories/rx_family/data_transfer_(dmac_dtc_others)/392527ad99a936bafbcd9ecf8daf19f2/images/38a51ae57dc7c588e03594f35c88dd01.png', 'data/categories/rx_family/data_transfer_(dmac_dtc_others)/392527ad99a936bafbcd9ecf8daf19f2/images/db82a79e1a94ed77cf22d776e0135a4f.png']",[],['|  |\n|  |\n| RX |'],"{'title': 'RX Family: How to set up multiple trigger sources on DTC using Code Generator driver', 'url': 'https://en-support.renesas.com/knowledgeBase/21419422', 'last_updated': '2024-04-06', 'extracted_at': '2025-03-09T00:12:20.007831'}","Question How do I set up the Data Transfer Controller (DTC) for the several trigger sources by using code generator driver? Answer To use DTC with multiple trigger sources, set up the DTC Code Generator driver as follows (1) Add as many DTC drivers to the Component tab of the Smart Configurator as the number of trigger sources. Example Select the two trigger sources Note At this time, the default trigger source is selected. Then each driver shows an error icon on the bottom left of the driver. Please remove this error applying step 2 and 3. (2) Select a different ""Activation source"" trigger source for each DTC driver and make other settings as needed. (3) All the settings in Base setting tab must remain the same for all DTC driver instances. If you change some settings on this ""Base setting"" tab, you will need to apply the same settings to the ""Base setting"" tabs of other DTC drivers as well. Please refer to more information including use case from the following application note and sample code RX Family How to Change Transfer Data Length During RSPI Communication Using a DTC Rev.1.00 https//www.renesas.com/search?keywordsR01AN7238 Suitable Products RX ","['The image shows a screenshot of a computer program, specifically a software component selection window. The window is titled ""Software Component Selection"" and has a list of components on the left side, with checkboxes next to each one. The components are:\n\n* Data Transfer Controller\n* DMA Controller\n* DMAC driver\n* DTC driver\n\nEach component has a checkbox next to it, and there is a ""Show only latest version"" checkbox at the bottom of the window. Below this checkbox, there is a description of the software component that provides configurations for Data Transfer Controller (DTC) to perform data transfers.\n\nAt the bottom of the window, there are buttons labeled ""Back"", ""Next"", ""Finish"", and ""Cancel"". The ""Finish"" button is highlighted in blue, indicating that it is the default action.\n\nOverall, the image appears to be a screenshot of a software development tool or a configuration window for a specific application. The user is likely selecting components to include in their project or configuration.', 'The image shows a screenshot of a computer program, specifically a component list. The top of the image has a gray bar with the word ""Components"" in black text on the left side. On the right side, there are several icons and buttons, including a printer icon, a magnifying glass icon, a plus sign icon, and a minus sign icon.\n\nBelow the gray bar is a white box with a title that reads ""type filter text"" in gray text. Below the title is a text box where you can type in a filter text. To the left of the text box is a dropdown menu with several options, including ""Startup"", ""Generic"", ""r_bsp"", ""Drivers"", and ""DMA"". Each option has a checkbox next to it, and some of them have additional icons or text.\n\nBelow the dropdown menu is a list of components, which includes:\n\n* Config_DTC_SCI5_RX\n* Config_DTC_SCI5_TX\n\nEach component has a checkbox next to it, and some of them have additional icons or text. The background of the image is white, with a light gray border around the edges.\n\nOverall, the image appears to be a screenshot of a computer program used for managing components or settings. The user can filter the list of components by selecting an option from the dropdown menu and typing in a filter text in the text box. The program also allows the user to select or deselect individual components using the checkboxes.', 'The image shows a screenshot of a computer program with a white background and a gray window in the center. The window is titled ""Components"" and has a list of items on the left side, including ""Startup,"" ""Generic,"" ""r_bsp,"" ""Drivers,"" ""DMA,"" and ""Config_DTC_SCIS_RX."" There are also several icons and buttons at the top of the window.\n\nOn the right side of the window, there is a large text box with a dropdown menu that says ""Base setting"" and ""DTCO."" Below this, there are several lines of text with checkboxes and dropdown menus. The text is too small to read clearly, but it appears to be related to settings for the program.\n\nThere are also several lines of code in the bottom-right corner of the window, which are too small to read clearly. Overall, the image suggests that the program is a software development tool or a configuration utility for a specific device or system.', 'The image shows a screenshot of a computer program with a dropdown menu and a configuration window. The program is likely used for configuring settings or parameters in a specific application or system.\n\n*   **Dropdown Menu**\n    *   The dropdown menu is located at the top left of the image and has several options, including ""type filter text"", ""Startup"", ""Generic"", ""r_bsp"", ""Drivers"", and ""DMA"".\n    *   The selected option is ""Config_DTC_SCI5_RX"".\n*   **Configuration Window**\n    *   The configuration window is located below the dropdown menu and has several fields for entering data.\n    *   The fields include ""Base setting"", ""Transfer data read skip"", ""Address mode"", and ""DTC vector base address"".\n    *   The ""Base setting"" field has a dropdown menu with options ""DTC0"" and ""DTC1"".\n    *   The ""Transfer data read skip"" field has a checkbox with the label ""Disable"".\n    *   The ""Address mode"" field has a dropdown menu with options ""Full-address mode (32 bits)"" and ""0x0003FC00"".\n    *   The ""DTC vector base address"" field has a text box for entering a value.\n*   **Background**\n    *   The background of the image is a light gray color.\n\nOverall, the image appears to be a screenshot of a computer program used for configuring settings or parameters in a specific application or system. The dropdown menu and configuration window suggest that the program is designed to allow users to customize various settings and options.']"
bcc73008f3a1cb3e9fe098e551ea3b76,"Question:
Where should the RTCICn pins be pulled up when using battery backup mode where power is supplied from the VBATT pin when the voltage from the VCC pin drops?
Answer:
First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8 × VBATT.
Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation.
When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation.
(Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics.
Suitable Products
RX
Where should the RTCICn pins be pulled up when using battery backup mode where power is supplied from the VBATT pin when the voltage from the VCC pin drops?
Where should the RTCICn pins be pulled up when using battery backup mode where power is supplied from the VBATT pin when the voltage from the VCC pin drops?
Answer:
First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8 × VBATT.
Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation.
When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation.
(Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics.
Suitable Products
RX
First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8 × VBATT.
Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation.
When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation.
(Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics.
First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8 × VBATT.
Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation.
When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation.
(Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics.
First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8 × VBATT.
Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation.
When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation.
(Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics.
Suitable Products
RX
日本語
日本語",['data/categories/rx_family/battery_backup_function/bcc73008f3a1cb3e9fe098e551ea3b76/images/58462d2cb45ad055cc284d541842ea7f.png'],[],['|  |\n|  |\n| RX |'],"{'title': 'RX Family: When using battery backup mode, where should the RTCICn pins be pulled up?', 'url': 'https://en-support.renesas.com/knowledgeBase/21588894', 'last_updated': None, 'extracted_at': '2025-03-09T00:06:58.169554'}","Question Where should the RTCICn pins be pulled up when using battery backup mode where power is supplied from the VBATT pin when the voltage from the VCC pin drops? Answer First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8  VBATT. Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation. When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation. (Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics. Suitable Products RX ","['The image depicts a circuit diagram, showcasing various components and their connections. The diagram is set against a white background, with black lines and symbols used to represent the different parts of the circuit.\n\n**Components:**\n\n*   **Battery:** A battery is connected to the circuit, providing power to the other components.\n*   **Protection Resistor:** A protection resistor is included in the circuit to limit the current flowing through it.\n*   **RX MCU:** The RX MCU (Receiver Microcontroller Unit) is a key component of the circuit, responsible for receiving and processing data.\n*   **VCC:** VCC represents the positive power supply voltage of the circuit.\n*   **VCL:** VCL represents the voltage at the collector of the transistor.\n*   **VSS:** VSS represents the ground or common reference point of the circuit.\n*   **RTCICn:** RTCICn is a component that likely represents a real-time clock or timer circuit.\n*   **VBATT:** VBATT represents the voltage at the battery terminal.\n\n**Connections:**\n\n*   The battery is connected to the protection resistor, which is then connected to the RX MCU.\n*   The RX MCU is connected to VCC and VCL.\n*   VCL is connected to VSS.\n*   RTCICn is connected to VBATT.\n\n**Overall:**\n\nThe circuit diagram appears to be a simple power supply circuit with a battery, protection resistor, and RX MCU. The inclusion of RTCICn suggests that the circuit may also be used for timing or clocking purposes. The connections between the components are straightforward, indicating a basic and functional design.']"
e91bb1809fd784a3ae3f68c8e6d4f02d,"Question:
Is there any limitation when using Double-Precision Floating-Point Coprocessor on some RXv3 devices (RX66N, RX72N, RX72M)?
  Answer:
  Ιn some RXv3 devices, when the Double-Precision Floating Point Coprocessor is enabled, the byte-alignement for the floating point variables should be 4 bytes or 8bytes respectively. Any other byte-alignement smaller than 4 bytes will cause an undefined exeption.
  If the double precision floating handling isn't enabled, there isn't any byte-alignement limitation on the RXv3 core.
  For more information, Chapter 2.8 of RX66N user's manual describes this feature:
  https://www.renesas.com/en/document/mah/rx66n-group-users-manual-hardware?r=1170201
  The double- Precision Floating Coprocessor can be enabled/disabled on the e2studio from the setting below:
        Ιf IAR is using for the RX project developement, the double FPU functionality can be enabled/disabled from the setting below:
      Suitable Products
RX66N, RX72N, RX72M
Is there any limitation when using Double-Precision Floating-Point Coprocessor on some RXv3 devices (RX66N, RX72N, RX72M)?
Answer:
  Ιn some RXv3 devices, when the Double-Precision Floating Point Coprocessor is enabled, the byte-alignement for the floating point variables should be 4 bytes or 8bytes respectively. Any other byte-alignement smaller than 4 bytes will cause an undefined exeption.
  If the double precision floating handling isn't enabled, there isn't any byte-alignement limitation on the RXv3 core.
  For more information, Chapter 2.8 of RX66N user's manual describes this feature:
  https://www.renesas.com/en/document/mah/rx66n-group-users-manual-hardware?r=1170201
  The double- Precision Floating Coprocessor can be enabled/disabled on the e2studio from the setting below:
        Ιf IAR is using for the RX project developement, the double FPU functionality can be enabled/disabled from the setting below:
      Suitable Products
RX66N, RX72N, RX72M
Ιn some RXv3 devices, when the Double-Precision Floating Point Coprocessor is enabled, the byte-alignement for the floating point variables should be 4 bytes or 8bytes respectively. Any other byte-alignement smaller than 4 bytes will cause an undefined exeption.
If the double precision floating handling isn't enabled, there isn't any byte-alignement limitation on the RXv3 core.
For more information, Chapter 2.8 of RX66N user's manual describes this feature:
https://www.renesas.com/en/document/mah/rx66n-group-users-manual-hardware?r=1170201
The double- Precision Floating Coprocessor can be enabled/disabled on the e2studio from the setting below:
Ιf IAR is using for the RX project developement, the double FPU functionality can be enabled/disabled from the setting below:
Suitable Products
RX66N, RX72N, RX72M
??? ??
???
??","['data/categories/rx_family/rx72m_rx72n_rx66n/e91bb1809fd784a3ae3f68c8e6d4f02d/images/21e9b37a6a9e7a6fdf3c40eb2897e807.png', 'data/categories/rx_family/rx72m_rx72n_rx66n/e91bb1809fd784a3ae3f68c8e6d4f02d/images/b186c0cd427793732d9768d591175945.png']",[],"['|  |\n|  |\n| RX66N, RX72N, RX72M |']","{'title': 'Is there any limitation when using Double-Precision Floating-Point Coprocessor on some RXv3 devices (RX66N, RX72N, RX72M)?', 'url': 'https://en-support.renesas.com/knowledgeBase/21716024', 'last_updated': '2024-10-12', 'extracted_at': '2025-03-09T00:02:24.563425'}","Question Is there any limitation when using Double-Precision Floating-Point Coprocessor on some RXv3 devices (RX66N, RX72N, RX72M)? Answer n some RXv3 devices, when the Double-Precision Floating Point Coprocessor is enabled, the byte-alignement for the floating point variables should be 4 bytes or 8bytes respectively. Any other byte-alignement smaller than 4 bytes will cause an undefined exeption. If the double precision floating handling isn't enabled, there isn't any byte-alignement limitation on the RXv3 core. For more information, Chapter 2.8 of RX66N user's manual describes this feature https//www.renesas.com/en/document/mah/rx66n-group-users-manual-hardware?r1170201 The double- Precision Floating Coprocessor can be enabled/disabled on the e2studio from the setting below f IAR is using for the RX project developement, the double FPU functionality can be enabled/disabled from the setting below Suitable Products RX66N, RX72N, RX72M Answer n some RXv3 devices, when the Double-Precision Floating Point Coprocessor is enabled, the byte-alignement for the floating point variables should be 4 bytes or 8bytes respectively. Any other byte-alignement smaller than 4 bytes will cause an undefined exeption. If the double precision floating handling isn't enabled, there isn't any byte-alignement limitation on the RXv3 core. For more information, Chapter 2.8 of RX66N user's manual describes this feature https//www.renesas.com/en/document/mah/rx66n-group-users-manual-hardware?r1170201 The double- Precision Floating Coprocessor can be enabled/disabled on the e2studio from the setting below f IAR is using for the RX project developement, the double FPU functionality can be enabled/disabled from the setting below Suitable Products ??? ?? ??? ??","['The image shows a screenshot of the ""Settings"" window in Visual Studio, with the ""CPU"" tab selected. The window is divided into two sections: the left side lists various options, and the right side displays the settings for the selected option.\n\n*   **Left Side:**\n    *   The left side of the window is a list of options, including:\n        *   Resource\n        *   Builders\n        *   C/C++ Build\n        *   Build Variables\n        *   Environment\n        *   Logging\n        *   Settings\n        *   Tool Chain Editor\n        *   C/C++ General\n        *   Project Natures\n        *   Project References\n        *   Renesas QE\n        *   Run/Debug Settings\n        *   Task Tags\n        *   Validation\n*   **Right Side:**\n    *   The right side of the window displays the settings for the selected option, which is ""CPU"".\n    *   The settings include:\n        *   Make the double data type be 64 bits in size (-m64bit-doubles)\n        *   CPU Type\n            *   Default\n            *   RXv3\n        *   Architecture\n            *   MTFU\n        *   (mtfu-version)\n        *   Data Endian\n            *   Big-endian data\n        *   Registers reserved for fast interrupt\n            *   Default\n        *   Max size of constant operand values\n            *   Default\n        *   Disable generation of RX hardware FPU instructions\n            *   Generate assembler output compatible with Renesas\' AS100 assembler\n        *   Interrupt handler functions should preserve the accumulator register\n            *   Generate position independent code and data (-mpid)\n        *   Disable String Instructions\n            *   Use ISB instead of DSB for calls (-mjsr)\n        *   Double FPU instruction\n            *   Fix error parser\n\nThe image shows a screenshot of the ""Settings"" window in Visual Studio, with the ""CPU"" tab selected. The window is divided into two sections: the left side lists various options, and the right side displays the settings for the selected option. The settings include options for CPU type, architecture, data endian, registers reserved for fast interrupt, max size of constant operand values, disable generation of RX hardware FPU instructions, interrupt handler functions, generate position independent code and data, disable string instructions, double FPU instruction, and fix error parser.', 'The image shows a screenshot of a computer program with a window titled ""Options for node \'RX66N_FLOATING\'"". The window is divided into two sections: a left section with a list of categories and a right section with a list of options.\n\n*   **Left Section:**\n    *   The left section has a list of categories, including:\n        *   General Options\n        *   Static Analysis\n        *   Runtime Checking\n        *   C/C++ Compiler\n        *   Assembler\n        *   Output Converter\n        *   Custom Build\n        *   Linker\n        *   Build Actions\n        *   Debugger\n        *   E1 / E20\n        *   E2\n        *   E2 Lite / E2-CLIBE2\n        *   J-Link\n        *   Simulator\n*   **Right Section:**\n    *   The right section has a list of options, including:\n        *   Library Options 1\n        *   Library Options 2\n        *   Stack/Heap\n        *   Device\n        *   Byte order\n        *   Floating-point\n        *   Position-independence\n        *   Data model\n*   **Highlighted Option:**\n    *   The highlighted option is ""Floating-point Size of type \'double\': 32 bits"".\n\nThe image appears to be a screenshot of a computer program used for configuring options related to a specific node, likely in a programming or development context. The highlighted option suggests that the user is configuring the size of the ""double"" data type for floating-point operations.']"
9a52300879ee0df7febd7d1b2f7b3784,"Question:
Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment.
Answer:
Make sure that bitmap data is positioned at 4-byte aligned addresses.
In a GCC environment:
In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables.
If you are using e2 studio, select [Project] > [C/C++ Project Settings] to display the properties window. Then, in the tree view of the window, under the [C/C++ General] node, select [Paths and Symbols], open the [Symbols] tab, click the [Add] button, and then add the following definition:
Name: GUI_CONST_STORAGE
Value: __attribute__ ((aligned(4))) const
  In an IAR environment:
In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. Therefore, add the “#pragma data_alignment=4” specification to each variable by, for example, a search-and-replace operation.
Suitable Products
RX Family
  日本語
Question:
Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment.
Answer:
Make sure that bitmap data is positioned at 4-byte aligned addresses.
In a GCC environment:
In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables.
If you are using e2 studio, select [Project] > [C/C++ Project Settings] to display the properties window. Then, in the tree view of the window, under the [C/C++ General] node, select [Paths and Symbols], open the [Symbols] tab, click the [Add] button, and then add the following definition:
Name: GUI_CONST_STORAGE
Value: __attribute__ ((aligned(4))) const
  In an IAR environment:
In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. Therefore, add the “#pragma data_alignment=4” specification to each variable by, for example, a search-and-replace operation.
Suitable Products
RX Family
Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment.
Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment.
Answer:
Make sure that bitmap data is positioned at 4-byte aligned addresses.
In a GCC environment:
In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables.
If you are using e2 studio, select [Project] > [C/C++ Project Settings] to display the properties window. Then, in the tree view of the window, under the [C/C++ General] node, select [Paths and Symbols], open the [Symbols] tab, click the [Add] button, and then add the following definition:
Name: GUI_CONST_STORAGE
Value: __attribute__ ((aligned(4))) const
  In an IAR environment:
In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. Therefore, add the “#pragma data_alignment=4” specification to each variable by, for example, a search-and-replace operation.
Suitable Products
RX Family
Make sure that bitmap data is positioned at 4-byte aligned addresses.
In a GCC environment:
In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables.
If you are using e2 studio, select [Project] > [C/C++ Project Settings] to display the properties window. Then, in the tree view of the window, under the [C/C++ General] node, select [Paths and Symbols], open the [Symbols] tab, click the [Add] button, and then add the following definition:
Name: GUI_CONST_STORAGE
Value: __attribute__ ((aligned(4))) const
  In an IAR environment:
In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. Therefore, add the “#pragma data_alignment=4” specification to each variable by, for example, a search-and-replace operation.
Make sure that bitmap data is positioned at 4-byte aligned addresses.
In a GCC environment:
In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables.
If you are using e2 studio, select [Project] > [C/C++ Project Settings] to display the properties window. Then, in the tree view of the window, under the [C/C++ General] node, select [Paths and Symbols], open the [Symbols] tab, click the [Add] button, and then add the following definition:
In an IAR environment:
In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. Therefore, add the “#pragma data_alignment=4” specification to each variable by, for example, a search-and-replace operation.
Suitable Products
RX Family
日本語
日本語",['data/categories/rx_family/others/9a52300879ee0df7febd7d1b2f7b3784/images/5637767e76701d01bb3fc173ea2b08e8.png'],[],['|  |\n|  |\n| RX Family |'],"{'title': 'Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment.', 'url': 'https://en-support.renesas.com/knowledgeBase/20940283', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:29.040606'}","Question Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment. Answer Make sure that bitmap data is positioned at 4-byte aligned addresses. In a GCC environment In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUICONSTSTORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables. If you are using e2 studio, select Project  C/C Project Settings to display the properties window. Then, in the tree view of the window, under the C/C General node, select Paths and Symbols, open the Symbols tab, click the Add button, and then add the following definition Name GUICONSTSTORAGE Value attribute ((aligned(4))) const In an IAR environment In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUICONSTSTORAGE macro. Therefore, add the pragma dataalignment4 specification to each variable by, for example, a search-and-replace operation. Suitable Products RX Family  In an IAR environment ","['The image shows a screenshot of a computer program, specifically the ""Paths and Symbols"" window in Visual Studio. The window is open on a Windows computer, with the title ""Paths and Symbols"" at the top.\n\n*   **Title Bar**\n    *   The title bar is at the top of the window and displays the text ""Paths and Symbols"".\n*   **Menu Bar**\n    *   The menu bar is located below the title bar and contains several menus, including ""File"", ""Edit"", ""View"", ""Tools"", ""Debug"", and ""Help"".\n*   **Toolbar**\n    *   The toolbar is located below the menu bar and contains several buttons, including ""Add"", ""Edit"", ""Delete"", and ""Export"".\n*   **Main Window**\n    *   The main window is the largest part of the window and displays a list of paths and symbols.\n    *   The list includes several columns, including ""Name"", ""Value"", and ""Type"".\n    *   There are also several buttons and controls in the main window, including ""Add symbol"", ""Show"", ""Import Settings"", and ""Export Settings"".\n*   **Status Bar**\n    *   The status bar is located at the bottom of the window and displays information about the current selection, such as the number of items selected and the total number of items in the list.\n\nOverall, the image shows a screenshot of the ""Paths and Symbols"" window in Visual Studio, which is used to manage paths and symbols in a project. The window has several menus, buttons, and controls that allow users to add, edit, and delete paths and symbols, as well as import and export settings.']"
5e5bc918d6d283f85868037d4d180167,"Question:
How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured?
Answer:
In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area.
Therefore, the size of frame buffers is not included in the buffer size set with [Work area size for GUI] (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio.
If you use QE for Display, you can set frame buffers in the following location.
emWin FIT Module Settings:
Note: The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings.
GLCDC FIT Module Settings:
  Note: The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer.
Suitable Products
RX Family
  日本語
Question:
How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured?
Answer:
In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area.
Therefore, the size of frame buffers is not included in the buffer size set with [Work area size for GUI] (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio.
If you use QE for Display, you can set frame buffers in the following location.
emWin FIT Module Settings:
Note: The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings.
GLCDC FIT Module Settings:
  Note: The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer.
Suitable Products
RX Family
How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured?
How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured?
Answer:
In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area.
Therefore, the size of frame buffers is not included in the buffer size set with [Work area size for GUI] (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio.
If you use QE for Display, you can set frame buffers in the following location.
emWin FIT Module Settings:
Note: The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings.
GLCDC FIT Module Settings:
  Note: The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer.
Suitable Products
RX Family
In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area.
Therefore, the size of frame buffers is not included in the buffer size set with [Work area size for GUI] (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio.
If you use QE for Display, you can set frame buffers in the following location.
emWin FIT Module Settings:
Note: The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings.
GLCDC FIT Module Settings:
  Note: The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer.
In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area.
Therefore, the size of frame buffers is not included in the buffer size set with [Work area size for GUI] (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio.
If you use QE for Display, you can set frame buffers in the following location.
emWin FIT Module Settings:
Note: The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings.
GLCDC FIT Module Settings:
Note: The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer.
Suitable Products
RX Family
日本語
日本語","['data/categories/rx_family/others/5e5bc918d6d283f85868037d4d180167/images/b27433509fd2a4ca01dd585107531e80.png', 'data/categories/rx_family/others/5e5bc918d6d283f85868037d4d180167/images/ebe6d8707bb5afc67f836cb783939e3b.png', 'data/categories/rx_family/others/5e5bc918d6d283f85868037d4d180167/images/691876c97c7bd58f8bd2e7fc3ad38aa2.png', 'data/categories/rx_family/others/5e5bc918d6d283f85868037d4d180167/images/03a54a7159f31e4505be0df3634ffcba.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940278', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:18.538511'}","Question How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured? Answer In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area. Therefore, the size of frame buffers is not included in the buffer size set with Work area size for GUI (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio. If you use QE for Display, you can set frame buffers in the following location. emWin FIT Module Settings Note The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings. GLCDC FIT Module Settings Note The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer. Suitable Products RX Family  Note The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer. ","['The image shows a screenshot of a computer program with a light blue background and black text. The title at the top reads ""3. GUI creation on LCD"" in bold font, followed by the subtitle ""Installing the GUI drawing tool driver"" in smaller text.\n\nBelow the title are several sections with headings such as ""Initial setting of GUI drawing tool"", ""GUI drawing tool setting:"", ""Generate GUI"", and ""Implementation"". Each section has a checkbox or dropdown menu for selecting options, and some have additional text or buttons for further configuration.\n\nThe overall design of the program appears to be user-friendly and intuitive, with clear headings and concise instructions. The use of checkboxes and dropdown menus makes it easy for users to select options and configure settings without having to navigate through complex menus or interfaces.\n\nOverall, the image suggests that the program is designed to help users create and customize GUIs (Graphical User Interfaces) for their applications, and provides a range of tools and features to make the process as easy and efficient as possible.', 'The image shows a screenshot of a computer program with a white background and black text. The program is titled ""emWin setting"" and has a menu bar at the top with various options such as ""Board settings,"" ""Pin settings,"" and ""Memory settings."" \n\n*   **Board settings**\n    *   LCD width: 480\n    *   LCD height: 272\n    *   LCD rotation: ORIENTATION_0\n    *   Color depth per pixel: 16bits\n*   **Pin settings**\n    *   Port: B\n    *   Bit: 3\n    *   Port: 6\n    *   Bit: 7\n    *   Port: 6\n    *   Bit: 6\n*   **Memory settings**\n    *   Address of frame buffer 1: 0x00800000\n    *   Address of frame buffer 2: 0x00840000\n*   **Touch settings**\n    *   Touch function: Use\n    *   Touch connection interface: SCL_IIC\n    *   Touch interface channel number: 6\n    *   Slave address of touch panel: 0x38\n    *   Multi-touch function: Not Use\n    *   Maximum number of touch panel points: 10\n*   **DRW2D setting**\n    *   DRW2D: Not Use\n\nThe program also includes a diagram on the right side, which appears to be a representation of the memory settings. The diagram shows two rectangles, one labeled ""0x00800000"" and the other labeled ""0x00840000."" There are also several lines connecting the rectangles, indicating the relationships between them.\n\nOverall, the image suggests that the program is used to configure the settings for a display device, such as a LCD screen or a touch panel. The user can adjust various parameters, including the LCD width and height, the color depth per pixel, and the address of the frame buffers. The program also allows the user to select the touch function and the maximum number of touch panel points.', 'The image depicts a screenshot of a computer program\'s settings menu, specifically the ""LCD adjustment"" section. The title ""2. LCD adjustment"" is prominently displayed at the top, followed by a subtitle that reads ""Installing the LCD controller."" Below this, there are two sections: ""Added"" and ""How to add.""\n\nThe ""Added"" section contains a list of options, including ""LCD display adjustment,"" ""Adjustment for display on LCD,"" ""TCON/LCD setting,"" ""Timing adjustment,"" ""Graphic layer setting,"" ""Adjust image quality/color,"" and ""Image quality adjustment."" Each option is accompanied by a checkbox or a dropdown menu, allowing users to select their preferred settings.\n\nThe ""How to add"" section provides instructions on how to add new settings to the list. It includes a brief description of the process and a link to a tutorial or documentation for further guidance.\n\nOverall, the image suggests that the program is designed to help users customize their LCD display settings, including adjusting the display\'s brightness, contrast, and color balance. The program appears to be user-friendly, with clear instructions and intuitive interfaces.', 'The image shows a screenshot of a computer program with a graph and text. The program is titled ""Start Display Adjustment"" and has a menu bar at the top with options such as ""Block Image"", ""TCON/LCD Setting"", ""Timing Adjustment"", ""Graphic Layer Setting"", and ""Image Quality Adjustment"". \n\n*   The main window of the program displays a graph with a pink rectangle in the center, surrounded by a green border. The graph has a title that reads ""Display Start Position"" and has several lines and labels on it.\n*   Below the graph, there are several text boxes and dropdown menus that allow the user to adjust various settings, such as the width and height of the image data, the display start position, and the output data format.\n*   In the bottom-left corner of the window, there is a section labeled ""Interrupts Setting"" that allows the user to enable or disable various interrupts, such as VPOS detection and VPOS interrupt.\n*   In the bottom-right corner of the window, there is a section labeled ""Callback Function Name"" that allows the user to enter a callback function name.\n\nOverall, the image suggests that the program is used for adjusting display settings, such as the size and position of the image data, and for configuring interrupts and callback functions.']"
15b8c3770d2ad86ca65ea35992eef21e,"Question:
Enabling an interrupt (software configurable) on a peripheral results in an error in the smart configurator. How can I fix this issue?
Answer:
Some RX MCU peripherals use only fixed interrupt vectors, while some others also use software configurable interrupt vectors. If you use a software configurable interrupt and only configure the ""Component tab"", you will get the following error:
Example for GTCIU2 setting:
To resolve this error, you must configure additional interrupt settings in the “Interrupt tab”.
As shown in the figure below, you need to select the interrupt from the corresponding interrupt vector group, INTA or INTB.
Please also refer to the ""User Manual: Hardware"" of each product to determine whether the interrupt belongs to INTA or INTB.
Suitable Products
RX Family
Enabling an interrupt (software configurable) on a peripheral results in an error in the smart configurator. How can I fix this issue?
Enabling an interrupt (software configurable) on a peripheral results in an error in the smart configurator. How can I fix this issue?
Answer:
Some RX MCU peripherals use only fixed interrupt vectors, while some others also use software configurable interrupt vectors. If you use a software configurable interrupt and only configure the ""Component tab"", you will get the following error:
Example for GTCIU2 setting:
To resolve this error, you must configure additional interrupt settings in the “Interrupt tab”.
As shown in the figure below, you need to select the interrupt from the corresponding interrupt vector group, INTA or INTB.
Please also refer to the ""User Manual: Hardware"" of each product to determine whether the interrupt belongs to INTA or INTB.
Suitable Products
RX Family
Some RX MCU peripherals use only fixed interrupt vectors, while some others also use software configurable interrupt vectors. If you use a software configurable interrupt and only configure the ""Component tab"", you will get the following error:
Example for GTCIU2 setting:
To resolve this error, you must configure additional interrupt settings in the “Interrupt tab”.
As shown in the figure below, you need to select the interrupt from the corresponding interrupt vector group, INTA or INTB.
Please also refer to the ""User Manual: Hardware"" of each product to determine whether the interrupt belongs to INTA or INTB.
Some RX MCU peripherals use only fixed interrupt vectors, while some others also use software configurable interrupt vectors. If you use a software configurable interrupt and only configure the ""Component tab"", you will get the following error:
Example for GTCIU2 setting:
To resolve this error, you must configure additional interrupt settings in the “Interrupt tab”.
As shown in the figure below, you need to select the interrupt from the corresponding interrupt vector group, INTA or INTB.
Please also refer to the ""User Manual: Hardware"" of each product to determine whether the interrupt belongs to INTA or INTB.
Suitable Products
RX Family
日本語
日本語","['data/categories/rx_family/others/15b8c3770d2ad86ca65ea35992eef21e/images/41f4c059480f96c6a721c90f2f416caa.png', 'data/categories/rx_family/others/15b8c3770d2ad86ca65ea35992eef21e/images/3ceb03b38c7e310a9541757368c67e29.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'RX Family: How to configure the software configurable interrupt in the Smart Configurator?', 'url': 'https://en-support.renesas.com/knowledgeBase/21634939', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:12.081498'}","Question Enabling an interrupt (software configurable) on a peripheral results in an error in the smart configurator. How can I fix this issue? Answer Some RX MCU peripherals use only fixed interrupt vectors, while some others also use software configurable interrupt vectors. If you use a software configurable interrupt and only configure the ""Component tab"", you will get the following error Example for GTCIU2 setting To resolve this error, you must configure additional interrupt settings in the Interrupt tab. As shown in the figure below, you need to select the interrupt from the corresponding interrupt vector group, INTA or INTB. Please also refer to the ""User Manual Hardware"" of each product to determine whether the interrupt belongs to INTA or INTB. Suitable Products RX Family ","['The image shows a screenshot of a computer program with a list of components and settings. The title at the top reads ""Software component configuration"" in black text.\n\n*   **Title and Menu**\n    *   The title is in black text at the top of the image.\n    *   There are several icons and menus along the top of the image, including a ""Components"" menu, a ""Generate Code"" button, and a ""G"" button.\n*   **List of Components**\n    *   The list of components is on the left side of the image.\n    *   It includes a list of folders and files, such as ""type filter text"", ""Startup"", ""Generic"", ""r_bsp"", ""Drivers"", ""I/O Ports"", ""Config_PORT"", ""Timers"", ""Config_GPT0"", ""Config_GPT1"", and ""Config_GPT2"".\n    *   Each folder or file has a small icon next to it.\n*   **Settings**\n    *   The settings are on the right side of the image.\n    *   They include a list of options, such as ""Buffer transfer timing"", ""Output stop setting"", ""Interrupt setting"", and ""Enable GTCNT underflow interrupt (GTCIU2)"".\n    *   Each option has a checkbox next to it, and some have additional settings or options.\n*   **Red Box**\n    *   There is a red box around the ""Enable GTCNT underflow interrupt (GTCIU2)"" option.\n    *   The box highlights the option and draws attention to it.\n\nOverall, the image appears to be a screenshot of a software development tool or IDE, showing a list of components and settings for configuring a software component. The red box highlights a specific option that may be important or relevant to the user.', 'The image shows a screenshot of a computer program with a table of data. The table is titled ""Interrupt configuration"" and has several columns, including ""Vector Number"", ""Interrupt"", ""Peripheral"", ""Priority"", ""Status"", ""Multiple Interrupts"", and ""Fast Interrupt"". \n\n*   The table contains 30 rows of data, each representing a different interrupt vector.\n*   The ""Vector Number"" column lists the numbers 206 to 229.\n*   The ""Interrupt"" column lists the names of the interrupts, such as ""INTB206"", ""GTCID1"", and ""GTCIV2"".\n*   The ""Peripheral"" column lists the peripherals associated with each interrupt, such as ""MTU0"", ""MTU1"", and ""MTU2"".\n*   The ""Priority"" column lists the priority levels of each interrupt, ranging from 15 to 0.\n*   The ""Status"" column lists the status of each interrupt, with most being ""Level 15"".\n*   The ""Multiple Interrupts"" column lists the number of multiple interrupts for each vector, with most being 0.\n*   The ""Fast Interrupt"" column lists the fast interrupt status for each vector, with most being ""Level 15"".\n\nOverall, the table provides a detailed overview of the interrupt configuration for a computer system, including the vector numbers, interrupt names, peripherals, priorities, statuses, and fast interrupt settings.']"
94cc854ff3d461dcab0b65f54fb8e25f,"Question:
How to configure the CC-RX Optimizing Linkage Options through the project configuration in the e2studio IDE
Answer:
The CC-RX compiler offers Optimizing Linkage Editor (rlink) Options for users to determine how to link object module, link directive files, and library files and generates an object file executable in the target system. This article is meant for guiding fresh users to configure the CC-RX Compiler linker optimization through the e2 studio IDE. In addition, user can also refer to the CC-RX Compiler User’s Manual for the detail descriptions of the supported Optimizing Linkage Editor Options after reading this article.
The first step for user is to open the Linker Optimization configuration through the e2 studio IDE. Please follow the instructions below to get ready for doing the further configuration.
Specify the RX project
Through the e2studio toolbar, click the Project and click the Properties
In the Properties window, navigate to C/C++ Build and expand it
Select the Settings to open the corresponding configuration in the left side pane of Properties window.
In the left side pane, navigate to the Tool Settings tab and expand the Linker item
Select the Optimization item within Linker settings
Now, users can proceed with the Optimization configuration based on your needs, and there are five major settings which are introduced below.
The Optimization Type (-optimize) configuration:
When Optimization type is configured as All, the -optimize without sub options, which executes all optimization, is used.
It is equivalent to “-optimize=symbol_delete,same_code,short_format,branch”.
User can specify the Minimum code size (-samesize) with a hexadecimal value from 8 to 7FFF for the optimization with the “same_code” unification. The default size is 0x1E (-samesize=1E).
When Optimization type is configured as No optimize, the -nooptimize option is specified, and optimization is not performed at linkage.
When Optimization type is configured as Speed-oriented optimization, the -optimize=speed option is used.
This configuration executes optimizations other than those reducing object speed.
This is equivalent to “-optimize=symbol_delete,short_format,branch”.
When Optimization type is configured as Safe optimization, the -optimize=safe option is used.
This configuration executes optimization other than those limited by variable or function attributes. This is equivalent to “-optimize=short_format,branch”.
When Optimization type is configured as Custom, the sub options will be incorporated based upon the following user configuration.
Deletes variables/functions that are not referenced (-optimize=symbol_delete)
Creates a subroutine for the same instruction sequence (-optimize=same_code)
When “-optimize=same_code” is specified, the “-samesize” will be included along with the option.
Replaces an instruction with a smaller-size instruction (-optimize=short_format)
Optimizes branch instruction size (optimize=branch)
For example, the Custom configuration incorporates the symbol_delete sub option usage.
Exclude the specified variable or function from the unreferenced symbol deletion optimization (-symbol_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration.
For an example as below, if I want to disable the optimization for an unreferenced variable (test_unreference_variable) in my program, the corresponding configuration is like below. This is equivalent to -symbol_forbid=_test_unreference_variable
Exclude the specified variable or function from the same-code unification optimization (-samecode_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration. When the function argument is void, specify as _<function name>().
For example, if I want to exclude the “test_func()” from the optimization in my program, the corresponding configuration is like below. Note that this is equivalent to -samecode_forbid=_test_func().
Exclude the specified from the optimization (-section_forbid)
In the e2studio properties window, user can go to Section (Linker/Section) and open the section viewer to add or check the section configuration.
For example, if I want to exclude the PFRAM section from the optimization in my program, the corresponding configuration is like below. This is equivalent to -section_forbid=(PFRAM)
Exclude a specified address range from the optimization (-absolute_forbid)
Disables optimization regarding the input address plus size specification.
For example:
Suitable Products
RX Family
How to configure the CC-RX Optimizing Linkage Options through the project configuration in the e2studio IDE
How to configure the CC-RX Optimizing Linkage Options through the project configuration in the e2studio IDE
Answer:
The CC-RX compiler offers Optimizing Linkage Editor (rlink) Options for users to determine how to link object module, link directive files, and library files and generates an object file executable in the target system. This article is meant for guiding fresh users to configure the CC-RX Compiler linker optimization through the e2 studio IDE. In addition, user can also refer to the CC-RX Compiler User’s Manual for the detail descriptions of the supported Optimizing Linkage Editor Options after reading this article.
The first step for user is to open the Linker Optimization configuration through the e2 studio IDE. Please follow the instructions below to get ready for doing the further configuration.
Specify the RX project
Through the e2studio toolbar, click the Project and click the Properties
In the Properties window, navigate to C/C++ Build and expand it
Select the Settings to open the corresponding configuration in the left side pane of Properties window.
In the left side pane, navigate to the Tool Settings tab and expand the Linker item
Select the Optimization item within Linker settings
Now, users can proceed with the Optimization configuration based on your needs, and there are five major settings which are introduced below.
The Optimization Type (-optimize) configuration:
When Optimization type is configured as All, the -optimize without sub options, which executes all optimization, is used.
It is equivalent to “-optimize=symbol_delete,same_code,short_format,branch”.
User can specify the Minimum code size (-samesize) with a hexadecimal value from 8 to 7FFF for the optimization with the “same_code” unification. The default size is 0x1E (-samesize=1E).
When Optimization type is configured as No optimize, the -nooptimize option is specified, and optimization is not performed at linkage.
When Optimization type is configured as Speed-oriented optimization, the -optimize=speed option is used.
This configuration executes optimizations other than those reducing object speed.
This is equivalent to “-optimize=symbol_delete,short_format,branch”.
When Optimization type is configured as Safe optimization, the -optimize=safe option is used.
This configuration executes optimization other than those limited by variable or function attributes. This is equivalent to “-optimize=short_format,branch”.
When Optimization type is configured as Custom, the sub options will be incorporated based upon the following user configuration.
Deletes variables/functions that are not referenced (-optimize=symbol_delete)
Creates a subroutine for the same instruction sequence (-optimize=same_code)
When “-optimize=same_code” is specified, the “-samesize” will be included along with the option.
Replaces an instruction with a smaller-size instruction (-optimize=short_format)
Optimizes branch instruction size (optimize=branch)
For example, the Custom configuration incorporates the symbol_delete sub option usage.
Exclude the specified variable or function from the unreferenced symbol deletion optimization (-symbol_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration.
For an example as below, if I want to disable the optimization for an unreferenced variable (test_unreference_variable) in my program, the corresponding configuration is like below. This is equivalent to -symbol_forbid=_test_unreference_variable
Exclude the specified variable or function from the same-code unification optimization (-samecode_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration. When the function argument is void, specify as _<function name>().
For example, if I want to exclude the “test_func()” from the optimization in my program, the corresponding configuration is like below. Note that this is equivalent to -samecode_forbid=_test_func().
Exclude the specified from the optimization (-section_forbid)
In the e2studio properties window, user can go to Section (Linker/Section) and open the section viewer to add or check the section configuration.
For example, if I want to exclude the PFRAM section from the optimization in my program, the corresponding configuration is like below. This is equivalent to -section_forbid=(PFRAM)
Exclude a specified address range from the optimization (-absolute_forbid)
Disables optimization regarding the input address plus size specification.
For example:
Suitable Products
RX Family
The CC-RX compiler offers Optimizing Linkage Editor (rlink) Options for users to determine how to link object module, link directive files, and library files and generates an object file executable in the target system. This article is meant for guiding fresh users to configure the CC-RX Compiler linker optimization through the e2 studio IDE. In addition, user can also refer to the CC-RX Compiler User’s Manual for the detail descriptions of the supported Optimizing Linkage Editor Options after reading this article.
The first step for user is to open the Linker Optimization configuration through the e2 studio IDE. Please follow the instructions below to get ready for doing the further configuration.
Specify the RX project
Through the e2studio toolbar, click the Project and click the Properties
In the Properties window, navigate to C/C++ Build and expand it
Select the Settings to open the corresponding configuration in the left side pane of Properties window.
In the left side pane, navigate to the Tool Settings tab and expand the Linker item
Select the Optimization item within Linker settings
Now, users can proceed with the Optimization configuration based on your needs, and there are five major settings which are introduced below.
The Optimization Type (-optimize) configuration:
When Optimization type is configured as All, the -optimize without sub options, which executes all optimization, is used.
It is equivalent to “-optimize=symbol_delete,same_code,short_format,branch”.
User can specify the Minimum code size (-samesize) with a hexadecimal value from 8 to 7FFF for the optimization with the “same_code” unification. The default size is 0x1E (-samesize=1E).
When Optimization type is configured as No optimize, the -nooptimize option is specified, and optimization is not performed at linkage.
When Optimization type is configured as Speed-oriented optimization, the -optimize=speed option is used.
This configuration executes optimizations other than those reducing object speed.
This is equivalent to “-optimize=symbol_delete,short_format,branch”.
When Optimization type is configured as Safe optimization, the -optimize=safe option is used.
This configuration executes optimization other than those limited by variable or function attributes. This is equivalent to “-optimize=short_format,branch”.
When Optimization type is configured as Custom, the sub options will be incorporated based upon the following user configuration.
Deletes variables/functions that are not referenced (-optimize=symbol_delete)
Creates a subroutine for the same instruction sequence (-optimize=same_code)
When “-optimize=same_code” is specified, the “-samesize” will be included along with the option.
Replaces an instruction with a smaller-size instruction (-optimize=short_format)
Optimizes branch instruction size (optimize=branch)
For example, the Custom configuration incorporates the symbol_delete sub option usage.
Exclude the specified variable or function from the unreferenced symbol deletion optimization (-symbol_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration.
For an example as below, if I want to disable the optimization for an unreferenced variable (test_unreference_variable) in my program, the corresponding configuration is like below. This is equivalent to -symbol_forbid=_test_unreference_variable
Exclude the specified variable or function from the same-code unification optimization (-samecode_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration. When the function argument is void, specify as _<function name>().
For example, if I want to exclude the “test_func()” from the optimization in my program, the corresponding configuration is like below. Note that this is equivalent to -samecode_forbid=_test_func().
Exclude the specified from the optimization (-section_forbid)
In the e2studio properties window, user can go to Section (Linker/Section) and open the section viewer to add or check the section configuration.
For example, if I want to exclude the PFRAM section from the optimization in my program, the corresponding configuration is like below. This is equivalent to -section_forbid=(PFRAM)
Exclude a specified address range from the optimization (-absolute_forbid)
Disables optimization regarding the input address plus size specification.
For example:
The CC-RX compiler offers Optimizing Linkage Editor (rlink) Options for users to determine how to link object module, link directive files, and library files and generates an object file executable in the target system. This article is meant for guiding fresh users to configure the CC-RX Compiler linker optimization through the e2 studio IDE. In addition, user can also refer to the CC-RX Compiler User’s Manual for the detail descriptions of the supported Optimizing Linkage Editor Options after reading this article.
The first step for user is to open the Linker Optimization configuration through the e2 studio IDE. Please follow the instructions below to get ready for doing the further configuration.
Now, users can proceed with the Optimization configuration based on your needs, and there are five major settings which are introduced below.
Suitable Products
RX Family","['data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/5fb9db7af0c037fd31d168caaab5eb42.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/adac9960064a98a453f5e04c4794be38.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/999e1788be2278656c8f0361983dc09c.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/fc8ca249b46d51a86d368616d2eaee45.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/9ac8679252f3440a58b18aeded5a4bd4.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/3b4ce9eaf37b46cf549ce765850eb948.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/b39b1b862bebfd07a2c6c34503e4a081.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/83a1bfbe0c718f4eea4b41a7e69b01a4.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/7f3c4fd447588fee97bc7e7fa4adb1b8.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/633e4df4df0e971956873910ccbf7582.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/7d823e46016bcb87d7a11600b643c820.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'RX Family: How to configure the CC-RX Optimizing Linkage Options through the project configuration in the e2studio IDE', 'url': 'https://en-support.renesas.com/knowledgeBase/21727826', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:04.242757'}","Question How to configure the CC-RX Optimizing Linkage Options through the project configuration in the e2studio IDE Answer The CC-RX compiler offers Optimizing Linkage Editor (rlink) Options for users to determine how to link object module, link directive files, and library files and generates an object file executable in the target system. This article is meant for guiding fresh users to configure the CC-RX Compiler linker optimization through the e2 studio IDE. In addition, user can also refer to the CC-RX Compiler Users Manual for the detail descriptions of the supported Optimizing Linkage Editor Options after reading this article. The first step for user is to open the Linker Optimization configuration through the e2 studio IDE. Please follow the instructions below to get ready for doing the further configuration. Specify the RX project Through the e2studio toolbar, click the Project and click the Properties In the Properties window, navigate to C/C Build and expand it Select the Settings to open the corresponding configuration in the left side pane of Properties window. In the left side pane, navigate to the Tool Settings tab and expand the Linker item Select the Optimization item within Linker settings Now, users can proceed with the Optimization configuration based on your needs, and there are five major settings which are introduced below. The Optimization Type (-optimize) configuration When Optimization type is configured as All, the -optimize without sub options, which executes all optimization, is used. It is equivalent to -optimizesymboldelete,samecode,shortformat,branch. User can specify the Minimum code size (-samesize) with a hexadecimal value from 8 to 7FFF for the optimization with the samecode unification. The default size is 0x1E (-samesize1E). When Optimization type is configured as No optimize, the -nooptimize option is specified, and optimization is not performed at linkage. When Optimization type is configured as Speed-oriented optimization, the -optimizespeed option is used. This configuration executes optimizations other than those reducing object speed. This is equivalent to -optimizesymboldelete,shortformat,branch. When Optimization type is configured as Safe optimization, the -optimizesafe option is used. This configuration executes optimization other than those limited by variable or function attributes. This is equivalent to -optimizeshortformat,branch. When Optimization type is configured as Custom, the sub options will be incorporated based upon the following user configuration. Deletes variables/functions that are not referenced (-optimizesymboldelete) Creates a subroutine for the same instruction sequence (-optimizesamecode) When -optimizesamecode is specified, the -samesize will be included along with the option. Replaces an instruction with a smaller-size instruction (-optimizeshortformat) Optimizes branch instruction size (optimizebranch) For example, the Custom configuration incorporates the symboldelete sub option usage. Exclude the specified variable or function from the unreferenced symbol deletion optimization (-symbolforbid) For a C/C variable or C function name, add an underscore () at the head of the definition name in the configuration. For an example as below, if I want to disable the optimization for an unreferenced variable (testunreferencevariable) in my program, the corresponding configuration is like below. This is equivalent to -symbolforbidtestunreferencevariable Exclude the specified variable or function from the same-code unification optimization (-samecodeforbid) For a C/C variable or C function name, add an underscore () at the head of the definition name in the configuration. When the function argument is void, specify as function name(). For example, if I want to exclude the testfunc() from the optimization in my program, the corresponding configuration is like below. Note that this is equivalent to -samecodeforbidtestfunc(). Exclude the specified from the optimization (-sectionforbid) In the e2studio properties window, user can go to Section (Linker/Section) and open the section viewer to add or check the section configuration. For example, if I want to exclude the PFRAM section from the optimization in my program, the corresponding configuration is like below. This is equivalent to -sectionforbid(PFRAM) Exclude a specified address range from the optimization (-absoluteforbid) Disables optimization regarding the input address plus size specification. For example Suitable Products RX Family","['The image shows a screenshot of a computer program with a menu bar at the top and a list of options on the left side. The menu bar has several tabs, including ""Tool Settings,"" ""Toolchain,"" ""Device,"" ""Build Steps,"" ""Build Artifact,"" ""Binary Parsers,"" and ""Error Parsers."" The left side of the image has a list of options, including ""Common,"" ""Compiler,"" ""Assembler,"" ""Linker,"" ""Input,"" ""Output,"" ""List,"" ""Optimization,"" ""Section,"" ""Subcommand file,"" ""Miscellaneous,"" ""User,"" ""Library Generator,"" and ""Converter."" The ""Optimization"" option is highlighted in blue, indicating that it is the current selection.\n\nThe background of the image is a light gray color, which provides good contrast with the darker text and makes it easy to read. Overall, the image appears to be a screenshot of a software development tool, possibly a compiler or linker, with various options and settings available for customization.', 'The image shows a screenshot of a computer program\'s settings menu, specifically the ""Optimization type"" section. The menu is titled ""Optimization type (-nooptimize/-optimize)"" and has a dropdown arrow to the right of it. Below the title are two options: ""Deletes variables/functions that are not referenced (-optimize=symbol_delete)"" and ""Creates a subroutine for the same instruction sequence (-optimize=same_code)"". The second option is selected, and there is a text box to the right of it with the value ""1E"" entered.\n\nBelow these options are two more options: ""Minimum code size (-samesize)"" and ""Replaces an instruction with a smaller-size instruction (-optimize=short_format)"". The first option is selected, and there is a text box to the right of it with the value ""1E"" entered. The second option is not selected, and there is no text box to the right of it.\n\nAt the bottom of the menu are two more options: ""Optimizes branch instruction size (-optimize=branch)"" and ""Replaces an instruction with a smaller-size instruction (-optimize=short_format)"". The first option is not selected, and there is no text box to the right of it. The second option is not selected, and there is no text box to the right of it.\n\nThe background of the menu is a light gray color, and the text is black. The overall design of the menu is clean and simple, making it easy to navigate and understand.', 'The image displays a screenshot of a computer program\'s settings menu, specifically the ""Optimization type"" section. The menu is titled ""Optimization type (-nooptimize/-optimize)"" and features a dropdown arrow to the right of the title.\n\nBelow the title are two options:\n\n*   **No optimize**: This option is selected by default.\n*   **Deletes variables/functions that are not referenced (-optimize=symbol_delete)**\n\nUnderneath these options are four additional settings:\n\n*   **Creates a subroutine for the same instruction sequence (-optimize=same_code)**\n*   **Minimum code size (-samesize)**\n*   **Replaces an instruction with a smaller-size instruction (-optimize=short_format)**\n*   **Optimizes branch instruction size (-optimize=branch)**\n\nThe background of the image is a light gray color, providing a clean and neutral visual environment for the user to navigate the settings menu. Overall, the image effectively communicates the available optimization options and their corresponding settings, allowing users to customize their program\'s performance and efficiency.', 'The image shows a screenshot of a computer program with a dropdown menu and a list of options. The dropdown menu is titled ""Optimization type (-nooptimize/-optimize)"" and has two options: ""-nooptimize"" and ""-optimize"". Below the dropdown menu, there is a list of options that can be selected when the ""-optimize"" option is chosen. These options include:\n\n* Deletes variables/functions that are not referenced (-optimize=symbol_delete)\n* Creates a subroutine for the same instruction sequence (-optimize=same_code)\n* Minimum code size (-samesize) 1E\n* Replaces an instruction with a smaller-size instruction (-optimize=short_format)\n* Optimizes branch instruction size (-optimize=branch)\n\nThe background of the image is a light gray color, and the text is black. The overall design of the image suggests that it is a screenshot of a computer program or software tool that is used for optimizing code.', 'The image shows a screenshot of a computer program with a dropdown menu and a list of options. The dropdown menu is titled ""Optimization type (-nooptimize/-optimize)"" and has a subheading ""Safe optimization"". The list of options includes:\n\n* Deletes variables/functions that are not referenced (-optimize=symbol_delete)\n* Creates a subroutine for the same instruction sequence (-optimize=same_code)\n* Minimum code size (-same_size) 1E\n* Replaces an instruction with a smaller-size instruction (-optimize=short_format)\n* Optimizes branch instruction size (-optimize=branch)\n\nThe background of the image is a light gray color, and the text is black. The overall design of the image suggests that it is part of a software development tool or IDE (Integrated Development Environment).', 'The image shows a screenshot of a computer program with a dropdown menu and a list of options. The dropdown menu is titled ""Optimization type (-nooptimize/-optimize)"" and has a checkbox next to it that says ""Custom"". Below the dropdown menu, there are several options listed in a checkbox format, including:\n\n* Deletes variables/functions that are not referenced (-optimize= symbol_delete)\n* Creates a subroutine for the same instruction sequence (-optimize=same_code)\n* Minimum code size (-samesize)\n* Replaces an instruction with a smaller-size instruction (-optimize=short_format)\n* Optimizes branch instruction size (-optimize=branch)\n\nThe background of the image is a light gray color, and the text is black. The overall design of the image suggests that it is a screenshot of a computer program or software tool that is used for optimizing code.', 'The image shows a screenshot of a computer program with a text box and a button. The text box is at the top of the image and has a gray background with black text that reads, ""Unreferenced symbol that disables deletion by optimization (-symbol_forbid)"". Below the text box, there is a white rectangle with a thin gray border. Inside the rectangle, there is a single line of text that reads, ""_test_unreference_variable"". To the right of the text box, there are three icons: a red circle with a white minus sign, a green circle with a white plus sign, and a gray circle with a white question mark. The background of the image is light gray.\n\nThe image appears to be a screenshot of a computer program, possibly a coding or development environment. The text box and button suggest that the program is used for editing or managing code. The icons to the right of the text box may represent different functions or actions that can be performed within the program. Overall, the image provides a glimpse into the user interface of a computer program, highlighting its features and functionality.', 'The image shows a screenshot of a code editor with a single line of code. The code is written in a programming language, likely C# or Java, and reads ""Same-code that disables unification regarding optimization (-samecode_forbid)"". The code is displayed in a text box with a gray background, and there are several icons at the top of the screen, including a save icon, a run icon, and a debug icon. The overall appearance of the image suggests that it is a screenshot of a coding environment, possibly an Integrated Development Environment (IDE) or a code editor.', 'The image shows a screenshot of a computer program, specifically a section viewer. The program is open on a computer screen, with a menu bar at the top and a list of sections in the center. The menu bar has several options, including ""Linker,"" ""Input,"" ""Advanced,"" ""Output,"" ""List,"" ""Optimization,"" ""Section,"" ""Symbol file,"" ""Advanced,"" ""Subcommand file,"" ""Miscellaneous,"" ""User,"" ""Library Generator,"" ""Mode,"" ""Standard Library,"" ""Object,"" ""Optimization,"" ""Advanced,"" ""Miscellaneous,"" ""User,"" ""Converter,"" ""Output,"" and ""Hex format."" The list of sections is organized into columns, with the first column showing the address and the second column showing the section name. The background of the image is a light gray color, with a darker gray border around the edges. Overall, the image appears to be a screenshot of a computer program used for managing and viewing sections of code or data.', ""The image shows a screenshot of a web browser with a search bar and a URL bar. The search bar is at the top of the page, and it has a magnifying glass icon on the left side. The URL bar is below the search bar, and it has a back button, a forward button, and a refresh button on the left side. The URL bar also has a text box where you can enter a URL or search query.\n\nHere are the details of the image:\n\n*   **Search Bar:**\n    *   Location: Top of the page\n    *   Icon: Magnifying glass\n    *   Function: Allows users to search for content on the web\n*   **URL Bar:**\n    *   Location: Below the search bar\n    *   Buttons: Back, forward, and refresh\n    *   Text Box: Allows users to enter a URL or search query\n*   **Background:**\n    *   Color: White\n\nOverall, the image shows a simple and clean design for a web browser's interface. The search bar and URL bar are prominently displayed, making it easy for users to navigate and find the content they need."", 'The image shows a screenshot of a web browser with a pop-up window. The pop-up window is titled ""Address range to disable optimization (-absolute_forbid)"" and has a text box with the value ""ffff06b6+100"". The pop-up window is likely related to web development or debugging, as it mentions ""disable optimization"" and ""absolute_forbid"", which are terms commonly used in web development. The presence of a pop-up window suggests that the user is interacting with a web application or website that is using JavaScript or other client-side scripting languages. The specific content of the pop-up window is not clear without more context, but it appears to be related to configuring or troubleshooting the behavior of a web application.']"
24ae2369724a839c71b001dfcb96c279,"Question:
I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations.
Answer:
Did you complete the pin settings?
If you select [Custom board] when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.
• Properties of each FIT module in the [Components] tab
Select the check boxes of the pins to be used.
• Peripherals in the [Pins] tab
For each pin, click [Pin Assignment], and then select the pin to be assigned.
• For GLCDC (r_glcdc_rx)
    Suitable Products
RX Family
  日本語
Question:
I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations.
Answer:
Did you complete the pin settings?
If you select [Custom board] when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.
• Properties of each FIT module in the [Components] tab
Select the check boxes of the pins to be used.
• Peripherals in the [Pins] tab
For each pin, click [Pin Assignment], and then select the pin to be assigned.
• For GLCDC (r_glcdc_rx)
    Suitable Products
RX Family
I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations.
I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations.
Answer:
Did you complete the pin settings?
If you select [Custom board] when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.
• Properties of each FIT module in the [Components] tab
Select the check boxes of the pins to be used.
• Peripherals in the [Pins] tab
For each pin, click [Pin Assignment], and then select the pin to be assigned.
• For GLCDC (r_glcdc_rx)
    Suitable Products
RX Family
Did you complete the pin settings?
If you select [Custom board] when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.
• Properties of each FIT module in the [Components] tab
Select the check boxes of the pins to be used.
• Peripherals in the [Pins] tab
For each pin, click [Pin Assignment], and then select the pin to be assigned.
• For GLCDC (r_glcdc_rx)
Did you complete the pin settings?
If you select [Custom board] when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.
• Properties of each FIT module in the [Components] tab
Select the check boxes of the pins to be used.
• Peripherals in the [Pins] tab
For each pin, click [Pin Assignment], and then select the pin to be assigned.
• For GLCDC (r_glcdc_rx)
Suitable Products
RX Family
日本語
日本語","['data/categories/rx_family/others/24ae2369724a839c71b001dfcb96c279/images/c2ef01d20c3a4384c8ea21660576743e.png', 'data/categories/rx_family/others/24ae2369724a839c71b001dfcb96c279/images/03bf9495f310eadc6f82d5469dc82805.png', 'data/categories/rx_family/others/24ae2369724a839c71b001dfcb96c279/images/2b6ce40dd1978753f5da261c4d7d4086.png', 'data/categories/rx_family/others/24ae2369724a839c71b001dfcb96c279/images/ce3c68f6064a9f48d481166a92659f42.png', 'data/categories/rx_family/others/24ae2369724a839c71b001dfcb96c279/images/7b1f4044af6c6c7c0d5c73f879cc29b2.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations.', 'url': 'https://en-support.renesas.com/knowledgeBase/20940281', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:23.782681'}","Question I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations. Answer Did you complete the pin settings? If you select Custom board when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.  Properties of each FIT module in the Components tab Select the check boxes of the pins to be used.  Peripherals in the Pins tab For each pin, click Pin Assignment, and then select the pin to be assigned.  For GLCDC (rglcdcrx) Suitable Products RX Family  Suitable Products ","['The image shows a screenshot of a computer program with a list of components and their properties. The program is titled ""Software component configuration"" and has a menu bar at the top with options such as ""Components"", ""Configure"", and ""Generate Code"". \n\n*   The left side of the window has a list of components, including ""Startup"", ""Generic"", ""Drivers"", ""DMA"", ""I/O Ports"", ""Communications"", ""Graphics"", ""Timers"", and ""Middleware"". Each component has a checkbox next to it, indicating whether it is used or not.\n*   The right side of the window has a table with two columns: ""Property"" and ""Value"". The ""Property"" column lists various properties of the components, such as ""Resources"", ""LCD_CLK Pin"", ""LCD_TCON0 Pin"", ""LCD_TCON1 Pin"", ""LCD_TCON2 Pin"", ""LCD_TCON3 Pin"", ""LCD_DATA0 Pin"", ""LCD_DATA1 Pin"", ""LCD_DATA2 Pin"", ""LCD_DATA3 Pin"", ""LCD_DATA4 Pin"", ""LCD_DATA5 Pin"", ""LCD_DATA6 Pin"", ""LCD_DATA7 Pin"", ""LCD_DATA8 Pin"", ""LCD_DATA9 Pin"", ""LCD_DATA10 Pin"", ""LCD_DATA11 Pin"", ""LCD_DATA12 Pin"", ""LCD_DATA13 Pin"", ""LCD_DATA14 Pin"", ""LCD_DATA15 Pin"", ""LCD_DATA16 Pin"", ""LCD_DATA17 Pin"", ""LCD_DATA18 Pin"", ""LCD_DATA19 Pin"", ""LCD_DATA20 Pin"", ""LCD_DATA21 Pin"", ""LCD_DATA22 Pin"", ""LCD_DATA23 Pin"", and ""LCD_EXTCLK Pin"". The ""Value"" column shows the values associated with each property, which are mostly ""Used"".\n*   At the bottom of the window, there is a toolbar with buttons for ""Overview"", ""Board"", ""Clocks"", ""System"", ""Components"", ""Pins"", and ""Interrupts"".\n\nOverall, the image appears to be a screenshot of a software development tool, possibly a microcontroller development environment, where users can configure and manage the components of their project.', 'The image shows a screenshot of a computer program, specifically a pin configuration window. The window is titled ""Pin configuration"" and has a yellow bar at the top with the text ""Hint: This button will assign pin function to the default board pins if a board is selected."" Below this, there are two columns of text: ""Hardware Resource"" and ""Pin Function"". The ""Hardware Resource"" column lists various hardware components, such as ""On-chip emulator"", ""Buses"", ""EXDMA controller"", and ""Interrupt controller unit"". The ""Pin Function"" column lists the corresponding pin functions for each hardware component, such as ""LCD_DATA0"", ""LCD_DATA1"", ""LCD_DATA2"", and ""LCD_DATA3"".\n\nTo the right of the columns, there is a table with three columns: ""Enabled"", ""Function"", and ""Assignment"". The ""Enabled"" column has checkboxes next to each row, indicating whether the pin function is enabled or not. The ""Function"" column lists the specific pin function for each row, such as ""LCD_DATA0"" or ""LCD_DATA1"". The ""Assignment"" column lists the assignment of each pin function, such as ""PJ0/MTIOC6B/SSLC1-B/EPLSOUT0/LCD_DATA0"" or ""P85/MTIOC6C/TIOCCO/LCD_DATA1-A"".\n\nAt the bottom of the window, there is a section titled ""Pin Function"" with a list of pin functions, including ""LCD_TCON0"", ""LCD_TCON1"", ""LCD_TCON2"", and ""LCD_TCON3"". Each pin function has a checkbox next to it, indicating whether it is enabled or not.\n\nOverall, the image appears to be a screenshot of a computer program used for configuring pins on a microcontroller or other electronic device. The program allows users to select and enable specific pin functions, assign them to hardware components, and view the assignments in a table.', 'The image displays a line of text in a programming context, likely from a code snippet or documentation. The text is written in a monospaced font and reads:\n\n""For simpleified I2C (r_sci_iic_rx) (example when SCI ch6 is used).""\n\nThe text is centered on the page, with the first word ""For"" aligned to the left margin. The rest of the text is left-justified, with each word or phrase separated by a single space.\n\nThe text is written in a dark gray color, which provides good contrast against the white background. The font size is moderate, making it easy to read but not too large or overwhelming.\n\nOverall, the image appears to be a screenshot or a snippet of code or documentation, possibly from a technical manual or tutorial. The text is clear and concise, and the formatting is easy to follow.', 'The image shows a screenshot of a computer program with a white background and black text. The title at the top reads ""Software component configuration"" in black text.\n\nBelow the title, there are two columns of text. The left column is labeled ""Components"" and contains a list of items, including ""type filter text"", ""Startup"", ""Generic"", ""r_bsp"", ""Drivers"", ""DMA"", ""r_dmaca_rx"", ""I/O Ports"", ""r_gpio_rx"", ""Communications"", ""r_sci_iic_rx"", ""Graphics"", ""r_drw2d_rx"", ""r_gldc_rx"", ""Timers"", ""r_cmt_rx"", ""r_cmtw_rx"", ""Middleware"", and ""Graphics"". Each item has a checkbox next to it, and some have additional text or icons.\n\nThe right column is labeled ""Configure"" and contains a table with three columns: ""Property"", ""Value"", and ""Include port setting"". The table has several rows, each with a checkbox next to it. The ""Property"" column lists various settings, such as ""Setting port setting processing"", ""Resources"", ""SCI0"", ""SCI1"", ""SCI2"", ""SCI3"", ""SCI4"", ""SCI5"", ""SCI6"", ""SCI7"", and ""SC16"". The ""Value"" column shows the corresponding values for each setting, and the ""Include port setting"" column has checkboxes next to each row.\n\nAt the bottom of the image, there is a gray bar with black text that reads ""Overview"", ""Board"", ""Clocks"", ""System"", ""Components"", ""Pins"", and ""Interrupts"". The background of the image is white, with a light gray border around the edges. Overall, the image appears to be a screenshot of a software configuration tool, possibly used for setting up and customizing a computer system or device.', 'The image shows a screenshot of a computer program, specifically a pin configuration window. The window is divided into two main sections: the left side, which lists various hardware resources, and the right side, which displays a table with columns for ""Enabled"", ""Function"", ""Assignment"", ""Pin Number"", and ""Direction"".\n\n**Left Side:**\n\n*   The left side of the window is titled ""Hardware Resource"" and contains a list of items, including:\n    *   Interrupt controller unit\n    *   Multi-function timer pulse unit\n    *   Port output enable 3\n    *   General PWM timer\n    *   16-bit timer pulse unit\n    *   Programmable pulse generator\n    *   8-bit timer\n    *   Compare match timer W\n    *   Serial communications interface\n    *   SCI0\n    *   SCI1\n    *   SCI2\n    *   SCI3\n    *   SCI4\n    *   SCI5\n    *   SCI6\n    *   SCI7\n    *   SCI8\n    *   SCI9\n    *   SCI10\n    *   SCI11\n    *   SCI12\n    *   I2C bus interface\n    *   Ethernet controller\n    *   PTP module for the Ethernet co\n    *   PHY management interface\n    *   USB 2.0 host/function module\n    *   CAN module\n    *   Serial peripheral interface\n    *   Quad serial peripheral interface\n\n**Right Side:**\n\n*   The right side of the window is titled ""Pin Function"" and contains a table with the following columns:\n    *   Enabled: A checkbox indicating whether the pin is enabled or not.\n    *   Function: A dropdown menu listing various functions, such as ""CTS6#"", ""RTS6#"", ""RXD6"", ""SCK6"", ""SMISO6"", ""SMOSI6"", ""SS6#"", ""SSC16"", ""SSDA6"", and ""TXD6"".\n    *   Assignment: A dropdown menu listing various assignments, such as ""Not assigned"", ""P33/EDREQ1/MTIOC0D/TIOCD0/TMR13/PO11/PO4A1"", ""P32/MTIOC0C/TIOCC0/TMO3/PO10/RTCIC2/RTCOUT1"", and ""27"".\n    *   Pin Number: A text field displaying the pin number, which can be edited.\n    *   Direction: A dropdown menu listing various directions, such as ""Not assigned"", ""IO"", and ""None"".\n\n**Top Bar:**\n\n*   The top bar of the window contains several buttons and menus, including:\n    *   ""Generate Code""\n    *   ""Generate Report""\n    *   ""Don\'t Show Again""\n    *   ""Pin Configuration""\n\n**Overall:**\n\n*   The image shows a screenshot of a computer program used for configuring pins on a microcontroller or other electronic device.\n*   The program allows users to select and configure various pins, including their function, assignment, pin number, and direction.\n*   The program also provides options for generating code and reports, as well as hiding or showing certain elements of the interface.']"
7d965eee5b1ea2fae1923366dc6abb60,"Question:
A link error occurs due to insufficient internal RAM for some reason.
For example, in a use case where multiple windows are to be displayed on an on-board LCD by using the RX65N Envision Kit, I created the windows by using AppWizard (a GUI design tool for the emWin graphic middleware of Segger) and then built the windows by using e2 studio. At this time, a link error occurred. Why?
Answer:
This is probably due to RAM space being insufficient to allocate window data. 
If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. 
Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas.
Suitable Products
RX Family
  日本語
Question:
A link error occurs due to insufficient internal RAM for some reason.
For example, in a use case where multiple windows are to be displayed on an on-board LCD by using the RX65N Envision Kit, I created the windows by using AppWizard (a GUI design tool for the emWin graphic middleware of Segger) and then built the windows by using e2 studio. At this time, a link error occurred. Why?
Answer:
This is probably due to RAM space being insufficient to allocate window data. 
If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. 
Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas.
Suitable Products
RX Family
A link error occurs due to insufficient internal RAM for some reason.
For example, in a use case where multiple windows are to be displayed on an on-board LCD by using the RX65N Envision Kit, I created the windows by using AppWizard (a GUI design tool for the emWin graphic middleware of Segger) and then built the windows by using e2 studio. At this time, a link error occurred. Why?
A link error occurs due to insufficient internal RAM for some reason.
For example, in a use case where multiple windows are to be displayed on an on-board LCD by using the RX65N Envision Kit, I created the windows by using AppWizard (a GUI design tool for the emWin graphic middleware of Segger) and then built the windows by using e2 studio. At this time, a link error occurred. Why?
Answer:
This is probably due to RAM space being insufficient to allocate window data. 
If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. 
Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas.
Suitable Products
RX Family
This is probably due to RAM space being insufficient to allocate window data. 
If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. 
Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas.
This is probably due to RAM space being insufficient to allocate window data. 
If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. 
Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas.
Suitable Products
RX Family
日本語
日本語",['data/categories/rx_family/others/7d965eee5b1ea2fae1923366dc6abb60/images/bc0b61a5727812c674510d3fc75e9b79.png'],[],['|  |\n|  |\n| RX Family |'],"{'title': 'A link error occurs due to insufficient internal RAM for some reason.', 'url': 'https://en-support.renesas.com/knowledgeBase/20940271', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:59.104920'}","Question A link error occurs due to insufficient internal RAM for some reason. For example, in a use case where multiple windows are to be displayed on an on-board LCD by using the RX65N Envision Kit, I created the windows by using AppWizard (a GUI design tool for the emWin graphic middleware of Segger) and then built the windows by using e2 studio. At this time, a link error occurred. Why? Answer This is probably due to RAM space being insufficient to allocate window data. If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas. Suitable Products RX Family  ","['The image presents a detailed diagram of the memory map for the Intel 8086 microprocessor, a crucial component in the development of personal computers during the 1980s. The diagram is divided into several sections, each representing a specific area of memory.\n\n*   **On-chip RAM**\n    *   The on-chip RAM is located at address 0000 0000h and has a size of 4KB.\n    *   It is used for storing data and program instructions that are currently being executed by the processor.\n*   **Reserved area**\n    *   The reserved area is located at address 0004 0000h and has a size of 2KB.\n    *   It is not used by the processor and is reserved for future use or debugging purposes.\n*   **Peripheral I/O registers**\n    *   The peripheral I/O registers are located at address 0008 0000h and have a size of 2KB.\n    *   They are used to control and interact with external devices such as keyboards, displays, and printers.\n*   **Standby RAM**\n    *   The standby RAM is located at address 000A 4000h and has a size of 2KB.\n    *   It is used to store data that is not currently being accessed by the processor but may be needed in the near future.\n*   **Peripheral I/O registers**\n    *   The peripheral I/O registers are located at address 000A 6000h and have a size of 2KB.\n    *   They are used to control and interact with external devices such as keyboards, displays, and printers.\n*   **On-chip ROM (data flash memory)**\n    *   The on-chip ROM is located at address 0010 0000h and has a size of 16KB.\n    *   It is used to store firmware and other data that is not changed frequently.\n*   **Reserved area**\n    *   The reserved area is located at address 0010 8000h and has a size of 2KB.\n    *   It is not used by the processor and is reserved for future use or debugging purposes.\n*   **FACI command issuing area**\n    *   The FACI command issuing area is located at address 007E 0000h and has a size of 2KB.\n    *   It is used to issue commands to the FACI (Floating-Point Arithmetic Coprocessor Interface) unit.\n*   **Reserved area**\n    *   The reserved area is located at address 007F 0004h and has a size of 2KB.\n    *   It is not used by the processor and is reserved for future use or debugging purposes.\n*   **Peripheral I/O registers**\n    *   The peripheral I/O registers are located at address 007F C000h and have a size of 2KB.\n    *   They are used to control and interact with external devices such as keyboards, displays, and printers.\n*   **On-chip expansion RAM**\n    *   The on-chip expansion RAM is located at address 0080 0000h and has a size of 4KB.\n    *   It is used to store data and program instructions that are not currently being executed by the processor.\n\nIn summary, the memory map for the Intel 8086 microprocessor is divided into several sections, each with its own specific purpose and size. The on-chip RAM and ROM are used for storing data and program instructions, while the peripheral I/O registers are used to control and interact with external devices. The reserved areas are not used by the processor and are reserved for future use or debugging purposes.']"
85f2f3ea1400a595658872fdb8fe99d6,"Question:
How can I use a touch controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
  (2) In the “qe_emwin_config.h” file that is output, set the EMWIN_TOUCH_IF definition to TOUCH_IF_OTHER.
To use multi-touch operations, also set the EMWIN_USE_MULTITOUCH definition to 1.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the touch controller you use in the following two files:
• r_emwin_rx_pid_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\src
Overview of the program to be implemented:
Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the r_emwin_rx_pidconf_cb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically.
Notes on implementation:
The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop.
Hint:
Consult the implementations of r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c in the same directory.
• PIDConf.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config\PIDConf.c
Overview of the program to be implemented:
Implement the pidconf_cb_single function called from the r_emwin_rx_pidconf_cb function. (Lines 363 to 383)
The pidconf_cb_single function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUI_PID_STATE type (GUI_Type.h)). The function then sets the data in the GUI_TOUCH_StoreStateEx function so that the data is sent to emWin.
For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUI_MTOUCH_StoreEvent function is required, instead of GUI_TOUCH_StoreStateEx, for notification to emWin.
For an analog touch device, you need to implement measurement processing. (Lines 827 to 888)
GUI_TOUCH_X_ActivateX, GUI_TOUCH_X_MeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions.
And create a program in r_emwin_rx_pid_user_if.c to periodically execute GUI_TOUCH_Exec().
(For information on how to execute periodically, refer to r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c.)
Notes on implementation:
The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used.
Hint: 
• pidconf_cb_single, pidconf_cb_multi, and other functions in PIDConf.c
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details about the GUI_PID_STATE type, the GUI_TOUCH_StoreStateEx function, and the GUI_MTOUCH_StoreEvent function, see the emWin user's manual (UM03001_emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide & Reference Manual (segger.com)).
• Page related to touch operations
5.9.4.1 Generic touch screen API
(https://www.segger.com/doc/UM03001_emWin.html#Generic_touch_screen_API)
5.9.4.2.3.4 GUI_TOUCH_X_MeasureY()
(https://www.segger.com/doc/UM03001_emWin.html#GUI_TOUCH_X_MeasureY)
5.9.4.2 The analog touch screen driver
(https://www.segger.com/doc/UM03001_emWin.html#The_analog_touch_screen_driver)
For details about emWin, contact Segger(https://www.segger.com/) or it local agency. 
Suitable Products
RX Family
  日本語
Question:
How can I use a touch controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
  (2) In the “qe_emwin_config.h” file that is output, set the EMWIN_TOUCH_IF definition to TOUCH_IF_OTHER.
To use multi-touch operations, also set the EMWIN_USE_MULTITOUCH definition to 1.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the touch controller you use in the following two files:
• r_emwin_rx_pid_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\src
Overview of the program to be implemented:
Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the r_emwin_rx_pidconf_cb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically.
Notes on implementation:
The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop.
Hint:
Consult the implementations of r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c in the same directory.
• PIDConf.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config\PIDConf.c
Overview of the program to be implemented:
Implement the pidconf_cb_single function called from the r_emwin_rx_pidconf_cb function. (Lines 363 to 383)
The pidconf_cb_single function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUI_PID_STATE type (GUI_Type.h)). The function then sets the data in the GUI_TOUCH_StoreStateEx function so that the data is sent to emWin.
For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUI_MTOUCH_StoreEvent function is required, instead of GUI_TOUCH_StoreStateEx, for notification to emWin.
For an analog touch device, you need to implement measurement processing. (Lines 827 to 888)
GUI_TOUCH_X_ActivateX, GUI_TOUCH_X_MeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions.
And create a program in r_emwin_rx_pid_user_if.c to periodically execute GUI_TOUCH_Exec().
(For information on how to execute periodically, refer to r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c.)
Notes on implementation:
The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used.
Hint: 
• pidconf_cb_single, pidconf_cb_multi, and other functions in PIDConf.c
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details about the GUI_PID_STATE type, the GUI_TOUCH_StoreStateEx function, and the GUI_MTOUCH_StoreEvent function, see the emWin user's manual (UM03001_emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide & Reference Manual (segger.com)).
• Page related to touch operations
5.9.4.1 Generic touch screen API
(https://www.segger.com/doc/UM03001_emWin.html#Generic_touch_screen_API)
5.9.4.2.3.4 GUI_TOUCH_X_MeasureY()
(https://www.segger.com/doc/UM03001_emWin.html#GUI_TOUCH_X_MeasureY)
5.9.4.2 The analog touch screen driver
(https://www.segger.com/doc/UM03001_emWin.html#The_analog_touch_screen_driver)
For details about emWin, contact Segger(https://www.segger.com/) or it local agency. 
Suitable Products
RX Family
How can I use a touch controller that is not supported by the emWin FIT module or QE for Display?
How can I use a touch controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
  (2) In the “qe_emwin_config.h” file that is output, set the EMWIN_TOUCH_IF definition to TOUCH_IF_OTHER.
To use multi-touch operations, also set the EMWIN_USE_MULTITOUCH definition to 1.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the touch controller you use in the following two files:
• r_emwin_rx_pid_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\src
Overview of the program to be implemented:
Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the r_emwin_rx_pidconf_cb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically.
Notes on implementation:
The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop.
Hint:
Consult the implementations of r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c in the same directory.
• PIDConf.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config\PIDConf.c
Overview of the program to be implemented:
Implement the pidconf_cb_single function called from the r_emwin_rx_pidconf_cb function. (Lines 363 to 383)
The pidconf_cb_single function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUI_PID_STATE type (GUI_Type.h)). The function then sets the data in the GUI_TOUCH_StoreStateEx function so that the data is sent to emWin.
For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUI_MTOUCH_StoreEvent function is required, instead of GUI_TOUCH_StoreStateEx, for notification to emWin.
For an analog touch device, you need to implement measurement processing. (Lines 827 to 888)
GUI_TOUCH_X_ActivateX, GUI_TOUCH_X_MeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions.
And create a program in r_emwin_rx_pid_user_if.c to periodically execute GUI_TOUCH_Exec().
(For information on how to execute periodically, refer to r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c.)
Notes on implementation:
The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used.
Hint: 
• pidconf_cb_single, pidconf_cb_multi, and other functions in PIDConf.c
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details about the GUI_PID_STATE type, the GUI_TOUCH_StoreStateEx function, and the GUI_MTOUCH_StoreEvent function, see the emWin user's manual (UM03001_emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide & Reference Manual (segger.com)).
• Page related to touch operations
5.9.4.1 Generic touch screen API
(https://www.segger.com/doc/UM03001_emWin.html#Generic_touch_screen_API)
5.9.4.2.3.4 GUI_TOUCH_X_MeasureY()
(https://www.segger.com/doc/UM03001_emWin.html#GUI_TOUCH_X_MeasureY)
5.9.4.2 The analog touch screen driver
(https://www.segger.com/doc/UM03001_emWin.html#The_analog_touch_screen_driver)
For details about emWin, contact Segger(https://www.segger.com/) or it local agency. 
Suitable Products
RX Family
With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
  (2) In the “qe_emwin_config.h” file that is output, set the EMWIN_TOUCH_IF definition to TOUCH_IF_OTHER.
To use multi-touch operations, also set the EMWIN_USE_MULTITOUCH definition to 1.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the touch controller you use in the following two files:
• r_emwin_rx_pid_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\src
Overview of the program to be implemented:
Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the r_emwin_rx_pidconf_cb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically.
Notes on implementation:
The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop.
Hint:
Consult the implementations of r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c in the same directory.
• PIDConf.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config\PIDConf.c
Overview of the program to be implemented:
Implement the pidconf_cb_single function called from the r_emwin_rx_pidconf_cb function. (Lines 363 to 383)
The pidconf_cb_single function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUI_PID_STATE type (GUI_Type.h)). The function then sets the data in the GUI_TOUCH_StoreStateEx function so that the data is sent to emWin.
For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUI_MTOUCH_StoreEvent function is required, instead of GUI_TOUCH_StoreStateEx, for notification to emWin.
For an analog touch device, you need to implement measurement processing. (Lines 827 to 888)
GUI_TOUCH_X_ActivateX, GUI_TOUCH_X_MeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions.
And create a program in r_emwin_rx_pid_user_if.c to periodically execute GUI_TOUCH_Exec().
(For information on how to execute periodically, refer to r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c.)
Notes on implementation:
The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used.
Hint: 
• pidconf_cb_single, pidconf_cb_multi, and other functions in PIDConf.c
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details about the GUI_PID_STATE type, the GUI_TOUCH_StoreStateEx function, and the GUI_MTOUCH_StoreEvent function, see the emWin user's manual (UM03001_emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide & Reference Manual (segger.com)).
• Page related to touch operations
5.9.4.1 Generic touch screen API
(https://www.segger.com/doc/UM03001_emWin.html#Generic_touch_screen_API)
5.9.4.2.3.4 GUI_TOUCH_X_MeasureY()
(https://www.segger.com/doc/UM03001_emWin.html#GUI_TOUCH_X_MeasureY)
5.9.4.2 The analog touch screen driver
(https://www.segger.com/doc/UM03001_emWin.html#The_analog_touch_screen_driver)
For details about emWin, contact Segger(https://www.segger.com/) or it local agency.
With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the “qe_emwin_config.h” file that is output, set the EMWIN_TOUCH_IF definition to TOUCH_IF_OTHER.
To use multi-touch operations, also set the EMWIN_USE_MULTITOUCH definition to 1.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the touch controller you use in the following two files:
• r_emwin_rx_pid_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\src
Overview of the program to be implemented:
Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the r_emwin_rx_pidconf_cb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically.
Notes on implementation:
The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop.
Hint:
Consult the implementations of r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c in the same directory.
• PIDConf.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config\PIDConf.c
Overview of the program to be implemented:
Implement the pidconf_cb_single function called from the r_emwin_rx_pidconf_cb function. (Lines 363 to 383)
The pidconf_cb_single function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUI_PID_STATE type (GUI_Type.h)). The function then sets the data in the GUI_TOUCH_StoreStateEx function so that the data is sent to emWin.
For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUI_MTOUCH_StoreEvent function is required, instead of GUI_TOUCH_StoreStateEx, for notification to emWin.
For an analog touch device, you need to implement measurement processing. (Lines 827 to 888)
GUI_TOUCH_X_ActivateX, GUI_TOUCH_X_MeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions.
And create a program in r_emwin_rx_pid_user_if.c to periodically execute GUI_TOUCH_Exec().
(For information on how to execute periodically, refer to r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c.)
Notes on implementation:
The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used.
Hint: 
• pidconf_cb_single, pidconf_cb_multi, and other functions in PIDConf.c
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details about the GUI_PID_STATE type, the GUI_TOUCH_StoreStateEx function, and the GUI_MTOUCH_StoreEvent function, see the emWin user's manual (UM03001_emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide & Reference Manual (segger.com)).
• Page related to touch operations
5.9.4.1 Generic touch screen API
(https://www.segger.com/doc/UM03001_emWin.html#Generic_touch_screen_API)
5.9.4.2.3.4 GUI_TOUCH_X_MeasureY()
(https://www.segger.com/doc/UM03001_emWin.html#GUI_TOUCH_X_MeasureY)
5.9.4.2 The analog touch screen driver
(https://www.segger.com/doc/UM03001_emWin.html#The_analog_touch_screen_driver)
For details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
RX Family
日本語
日本語",['data/categories/rx_family/others/85f2f3ea1400a595658872fdb8fe99d6/images/1159e5a88de327f27e91e3d6feb5f337.png'],[],['|  |\n|  |\n| RX Family |'],"{'title': 'How can I use a touch controller that is not supported by the emWin FIT module or QE for Display?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940276', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:21.441307'}","Question How can I use a touch controller that is not supported by the emWin FIT module or QE for Display? Answer With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself. See the following procedure (1) Specify the settings to the extent possible, and then output the configuration file (qeemwinconfig.h). (2) In the qeemwinconfig.h file that is output, set the EMWINTOUCHIF definition to TOUCHIFOTHER. To use multi-touch operations, also set the EMWINUSEMULTITOUCH definition to 1. (Note that if you output the configuration file from QE again, the changes you made will be lost.) (3) Implement a program that communicates with the touch controller you use in the following two files  remwinrxpiduserif.c Directory project-namesrcsmcgenremwinrxsrc Overview of the program to be implemented Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the remwinrxpidconfcb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically. Notes on implementation The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop. Hint Consult the implementations of remwinrxpidiicif.c and remwinrxpidspiif.c in the same directory.  PIDConf.c project-namesrcsmcgenremwinrxlibConfigPIDConf.c Implement the pidconfcbsingle function called from the remwinrxpidconfcb function. (Lines 363 to 383) The pidconfcbsingle function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUIPIDSTATE type (GUIType.h)). The function then sets the data in the GUITOUCHStoreStateEx function so that the data is sent to emWin. For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUIMTOUCHStoreEvent function is required, instead of GUITOUCHStoreStateEx, for notification to emWin. For an analog touch device, you need to implement measurement processing. (Lines 827 to 888) GUITOUCHXActivateX, GUITOUCHXMeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions. And create a program in remwinrxpiduserif.c to periodically execute GUITOUCHExec(). (For information on how to execute periodically, refer to remwinrxpidiicif.c and remwinrxpidspiif.c.) The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used. Hint  pidconfcbsingle, pidconfcbmulti, and other functions in PIDConf.c Supplementary information You need to implement the programs in accordance with the emWin specifications. For details about the GUIPIDSTATE type, the GUITOUCHStoreStateEx function, and the GUIMTOUCHStoreEvent function, see the emWin user's manual (UM03001emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide  Reference Manual (segger.com)).  Page related to touch operations 5.9.4.1 Generic touch screen API (https//www.segger.com/doc/UM03001emWin.htmlGenerictouchscreenAPI) 5.9.4.2.3.4 GUITOUCHXMeasureY() (https//www.segger.com/doc/UM03001emWin.htmlGUITOUCHXMeasureY) 5.9.4.2 The analog touch screen driver (https//www.segger.com/doc/UM03001emWin.htmlTheanalogtouchscreendriver) For details about emWin, contact Segger(https//www.segger.com/) or it local agency. Suitable Products RX Family  For details about emWin, contact Segger(https//www.segger.com/) or it local agency. (2) In the qeemwinconfig.h file that is output, set the EMWINTOUCHIF definition to TOUCHIFOTHER. ","['The image shows a screenshot of a computer program with a light blue background and black text. The title at the top reads ""3. GUI creation on LCD"" in bold font.\n\nBelow the title, there are two sections: ""Installing the GUI drawing tool driver"" and ""Initial setting of GUI drawing tool"". The first section has a checkbox next to it, while the second section has a dropdown menu with options ""Info setting"" and ""GUI drawing tool setting:"". A red box highlights the ""Generate file"" option within the dropdown menu.\n\nIn the top-right corner, there is a small icon resembling a film strip. In the bottom-right corner, there is a checkbox labeled ""Select folder"". The overall design of the program appears to be user-friendly and intuitive, with clear headings and concise instructions.']"
c436f6248565606875b83e7d27b76bc5,"Question:
I have a question in regard to an example shown in the RX113 Group User's Manual: Hardware Rev.1.20 (https://www.renesas.com/us/en/document/man/rx113-group-user-s-manual-hardware).
In the connection shown in the following figure, suppose that no power is supplied to the microcomputer. In this case, if a voltage of 5 V DC is supplied to VBUS from a device via the USB connector, isn't the pin (PC16 or PC4) to which USB0_VBUS is connected damaged?
Answer:
The PC16 is 5-volt tolerant even when power is off. Therefore, no problem occurs when VBUS is directly connected.
Because the PC4 is not 5-volt tolerant, lower the voltage to 3.3 V by using, for example, a resistive voltage divider.
Suitable Products
RX113
I have a question in regard to an example shown in the RX113 Group User's Manual: Hardware Rev.1.20 (https://www.renesas.com/us/en/document/man/rx113-group-user-s-manual-hardware).
In the connection shown in the following figure, suppose that no power is supplied to the microcomputer. In this case, if a voltage of 5 V DC is supplied to VBUS from a device via the USB connector, isn't the pin (PC16 or PC4) to which USB0_VBUS is connected damaged?
I have a question in regard to an example shown in the RX113 Group User's Manual: Hardware Rev.1.20 (https://www.renesas.com/us/en/document/man/rx113-group-user-s-manual-hardware).
In the connection shown in the following figure, suppose that no power is supplied to the microcomputer. In this case, if a voltage of 5 V DC is supplied to VBUS from a device via the USB connector, isn't the pin (PC16 or PC4) to which USB0_VBUS is connected damaged?
Answer:
The PC16 is 5-volt tolerant even when power is off. Therefore, no problem occurs when VBUS is directly connected.
Because the PC4 is not 5-volt tolerant, lower the voltage to 3.3 V by using, for example, a resistive voltage divider.
Suitable Products
RX113
The PC16 is 5-volt tolerant even when power is off. Therefore, no problem occurs when VBUS is directly connected.
Because the PC4 is not 5-volt tolerant, lower the voltage to 3.3 V by using, for example, a resistive voltage divider.
The PC16 is 5-volt tolerant even when power is off. Therefore, no problem occurs when VBUS is directly connected.
Because the PC4 is not 5-volt tolerant, lower the voltage to 3.3 V by using, for example, a resistive voltage divider.
Suitable Products
RX113
日本語
日本語",['data/categories/rx_family/others/c436f6248565606875b83e7d27b76bc5/images/76e4362fcd0128981e3a583e5e6dcf9f.png'],[],['|  |\n|  |\n| RX113 |'],"{'title': 'A question in regard to the function connection example for a self-powered USB connector', 'url': 'https://en-support.renesas.com/knowledgeBase/21245144', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:48.745923'}","Question I have a question in regard to an example shown in the RX113 Group User's Manual Hardware Rev.1.20 (https//www.renesas.com/us/en/document/man/rx113-group-user-s-manual-hardware). In the connection shown in the following figure, suppose that no power is supplied to the microcomputer. In this case, if a voltage of 5 V DC is supplied to VBUS from a device via the USB connector, isn't the pin (PC16 or PC4) to which USB0VBUS is connected damaged? Answer The PC16 is 5-volt tolerant even when power is off. Therefore, no problem occurs when VBUS is directly connected. Because the PC4 is not 5-volt tolerant, lower the voltage to 3.3 V by using, for example, a resistive voltage divider. Suitable Products RX113 ","['The image presents a technical diagram illustrating the functional connection of a USB connector in self-powered state. The diagram is divided into two main sections: the external connection and the internal circuitry.\n\n**External Connection:**\n\n*   **MCU:** The diagram begins with the MCU (Microcontroller Unit), which is connected to the USB connector.\n*   **USB0_VBUS:** The MCU is connected to the USB0_VBUS pin, which is a 5V tolerant pin.\n*   **USB0_DP and USB0_DM:** The MCU is also connected to the USB0_DP and USB0_DM pins, which are used for data transmission.\n\n**Internal Circuitry:**\n\n*   **USB Transceiver:** The internal circuitry includes a USB transceiver, which is connected to the MCU.\n*   **RPU:** The USB transceiver is connected to a pull-up resistor (RPU), which is set to 1MΩ.\n*   **ZoRV:** The output impedance (ZoRV) of the USB transceiver is set to 5V tolerant.\n*   **RPU:** The pull-up resistor (RPU) is set to 1MΩ.\n*   **ZoRV:** The output impedance (ZoRV) of the USB transceiver is set to 5V tolerant.\n*   **USB B Connector:** The internal circuitry also includes a USB B connector, which is connected to the USB transceiver.\n\n**Notes:**\n\n*   **Note 1:** P16 is 5V tolerant. When using non-5V tolerant PC4, reduce VBUS to 3.3V and connect to the pin.\n*   **Note 2:** Design the board so that the total VBUS capacitance ranges from 1.0 to 10 μF.\n\nIn summary, the diagram illustrates the functional connection of a USB connector in self-powered state, including the external connection to the MCU and the internal circuitry, which includes a USB transceiver, pull-up resistor, and USB B connector. The notes provide additional information on the tolerance of the USB transceiver and the design requirements for the board.']"
7cd7aedfbd9f831eb17a706ba700d0d1,"Question:
Is there a way in which I can use a debugger to check the data drawn in a frame buffer?
Answer:
If you are using e2 studio, you can check drawn data by using the [Memory] view.
Note: This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette.
1. From the menu bar, select [Window] > [Display View] > [Memory] to open the [Memory] view.
  2. In the [Memory] view, specify the settings so that the first address of a frame buffer is monitored.
  3. In the [New Rendering] tab, select [RAW Image], and then add a new rendering.
  4. Click the [Raw Image Format] button.
  5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click [OK].
  After a while, an image will appear.
The following example shows an image that appears when the display adjustment function is used in QE for Display.
Suitable Products
RX Family
  日本語
Question:
Is there a way in which I can use a debugger to check the data drawn in a frame buffer?
Answer:
If you are using e2 studio, you can check drawn data by using the [Memory] view.
Note: This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette.
1. From the menu bar, select [Window] > [Display View] > [Memory] to open the [Memory] view.
  2. In the [Memory] view, specify the settings so that the first address of a frame buffer is monitored.
  3. In the [New Rendering] tab, select [RAW Image], and then add a new rendering.
  4. Click the [Raw Image Format] button.
  5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click [OK].
  After a while, an image will appear.
The following example shows an image that appears when the display adjustment function is used in QE for Display.
Suitable Products
RX Family
Is there a way in which I can use a debugger to check the data drawn in a frame buffer?
Is there a way in which I can use a debugger to check the data drawn in a frame buffer?
Answer:
If you are using e2 studio, you can check drawn data by using the [Memory] view.
Note: This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette.
1. From the menu bar, select [Window] > [Display View] > [Memory] to open the [Memory] view.
  2. In the [Memory] view, specify the settings so that the first address of a frame buffer is monitored.
  3. In the [New Rendering] tab, select [RAW Image], and then add a new rendering.
  4. Click the [Raw Image Format] button.
  5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click [OK].
  After a while, an image will appear.
The following example shows an image that appears when the display adjustment function is used in QE for Display.
Suitable Products
RX Family
If you are using e2 studio, you can check drawn data by using the [Memory] view.
Note: This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette.
1. From the menu bar, select [Window] > [Display View] > [Memory] to open the [Memory] view.
  2. In the [Memory] view, specify the settings so that the first address of a frame buffer is monitored.
  3. In the [New Rendering] tab, select [RAW Image], and then add a new rendering.
  4. Click the [Raw Image Format] button.
  5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click [OK].
  After a while, an image will appear.
The following example shows an image that appears when the display adjustment function is used in QE for Display.
If you are using e2 studio, you can check drawn data by using the [Memory] view.
Note: This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette.
1. From the menu bar, select [Window] > [Display View] > [Memory] to open the [Memory] view.
2. In the [Memory] view, specify the settings so that the first address of a frame buffer is monitored.
3. In the [New Rendering] tab, select [RAW Image], and then add a new rendering.
4. Click the [Raw Image Format] button.
5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click [OK].
After a while, an image will appear.
The following example shows an image that appears when the display adjustment function is used in QE for Display.
Suitable Products
RX Family
日本語
日本語","['data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/687fedfcce2f9beebff26e8d68a77377.png', 'data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/3cd62b8ebfe450eca7b607238be800f5.png', 'data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/34f9039af9fe5c1a6aff18e6127ed7bf.png', 'data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/5a74f74e4d4f6e25e8ec31e6130b9e47.png', 'data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/0a843c77b4df91605afe3c023aeb7590.png', 'data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/6af1e09e718b5d1b4547830bd8c632be.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'Is there a way in which I can use a debugger to check the data drawn in a frame buffer?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940280', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:19.723975'}","Question Is there a way in which I can use a debugger to check the data drawn in a frame buffer? Answer If you are using e2 studio, you can check drawn data by using the Memory view. Note This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette. 1. From the menu bar, select Window  Display View  Memory to open the Memory view. 2. In the Memory view, specify the settings so that the first address of a frame buffer is monitored. 3. In the New Rendering tab, select RAW Image, and then add a new rendering. 4. Click the Raw Image Format button. 5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click OK. After a while, an image will appear. The following example shows an image that appears when the display adjustment function is used in QE for Display. Suitable Products RX Family  2. In the Memory view, specify the settings so that the first address of a frame buffer is monitored. 3. In the New Rendering tab, select RAW Image, and then add a new rendering. 4. Click the Raw Image Format button. 5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click OK. After a while, an image will appear. ","['The image shows a screenshot of a computer window with a menu open. The menu is titled ""Window"" and has several options, including ""New Window"", ""Editor"", ""Appearance"", ""Show View"", ""Perspective"", ""Navigation"", and ""Preferences"". The ""Show View"" option is highlighted in blue and has a dropdown menu with various options, such as ""Breakpoints"", ""Console"", ""Debug"", ""Debugger Console"", ""Debug Sources"", ""Disassembly"", ""Error Log"", ""Executables"", ""Expressions"", ""Memory"", ""Modules"", ""Outline"", ""Problems"", ""Progress"", ""Project Explorer"", ""Registers"", ""Signals"", ""Smart Browser"", ""Smart Manual"", ""Templates"", and ""Variables"".\n\nThe background of the image is a light gray color, with a darker gray border around the edges. The overall design of the window and menu suggests that it is part of a software development environment, possibly an Integrated Development Environment (IDE) or a code editor. The presence of options like ""Breakpoints"", ""Console"", and ""Debug"" suggests that the software is used for debugging and testing code. The ""Project Explorer"" and ""Registers"" options suggest that the software is also used for managing projects and working with registers. Overall, the image appears to be a screenshot of a software development tool, possibly used for coding, debugging, and testing.', 'The image shows a screenshot of a Windows computer with two windows open. The top window is titled ""Memory"" and has a red box around a small icon in the top left corner. The bottom window is also titled ""Memory"" and has a list of hexadecimal numbers in it.\n\n*   The top window is titled ""Memory"" and has a red box around a small icon in the top left corner.\n    *   The icon is a small square with a white background and a blue border.\n    *   The window has a gray background and a white title bar.\n    *   There are several buttons and menus at the top of the window, including a ""File"" menu, a ""Edit"" menu, and a ""View"" menu.\n*   The bottom window is also titled ""Memory"" and has a list of hexadecimal numbers in it.\n    *   The list is organized into columns, with each column representing a different type of data.\n    *   The columns are labeled with abbreviations such as ""Address"", ""Value"", and ""Type"".\n    *   The list contains several rows of data, each representing a different memory location.\n    *   The data in the list is displayed in hexadecimal format, with each byte represented by a pair of digits (e.g. ""00"" or ""FF"").\n    *   The list also includes some additional information, such as the size of each memory location and the type of data stored in it.\n\nOverall, the image appears to be a screenshot of a Windows computer\'s memory management system, showing the contents of the computer\'s memory in hexadecimal format.', 'The image shows a screenshot of a computer program, specifically a memory monitor. The program is open on a Windows computer, as indicated by the Windows logo in the top-left corner. The program\'s window is titled ""Memory Monitor"" and has a blue bar at the top with the text ""New Renderings..."" in white.\n\nBelow the title bar, there are several buttons and menus. The first button is labeled ""Monitors"" and has a dropdown menu with options such as ""0x00800000 <Hex Integer>"" and ""0x00800000"". The second button is labeled ""Memory Monitor"" and has a dropdown menu with options such as ""0x00800000 : 0x800000"".\n\nTo the right of the buttons, there is a text box labeled ""Select rendering(s) to create:"". This text box contains a list of options, including ""Waveform"", ""Hex Integer"", ""Fixed Floating Point"", ""Fixed Point"", ""Image"", ""Raw Image"", ""Floating Point"", ""Traditional"", ""Raw Hex"", ""ASCII"", ""Signed Integer"", and ""Unsigned Integer"".\n\nBelow the text box, there is a red box with the text ""Add Rendering(s)"" inside it. This suggests that the user can add new renderings to the memory monitor by clicking on this button.\n\nOverall, the image appears to be a screenshot of a computer program used for monitoring memory usage. The program allows users to select different types of renderings to create and add new renderings to the memory monitor.', 'The image shows a screenshot of a computer program, specifically a memory monitor. The program is open on a Windows computer, as indicated by the Windows logo in the top-left corner. The program\'s window is titled ""Memory"" and has a white background with black text.\n\nHere are the key features of the program:\n\n*   **Title Bar:** The title bar at the top of the window displays the program\'s name, ""Memory,"" and has a blue bar with a white ""X"" button to close the program.\n*   **Menu Bar:** Below the title bar is a menu bar with several options, including ""File,"" ""Edit,"" ""View,"" and ""Help."" The ""View"" menu is currently selected, and it has several sub-options, such as ""Raw Image Format..."" and ""New Renderings...""\n*   **Main Window:** The main window of the program is divided into two sections. The left section displays a list of memory addresses, with each address represented by a hexadecimal value. The right section displays the corresponding raw image data for each address.\n*   **Raw Image Data:** The raw image data is displayed in a hexadecimal format, with each byte represented by a pair of hexadecimal digits. The data is organized into rows, with each row representing a single byte.\n*   **New Renderings... Button:** In the top-right corner of the window is a button labeled ""New Renderings..."". This button likely allows the user to create a new rendering of the memory data.\n*   **Raw Image Format... Button:** Below the ""New Renderings..."" button is another button labeled ""Raw Image Format..."". This button likely allows the user to change the format of the raw image data.\n\nOverall, the program appears to be a memory monitor that displays the raw image data for a given memory address. It provides several options for customizing the display, including changing the format of the raw image data and creating new renderings of the data.', 'The image depicts a screenshot of a computer program\'s settings menu, specifically the ""Raw Image Format"" section. The menu is organized into several categories, including ""Dimensions,"" ""Encoding,"" ""RGB,"" ""BGR,"" ""YCbCr,"" and ""Line alignment."" Each category contains a list of options, with the selected option highlighted in blue.\n\n**Dimensions:**\n\n* Width: 480\n* Height: 272\n\n**Encoding:**\n\n* Monochrome: 1bpp\n\n**RGB:**\n\n* 32bpp (8:8:8:8)\n\n**BGR:**\n\n* 32bpp (8:8:8:8)\n\n**YCbCr:**\n\n* 16bpp (5:5:5)\n\n**Line alignment:**\n\n* 4 bytes\n\nAt the bottom of the menu, there are two buttons: ""OK"" and ""Cancel."" The background of the menu is a light gray color, with black text and blue highlights for the selected options. Overall, the image suggests that the user is configuring the settings for a raw image file, selecting the appropriate format and encoding options for their specific needs.', 'The image shows a screenshot of a computer program, likely a graphics or image editing software. The program is open on a Windows computer, as indicated by the taskbar at the top of the screen.\n\n*   **Taskbar:**\n    *   The taskbar is located at the top of the screen and contains several icons and buttons.\n    *   The icons include the Windows logo, the Start menu, and the clock.\n    *   The buttons include the minimize, maximize, and close buttons for the current window.\n*   **Window:**\n    *   The window is open and displays a color gradient.\n    *   The gradient starts with a dark blue color at the top and gradually transitions to a light yellow color at the bottom.\n    *   The gradient is displayed in a rectangular shape, with a width of approximately 400 pixels and a height of approximately 200 pixels.\n*   **Menu Bar:**\n    *   The menu bar is located at the top of the window and contains several menus and submenus.\n    *   The menus include ""File"", ""Edit"", ""View"", and ""Help"".\n    *   The submenus include options such as ""New"", ""Open"", ""Save"", and ""Print"".\n*   **Color Palette:**\n    *   The color palette is located on the left side of the window and displays a range of colors.\n    *   The colors are arranged in a vertical column, with each color represented by a small square.\n    *   The colors range from dark blue to light yellow, with various shades of red, green, and purple in between.\n*   **Color Gradient:**\n    *   The color gradient is displayed in the main window and shows a smooth transition from one color to another.\n    *   The gradient starts with a dark blue color at the top and gradually transitions to a light yellow color at the bottom.\n    *   The gradient is displayed in a rectangular shape, with a width of approximately 400 pixels and a height of approximately 200 pixels.\n\nOverall, the image suggests that the program is a graphics or image editing software, possibly used for creating digital art or designing visual effects. The color palette and gradient display indicate that the program is capable of producing a wide range of colors and effects.']"
66b8e403181e3afaf8bcbe519679c4f5,"Question:
When updating leaf devices with Azure RTOS ver. 6.2.1 or earlier, if one of the devices fails to update the firmware, consecutive updates on other devices are stopped.
In such a situation, how can I apply the firmware update to the following  leaf devices?
Answer:
On Azure RTOS ver. 6.2.1 or earlier, when OTA fails on one of the leaf devices, the updating process terminates at that point even if the next device is listed.
Renesas reported this issue to Microsoft issue and received a patch for the Azure RTOS ver.6.2.1.
This patch will allow the update process to continue by skipping the faulted device.
Figure 1. Overview of leaf device update
Figure 2. The process for  leaf device update before and after applying the patch.
Renesas can provide the patch on request, please contact your Renesas FAE or use our online support for further information.
This issue is fixed on Azure RTOS ver.6.3.0.
Please note, user can apply patch to Azure RTOS ver.6.2.1 or use the latest version for RX to overcome from such scenario.
More information about the Leaf Update (secondary OTA) can be found from the below link -
https://www.renesas.com/document/apn/rx-family-sample-code-secondary-ota-update-using-microsoft-azure-adu-rev100
Suitable Products
RX65N, RX
When updating leaf devices with Azure RTOS ver. 6.2.1 or earlier, if one of the devices fails to update the firmware, consecutive updates on other devices are stopped.
In such a situation, how can I apply the firmware update to the following  leaf devices?
When updating leaf devices with Azure RTOS ver. 6.2.1 or earlier, if one of the devices fails to update the firmware, consecutive updates on other devices are stopped.
In such a situation, how can I apply the firmware update to the following  leaf devices?
Answer:
On Azure RTOS ver. 6.2.1 or earlier, when OTA fails on one of the leaf devices, the updating process terminates at that point even if the next device is listed.
Renesas reported this issue to Microsoft issue and received a patch for the Azure RTOS ver.6.2.1.
This patch will allow the update process to continue by skipping the faulted device.
Figure 1. Overview of leaf device update
Figure 2. The process for  leaf device update before and after applying the patch.
Renesas can provide the patch on request, please contact your Renesas FAE or use our online support for further information.
This issue is fixed on Azure RTOS ver.6.3.0.
Please note, user can apply patch to Azure RTOS ver.6.2.1 or use the latest version for RX to overcome from such scenario.
More information about the Leaf Update (secondary OTA) can be found from the below link -
https://www.renesas.com/document/apn/rx-family-sample-code-secondary-ota-update-using-microsoft-azure-adu-rev100
Suitable Products
RX65N, RX
On Azure RTOS ver. 6.2.1 or earlier, when OTA fails on one of the leaf devices, the updating process terminates at that point even if the next device is listed.
Renesas reported this issue to Microsoft issue and received a patch for the Azure RTOS ver.6.2.1.
This patch will allow the update process to continue by skipping the faulted device.
Figure 1. Overview of leaf device update
Figure 2. The process for  leaf device update before and after applying the patch.
Renesas can provide the patch on request, please contact your Renesas FAE or use our online support for further information.
This issue is fixed on Azure RTOS ver.6.3.0.
Please note, user can apply patch to Azure RTOS ver.6.2.1 or use the latest version for RX to overcome from such scenario.
More information about the Leaf Update (secondary OTA) can be found from the below link -
https://www.renesas.com/document/apn/rx-family-sample-code-secondary-ota-update-using-microsoft-azure-adu-rev100
Suitable Products
On Azure RTOS ver. 6.2.1 or earlier, when OTA fails on one of the leaf devices, the updating process terminates at that point even if the next device is listed.
Renesas reported this issue to Microsoft issue and received a patch for the Azure RTOS ver.6.2.1.
This patch will allow the update process to continue by skipping the faulted device.
Figure 1. Overview of leaf device update
Figure 2. The process for  leaf device update before and after applying the patch.
Renesas can provide the patch on request, please contact your Renesas FAE or use our online support for further information.
This issue is fixed on Azure RTOS ver.6.3.0.
Please note, user can apply patch to Azure RTOS ver.6.2.1 or use the latest version for RX to overcome from such scenario.
More information about the Leaf Update (secondary OTA) can be found from the below link -
https://www.renesas.com/document/apn/rx-family-sample-code-secondary-ota-update-using-microsoft-azure-adu-rev100
Suitable Products
RX65N, RX
日本語
日本語","['data/categories/rx_family/others/66b8e403181e3afaf8bcbe519679c4f5/images/52a7e611ce022a6c036d6eefa9a2ab19.png', 'data/categories/rx_family/others/66b8e403181e3afaf8bcbe519679c4f5/images/fbf53e7d6b39b2f5836299f3f26f667d.png']",[],"['|  |\n|  |\n| RX65N, RX |']","{'title': 'RX Family: Is it possible to skip the failed leaf device and continue updating the other leaf devices using Azure cloud?', 'url': 'https://en-support.renesas.com/knowledgeBase/21450120', 'last_updated': '2024-07-08', 'extracted_at': '2025-03-09T00:23:24.620802'}","Question When updating leaf devices with Azure RTOS ver. 6.2.1 or earlier, if one of the devices fails to update the firmware, consecutive updates on other devices are stopped. In such a situation, how can I apply the firmware update to the following leaf devices? Answer On Azure RTOS ver. 6.2.1 or earlier, when OTA fails on one of the leaf devices, the updating process terminates at that point even if the next device is listed. Renesas reported this issue to Microsoft issue and received a patch for the Azure RTOS ver.6.2.1. This patch will allow the update process to continue by skipping the faulted device. Figure 1. Overview of leaf device update Figure 2. The process for leaf device update before and after applying the patch. Renesas can provide the patch on request, please contact your Renesas FAE or use our online support for further information. This issue is fixed on Azure RTOS ver.6.3.0. Please note, user can apply patch to Azure RTOS ver.6.2.1 or use the latest version for RX to overcome from such scenario. More information about the Leaf Update (secondary OTA) can be found from the below link - https//www.renesas.com/document/apn/rx-family-sample-code-secondary-ota-update-using-microsoft-azure-adu-rev100 Suitable Products RX65N, RX ","['The image depicts a cloud-based system with a central host device connected to multiple leaf devices. The host device is linked to the Azure Cloud, which is represented by a blue cloud icon with the text ""Azure Cloud"" in white. The host device is connected to three leaf devices, each labeled as ""Leaf device 1,"" ""Leaf device 2,"" and ""Leaf device N."" These leaf devices are depicted as small blue boxes with various components inside.\n\nA blue line connects the host device to the Azure Cloud, indicating the connection between the two. A red circle and a green circle are positioned above the host device, with a dotted line connecting them to the Azure Cloud. The red circle is labeled ""Update firmware for each leaf device,"" suggesting that the Azure Cloud is responsible for updating the firmware of the leaf devices.\n\nThe background of the image is white, providing a clean and simple visual representation of the system architecture. Overall, the image effectively illustrates the relationship between the host device, leaf devices, and the Azure Cloud, highlighting the role of the cloud in managing and updating the firmware of the leaf devices.', 'The image presents a flowchart illustrating the process of updating Azure RTOS without and with a patch. The flowchart is divided into two main sections: ""without patch"" and ""with patch."" Each section contains a series of steps, represented by blue boxes, that outline the update process.\n\n**Without Patch:**\n\n*   **Update Leaf Device 1**\n    *   If the update is successful, proceed to the next step.\n    *   If the update fails, end the process.\n*   **Update complete?**\n    *   If the update is complete, proceed to the next step.\n    *   If the update is not complete, repeat the update process.\n*   **Update Leaf Device 2**\n    *   If the update is successful, proceed to the next step.\n    *   If the update fails, end the process.\n*   **Update complete?**\n    *   If the update is complete, proceed to the next step.\n    *   If the update is not complete, repeat the update process.\n*   **Update Leaf Device N**\n    *   If the update is successful, proceed to the next step.\n    *   If the update fails, end the process.\n*   **Update complete?**\n    *   If the update is complete, proceed to the next step.\n    *   If the update is not complete, repeat the update process.\n*   **Finish update process**\n    *   If the update is complete, end the process.\n    *   If the update is not complete, repeat the update process.\n\n**With Patch:**\n\n*   **Update Leaf Device 1**\n    *   If the update is successful, proceed to the next step.\n    *   If the update fails, end the process.\n*   **Success or False**\n    *   If the update is successful, proceed to the next step.\n    *   If the update fails, end the process.\n*   **Update Leaf Device 2**\n    *   If the update is successful, proceed to the next step.\n    *   If the update fails, end the process.\n*   **Success or False**\n    *   If the update is successful, proceed to the next step.\n    *   If the update fails, end the process.\n*   **Update Leaf Device N**\n    *   If the update is successful, proceed to the next step.\n    *   If the update fails, end the process.\n*   **Success or False**\n    *   If the update is successful, proceed to the next step.\n    *   If the update fails, end the process.\n*   **Update is success at least one device**\n    *   If the update is successful, end the process.\n    *   If the update fails, repeat the update process.\n*   **Finish update process**\n    *   If the update is complete, end the process.\n    *   If the update is not complete, repeat the update process.\n\nIn summary, the flowchart illustrates the process of updating Azure RTOS without and with a patch. The process involves updating multiple devices, checking for success or failure, and repeating the update process if necessary. The flowchart provides a clear and concise visual representation of the update process, making it easier to understand and follow.']"
5bdb8b5e8105c2717a48a355c0c69f79,"Question:
How can I change the color format when emWin and QE for Display are used?
Answer:
Change the following settings.
The following is an example of changing the color format to CLUT8.
emWin Settings:
(1) Specify a color format that will be used for color depth per pixel (e.g., 8bit).
(2) For DRW2D, specify “Do not use” because it is unavailable with CLUT8 or lower.
(3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8).
(4) If an AppWizard project has not been generated yet, the project is generated according to the “Color Depth per Pixel” settings in “emWin Settings”.
If an AppWizard project has already been generated, specify the color format that you want to use (for example, “8 Bit, GUICC_8666”) for “Color format” in the “Edit project properties” dialog box shown below.
  Suitable Products
RX Family
  日本語
Question:
How can I change the color format when emWin and QE for Display are used?
Answer:
Change the following settings.
The following is an example of changing the color format to CLUT8.
emWin Settings:
(1) Specify a color format that will be used for color depth per pixel (e.g., 8bit).
(2) For DRW2D, specify “Do not use” because it is unavailable with CLUT8 or lower.
(3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8).
(4) If an AppWizard project has not been generated yet, the project is generated according to the “Color Depth per Pixel” settings in “emWin Settings”.
If an AppWizard project has already been generated, specify the color format that you want to use (for example, “8 Bit, GUICC_8666”) for “Color format” in the “Edit project properties” dialog box shown below.
  Suitable Products
RX Family
How can I change the color format when emWin and QE for Display are used?
How can I change the color format when emWin and QE for Display are used?
Answer:
Change the following settings.
The following is an example of changing the color format to CLUT8.
emWin Settings:
(1) Specify a color format that will be used for color depth per pixel (e.g., 8bit).
(2) For DRW2D, specify “Do not use” because it is unavailable with CLUT8 or lower.
(3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8).
(4) If an AppWizard project has not been generated yet, the project is generated according to the “Color Depth per Pixel” settings in “emWin Settings”.
If an AppWizard project has already been generated, specify the color format that you want to use (for example, “8 Bit, GUICC_8666”) for “Color format” in the “Edit project properties” dialog box shown below.
  Suitable Products
RX Family
Change the following settings.
The following is an example of changing the color format to CLUT8.
emWin Settings:
(1) Specify a color format that will be used for color depth per pixel (e.g., 8bit).
(2) For DRW2D, specify “Do not use” because it is unavailable with CLUT8 or lower.
(3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8).
(4) If an AppWizard project has not been generated yet, the project is generated according to the “Color Depth per Pixel” settings in “emWin Settings”.
If an AppWizard project has already been generated, specify the color format that you want to use (for example, “8 Bit, GUICC_8666”) for “Color format” in the “Edit project properties” dialog box shown below.
Change the following settings.
The following is an example of changing the color format to CLUT8.
emWin Settings:
(1) Specify a color format that will be used for color depth per pixel (e.g., 8bit).
(2) For DRW2D, specify “Do not use” because it is unavailable with CLUT8 or lower.
(3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8).
(4) If an AppWizard project has not been generated yet, the project is generated according to the “Color Depth per Pixel” settings in “emWin Settings”.
If an AppWizard project has already been generated, specify the color format that you want to use (for example, “8 Bit, GUICC_8666”) for “Color format” in the “Edit project properties” dialog box shown below.
Suitable Products
RX Family
日本語
日本語","['data/categories/rx_family/others/5bdb8b5e8105c2717a48a355c0c69f79/images/5d2b4e96d697a8ab483bd22eea7e11f6.png', 'data/categories/rx_family/others/5bdb8b5e8105c2717a48a355c0c69f79/images/37ab2ddf7584e6559fd96290d29f67dc.png', 'data/categories/rx_family/others/5bdb8b5e8105c2717a48a355c0c69f79/images/8718f3ed4aced4f9637ddac4eda60cb1.png', 'data/categories/rx_family/others/5bdb8b5e8105c2717a48a355c0c69f79/images/f83b095b6d567f82483c5462fc408f5c.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'How can I change the color format when emWin and QE for Display are used?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940277', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:12.691023'}","Question How can I change the color format when emWin and QE for Display are used? Answer Change the following settings. The following is an example of changing the color format to CLUT8. emWin Settings (1) Specify a color format that will be used for color depth per pixel (e.g., 8bit). (2) For DRW2D, specify Do not use because it is unavailable with CLUT8 or lower. (3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8). (4) If an AppWizard project has not been generated yet, the project is generated according to the Color Depth per Pixel settings in emWin Settings. If an AppWizard project has already been generated, specify the color format that you want to use (for example, 8 Bit, GUICC8666) for Color format in the Edit project properties dialog box shown below. Suitable Products RX Family  Suitable Products ","['The image shows a screenshot of a computer program with a white background and black text. The program is titled ""emWin setting"" and has a menu bar at the top with various options such as ""Board settings,"" ""LCD settings,"" and ""Pin settings."" \n\n*   The ""Board settings"" section includes options for setting the board\'s LCD width, height, and rotation.\n*   The ""LCD settings"" section includes options for setting the LCD\'s color depth per pixel, pin settings, and memory settings.\n*   The ""Pin settings"" section includes options for setting the pin\'s port, bit, and backlight pin.\n*   The ""Memory settings"" section includes options for setting the address of frame buffer 1 and 2, and the maximum memory size used in GUI.\n*   The ""Touch settings"" section includes options for setting the touch function, touch connection interface, and touch interface channel number.\n*   The ""Slave address of touch panel"" section includes options for setting the slave address of touch panel.\n*   The ""Multi-touch function"" section includes options for setting the multi-touch function.\n*   The ""Maximum number of touch panel points"" section includes options for setting the maximum number of touch panel points.\n*   The ""DRW2D setting"" section includes options for setting the DRW2D setting.\n\nOverall, the image appears to be a screenshot of a computer program used for configuring and customizing the settings of a device or system.', 'The image shows a screenshot of a computer program with a gray background and various windows and menus. The program appears to be a display tuning software, with options for adjusting the display settings.\n\n*   **Start Display Adjustment**\n    *   This is the title of the window.\n    *   It is located at the top of the window.\n*   **Maker/Type**\n    *   This is a dropdown menu that allows the user to select the maker and type of the display.\n    *   The current selection is ""Larifizing"".\n*   **Model Name/Size**\n    *   This is a text field that allows the user to enter the model name and size of the display.\n    *   The current entry is ""CR-TFT043-3"".\n*   **Block Image TCON/LCD Setting**\n    *   This is a dropdown menu that allows the user to select the block image TCON/LCD setting.\n    *   The current selection is ""Timing Adjustment"".\n*   **Graphic Layer Setting**\n    *   This is a dropdown menu that allows the user to select the graphic layer setting.\n    *   The current selection is ""Graphic Layer2"".\n*   **Select Using Graphic Layer**\n    *   This is a dropdown menu that allows the user to select the graphic layer to use.\n    *   The current selection is ""Graphic Layer2"".\n*   **Graphic Layer1 Setting**\n    *   This is a dropdown menu that allows the user to select the graphic layer 1 setting.\n    *   The current selection is ""272"".\n*   **Height of Image Data**\n    *   This is a dropdown menu that allows the user to select the height of the image data.\n    *   The current selection is ""480"".\n*   **Width of Image Data**\n    *   This is a dropdown menu that allows the user to select the width of the image data.\n    *   The current selection is ""480"".\n*   **Display Start Position(y-coordinate)**\n    *   This is a dropdown menu that allows the user to select the display start position (y-coordinate).\n    *   The current selection is ""0"".\n*   **Display Start Position(x-coordinate)**\n    *   This is a dropdown menu that allows the user to select the display start position (x-coordinate).\n    *   The current selection is ""0"".\n*   **Start Address of Frame Buffer**\n    *   This is a dropdown menu that allows the user to select the start address of the frame buffer.\n    *   The current selection is ""0x00800000"".\n*   **Output Data Format**\n    *   This is a dropdown menu that allows the user to select the output data format.\n    *   The current selection is ""ARGB8888 (GLCDC_IN_FORMAT_32BITS_ARGB8888)"".\n*   **Interrupts Setting**\n    *   This is a dropdown menu that allows the user to select the interrupts setting.\n    *   The current selection is ""Enable VPOS Detection"".\n*   **Enable VPOS Interrupt**\n    *   This is a dropdown menu that allows the user to select whether to enable the VPOS interrupt.\n    *   The current selection is ""Enable VPOS Interrupt"".\n*   **Use Callback Function**\n    *   This is a dropdown menu that allows the user to select whether to use a callback function.\n    *   The current selection is ""Use Callback Function"".\n*   **Callback Function Name**\n    *   This is a text field that allows the user to enter the name of the callback function.\n    *   The current entry is ""_VSYNC_ISR"".\n\nOverall, the image shows a complex display tuning software with many options for adjusting the display settings. The user can select the maker and type of the display, as well as the graphic layer and output data format. They can also enable or disable interrupts and use a callback function.', 'The image shows a screenshot of a computer window with a light blue border and a white background. The window is titled ""Generate GUI"" in black text, with the subtitle ""Generate GUI to display on LCD."" below it.\n\n*   **Title and Subtitle**\n    *   The title ""Generate GUI"" is in bold, black text.\n    *   The subtitle ""Generate GUI to display on LCD."" is in smaller, non-bold black text.\n*   **Button**\n    *   There is a button labeled ""Start GUI drawing tool"" in black text.\n    *   The button is outlined in blue and has a rectangular shape.\n*   **Setting Button**\n    *   There is a button labeled ""Setting"" in black text.\n    *   The button is outlined in a thin gray line and has a rectangular shape.\n\nThe window appears to be a GUI (Graphical User Interface) generator tool, allowing users to create custom interfaces for LCD displays. The ""Start GUI drawing tool"" button likely opens a new window or interface where users can design and customize their GUI. The ""Setting"" button may provide additional options or configurations for the GUI generator tool.', 'The image shows a screenshot of a computer program with a blue background and white text. The program is titled ""Edit project properties"" and has several sections with various settings.\n\n*   **BSP**\n    *   Selected BSP: None\n    *   Color scheme and display options\n        *   Display size x: 480\n        *   Display size y: 272\n    *   Color format: 8 Bit, GUICC_8666\n*   **Text**\n    *   Show text from SD-card: checked\n    *   Show missing characters: checked\n    *   Enable bi-directional text: unchecked\n    *   Enable Thai support: unchecked\n*   **Focus**\n    *   Enable focus support: unchecked\n    *   Select focus color: 0\n    *   Set focus radius: 1\n    *   Set focus width: 1\n\nThe program appears to be a settings menu for a video game or other interactive application, allowing users to customize various aspects of the game\'s display and behavior.']"
52bf941c703d009eb90dc54cddc8c1c6,"Question:
Is there a way to lower RAM consumption in emWin or GLCDC?
Answer:
For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM.
RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive.
Therefore, it is very important to manage RAM usage and section allocation.
If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take:
• Tune the stack size, heap size, and emWin work size.
You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application.
We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed.
See also the guideline values for memory usage in the emWin user's manual.
Stack size and heap size settings:
  emWin work size setting:
  • Use a smaller data format (such as an 8-bit format).
For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows.
If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM + 512 KB Extended Internal RAM).
Suitable Products
RX Family
  日本語
Question:
Is there a way to lower RAM consumption in emWin or GLCDC?
Answer:
For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM.
RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive.
Therefore, it is very important to manage RAM usage and section allocation.
If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take:
• Tune the stack size, heap size, and emWin work size.
You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application.
We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed.
See also the guideline values for memory usage in the emWin user's manual.
Stack size and heap size settings:
  emWin work size setting:
  • Use a smaller data format (such as an 8-bit format).
For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows.
If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM + 512 KB Extended Internal RAM).
Suitable Products
RX Family
Is there a way to lower RAM consumption in emWin or GLCDC?
Is there a way to lower RAM consumption in emWin or GLCDC?
Answer:
For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM.
RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive.
Therefore, it is very important to manage RAM usage and section allocation.
If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take:
• Tune the stack size, heap size, and emWin work size.
You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application.
We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed.
See also the guideline values for memory usage in the emWin user's manual.
Stack size and heap size settings:
  emWin work size setting:
  • Use a smaller data format (such as an 8-bit format).
For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows.
If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM + 512 KB Extended Internal RAM).
Suitable Products
RX Family
For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM.
RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive.
Therefore, it is very important to manage RAM usage and section allocation.
If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take:
• Tune the stack size, heap size, and emWin work size.
You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application.
We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed.
See also the guideline values for memory usage in the emWin user's manual.
Stack size and heap size settings:
  emWin work size setting:
  • Use a smaller data format (such as an 8-bit format).
For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows.
If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM + 512 KB Extended Internal RAM).
For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM.
RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive.
Therefore, it is very important to manage RAM usage and section allocation.
If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take:
• Tune the stack size, heap size, and emWin work size.
You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application.
We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed.
See also the guideline values for memory usage in the emWin user's manual.
Stack size and heap size settings:
emWin work size setting:
• Use a smaller data format (such as an 8-bit format).
For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows.
If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM + 512 KB Extended Internal RAM).
Suitable Products
RX Family
日本語
日本語","['data/categories/rx_family/others/52bf941c703d009eb90dc54cddc8c1c6/images/cf6deae293a960ae4fbbc29ef011b7cc.png', 'data/categories/rx_family/others/52bf941c703d009eb90dc54cddc8c1c6/images/f950f2012d8ba8fc1e8a365b5f386d1c.png', 'data/categories/rx_family/others/52bf941c703d009eb90dc54cddc8c1c6/images/594f012f40b3c5e173e4b67f445f3b37.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'Is there a way to lower RAM consumption in emWin or GLCDC?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940274', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:05.044056'}","Question Is there a way to lower RAM consumption in emWin or GLCDC? Answer For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM. RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive. Therefore, it is very important to manage RAM usage and section allocation. If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take  Tune the stack size, heap size, and emWin work size. You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application. We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed. See also the guideline values for memory usage in the emWin user's manual. Stack size and heap size settings emWin work size setting  Use a smaller data format (such as an 8-bit format). For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows. If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM  512 KB Extended Internal RAM). Suitable Products RX Family  emWin work size setting  Use a smaller data format (such as an 8-bit format). ","['The image shows a screenshot of a computer program with a gray background and black text. The title at the top reads ""Software component configuration"" in bold black font.\n\nBelow the title, there are two columns of text. The left column is labeled ""Components"" and contains a list of items, including ""type filter text"", ""Startup"", ""Generic"", ""Drivers"", ""Graphics"", and ""r_glcdc_rx"". Each item has a checkbox next to it, and some have additional text or icons.\n\nThe right column is labeled ""Configure"" and contains a list of properties that can be configured, including ""User stack setting"", ""User stack size"", ""Interrupt stack size"", ""Heap size"", ""Initializes C input and output library functions"", ""Enable user stdio charget function"", and ""Use BSP charget function"". Each property has a dropdown menu or text box where the user can enter a value.\n\nAt the bottom of the image, there is a gray bar with the words ""Generate Code"" and ""Generate Report"" in black font. There is also a small icon of a document with a checkmark next to it.\n\nOverall, the image appears to be a screenshot of a software development tool or IDE (Integrated Development Environment) that allows users to configure various properties of a software component.', 'The image shows a screenshot of a computer program\'s settings menu, with a red box highlighting the ""ORIENTATION_0"" section. The menu is organized into sections, each with its own set of options and sub-options.\n\n*   **Board settings**\n    *   Board: RX65N_ENVISION_KIT\n    *   LCD width: 480\n    *   LCD height: 272\n*   **LCD settings**\n    *   LCD rotation: 16bits\n    *   Color depth per pixel: 4bit\n    *   Pin settings\n        *   LCD reset pin: 4bits\n        *   LCD backlight pin: 16bits\n        *   LCD touch IC reset pin: 32bits\n*   **Memory settings**\n    *   Address of frame buffer 1: 0x00800000\n    *   Address of frame buffer 2: 0x00000100\n    *   Maximum memory size used in GUI: 81920\n*   **Touch settings**\n    *   Touch function: Use\n    *   Touch connection interface: SCI_IIC\n    *   Touch interface channel number: 6\n    *   Slave address of touch panel: 0x38\n    *   Multi-touch function: Not Use\n    *   Maximum number of touch panel points: 10\n*   **DRW2D setting**\n    *   DRW2D: Use\n\nThe image shows a computer program\'s settings menu, with a red box highlighting the ""ORIENTATION_0"" section. The menu is organized into sections, each with its own set of options and sub-options. The user can adjust various settings, such as the LCD width and height, color depth per pixel, and touch function. The image provides a clear view of the program\'s settings menu, allowing the user to easily navigate and adjust the settings as needed.', 'The image shows a screenshot of a computer settings window, specifically the ""emWin setting"" window. The window is divided into two columns, with the left column listing various settings and the right column displaying the corresponding values.\n\n**Left Column:**\n\n* **Board settings**\n\t+ Board\n\t+ LCD width\n\t+ LCD height\n* **LCD settings**\n\t+ LCD rotation\n\t+ Color depth per pixel\n\t+ Pin settings\n\t+ LCD backlight pin\n\t+ LCD touch IC reset pin\n* **Memory settings**\n\t+ Address of frame buffer 1\n\t+ Address of frame buffer 2\n\t+ Maximum memory size used in GUI\n* **Touch settings**\n\t+ Touch function\n\t+ Touch connection interface\n\t+ Touch interface channel number\n\t+ Slave address of touch panel\n\t+ Multi-touch function\n\t+ Maximum number of touch panel points\n* **DRW2D setting**\n\t+ DRW2D\n\n**Right Column:**\n\n* **Board**\n\t+ RX65N_ENVISION_KIT\n* **LCD width**\n\t+ 480\n* **LCD height**\n\t+ 272\n* **LCD rotation**\n\t+ ORIENTATION_0\n* **Color depth per pixel**\n\t+ 16bits\n* **Pin settings**\n\t+ 1bit\n\t+ 4bits\n\t+ 8bits\n\t+ 16bits\n\t+ 32bits\n* **LCD backlight pin**\n\t+ Port: 0\n\t+ Bit: 7\n* **LCD touch IC reset pin**\n\t+ Port: 0\n\t+ Bit: 7\n* **Memory settings**\n\t+ 0x00800000\n\t+ 0x00000100\n\t+ 81920\n* **Touch settings**\n\t+ Use\n\t+ SCI_IIC\n\t+ 6\n\t+ 0x38\n\t+ Not Use\n\t+ 10\n* **DRW2D setting**\n\t+ Use\n\nThe background of the window is a light gray color, and the text is black. The window has a title bar at the top with the text ""emWin setting"" in blue font. There are also several buttons and menus along the top and bottom of the window, but they are not clearly visible in the screenshot. Overall, the image appears to be a screenshot of a computer settings window, possibly for a graphics or display-related application.']"
7f590ca5d35c0d379bfa7975f48ca7af,"Question:
How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller.
Display drivers and functions other than RGB connection (GUIDRV_Lin) and serial connection (GUIDRV_FlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger.
Note: “GUIDRV_LIN” and “GUIDRV_FlexColor” are display driver names defined by emWin. You must use a display driver that supports the LCD controller.
1. In the case of an LCD controller for RGB connection (GUIDRV_Lin)
If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings.
2. In the case of an LCD controller for serial connection (GUIDRV_FlexColor)
For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the “qe_emwin_config.h” file that is output, 
set the EMWIN_LCD_IF definition to LCD_IF_RSPI or LCD_IF_SCI_SPI, and then
set the EMWIN_LCD_DRIVER_IC definition to LCD_DRV_IC_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
Note: If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly.
(3) Implement a program that communicates with the LCD controller you use in the following two files:
• LCDConf_spi_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection  interface of the controller to be used, and then implement the functions that send data.
Hint:
The implementations in the same program source will become helpful.
Notes on implementation:
Note the following points when referring to the ST7715 configuration program (LCDConf_spi_if.c).
a. About the offset of write buffer memory
For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory.
If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below.
b. About the connection interface
For example, the ST7715 supports two types of 4-line 8-bit serial interfaces.
These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK.
These interfaces do not support read from the LCD controller. 
(The implemented read8_a1 and readm8_a1 functions are dummy functions.)
3. In the case of an LCD controller that is neither for RGB connection (GUIDRV_Lin) nor for serial connection (GUIDRV_FlexColor)
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the “qe_emwin_config.h” file that is output,
Set the EMWIN_LCD_IF definition to LCD_IF_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the LCD controller you use in the following files:
• LCDConf_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data.
Hint:
The implementations of LCDConf_glcdc_if.c or LCDConf_spi_if.c will become helpful.
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details, see the emWin user's manual bundled with the emWin FIT module (UM03001_emWin.pdf) or the web manual (emWin User Guide & Reference Manual (segger.com)) provided by Segger that developed emWin.
emWin User Guide & Reference Manual (segger.com)
You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol.
See also the following documentation, which is bundled with the emWin FIT module:
• Documentation for the emWin FIT module
 Read the notes in Chapter 6.
For other details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
RX Family
  日本語
Question:
How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller.
Display drivers and functions other than RGB connection (GUIDRV_Lin) and serial connection (GUIDRV_FlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger.
Note: “GUIDRV_LIN” and “GUIDRV_FlexColor” are display driver names defined by emWin. You must use a display driver that supports the LCD controller.
1. In the case of an LCD controller for RGB connection (GUIDRV_Lin)
If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings.
2. In the case of an LCD controller for serial connection (GUIDRV_FlexColor)
For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the “qe_emwin_config.h” file that is output, 
set the EMWIN_LCD_IF definition to LCD_IF_RSPI or LCD_IF_SCI_SPI, and then
set the EMWIN_LCD_DRIVER_IC definition to LCD_DRV_IC_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
Note: If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly.
(3) Implement a program that communicates with the LCD controller you use in the following two files:
• LCDConf_spi_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection  interface of the controller to be used, and then implement the functions that send data.
Hint:
The implementations in the same program source will become helpful.
Notes on implementation:
Note the following points when referring to the ST7715 configuration program (LCDConf_spi_if.c).
a. About the offset of write buffer memory
For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory.
If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below.
b. About the connection interface
For example, the ST7715 supports two types of 4-line 8-bit serial interfaces.
These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK.
These interfaces do not support read from the LCD controller. 
(The implemented read8_a1 and readm8_a1 functions are dummy functions.)
3. In the case of an LCD controller that is neither for RGB connection (GUIDRV_Lin) nor for serial connection (GUIDRV_FlexColor)
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the “qe_emwin_config.h” file that is output,
Set the EMWIN_LCD_IF definition to LCD_IF_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the LCD controller you use in the following files:
• LCDConf_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data.
Hint:
The implementations of LCDConf_glcdc_if.c or LCDConf_spi_if.c will become helpful.
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details, see the emWin user's manual bundled with the emWin FIT module (UM03001_emWin.pdf) or the web manual (emWin User Guide & Reference Manual (segger.com)) provided by Segger that developed emWin.
emWin User Guide & Reference Manual (segger.com)
You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol.
See also the following documentation, which is bundled with the emWin FIT module:
• Documentation for the emWin FIT module
 Read the notes in Chapter 6.
For other details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
RX Family
How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display?
How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller.
Display drivers and functions other than RGB connection (GUIDRV_Lin) and serial connection (GUIDRV_FlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger.
Note: “GUIDRV_LIN” and “GUIDRV_FlexColor” are display driver names defined by emWin. You must use a display driver that supports the LCD controller.
1. In the case of an LCD controller for RGB connection (GUIDRV_Lin)
If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings.
2. In the case of an LCD controller for serial connection (GUIDRV_FlexColor)
For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the “qe_emwin_config.h” file that is output, 
set the EMWIN_LCD_IF definition to LCD_IF_RSPI or LCD_IF_SCI_SPI, and then
set the EMWIN_LCD_DRIVER_IC definition to LCD_DRV_IC_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
Note: If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly.
(3) Implement a program that communicates with the LCD controller you use in the following two files:
• LCDConf_spi_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection  interface of the controller to be used, and then implement the functions that send data.
Hint:
The implementations in the same program source will become helpful.
Notes on implementation:
Note the following points when referring to the ST7715 configuration program (LCDConf_spi_if.c).
a. About the offset of write buffer memory
For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory.
If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below.
b. About the connection interface
For example, the ST7715 supports two types of 4-line 8-bit serial interfaces.
These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK.
These interfaces do not support read from the LCD controller. 
(The implemented read8_a1 and readm8_a1 functions are dummy functions.)
3. In the case of an LCD controller that is neither for RGB connection (GUIDRV_Lin) nor for serial connection (GUIDRV_FlexColor)
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the “qe_emwin_config.h” file that is output,
Set the EMWIN_LCD_IF definition to LCD_IF_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the LCD controller you use in the following files:
• LCDConf_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data.
Hint:
The implementations of LCDConf_glcdc_if.c or LCDConf_spi_if.c will become helpful.
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details, see the emWin user's manual bundled with the emWin FIT module (UM03001_emWin.pdf) or the web manual (emWin User Guide & Reference Manual (segger.com)) provided by Segger that developed emWin.
emWin User Guide & Reference Manual (segger.com)
You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol.
See also the following documentation, which is bundled with the emWin FIT module:
• Documentation for the emWin FIT module
 Read the notes in Chapter 6.
For other details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
RX Family
With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller.
Display drivers and functions other than RGB connection (GUIDRV_Lin) and serial connection (GUIDRV_FlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger.
Note: “GUIDRV_LIN” and “GUIDRV_FlexColor” are display driver names defined by emWin. You must use a display driver that supports the LCD controller.
1. In the case of an LCD controller for RGB connection (GUIDRV_Lin)
If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings.
2. In the case of an LCD controller for serial connection (GUIDRV_FlexColor)
For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the “qe_emwin_config.h” file that is output, 
set the EMWIN_LCD_IF definition to LCD_IF_RSPI or LCD_IF_SCI_SPI, and then
set the EMWIN_LCD_DRIVER_IC definition to LCD_DRV_IC_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
Note: If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly.
(3) Implement a program that communicates with the LCD controller you use in the following two files:
• LCDConf_spi_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection  interface of the controller to be used, and then implement the functions that send data.
Hint:
The implementations in the same program source will become helpful.
Notes on implementation:
Note the following points when referring to the ST7715 configuration program (LCDConf_spi_if.c).
a. About the offset of write buffer memory
For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory.
If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below.
b. About the connection interface
For example, the ST7715 supports two types of 4-line 8-bit serial interfaces.
These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK.
These interfaces do not support read from the LCD controller. 
(The implemented read8_a1 and readm8_a1 functions are dummy functions.)
3. In the case of an LCD controller that is neither for RGB connection (GUIDRV_Lin) nor for serial connection (GUIDRV_FlexColor)
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the “qe_emwin_config.h” file that is output,
Set the EMWIN_LCD_IF definition to LCD_IF_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the LCD controller you use in the following files:
• LCDConf_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data.
Hint:
The implementations of LCDConf_glcdc_if.c or LCDConf_spi_if.c will become helpful.
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details, see the emWin user's manual bundled with the emWin FIT module (UM03001_emWin.pdf) or the web manual (emWin User Guide & Reference Manual (segger.com)) provided by Segger that developed emWin.
emWin User Guide & Reference Manual (segger.com)
You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol.
See also the following documentation, which is bundled with the emWin FIT module:
• Documentation for the emWin FIT module
 Read the notes in Chapter 6.
For other details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller.
Display drivers and functions other than RGB connection (GUIDRV_Lin) and serial connection (GUIDRV_FlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger.
Note: “GUIDRV_LIN” and “GUIDRV_FlexColor” are display driver names defined by emWin. You must use a display driver that supports the LCD controller.
1. In the case of an LCD controller for RGB connection (GUIDRV_Lin)
If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings.
2. In the case of an LCD controller for serial connection (GUIDRV_FlexColor)
For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the “qe_emwin_config.h” file that is output, 
set the EMWIN_LCD_IF definition to LCD_IF_RSPI or LCD_IF_SCI_SPI, and then
set the EMWIN_LCD_DRIVER_IC definition to LCD_DRV_IC_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
Note: If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly.
(3) Implement a program that communicates with the LCD controller you use in the following two files:
• LCDConf_spi_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection  interface of the controller to be used, and then implement the functions that send data.
Hint:
The implementations in the same program source will become helpful.
Notes on implementation:
Note the following points when referring to the ST7715 configuration program (LCDConf_spi_if.c).
a. About the offset of write buffer memory
For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory.
If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below.
b. About the connection interface
For example, the ST7715 supports two types of 4-line 8-bit serial interfaces.
These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK.
These interfaces do not support read from the LCD controller. 
(The implemented read8_a1 and readm8_a1 functions are dummy functions.)
3. In the case of an LCD controller that is neither for RGB connection (GUIDRV_Lin) nor for serial connection (GUIDRV_FlexColor)
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the “qe_emwin_config.h” file that is output,
Set the EMWIN_LCD_IF definition to LCD_IF_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the LCD controller you use in the following files:
• LCDConf_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data.
Hint:
The implementations of LCDConf_glcdc_if.c or LCDConf_spi_if.c will become helpful.
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details, see the emWin user's manual bundled with the emWin FIT module (UM03001_emWin.pdf) or the web manual (emWin User Guide & Reference Manual (segger.com)) provided by Segger that developed emWin.
emWin User Guide & Reference Manual (segger.com)
You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol.
See also the following documentation, which is bundled with the emWin FIT module:
• Documentation for the emWin FIT module
 Read the notes in Chapter 6.
For other details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
RX Family
日本語
日本語","['data/categories/rx_family/others/7f590ca5d35c0d379bfa7975f48ca7af/images/d15b5e080a69ec5e9ce5aba37a36a1aa.png', 'data/categories/rx_family/others/7f590ca5d35c0d379bfa7975f48ca7af/images/f9cefd22d409322ff89c745b6b88d941.png', 'data/categories/rx_family/others/7f590ca5d35c0d379bfa7975f48ca7af/images/1302202bc17536b8af00e9f665cd05a5.png', 'data/categories/rx_family/others/7f590ca5d35c0d379bfa7975f48ca7af/images/5c44d7ba6c635a045e005e037ecd515f.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940275', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:08.932759'}","Question How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display? Answer With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller. Display drivers and functions other than RGB connection (GUIDRVLin) and serial connection (GUIDRVFlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger. Note GUIDRVLIN and GUIDRVFlexColor are display driver names defined by emWin. You must use a display driver that supports the LCD controller. 1. In the case of an LCD controller for RGB connection (GUIDRVLin) If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings. 2. In the case of an LCD controller for serial connection (GUIDRVFlexColor) For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module. See the following procedure (1) Specify the settings to the extent possible, and then output the configuration file (qeemwinconfig.h). (2) In the qeemwinconfig.h file that is output, set the EMWINLCDIF definition to LCDIFRSPI or LCDIFSCISPI, and then set the EMWINLCDDRIVERIC definition to LCDDRVICOTHER. (Note that if you output the configuration file from QE again, the changes you made will be lost.) Note If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly. (3) Implement a program that communicates with the LCD controller you use in the following two files  LCDConfspiif.c Directory project-namesrcsmcgenremwinrxlibConfig Overview of the program to be implemented Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection interface of the controller to be used, and then implement the functions that send data. Hint The implementations in the same program source will become helpful. Notes on implementation Note the following points when referring to the ST7715 configuration program (LCDConfspiif.c). a. About the offset of write buffer memory For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory. If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below. b. About the connection interface For example, the ST7715 supports two types of 4-line 8-bit serial interfaces. These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK. These interfaces do not support read from the LCD controller. (The implemented read8a1 and readm8a1 functions are dummy functions.) 3. In the case of an LCD controller that is neither for RGB connection (GUIDRVLin) nor for serial connection (GUIDRVFlexColor) (2) In the qeemwinconfig.h file that is output, Set the EMWINLCDIF definition to LCDIFOTHER. (3) Implement a program that communicates with the LCD controller you use in the following files  LCDConfuserif.c Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data. The implementations of LCDConfglcdcif.c or LCDConfspiif.c will become helpful. Supplementary information You need to implement the programs in accordance with the emWin specifications. For details, see the emWin user's manual bundled with the emWin FIT module (UM03001emWin.pdf) or the web manual (emWin User Guide  Reference Manual (segger.com)) provided by Segger that developed emWin. emWin User Guide  Reference Manual (segger.com) You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol. See also the following documentation, which is bundled with the emWin FIT module  Documentation for the emWin FIT module Read the notes in Chapter 6. For other details about emWin, contact Segger(https//www.segger.com/) or it local agency. Suitable Products RX Family  ","['The image shows a screenshot of a computer program with a light blue background and black text. The top of the image has the title ""3. GUI creation on LCD"" in large font, with a small icon to the right. Below this, there is a section titled ""Installing the GUI drawing tool driver"" with a button that says ""How to add"". \n\nBelow this, there is a section titled ""Initial setting of GUI drawing tool"" with a dropdown menu that says ""GUI drawing tool setting:"" and two options: ""Info setting"" and ""Generate file"". The ""Generate file"" option is highlighted in red. \n\nAt the bottom of the image, there are two buttons: ""Select folder"" and ""Generate file"". The ""Generate file"" button is also highlighted in red. \n\nOverall, the image appears to be a screenshot of a computer program used for creating GUIs (Graphical User Interfaces) on LCD (Liquid Crystal Display) screens. The program seems to be guiding the user through the process of installing and setting up the GUI drawing tool driver.', 'The image displays a code snippet in a text editor, likely Visual Studio Code, with a black background and green and yellow text. The code is written in C++ and appears to be a part of a larger program.\n\nThe code snippet is divided into three lines:\n\n*   The first line reads `#define FIRST_SEG (2)`, which defines a constant named `FIRST_SEG` with the value `2`.\n*   The second line reads `#define FIRST_COM ((DISPLAY_ORIENTATION & GUI_MIRROR_Y) ? 3 : 1)`, which defines a constant named `FIRST_COM` using a ternary operator. The expression inside the parentheses checks the value of `DISPLAY_ORIENTATION` and `GUI_MIRROR_Y`, and if the result is true, it assigns the value `3` to `FIRST_COM`, otherwise it assigns the value `1`.\n*   The third line reads `165 #define FIRST_SEG (2)`, which is a duplicate of the first line.\n\nThe code snippet is likely part of a larger program that uses these constants to control the display orientation and GUI mirroring. The use of ternary operators and bitwise operations suggests that the program is designed to handle complex graphics and user interface logic.\n\nOverall, the code snippet provides a glimpse into the programming style and techniques used in the larger program, and highlights the importance of careful naming and organization of constants in C++ code.', 'The image presents a table with two rows and four columns, featuring a combination of text and binary numbers. The table is divided into two sections: the top section contains binary numbers, while the bottom section displays text.\n\n**Top Section:**\n\n*   The first column contains the binary number 0.\n*   The second column contains the binary number 1.\n*   The third column contains the binary number 1.\n*   The fourth column contains the binary number 0.\n\n**Bottom Section:**\n\n*   The first column contains the text ""4-line 8bit serial I/F"".\n*   The second column contains the text ""4-line 8bit serial I/F II"".\n*   The third column contains the text ""SDA: in/out"".\n*   The fourth column contains the text ""SDA:in/ SDO: out"".\n\nThe table appears to be a technical diagram or chart, possibly related to computer hardware or electronics. The use of binary numbers and technical terms suggests that it may be used to illustrate a specific concept or principle in the field of computer science or engineering.', 'The image shows a screenshot of a computer program with a light blue background and black text. The title at the top reads ""3. GUI creation on LCD"" in bold font.\n\nBelow the title, there is a section titled ""Installing the GUI drawing tool driver"" with a subheading that says ""Install GUI drawing tool driver."" There is a button labeled ""How to add"" to the right of this section.\n\nFurther down, there is another section titled ""Initial setting of GUI drawing tool"" with a subheading that says ""Configure settings to use GUI drawing tool."" This section has two buttons: ""GUI drawing tool setting:"" and ""Info setting."" The ""GUI drawing tool setting:"" button is highlighted in red, indicating that it is the current selection.\n\nAt the bottom of the image, there are two buttons: ""Generate file"" and ""Select folder."" The ""Generate file"" button is also highlighted in red, suggesting that it is the next step in the process.\n\nOverall, the image appears to be a step-by-step guide for creating a GUI (Graphical User Interface) on an LCD (Liquid Crystal Display) screen. The user is being walked through the process of installing the GUI drawing tool driver and configuring the settings for the GUI drawing tool.']"
90834a1150d409d7f533f8079d32c364,"Question:
If the port is pulled up externally, to which power supply should it be connected?
Answer:
A pull-up to the port's power supply is required. The power supply of the port can be checked with VIH or VIL listed in the electrical characteristics in the user's manual of the product used, as shown below. For example, the power supply of the port in the case where “0.8 x VCC” is written is VCC, so the pull-up resistor should be connected to VCC. If “0.8 x AVCC1” is written, the pull-up resistor should be connected to AVCC1. If VCC and AVCC1 are at the same potential, the pull-up resistor may be connected to either VCC or AVCC1.
(RX66T Group User's Manual Excerpt)
Suitable Products
RX Family
If the port is pulled up externally, to which power supply should it be connected?
If the port is pulled up externally, to which power supply should it be connected?
Answer:
A pull-up to the port's power supply is required. The power supply of the port can be checked with VIH or VIL listed in the electrical characteristics in the user's manual of the product used, as shown below. For example, the power supply of the port in the case where “0.8 x VCC” is written is VCC, so the pull-up resistor should be connected to VCC. If “0.8 x AVCC1” is written, the pull-up resistor should be connected to AVCC1. If VCC and AVCC1 are at the same potential, the pull-up resistor may be connected to either VCC or AVCC1.
(RX66T Group User's Manual Excerpt)
Suitable Products
RX Family
A pull-up to the port's power supply is required. The power supply of the port can be checked with VIH or VIL listed in the electrical characteristics in the user's manual of the product used, as shown below. For example, the power supply of the port in the case where “0.8 x VCC” is written is VCC, so the pull-up resistor should be connected to VCC. If “0.8 x AVCC1” is written, the pull-up resistor should be connected to AVCC1. If VCC and AVCC1 are at the same potential, the pull-up resistor may be connected to either VCC or AVCC1.
(RX66T Group User's Manual Excerpt)
A pull-up to the port's power supply is required. The power supply of the port can be checked with VIH or VIL listed in the electrical characteristics in the user's manual of the product used, as shown below. For example, the power supply of the port in the case where “0.8 x VCC” is written is VCC, so the pull-up resistor should be connected to VCC. If “0.8 x AVCC1” is written, the pull-up resistor should be connected to AVCC1. If VCC and AVCC1 are at the same potential, the pull-up resistor may be connected to either VCC or AVCC1.
(RX66T Group User's Manual Excerpt)
Suitable Products
RX Family
Japanese
Japanese",['data/categories/rx_family/io_port/90834a1150d409d7f533f8079d32c364/images/0c1bcbdeb149d08f0271ec257953a5b9.png'],[],['|  |\n|  |\n| RX Family |'],"{'title': 'RX Family: Power supply to pull up port', 'url': 'https://en-support.renesas.com/knowledgeBase/21810951', 'last_updated': None, 'extracted_at': '2025-03-09T00:16:22.294320'}","Question If the port is pulled up externally, to which power supply should it be connected? Answer A pull-up to the port's power supply is required. The power supply of the port can be checked with VIH or VIL listed in the electrical characteristics in the user's manual of the product used, as shown below. For example, the power supply of the port in the case where 0.8 x VCC is written is VCC, so the pull-up resistor should be connected to VCC. If 0.8 x AVCC1 is written, the pull-up resistor should be connected to AVCC1. If VCC and AVCC1 are at the same potential, the pull-up resistor may be connected to either VCC or AVCC1. (RX66T Group User's Manual Excerpt) Suitable Products RX Family Japanese","['The image presents a table detailing the input voltage specifications for various Schmitt trigger input voltages. The table is divided into several columns, each representing a different aspect of the input voltage:\n\n*   **Item**: Lists the specific Schmitt trigger input voltage being described.\n*   **Symbol**: Provides a symbol or abbreviation for the item listed in the ""Item"" column.\n*   **Min.**: Specifies the minimum input voltage required for the item.\n*   **Typ.**: Indicates the typical input voltage for the item.\n*   **Max.**: Shows the maximum input voltage allowed for the item.\n*   **Unit**: Specifies the unit of measurement for the input voltage.\n*   **Test Conditions**: Provides additional information on the test conditions under which the input voltage specifications are valid.\n\nThe table includes entries for various Schmitt trigger input voltages, such as CAN input pin, MTU input pin, GPTW input pin, POE input pin, POEG input pin, TMR input pin, SCI input pin, ADTRG# input pin, RES#, NMI, IRQ input pin, IRQ input pin (P52 to P55, and P60 to P65), RIIC input pin (except for SMBus), Pins for 5 V tolerant (PB1, PB2, PC0*, and PD2*1), Analog input pins (P40 to P47, and PH0 to PH7), Analog input pins (P50 to P55, and P60 to P65), and Other input pins (pins other than those above).\n\nEach entry in the table provides specific information on the input voltage requirements for the corresponding Schmitt trigger input voltage, including the minimum, typical, and maximum input voltages, as well as the unit of measurement and test conditions.']"
74d72c28a7ebe8fcb75352ee5454f6f7,"Question:
How to configure correctly  a custom project, in order to use MC-COM Port with Renesas Motor Workbench (RMW)?
Answer:
In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication.
MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu.
  By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project:
  1)Τhe user  should include the the necessary ICS2 library files on his project. The files that he will need is the ICS_RXxxT.h header file and ICS2_RXxxT.lib or ICS2_RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder.
  For the .lib or .obj files, the user should got to Project properties -> Linker -> Input and add the library:
        2)Τhe next step is to prepare the project, in order to generate the map file, that includes all the project’s variables and will be uploaded on the RMW tool. To do this check the screenshot below:
        3) Τhe next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added:
      4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose.  0x00000000 of RAM is used:
      5)Τhe next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added:
    Οn r_app_rmw_interrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2_init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate).
    6) The final function that should be used is the ics2_watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called.
For more information, about ics2_init and ics2_watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide:
RMW_Quick_Start_Guide
  After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel.
  Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project:
            Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application.
    Suitable Products
RX-T
  ??? ??
Question:
How to configure correctly  a custom project, in order to use MC-COM Port with Renesas Motor Workbench (RMW)?
Answer:
In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication.
MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu.
  By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project:
  1)Τhe user  should include the the necessary ICS2 library files on his project. The files that he will need is the ICS_RXxxT.h header file and ICS2_RXxxT.lib or ICS2_RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder.
  For the .lib or .obj files, the user should got to Project properties -> Linker -> Input and add the library:
        2)Τhe next step is to prepare the project, in order to generate the map file, that includes all the project’s variables and will be uploaded on the RMW tool. To do this check the screenshot below:
        3) Τhe next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added:
      4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose.  0x00000000 of RAM is used:
      5)Τhe next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added:
    Οn r_app_rmw_interrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2_init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate).
    6) The final function that should be used is the ics2_watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called.
For more information, about ics2_init and ics2_watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide:
RMW_Quick_Start_Guide
  After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel.
  Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project:
            Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application.
    Suitable Products
RX-T
How to configure correctly  a custom project, in order to use MC-COM Port with Renesas Motor Workbench (RMW)?
How to configure correctly  a custom project, in order to use MC-COM Port with Renesas Motor Workbench (RMW)?
Answer:
In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication.
MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu.
  By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project:
  1)Τhe user  should include the the necessary ICS2 library files on his project. The files that he will need is the ICS_RXxxT.h header file and ICS2_RXxxT.lib or ICS2_RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder.
  For the .lib or .obj files, the user should got to Project properties -> Linker -> Input and add the library:
        2)Τhe next step is to prepare the project, in order to generate the map file, that includes all the project’s variables and will be uploaded on the RMW tool. To do this check the screenshot below:
        3) Τhe next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added:
      4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose.  0x00000000 of RAM is used:
      5)Τhe next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added:
    Οn r_app_rmw_interrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2_init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate).
    6) The final function that should be used is the ics2_watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called.
For more information, about ics2_init and ics2_watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide:
RMW_Quick_Start_Guide
  After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel.
  Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project:
            Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application.
    Suitable Products
RX-T
In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication.
MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu.
  By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project:
  1)Τhe user  should include the the necessary ICS2 library files on his project. The files that he will need is the ICS_RXxxT.h header file and ICS2_RXxxT.lib or ICS2_RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder.
  For the .lib or .obj files, the user should got to Project properties -> Linker -> Input and add the library:
        2)Τhe next step is to prepare the project, in order to generate the map file, that includes all the project’s variables and will be uploaded on the RMW tool. To do this check the screenshot below:
        3) Τhe next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added:
      4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose.  0x00000000 of RAM is used:
      5)Τhe next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added:
    Οn r_app_rmw_interrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2_init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate).
    6) The final function that should be used is the ics2_watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called.
For more information, about ics2_init and ics2_watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide:
RMW_Quick_Start_Guide
  After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel.
  Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project:
            Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application.
In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication.
MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu.
By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project:
1)Τhe user  should include the the necessary ICS2 library files on his project. The files that he will need is the ICS_RXxxT.h header file and ICS2_RXxxT.lib or ICS2_RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder.
For the .lib or .obj files, the user should got to Project properties -> Linker -> Input and add the library:
2)Τhe next step is to prepare the project, in order to generate the map file, that includes all the project’s variables and will be uploaded on the RMW tool. To do this check the screenshot below:
3) Τhe next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added:
4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose.  0x00000000 of RAM is used:
5)Τhe next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added:
Οn r_app_rmw_interrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2_init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate).
6) The final function that should be used is the ics2_watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called.
For more information, about ics2_init and ics2_watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide:
RMW_Quick_Start_Guide
After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel.
Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project:
Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application.
Suitable Products
RX-T
??? ??
???
??","['data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/3c0c377540971b9e0b9dd32af515aec3.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/cdf8cc3c97eaf8b4aaeac0d760ba84f7.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/531c5a249d158d95d59b78fc4e29643b.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/92e57beb7c926a61c45078799116feec.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/6f0724da2f9d3872d56694e1bbffe9df.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/15d9685135a97e232c6b112eed860205.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/ceeaa92caf5f9f4810437de400641eb4.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/b8491061cac70a3506aaa2df321c4413.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/ee0c525a2f357ae97f8c005c076750c2.png']",[],['|  |\n|  |\n| RX-T |'],"{'title': 'Configuration of communication between Renesas Motor Workbench (RMW) and PC device on a custom RX-T project', 'url': 'https://en-support.renesas.com/knowledgeBase/21656980', 'last_updated': None, 'extracted_at': '2025-03-09T00:06:16.399871'}","Question How to configure correctly a custom project, in order to use MC-COM Port with Renesas Motor Workbench (RMW)? Answer In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication. MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu. By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project 1)he user should include the the necessary ICS2 library files on his project. The files that he will need is the ICSRXxxT.h header file and ICS2RXxxT.lib or ICS2RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder. For the .lib or .obj files, the user should got to Project properties - Linker - Input and add the library 2)he next step is to prepare the project, in order to generate the map file, that includes all the projects variables and will be uploaded on the RMW tool. To do this check the screenshot below 3) he next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added 4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose. 0x00000000 of RAM is used 5)he next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added n rapprmwinterrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate). 6) The final function that should be used is the ics2watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called. For more information, about ics2init and ics2watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide RMWQuickStartGuide After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel. Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application. Suitable Products RX-T ??? ?? By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project 1)he user should include the the necessary ICS2 library files on his project. The files that he will need is the ICSRXxxT.h header file and ICS2RXxxT.lib or ICS2RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder. For the .lib or .obj files, the user should got to Project properties - Linker - Input and add the library 2)he next step is to prepare the project, in order to generate the map file, that includes all the projects variables and will be uploaded on the RMW tool. To do this check the screenshot below 3) he next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added 4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose. 0x00000000 of RAM is used 5)he next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added n rapprmwinterrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate). 6) The final function that should be used is the ics2watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called. After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel. Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application. Suitable Products ??? ?? ??? ??","['The image shows a screenshot of the Visual Studio 2019 IDE, with the ""Settings"" window open. The window is divided into two main sections: the left side, which lists various settings categories, and the right side, which displays the selected category\'s settings.\n\n*   **Left Side:**\n    *   The left side of the window is a list of settings categories, including:\n        *   Resource\n        *   Builders\n        *   C/C++ Build\n        *   Build Variables\n        *   Environment\n        *   Logging\n        *   Settings\n        *   Tool Chain Editor\n        *   C/C++ General\n        *   Project Natures\n        *   Project References\n        *   Renesas QE\n        *   Run/Debug Settings\n        *   task Tags\n        *   Validation\n*   **Right Side:**\n    *   The right side of the window displays the selected category\'s settings. In this case, the ""Settings"" category is selected, and the following settings are displayed:\n        *   Tool Settings\n        *   Common\n        *   CPU\n        *   PIC/PID\n        *   Miscellaneous\n        *   Compiler\n        *   Source\n        *   Advanced\n        *   Object\n        *   List\n        *   Optimization\n        *   Advanced\n        *   Output\n        *   MISRA C Rule Check\n        *   Miscellaneous\n        *   User\n        *   Assembler\n        *   Source\n        *   Object\n        *   List\n        *   Optimization\n        *   Miscellaneous\n        *   User\n        *   Linker\n        *   Input\n        *   Advanced\n        *   Output\n        *   Advanced\n        *   List\n        *   Optimization\n        *   Section\n        *   Symbol file\n        *   Advanced\n        *   Subcommand file\n        *   Miscellaneous\n*   **Additional Features:**\n    *   The top-right corner of the window has a dropdown menu with options to manage configurations.\n    *   The bottom-right corner of the window has a button to apply the changes.\n\nOverall, the image shows a comprehensive settings window in Visual Studio 2019, allowing users to customize various aspects of their development environment.', 'The image shows a screenshot of the Visual Studio 2019 settings window, with the ""User-defined options"" section highlighted. The window is divided into two main sections: the left side, which lists various settings categories, and the right side, which displays the selected category\'s options.\n\n**Left Side:**\n\n*   The left side of the window features a vertical list of settings categories, including:\n    *   Resource\n    *   Builders\n    *   C/C++ Build\n    *   Build Variables\n    *   Environment\n    *   Logging\n    *   Settings\n    *   Tool Settings\n    *   Common\n    *   Compiler\n    *   Assembler\n    *   Linker\n    *   Input\n    *   Advanced\n    *   Output\n    *   Advanced\n    *   List\n    *   Optimization\n    *   Section\n    *   Symbol file\n    *   Advanced\n    *   Subcommand file\n    *   Miscellaneous\n    *   User\n    *   Library Generator\n    *   Converter\n    *   Output\n    *   Hex format\n    *   CRC Operation\n    *   Miscellaneous\n    *   User\n\n**Right Side:**\n\n*   The right side of the window displays the selected category\'s options. In this case, the ""User-defined options"" category is highlighted, and the ""Show=Symbol,struct"" option is selected.\n*   Below the selected option, there is a text box labeled ""User-defined options (added after all specified options)"". This text box allows users to enter custom options that will be added to the existing options.\n*   At the bottom of the window, there are several buttons, including:\n    *   Apply and Close\n    *   Cancel\n\n**Summary:**\n\nThe image shows a screenshot of the Visual Studio 2019 settings window, with the ""User-defined options"" section highlighted. The left side of the window lists various settings categories, while the right side displays the selected category\'s options. The user can select custom options to be added to the existing options in the ""User-defined options"" category.', 'The image shows a screenshot of a computer screen displaying a code editor with a large block of code in the center. The code is written in C++ and appears to be a part of a larger program.\n\n*   The code is written in a dark gray background with white text, making it easy to read.\n*   The code is divided into sections, each with its own set of variables and functions.\n*   The code includes several comments, which are denoted by the ""//"" symbol.\n*   The code also includes several error messages, which are displayed in red text.\n*   The code is surrounded by a red box, which highlights a specific section of the code.\n*   The code is displayed in a code editor window, which has a menu bar at the top and a toolbar on the left side.\n*   The code editor window is open on a computer screen, which has a gray background.\n\nOverall, the image suggests that the user is working on a complex program in C++ and is using a code editor to write and debug the code. The error messages and comments in the code indicate that the user is experiencing some issues with the program, but the red box highlighting a specific section of the code suggests that the user is trying to identify and fix the problem.', 'The image shows a screenshot of a computer screen with a window open, displaying a list of settings and options. The window is titled ""Properties for KCZBT_RMW"" and has a gray background with white text.\n\n*   **Window Title**\n    *   The window title is ""Properties for KCZBT_RMW"".\n*   **Settings List**\n    *   The settings list is displayed on the left side of the window.\n    *   It includes various options such as ""Resource"", ""Builders"", ""C/C++ Build"", ""Environment"", ""Logging"", ""Settings"", ""Tool Chain Editor"", ""C/C++ General"", ""Project References"", ""Releases"", ""Run/Debug Settings"", ""Task Tags"", and ""Validation"".\n*   **Section Selection**\n    *   A red box highlights the ""Optimization"" section in the settings list.\n*   **Section Details**\n    *   The ""Optimization"" section has several sub-options, including ""Optimization"", ""Section"", ""Symbol File"", ""Advanced"", ""Subcommand file"", ""Miscellaneous"", ""User"", ""Library Generator"", ""Mode"", ""Standard Library"", ""Object"", ""Optimization"", ""Advanced"", ""Miscellaneous"", ""User"", ""Converter"", ""Output"", ""Text Format"", ""CRC Operation"", and ""Miscellaneous"".\n*   **Section Viewer**\n    *   A red box highlights the ""Section Viewer"" window, which is located on the right side of the main window.\n    *   The ""Section Viewer"" window displays the contents of the selected section, including the ""Optimization"" section.\n*   **Button Bar**\n    *   A button bar is located at the bottom of the window, with options such as ""Apply and Close"", ""Cancel"", and ""OK"".\n*   **Menu Bar**\n    *   A menu bar is located at the top of the window, with options such as ""File"", ""Edit"", ""View"", ""Tools"", and ""Help"".\n\nOverall, the image shows a screenshot of a computer screen with a window open, displaying a list of settings and options. The window is titled ""Properties for KCZBT_RMW"" and has a gray background with white text. The settings list includes various options, and a red box highlights the ""Optimization"" section. The ""Section Viewer"" window displays the contents of the selected section, and a button bar is located at the bottom of the window with options such as ""Apply and Close"", ""Cancel"", and ""OK"". A menu bar is also located at the top of the window with options such as ""File"", ""Edit"", ""View"", ""Tools"", and ""Help"".', 'The image shows a screenshot of a computer file directory, with a red rectangle highlighting a specific folder. The folder is labeled ""r_app_rmw_interrupt.c"" and contains two subfolders: ""r_app_rmw.c"" and ""r_app_rmw.h"". \n\nThe background of the image is dark gray, with a lighter gray text and icons. The overall atmosphere suggests a technical or programming-related context, possibly related to software development or coding.', 'The image shows a screenshot of an oscilloscope software interface, with a waveform displayed on the screen. The waveform is a red line that oscillates between positive and negative values, with a frequency of approximately 1 Hz. The waveform is displayed on a black background with a grid pattern, and there are various buttons and menus along the top and right side of the screen.\n\n*   **Waveform:**\n    *   The waveform is a red line that oscillates between positive and negative values.\n    *   The frequency of the waveform is approximately 1 Hz.\n    *   The waveform is displayed on a black background with a grid pattern.\n*   **Buttons and Menus:**\n    *   There are various buttons and menus along the top and right side of the screen.\n    *   The buttons and menus appear to be used for controlling the oscilloscope and analyzing the waveform.\n    *   Some of the buttons and menus include ""Main"", ""Zoom"", ""Save"", ""Load"", ""All"", ""Double"", ""Scope Capture"", ""Acquiring Data"", ""Channel"", ""Length"", ""Run"", ""Graph Setting"", ""Smoothing"", ""Channel Setting"", and ""Set Color"".\n*   **Background:**\n    *   The background of the image is a light gray color.\n    *   The background is plain and does not have any patterns or textures.\n\nOverall, the image shows a screenshot of an oscilloscope software interface, with a waveform displayed on the screen. The waveform is a red line that oscillates between positive and negative values, and there are various buttons and menus along the top and right side of the screen. The background of the image is a light gray color.', 'The image shows a screenshot of a computer program, likely a software interface for a device or system. The program is titled ""Reanes Motor Revision"" and has a gray background with white text and buttons.\n\n*   **Title Bar**\n    *   The title bar at the top of the window displays the program\'s name, ""Reanes Motor Revision,"" in black text.\n    *   There are several buttons on the title bar, including ""File,"" ""Option,"" and ""Help.""\n*   **Menu Bar**\n    *   Below the title bar is a menu bar with several options, including ""Connection,"" ""Configuration,"" and ""Project File Path.""\n    *   Each menu option has a dropdown menu with additional sub-options.\n*   **Main Window**\n    *   The main window is divided into two sections: a left-hand column and a right-hand column.\n    *   The left-hand column contains several buttons and fields, including ""COM,"" ""Status,"" ""Connect - USB Serial Port,"" ""CPU,"" ""Motor Type,"" ""Control,"" and ""Inverter.""\n    *   The right-hand column contains a single field labeled ""File Information"" with a dropdown menu and a button labeled ""Select Tool.""\n*   **Buttons**\n    *   There are several buttons throughout the window, including ""Clock,"" ""RMT File,"" ""Map File,"" ""Easy,"" and ""Analyzer.""\n    *   Some buttons have dropdown menus or additional options.\n*   **Fields**\n    *   There are several fields throughout the window, including ""COM,"" ""Status,"" ""Connect - USB Serial Port,"" ""CPU,"" ""Motor Type,"" ""Control,"" and ""Inverter.""\n    *   Some fields have dropdown menus or additional options.\n\nOverall, the image suggests that the program is used for configuring and controlling a device or system, possibly related to motor control or automation. The various menus and fields provide options for setting up connections, configuring settings, and selecting tools or files.', 'The image shows a screenshot of a computer program, specifically a user setting form. The form is titled ""User Setting Form"" and has a gray background with black text. \n\n*   The form has several fields, including:\n    *   **Address**: This field contains a hexadecimal value, which appears to be a memory address.\n    *   **Name**: This field contains a string value, which is the name of the variable or object being referenced.\n    *   **DataType**: This field contains a string value, which indicates the data type of the variable or object being referenced.\n    *   **Value**: This field contains a string value, which is the actual value of the variable or object being referenced.\n\nThe form also has a button labeled ""Set"" and a dropdown menu labeled ""Date Modified"". The dropdown menu contains a list of dates, which appear to be the dates when the variable or object was last modified.\n\nOverall, the image suggests that the user setting form is used to configure settings for a program or application, and that the form is displaying information about variables or objects that are being used by the program.', 'The image shows a screenshot of a computer screen displaying a list of files and folders in a file explorer window. The list is organized in a hierarchical structure, with folders and subfolders nested within each other.\n\nThe top-level folder is labeled ""RX26T_RMW"" and contains several subfolders, including ""HardwareDebug"", ""src"", and ""Includes"". The ""HardwareDebug"" folder contains a single file named ""HardwareDebug.c"", while the ""src"" folder contains multiple files with names such as ""RX26T_RMW_abs.c"" and ""RX26T_RMW_x.c"".\n\nThe ""Includes"" folder contains a single file named ""RX26T_RMW.h"". The background of the image is a dark gray color, which helps to highlight the text and icons in the file explorer window.\n\nOverall, the image appears to be a screenshot of a computer screen displaying a list of files and folders related to a specific project or software development environment. The presence of files with names such as ""HardwareDebug.c"" and ""RX26T_RMW.h"" suggests that the project may be related to embedded systems or microcontroller programming.']"
50f645c4fbf9c072a2663f78c6fa169c,"Question:
What are the differences within the RX23E-B group?
Answer:
The RX23E-B are 32-bit microcontrollers with built-in high-speed, high-precision 24-bit Δ-ΣA/D converters, and the data rate and analog input voltage range of the 24-bit Δ-ΣA/D converters differ depending on the part number. Refer to the table below for details.
  Suitable Products
RX23E-B
What are the differences within the RX23E-B group?
What are the differences within the RX23E-B group?
Answer:
The RX23E-B are 32-bit microcontrollers with built-in high-speed, high-precision 24-bit Δ-ΣA/D converters, and the data rate and analog input voltage range of the 24-bit Δ-ΣA/D converters differ depending on the part number. Refer to the table below for details.
  Suitable Products
RX23E-B
The RX23E-B are 32-bit microcontrollers with built-in high-speed, high-precision 24-bit Δ-ΣA/D converters, and the data rate and analog input voltage range of the 24-bit Δ-ΣA/D converters differ depending on the part number. Refer to the table below for details.
The RX23E-B are 32-bit microcontrollers with built-in high-speed, high-precision 24-bit Δ-ΣA/D converters, and the data rate and analog input voltage range of the 24-bit Δ-ΣA/D converters differ depending on the part number. Refer to the table below for details.
Suitable Products
RX23E-B
日本語 中文
日本語
中文",['data/categories/rx_family/rx23e-b/50f645c4fbf9c072a2663f78c6fa169c/images/a2be97e31fafcbaa6af81b108eae8786.png'],[],['|  |\n|  |\n| RX23E-B |'],"{'title': 'Differences within the RX23E-B group', 'url': 'https://en-support.renesas.com/knowledgeBase/21106543', 'last_updated': None, 'extracted_at': '2025-03-09T00:04:36.965732'}","Question What are the differences within the RX23E-B group? Answer The RX23E-B are 32-bit microcontrollers with built-in high-speed, high-precision 24-bit -A/D converters, and the data rate and analog input voltage range of the 24-bit -A/D converters differ depending on the part number. Refer to the table below for details. Suitable Products RX23E-B Suitable Products    ","[""The image presents a table detailing the specifications of a device, likely a computer component or peripheral. The table is divided into several columns and rows, each containing specific information about the device.\n\n*   **Device Specifications**\n    *   **CPU:** RX v2 core 32MHz\n    *   **ROM/RAM:** 256kB/32kB, 128kB/16kB\n    *   **Operating Temperature:** -40 to 85°C, -40 to 105°C\n*   **ΔΣADC Data Rate**\n    *   **Analog Input Voltage**\n        *   +/-10V & 5V\n    *   **No Segment LCD Controller**\n        *   5V 2ch +/-10V 2ch\n        *   5V 4ch +/-10V 2ch\n        *   5V 6ch\n        *   5V 8ch\n    *   **Segment LCD Controller**\n        *   5V 8ch +/-10V 2ch LCDC\n        *   5V 8ch LCDC\n        *   5V 8ch LCDC\n        *   5V 8ch LCDC\n*   **PKG**\n    *   40pinQFN (6mm)\n    *   48pinQFP (7mm)\n    *   64pinQFP (10mm)\n    *   80pinQFP (12mm)\n    *   100pinQFP (14mm)\n    *   100pinBGA (5.5mm)\n\nThe table provides a comprehensive overview of the device's specifications, including its CPU, ROM/RAM, operating temperature, analog input voltage, and packaging options. This information can be useful for engineers, designers, or anyone looking to understand the capabilities and limitations of this device.""]"
b373bb4b6a72b3206cd5572f6b4a8cb4,"Question:
What are the differences between the RX23E-B and RX23E-A?
Answer:
The data rate and noise performance of the 24-bit Δ-ΣA/D converters and the number of them built in differ between the RX23E-B and RX23E-A. The Δ-ΣA/D converters of the RX23E-B have the high speed performance and noise performance enhanced from those of the RX23E-A. The Δ-ΣA/D converters of the RX23E-B support a maximum of 125 kSPS, which is eight times faster than that of the RX23E-A.. The RMS noise performance is also reduced from that of the RX23E-A to about a 1/3. Other differences are that a 16-bit D/A converter and +/-10 V analog input are newly incorporated from the RX23E-B.
Also refer to the table below for details.
Suitable Products
RX23E-B
What are the differences between the RX23E-B and RX23E-A?
What are the differences between the RX23E-B and RX23E-A?
Answer:
The data rate and noise performance of the 24-bit Δ-ΣA/D converters and the number of them built in differ between the RX23E-B and RX23E-A. The Δ-ΣA/D converters of the RX23E-B have the high speed performance and noise performance enhanced from those of the RX23E-A. The Δ-ΣA/D converters of the RX23E-B support a maximum of 125 kSPS, which is eight times faster than that of the RX23E-A.. The RMS noise performance is also reduced from that of the RX23E-A to about a 1/3. Other differences are that a 16-bit D/A converter and +/-10 V analog input are newly incorporated from the RX23E-B.
Also refer to the table below for details.
Suitable Products
RX23E-B
The data rate and noise performance of the 24-bit Δ-ΣA/D converters and the number of them built in differ between the RX23E-B and RX23E-A. The Δ-ΣA/D converters of the RX23E-B have the high speed performance and noise performance enhanced from those of the RX23E-A. The Δ-ΣA/D converters of the RX23E-B support a maximum of 125 kSPS, which is eight times faster than that of the RX23E-A.. The RMS noise performance is also reduced from that of the RX23E-A to about a 1/3. Other differences are that a 16-bit D/A converter and +/-10 V analog input are newly incorporated from the RX23E-B.
Also refer to the table below for details.
Suitable Products
RX23E-B
日本語 中文
日本語
中文",['data/categories/rx_family/rx23e-b/b373bb4b6a72b3206cd5572f6b4a8cb4/images/5b5aeefbea0f8d40e47d3d76a3f967b0.png'],[],['|  |\n|  |\n| RX23E-B |'],"{'title': 'Differences within the RX23E series', 'url': 'https://en-support.renesas.com/knowledgeBase/21106546', 'last_updated': None, 'extracted_at': '2025-03-09T00:04:39.619815'}","Question What are the differences between the RX23E-B and RX23E-A? Answer The data rate and noise performance of the 24-bit -A/D converters and the number of them built in differ between the RX23E-B and RX23E-A. The -A/D converters of the RX23E-B have the high speed performance and noise performance enhanced from those of the RX23E-A. The -A/D converters of the RX23E-B support a maximum of 125 kSPS, which is eight times faster than that of the RX23E-A.. The RMS noise performance is also reduced from that of the RX23E-A to about a 1/3. Other differences are that a 16-bit D/A converter and /-10 V analog input are newly incorporated from the RX23E-B. Also refer to the table below for details. Suitable Products RX23E-B    ","['The image presents a table comparing the specifications of two A/D converters, RX23E-A and RX23E-B. The table is divided into two columns, with the left column listing the specifications and the right column providing the corresponding values for each converter.\n\n**Specifications:**\n\n* Data rate (Max)\n* Number of units\n\n**RX23E-A Specifications:**\n\n* Data rate (Max): 125kSPS, 31.25kSPS, 15.6kSPS\n* Number of units: 1, 2, 1\n\n**RX23E-B Specifications:**\n\n* Data rate (Max): 40pin QFN, 48pin QFP, 40pin QFN, 48pin QFP, 64pin QFP, 80pin QFP, 100pin QFP, 100pin BGA\n* Number of units: 1, 1, 1, 1, 1, 1, 1, 1\n\n**Key Observations:**\n\n* RX23E-A has a lower data rate compared to RX23E-B.\n* RX23E-A has a lower number of units compared to RX23E-B.\n* RX23E-B has a wider range of data rates and pin configurations.\n\n**Conclusion:**\n\nThe table provides a clear comparison of the specifications of RX23E-A and RX23E-B. RX23E-A has a lower data rate and number of units, while RX23E-B has a wider range of data rates and pin configurations. This suggests that RX23E-B may be more suitable for applications that require higher data rates and more flexible pin configurations.']"
96c5bd114fd602960522608adb7f0495,"Question:
During normal read operation on a separate bus, why is one cycle of the CS signal negation period inserted even though the insertion of read recovery cycles is disabled?
Answer:
During normal read operation on a separate bus, if CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted even if no read recovery cycle is inserted.
This is because when CSnWCR2.CSROFF[2:0] = 000b, the next bus access can start one cycle after “Tend” in the diagram below.
The following explains the operation using the example of ""Figure 16.19 Bus Timing (Normal-Read Operation)"" in the ""RX64M Group User's Manual: Hardware"" as an example.
[CSnWCR2.CSROFF[2:0] setting and next bus access start timing]
Note 1 in the diagram shows that when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend"" in the diagram.
Furthermore, when CSnWCR2.CSROFF[2:0] = 001b, ""Tn1"" is inserted in the diagram, the next bus access can begin.
In other words, if CSnWCR2.CSROFF[2:0] = 000b or CSnWCR2.CSROFF[2:0] = 001b, in both cases the next bus access can start one cycle after ""Tend"".
[Regarding Separate Bus Read Recovery Cycle when CSnWCR2.CSROFF[2:0]=000b]
When not inserting Separate Bus Read Recovery Cycle
As explained above, when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend."" When inserting N cycles (1 or more) of Separate Bus Read Recovery Cycle
When CSnWCR2.CSROFF[2:0] = 000b, the bus access disable period of 1 cycle according to Note 1 in the above figure is ensured by the N cycles set for the read recovery cycle, so an N-cycle CS negate period is inserted.
[Separate Bus Read Recovery Cycle for when CSnWCR2.CSROFF[2:0] >= 001b]
If CSnWCR2.CSROFF[2:0] >= 001b, a read recovery cycle is inserted starting with the next cycle from Tn1 to Tnm.
Suitable Products
RX Family
During normal read operation on a separate bus, why is one cycle of the CS signal negation period inserted even though the insertion of read recovery cycles is disabled?
During normal read operation on a separate bus, why is one cycle of the CS signal negation period inserted even though the insertion of read recovery cycles is disabled?
Answer:
During normal read operation on a separate bus, if CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted even if no read recovery cycle is inserted.
This is because when CSnWCR2.CSROFF[2:0] = 000b, the next bus access can start one cycle after “Tend” in the diagram below.
The following explains the operation using the example of ""Figure 16.19 Bus Timing (Normal-Read Operation)"" in the ""RX64M Group User's Manual: Hardware"" as an example.
[CSnWCR2.CSROFF[2:0] setting and next bus access start timing]
Note 1 in the diagram shows that when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend"" in the diagram.
Furthermore, when CSnWCR2.CSROFF[2:0] = 001b, ""Tn1"" is inserted in the diagram, the next bus access can begin.
In other words, if CSnWCR2.CSROFF[2:0] = 000b or CSnWCR2.CSROFF[2:0] = 001b, in both cases the next bus access can start one cycle after ""Tend"".
[Regarding Separate Bus Read Recovery Cycle when CSnWCR2.CSROFF[2:0]=000b]
When not inserting Separate Bus Read Recovery Cycle
As explained above, when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend."" When inserting N cycles (1 or more) of Separate Bus Read Recovery Cycle
When CSnWCR2.CSROFF[2:0] = 000b, the bus access disable period of 1 cycle according to Note 1 in the above figure is ensured by the N cycles set for the read recovery cycle, so an N-cycle CS negate period is inserted.
[Separate Bus Read Recovery Cycle for when CSnWCR2.CSROFF[2:0] >= 001b]
If CSnWCR2.CSROFF[2:0] >= 001b, a read recovery cycle is inserted starting with the next cycle from Tn1 to Tnm.
Suitable Products
RX Family
During normal read operation on a separate bus, if CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted even if no read recovery cycle is inserted.
This is because when CSnWCR2.CSROFF[2:0] = 000b, the next bus access can start one cycle after “Tend” in the diagram below.
The following explains the operation using the example of ""Figure 16.19 Bus Timing (Normal-Read Operation)"" in the ""RX64M Group User's Manual: Hardware"" as an example.
[CSnWCR2.CSROFF[2:0] setting and next bus access start timing]
Note 1 in the diagram shows that when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend"" in the diagram.
Furthermore, when CSnWCR2.CSROFF[2:0] = 001b, ""Tn1"" is inserted in the diagram, the next bus access can begin.
In other words, if CSnWCR2.CSROFF[2:0] = 000b or CSnWCR2.CSROFF[2:0] = 001b, in both cases the next bus access can start one cycle after ""Tend"".
[Regarding Separate Bus Read Recovery Cycle when CSnWCR2.CSROFF[2:0]=000b]
When not inserting Separate Bus Read Recovery Cycle
As explained above, when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend."" When inserting N cycles (1 or more) of Separate Bus Read Recovery Cycle
When CSnWCR2.CSROFF[2:0] = 000b, the bus access disable period of 1 cycle according to Note 1 in the above figure is ensured by the N cycles set for the read recovery cycle, so an N-cycle CS negate period is inserted.
[Separate Bus Read Recovery Cycle for when CSnWCR2.CSROFF[2:0] >= 001b]
If CSnWCR2.CSROFF[2:0] >= 001b, a read recovery cycle is inserted starting with the next cycle from Tn1 to Tnm.
During normal read operation on a separate bus, if CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted even if no read recovery cycle is inserted.
This is because when CSnWCR2.CSROFF[2:0] = 000b, the next bus access can start one cycle after “Tend” in the diagram below.
The following explains the operation using the example of ""Figure 16.19 Bus Timing (Normal-Read Operation)"" in the ""RX64M Group User's Manual: Hardware"" as an example.
[CSnWCR2.CSROFF[2:0] setting and next bus access start timing]
Note 1 in the diagram shows that when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend"" in the diagram.
Furthermore, when CSnWCR2.CSROFF[2:0] = 001b, ""Tn1"" is inserted in the diagram, the next bus access can begin.
In other words, if CSnWCR2.CSROFF[2:0] = 000b or CSnWCR2.CSROFF[2:0] = 001b, in both cases the next bus access can start one cycle after ""Tend"".
[Regarding Separate Bus Read Recovery Cycle when CSnWCR2.CSROFF[2:0]=000b]
When not inserting Separate Bus Read Recovery Cycle
As explained above, when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend."" When inserting N cycles (1 or more) of Separate Bus Read Recovery Cycle
When CSnWCR2.CSROFF[2:0] = 000b, the bus access disable period of 1 cycle according to Note 1 in the above figure is ensured by the N cycles set for the read recovery cycle, so an N-cycle CS negate period is inserted.
[Separate Bus Read Recovery Cycle for when CSnWCR2.CSROFF[2:0] >= 001b]
If CSnWCR2.CSROFF[2:0] >= 001b, a read recovery cycle is inserted starting with the next cycle from Tn1 to Tnm.
Suitable Products
RX Family
Japanese
Japanese",['data/categories/rx_family/external_bus/96c5bd114fd602960522608adb7f0495/images/74f890308b8213a5e46e8fb52f29d0c9.png'],[],['|  |\n|  |\n| RX Family |'],"{'title': 'RX Family: Why is one cycle of the CS signal negation period inserted even though the insertion of read recovery is disabled?', 'url': 'https://en-support.renesas.com/knowledgeBase/21810950', 'last_updated': None, 'extracted_at': '2025-03-09T00:13:40.609559'}","Question During normal read operation on a separate bus, why is one cycle of the CS signal negation period inserted even though the insertion of read recovery cycles is disabled? Answer During normal read operation on a separate bus, if CSnWCR2.CSROFF20  000b, a one-cycle bus access disable period (CS negation period) is inserted even if no read recovery cycle is inserted. This is because when CSnWCR2.CSROFF20  000b, the next bus access can start one cycle after Tend in the diagram below. The following explains the operation using the example of ""Figure 16.19 Bus Timing (Normal-Read Operation)"" in the ""RX64M Group User's Manual Hardware"" as an example. CSnWCR2.CSROFF20 setting and next bus access start timing Note 1 in the diagram shows that when CSnWCR2.CSROFF20  000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend"" in the diagram. Furthermore, when CSnWCR2.CSROFF20  001b, ""Tn1"" is inserted in the diagram, the next bus access can begin. In other words, if CSnWCR2.CSROFF20  000b or CSnWCR2.CSROFF20  001b, in both cases the next bus access can start one cycle after ""Tend"". Regarding Separate Bus Read Recovery Cycle when CSnWCR2.CSROFF20000b When not inserting Separate Bus Read Recovery Cycle As explained above, when CSnWCR2.CSROFF20  000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend."" When inserting N cycles (1 or more) of Separate Bus Read Recovery Cycle When CSnWCR2.CSROFF20  000b, the bus access disable period of 1 cycle according to Note 1 in the above figure is ensured by the N cycles set for the read recovery cycle, so an N-cycle CS negate period is inserted. Separate Bus Read Recovery Cycle for when CSnWCR2.CSROFF20  001b If CSnWCR2.CSROFF20  001b, a read recovery cycle is inserted starting with the next cycle from Tn1 to Tnm. Suitable Products RX Family Japanese","['The image presents a detailed diagram of the bus timing for a computer system, specifically focusing on the normal-read operation. The diagram is divided into two main sections: the top section illustrates the external bus clock (BCLK) and the bottom section depicts the internal bus timing.\n\n**Top Section: External Bus Clock (BCLK)**\n\n*   The external bus clock (BCLK) is represented by a series of rectangular blocks, each representing a clock cycle.\n*   The clock cycles are labeled with letters (Tw1, Tw2, Twn, Tend, Tn1, and Tnm), indicating the different stages of the bus timing process.\n*   The clock cycles are connected by arrows, showing the flow of data between the different components of the system.\n\n**Bottom Section: Internal Bus Timing**\n\n*   The internal bus timing is represented by a series of horizontal lines, each representing a different component of the system (Address, Chip select, Byte control, Data read, and Data bus).\n*   The lines are labeled with letters (A, CSON, BCm#, RD#, and D), indicating the different stages of the bus timing process.\n*   The lines are connected by arrows, showing the flow of data between the different components of the system.\n\n**Key Points**\n\n*   The diagram highlights the importance of proper bus timing in ensuring the correct operation of the computer system.\n*   The use of arrows and labels helps to clarify the flow of data between the different components of the system.\n*   The diagram provides a detailed understanding of the bus timing process, making it easier to identify potential issues and optimize system performance.\n\n**Conclusion**\n\nIn conclusion, the diagram provides a comprehensive overview of the bus timing process for a computer system. By understanding the different stages of the process and how they interact with each other, system designers and engineers can optimize system performance and ensure reliable operation.']"
f667dac2f8827a3fd660628fb62d3413,"Question:
What is the difference between RX26T products with 64 Kbytes of RAM and those with 48 Kbyte of RAM?
Answer:
The RX26T comes with either 48 Kbytes or 64 Kbytes of RAM. 
Refer to the following for details on the differences between each product. 
For detailed specifications, please refer to the RX26T Group User's Manual: Hardware.
*Mass production of the 48-Kbyte RAM products is scheduled to start in the second half of 2023.
Suitable Products
RX26T
What is the difference between RX26T products with 64 Kbytes of RAM and those with 48 Kbyte of RAM?
What is the difference between RX26T products with 64 Kbytes of RAM and those with 48 Kbyte of RAM?
Answer:
The RX26T comes with either 48 Kbytes or 64 Kbytes of RAM. 
Refer to the following for details on the differences between each product. 
For detailed specifications, please refer to the RX26T Group User's Manual: Hardware.
*Mass production of the 48-Kbyte RAM products is scheduled to start in the second half of 2023.
Suitable Products
RX26T
The RX26T comes with either 48 Kbytes or 64 Kbytes of RAM. 
Refer to the following for details on the differences between each product. 
For detailed specifications, please refer to the RX26T Group User's Manual: Hardware.
*Mass production of the 48-Kbyte RAM products is scheduled to start in the second half of 2023.
The RX26T comes with either 48 Kbytes or 64 Kbytes of RAM. 
Refer to the following for details on the differences between each product.
For detailed specifications, please refer to the RX26T Group User's Manual: Hardware.
*Mass production of the 48-Kbyte RAM products is scheduled to start in the second half of 2023.
Suitable Products
RX26T
日本語 中文
日本語
中文",['data/categories/rx_family/rx26t/f667dac2f8827a3fd660628fb62d3413/images/713f32e6f49f3b394e37e279da8dec8e.png'],[],['|  |\n|  |\n| RX26T |'],"{'title': 'Differences within the RX26T group', 'url': 'https://en-support.renesas.com/knowledgeBase/20938978', 'last_updated': None, 'extracted_at': '2025-03-09T00:06:01.625506'}","Question What is the difference between RX26T products with 64 Kbytes of RAM and those with 48 Kbyte of RAM? Answer The RX26T comes with either 48 Kbytes or 64 Kbytes of RAM. Refer to the following for details on the differences between each product. For detailed specifications, please refer to the RX26T Group User's Manual Hardware. Mass production of the 48-Kbyte RAM products is scheduled to start in the second half of 2023. Suitable Products RX26T Refer to the following for details on the differences between each product.    ","['The image presents a table comparing the specifications of three different microcontrollers: RX26T-RAM48KB, RX26T-RAM64KB, and RX26T-RAM64KB. The table is divided into two columns, with the left column listing the difference points and the right column providing the specifications for each microcontroller.\n\n**Difference Points:**\n\n* Register bank save\n* Code Flash size\n* Code Flash Config\n* RAM w parity\n* Timer\n* Communication\n* Analog\n* Security\n\n**Specifications:**\n\n* **RX26T-RAM48KB:**\n\t+ Register bank save: -\n\t+ Code Flash size: 256KB (120MHz)\n\t+ Code Flash Config: Single\n\t+ RAM w parity: 48KB\n\t+ Timer: 16bit GPT 8ch\n\t+ Communication: SCI 3ch + 1ch(LIN)\n\t+ Analog: 12bit DAC 2ch (as comparator Ref.)\n\t+ Security: TSIP-Lite PKG\n\n* **RX26T-RAM64KB:**\n\t+ Register bank save: Yes(16bank)\n\t+ Code Flash size: 512KB (120MHz)\n\t+ Code Flash Config: Dual\n\t+ RAM w parity: 64KB\n\t+ Timer: 32bit GPT 8ch w/ HRPWM 4ch\n\t+ Communication: 5ch + 1ch(LIN) + 1ch(FIFO)\n\t+ Analog: 2ch (as comparator Ref. & output)\n\t+ Security: Yes\n\n* **RX26T-RAM64KB:**\n\t+ Register bank save: Yes(16bank)\n\t+ Code Flash size: 512KB (120MHz)\n\t+ Code Flash Config: Dual\n\t+ RAM w parity: 64KB\n\t+ Timer: 32bit GPT 8ch w/ HRPWM 4ch\n\t+ Communication: 5ch + 1ch(LIN) + 1ch(FIFO)\n\t+ Analog: 2ch (as comparator Ref. & output)\n\t+ Security: Yes\n\nThe table provides a clear comparison of the specifications between the three microcontrollers, highlighting their differences in terms of register bank save, code flash size, code flash configuration, RAM with parity, timer, communication, analog, and security features.']"
8348c3c45c5165c7e201d965cc7d5f69,"Question:
How do I configure the IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board.
Answer:
The Fast Prototyping board has the onboard JLINK so you will have to use the Segger JLINK GDB Server to this setup.
Configuration options in IAR Embedded Work Bench
    The entry for the TCP/IP Address or hostname[.port] is different that what you expect this entry is using the localhost,port (using a comma to separate the two.)
    Launch the Segger Jlink GDB Server and configure as shown below
Once configured make sure the board is connected to your computer and launch the application by clicking OK.
This Dialog box should appear.  You can select the option to stay on top if you want but it is not needed.
  Suitable Products
R9A02G021
How do I configure the IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board.
How do I configure the IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board.
How do I configure the IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board.
Answer:
The Fast Prototyping board has the onboard JLINK so you will have to use the Segger JLINK GDB Server to this setup.
Configuration options in IAR Embedded Work Bench
    The entry for the TCP/IP Address or hostname[.port] is different that what you expect this entry is using the localhost,port (using a comma to separate the two.)
    Launch the Segger Jlink GDB Server and configure as shown below
Once configured make sure the board is connected to your computer and launch the application by clicking OK.
This Dialog box should appear.  You can select the option to stay on top if you want but it is not needed.
  Suitable Products
R9A02G021
The Fast Prototyping board has the onboard JLINK so you will have to use the Segger JLINK GDB Server to this setup.
Configuration options in IAR Embedded Work Bench
    The entry for the TCP/IP Address or hostname[.port] is different that what you expect this entry is using the localhost,port (using a comma to separate the two.)
    Launch the Segger Jlink GDB Server and configure as shown below
Once configured make sure the board is connected to your computer and launch the application by clicking OK.
This Dialog box should appear.  You can select the option to stay on top if you want but it is not needed.
The Fast Prototyping board has the onboard JLINK so you will have to use the Segger JLINK GDB Server to this setup.
Configuration options in IAR Embedded Work Bench
The entry for the TCP/IP Address or hostname[.port] is different that what you expect this entry is using the localhost,port (using a comma to separate the two.)
localhost,port
Launch the Segger Jlink GDB Server and configure as shown below
Once configured make sure the board is connected to your computer and launch the application by clicking OK.
This Dialog box should appear.  You can select the option to stay on top if you want but it is not needed.
Suitable Products
R9A02G021
R9A02G021
??? ??
???
??","['data/categories/risc-v/kit/8348c3c45c5165c7e201d965cc7d5f69/images/d72ba0492484bb30df711d27bd8d49e8.png', 'data/categories/risc-v/kit/8348c3c45c5165c7e201d965cc7d5f69/images/e3f015e8a2eff7728aad666b59482550.png', 'data/categories/risc-v/kit/8348c3c45c5165c7e201d965cc7d5f69/images/6a74d6cb21fca802623285b86e9ad2d3.png']",[],['|  |\n|  |\n| R9A02G021 |'],"{'title': 'Using IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board', 'url': 'https://en-support.renesas.com/knowledgeBase/21584038', 'last_updated': None, 'extracted_at': '2025-03-09T00:25:10.431117'}","Question How do I configure the IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board. Answer The Fast Prototyping board has the onboard JLINK so you will have to use the Segger JLINK GDB Server to this setup. Configuration options in IAR Embedded Work Bench The entry for the TCP/IP Address or hostname.port is different that what you expect this entry is using the localhost,port (using a comma to separate the two.) Launch the Segger Jlink GDB Server and configure as shown below Once configured make sure the board is connected to your computer and launch the application by clicking OK. This Dialog box should appear. You can select the option to stay on top if you want but it is not needed. Suitable Products R9A02G021 The entry for the TCP/IP Address or hostname.port is different that what you expect this entry is using the localhost,port (using a comma to separate the two.) localhost,port Launch the Segger Jlink GDB Server and configure as shown below Suitable Products ??? ?? ??? ??","['The image shows a screenshot of a computer window with a list of options on the left and a larger section on the right. The title at the top reads ""Options for node \'blinky\'"". \n\n*   The left side of the window has a list of categories, including:\n    *   General Options\n    *   Static Analysis\n    *   C/C++ Compiler\n    *   Assembler\n    *   Output Converter\n    *   Custom Build\n    *   Linker\n    *   Build Actions\n    *   Debugger\n    *   GDB Server\n    *   I-Jet\n    *   Simulator\n    *   Third-Party Driver\n*   The right side of the window has a larger section with several tabs, including:\n    *   Setup\n    *   Download\n    *   Images\n    *   Multicore\n    *   Extra Options\n    *   Plugins\n*   The ""Debugger"" category is selected, and the ""Run to:"" field is set to ""main"".\n*   There are several other fields and options in the window, including:\n    *   Device description file\n    *   Override default\n    *   $TOOLKIT_DIR$\\config\\debugger\\Renesas\\R9A02G021\n\nOverall, the image appears to be a screenshot of a computer program or tool used for debugging or testing purposes. The specific details of the program are not clear from the image alone, but it appears to be related to embedded systems or microcontrollers.', 'The image shows a screenshot of a computer window with a list of options for a node called ""blinky"". The window is titled ""Options for node \'blinky\'"".\n\n*   **Title**\n    *   The title of the window is ""Options for node \'blinky\'"".\n*   **List of Options**\n    *   The list of options includes:\n        *   General Options\n        *   Static Analysis\n        *   C/C++ Compiler\n        *   Assembler\n        *   Output Converter\n        *   Custom Build\n        *   Linker\n        *   Build Actions\n        *   Debugger\n        *   GDB Server\n        *   I-jet\n        *   Simulator\n        *   Third-Party Driver\n*   **Setup Tab**\n    *   The Setup tab is selected and has the following options:\n        *   TCP/IP address or hostname [port]\n        *   localhost:2331\n*   **Log Communication**\n    *   The Log communication checkbox is checked and has the following text: $PROJ_DIR$\\cspycomm.log\n*   **OK and Cancel Buttons**\n    *   There are two buttons at the bottom of the window: OK and Cancel.\n\nThe image shows a screenshot of a computer window with a list of options for a node called ""blinky"". The window is titled ""Options for node \'blinky\'"". The list of options includes General Options, Static Analysis, C/C++ Compiler, Assembler, Output Converter, Custom Build, Linker, Build Actions, Debugger, GDB Server, I-jet, Simulator, and Third-Party Driver. The Setup tab is selected and has the following options: TCP/IP address or hostname [port] and localhost:2331. The Log communication checkbox is checked and has the following text: $PROJ_DIR$\\cspycomm.log. There are two buttons at the bottom of the window: OK and Cancel.', 'The image shows a screenshot of a computer window with a gray background and black text. The window is titled ""SEGGER J-Link GDB Server V7.98h Config"" and has a blue logo in the top-left corner.\n\nThe window is divided into several sections, each with its own set of options and settings. The sections are:\n\n* **Connection to J-Link**: This section allows the user to select the connection method for the J-Link device. The options include USB, SN/Nickname, and TCP/IP.\n* **Target device**: This section allows the user to select the target device for the J-Link device. The options include R9A02G021 and Little Endian.\n* **Flash banks**: This section allows the user to select the flash banks for the J-Link device. The options include BaseAddr, Name, Loader, 0x00000000, Code Flash, Default, 0x01010008, Config Flash, Default, and 0x40100000, Data Flash, Default.\n* **Target interface**: This section allows the user to select the target interface for the J-Link device. The options include JTAG and Speed.\n* **Server settings**: This section allows the user to select the server settings for the J-Link device. The options include Init registers, Localhost only, Generate logfile, GDB port 2, SWO port 2, and Telnet port 2.\n* **Command line option**: This section allows the user to enter a command line option for the J-Link device.\n\nOverall, the image shows a complex configuration window for a J-Link device, with many options and settings available for customization.']"
61beafa427d1d4732b828ea8be2281c6,"Question:
What is the notes on RZ/A1H and RZ/A1M from a software perspective?
Answer:
Since RZ/A1H and RZ/A1M are pin-compatible, Renesas only provides evaluation board and software packages for RZ/A1H and not provides RZ/A1M's one.If you consider RZ/A1M, please use RZ/A1H's one.
(The built-in memory size is different between RZ/A1H and RZ/A1M: RZ/A1H: 10MB, RZ/A1M: 5MB)
However, when using the RZ/A1H software package to evaluate RZ/A1M, please note the following point.
Target RZ/A1H software package: RZ/A1H FreeRTOS™ Software Package
The above RZ/A1H software uses the red frame in the table below as the memory area. 
On the other hand, RZ/A1M can not use the reserved area in the blue frame in the table below.
When using the above software on RZ/A1M, it is possible to use the software as it is by arranging memory that does not use the reserved area in the blue frame above.
Suitable Products
RZ/A1M
What is the notes on RZ/A1H and RZ/A1M from a software perspective?
What is the notes on RZ/A1H and RZ/A1M from a software perspective?
Answer:
Since RZ/A1H and RZ/A1M are pin-compatible, Renesas only provides evaluation board and software packages for RZ/A1H and not provides RZ/A1M's one.If you consider RZ/A1M, please use RZ/A1H's one.
(The built-in memory size is different between RZ/A1H and RZ/A1M: RZ/A1H: 10MB, RZ/A1M: 5MB)
However, when using the RZ/A1H software package to evaluate RZ/A1M, please note the following point.
Target RZ/A1H software package: RZ/A1H FreeRTOS™ Software Package
The above RZ/A1H software uses the red frame in the table below as the memory area. 
On the other hand, RZ/A1M can not use the reserved area in the blue frame in the table below.
When using the above software on RZ/A1M, it is possible to use the software as it is by arranging memory that does not use the reserved area in the blue frame above.
Suitable Products
RZ/A1M
Since RZ/A1H and RZ/A1M are pin-compatible, Renesas only provides evaluation board and software packages for RZ/A1H and not provides RZ/A1M's one.If you consider RZ/A1M, please use RZ/A1H's one.
(The built-in memory size is different between RZ/A1H and RZ/A1M: RZ/A1H: 10MB, RZ/A1M: 5MB)
However, when using the RZ/A1H software package to evaluate RZ/A1M, please note the following point.
Target RZ/A1H software package: RZ/A1H FreeRTOS™ Software Package
The above RZ/A1H software uses the red frame in the table below as the memory area. 
On the other hand, RZ/A1M can not use the reserved area in the blue frame in the table below.
When using the above software on RZ/A1M, it is possible to use the software as it is by arranging memory that does not use the reserved area in the blue frame above.
Since RZ/A1H and RZ/A1M are pin-compatible, Renesas only provides evaluation board and software packages for RZ/A1H and not provides RZ/A1M's one.If you consider RZ/A1M, please use RZ/A1H's one.
(The built-in memory size is different between RZ/A1H and RZ/A1M: RZ/A1H: 10MB, RZ/A1M: 5MB)
However, when using the RZ/A1H software package to evaluate RZ/A1M, please note the following point.
Target RZ/A1H software package: RZ/A1H FreeRTOS™ Software Package
The above RZ/A1H software uses the red frame in the table below as the memory area. 
On the other hand, RZ/A1M can not use the reserved area in the blue frame in the table below.
When using the above software on RZ/A1M, it is possible to use the software as it is by arranging memory that does not use the reserved area in the blue frame above.
Suitable Products
RZ/A1M
日本語 中文
日本語
中文",['data/categories/rz_family/rza/61beafa427d1d4732b828ea8be2281c6/images/1b07bf68123dc56b75639427bd9967b8.png'],[],['|  |\n|  |\n| RZ/A1M |'],"{'title': 'RZ/A1M: Notes on RZ/A1H and RZ/A1M from a software perspective', 'url': 'https://en-support.renesas.com/knowledgeBase/21276790', 'last_updated': None, 'extracted_at': '2025-03-08T23:43:04.810110'}","Question What is the notes on RZ/A1H and RZ/A1M from a software perspective? Answer Since RZ/A1H and RZ/A1M are pin-compatible, Renesas only provides evaluation board and software packages for RZ/A1H and not provides RZ/A1M's one.If you consider RZ/A1M, please use RZ/A1H's one. (The built-in memory size is different between RZ/A1H and RZ/A1M RZ/A1H 10MB, RZ/A1M 5MB) However, when using the RZ/A1H software package to evaluate RZ/A1M, please note the following point. Target RZ/A1H software package RZ/A1H FreeRTOS Software Package The above RZ/A1H software uses the red frame in the table below as the memory area. On the other hand, RZ/A1M can not use the reserved area in the blue frame in the table below. When using the above software on RZ/A1M, it is possible to use the software as it is by arranging memory that does not use the reserved area in the blue frame above. Suitable Products RZ/A1M    ","['The image depicts a table titled ""Address Spaces of On-Chip Large-Capacity RAM"" from Table 53.1. The table is divided into three columns: ""Address,"" ""RZ/A1H,"" and ""RZ/A1M."" The ""Address"" column lists various memory addresses, while the ""RZ/A1H"" and ""RZ/A1M"" columns provide information on the corresponding memory spaces for each address.\n\nThe table includes a note at the bottom, which explains that the RAM of the RZ/A1H is in a two-bank configuration, consisting of bank 0 and bank 1. The RAM of the RZ/A1M is in a one-bank configuration, consisting only of bank 0.\n\nThe table provides a detailed breakdown of the memory spaces for each address, allowing for a clear understanding of how the memory is organized and accessed.']"
3dbde11d28df31639bc8a09f88b73fa3,"Question:
In what combinations can the three Ethernet ports of the RZ/N2L be used?
Answer:
The assignments of the Ethernet/EtherCAT communication ports for the RZ/N2L can be selected in the MODCTRL register. 
The following figure shows the available combinations.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode
26.2.2 MODCTRL: Mode Control Register in RZ/N2L Group User’s Manual: Hardware (r01uh0955ej0110-rzn2l)
Suitable Products
RZ/N2L
In what combinations can the three Ethernet ports of the RZ/N2L be used?
In what combinations can the three Ethernet ports of the RZ/N2L be used?
Answer:
The assignments of the Ethernet/EtherCAT communication ports for the RZ/N2L can be selected in the MODCTRL register. 
The following figure shows the available combinations.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode
26.2.2 MODCTRL: Mode Control Register in RZ/N2L Group User’s Manual: Hardware (r01uh0955ej0110-rzn2l)
Suitable Products
RZ/N2L
The assignments of the Ethernet/EtherCAT communication ports for the RZ/N2L can be selected in the MODCTRL register. 
The following figure shows the available combinations.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode
26.2.2 MODCTRL: Mode Control Register in RZ/N2L Group User’s Manual: Hardware (r01uh0955ej0110-rzn2l)
The assignments of the Ethernet/EtherCAT communication ports for the RZ/N2L can be selected in the MODCTRL register. 
The following figure shows the available combinations.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode
26.2.2 MODCTRL: Mode Control Register in RZ/N2L Group User’s Manual: Hardware (r01uh0955ej0110-rzn2l)
Suitable Products
RZ/N2L
Go to Japanese Go to Chinese
Go to Japanese
Go to Chinese",['data/categories/rz_family/rzn2l/3dbde11d28df31639bc8a09f88b73fa3/images/008031755259d543c144b56c9b0ceb79.png'],[],['|  |\n|  |\n| RZ/N2L |'],"{'title': 'In what combinations can the three Ethernet ports of the RZ/N2L be used?', 'url': 'https://en-support.renesas.com/knowledgeBase/20612313', 'last_updated': '2022-09-08', 'extracted_at': '2025-03-08T23:46:50.122557'}","Question In what combinations can the three Ethernet ports of the RZ/N2L be used? Answer The assignments of the Ethernet/EtherCAT communication ports for the RZ/N2L can be selected in the MODCTRL register. The following figure shows the available combinations. For details, refer to the following items. Table 26.4 MAC-PHY interface mode 26.2.2 MODCTRL Mode Control Register in RZ/N2L Group Users Manual Hardware (r01uh0955ej0110-rzn2l) Suitable Products RZ/N2L Go to Japanese Go to Chinese Go to Japanese Go to Chinese","['The image presents a table titled ""MAC-PHY interface mode"" with a combination of Ethernet and MAC-PHY interface modes. The table is divided into three columns, each representing a different mode: ETH0, ETH1, and ETH2. The rows list various combinations of Ethernet and MAC-PHY interface modes, with each combination numbered from 0 to 7.\n\n**Table Structure:**\n\n*   **Columns:**\n    *   ETH0\n    *   ETH1\n    *   ETH2\n*   **Rows:**\n    *   Combination 0\n    *   Combination 1\n    *   Combination 2\n    *   Combination 3\n    *   Combination 4\n    *   Combination 5\n    *   Combination 6\n    *   Combination 7\n\n**Content:**\n\n*   Each row lists a specific combination of Ethernet and MAC-PHY interface modes.\n*   The columns indicate the corresponding mode for each combination.\n*   The table provides a clear and organized overview of the different combinations and their corresponding modes.\n\n**Purpose:**\n\n*   The table appears to be used for reference or documentation purposes, providing a quick and easy way to look up specific combinations and their corresponding modes.\n*   It may be used by network administrators or engineers to configure and troubleshoot Ethernet and MAC-PHY interface modes.']"
5b422b7a44c7f9eed559902955806842,"Question:
How do I boot from NOR flash?
Answer:
RZ/T2H and RZ/N2H devices are not capable of booting from NOR flash.
Supported boot modes and mode setting pins (MDx) configurations are described below.
Suitable Products
RZ/T2H, RZ/N2H
How do I boot from NOR flash?
How do I boot from NOR flash?
Answer:
RZ/T2H and RZ/N2H devices are not capable of booting from NOR flash.
Supported boot modes and mode setting pins (MDx) configurations are described below.
Suitable Products
RZ/T2H, RZ/N2H
RZ/T2H and RZ/N2H devices are not capable of booting from NOR flash.
Supported boot modes and mode setting pins (MDx) configurations are described below.
RZ/T2H and RZ/N2H devices are not capable of booting from NOR flash.
Supported boot modes and mode setting pins (MDx) configurations are described below.
Suitable Products
RZ/T2H, RZ/N2H
日本語 中文
日本語
中文",['data/categories/rz_family/rzt2h_rzn2h/5b422b7a44c7f9eed559902955806842/images/9564c55e674ccfa7e25eae893f81e756.png'],[],"['|  |\n|  |\n| RZ/T2H, RZ/N2H |']","{'title': 'RZ/T2H, RZ/N2H: Booting from NOR flash', 'url': 'https://en-support.renesas.com/knowledgeBase/21681478', 'last_updated': '2025-07-02', 'extracted_at': '2025-03-08T23:49:22.219240'}","Question How do I boot from NOR flash? Answer RZ/T2H and RZ/N2H devices are not capable of booting from NOR flash. Supported boot modes and mode setting pins (MDx) configurations are described below. Suitable Products RZ/T2H, RZ/N2H    ","['The image presents a table detailing the mode setting pins for various operating modes in a microcontroller. The table is divided into three columns: ""Mode setting pins,"" ""MD2,"" ""MD1,"" and ""MD0."" The first column lists the different operating modes, including ""Low,"" ""Low,"" ""Low,"" ""High,"" ""Low,"" ""High,"" ""Low,"" ""Low,"" ""High,"" ""High,"" ""High,"" and ""High."" The subsequent columns provide information on the specific settings required for each mode, including the voltage levels and the type of connection (e.g., serial flash, eMMC, or USB).\n\nThe table provides a comprehensive overview of the different operating modes and their corresponding settings, allowing users to easily identify the required settings for each mode. The information is presented in a clear and concise manner, making it easy to understand and reference.']"
811c1c2702f2b6c084ff503d3efa38ed,"Question:
How do I use a PCIe card on the RZT2H-EVB.
Answer:
Using a 5Gbps PCIe NIC (Gen3 1-lane) as an example to explain the procedure, follow the below steps:
Step1: Modify the dts file (r9a09g077m44-dev.dts) to enable PCIe I/F as the root complex port.
Change SEL_ETHSS_PCIE from 1 (ETHSS/default) to 0 (PCIE) and compile the dts file.
Step2: Compile the in-box or out-of-box driver.
For in-box driver, reconfigure Linux kernel to enable it.
Eg. MACHINE=rzt2h-dev bitbake linux-renesas -c menuconfig
For out-of-box driver, use T2H Yocto SDK as the build env. to compile device driver module (*.ko) of the specific PCIe card.
Setup Yocto SDK env: source /opt/poky/3.1.21/environment-setup-aarch64-poky-linux
Modify the macro in Makefile of PCIe card device driver
Eg. BASEDIR, KERNELDIR, DRIVERDIR and etc
Step3: Change the SW setting on T2H-EVB to enable PCIe I/F.
For PCIe RC Configuration (2-port & 1-lane)
Set SW2-8 (OFF) and SW15-1 (ON), SW15-2 (ON), SW15-5~8 (ON)
Step4: Insert PCIe card and power on T2H-EVB.
Step5: Power on T2H-EVB and use lspci to check information about PCI buses in the system and devices connected to them.
lspci output is as following

If lspci utility is not available, check whether PCIe adaptor can be found under /sys/bus/pci/devices (or /sys/bus/pci-express/devices) directory

Step6: Install the PCIe card device driver (*.ko) by insmod command.
Eg. insmod r8126.ko
Now the 5Gbps PCIe NIC is working on T2H-EVB and can be configured by Linux ifconfig command. Utilities (ethtool and iperf3) can be used to set ethernet band (eg. 2.5GBaseT, 5GBaseT and etc) and performance/throughput.
Suitable Products
RZ/T2H
How do I use a PCIe card on the RZT2H-EVB.
How do I use a PCIe card on the RZT2H-EVB.
Answer:
Using a 5Gbps PCIe NIC (Gen3 1-lane) as an example to explain the procedure, follow the below steps:
Step1: Modify the dts file (r9a09g077m44-dev.dts) to enable PCIe I/F as the root complex port.
Change SEL_ETHSS_PCIE from 1 (ETHSS/default) to 0 (PCIE) and compile the dts file.
Step2: Compile the in-box or out-of-box driver.
For in-box driver, reconfigure Linux kernel to enable it.
Eg. MACHINE=rzt2h-dev bitbake linux-renesas -c menuconfig
For out-of-box driver, use T2H Yocto SDK as the build env. to compile device driver module (*.ko) of the specific PCIe card.
Setup Yocto SDK env: source /opt/poky/3.1.21/environment-setup-aarch64-poky-linux
Modify the macro in Makefile of PCIe card device driver
Eg. BASEDIR, KERNELDIR, DRIVERDIR and etc
Step3: Change the SW setting on T2H-EVB to enable PCIe I/F.
For PCIe RC Configuration (2-port & 1-lane)
Set SW2-8 (OFF) and SW15-1 (ON), SW15-2 (ON), SW15-5~8 (ON)
Step4: Insert PCIe card and power on T2H-EVB.
Step5: Power on T2H-EVB and use lspci to check information about PCI buses in the system and devices connected to them.
lspci output is as following

If lspci utility is not available, check whether PCIe adaptor can be found under /sys/bus/pci/devices (or /sys/bus/pci-express/devices) directory

Step6: Install the PCIe card device driver (*.ko) by insmod command.
Eg. insmod r8126.ko
Now the 5Gbps PCIe NIC is working on T2H-EVB and can be configured by Linux ifconfig command. Utilities (ethtool and iperf3) can be used to set ethernet band (eg. 2.5GBaseT, 5GBaseT and etc) and performance/throughput.
Suitable Products
RZ/T2H
Using a 5Gbps PCIe NIC (Gen3 1-lane) as an example to explain the procedure, follow the below steps:
Step1: Modify the dts file (r9a09g077m44-dev.dts) to enable PCIe I/F as the root complex port.
Change SEL_ETHSS_PCIE from 1 (ETHSS/default) to 0 (PCIE) and compile the dts file.
Step2: Compile the in-box or out-of-box driver.
For in-box driver, reconfigure Linux kernel to enable it.
Eg. MACHINE=rzt2h-dev bitbake linux-renesas -c menuconfig
For out-of-box driver, use T2H Yocto SDK as the build env. to compile device driver module (*.ko) of the specific PCIe card.
Setup Yocto SDK env: source /opt/poky/3.1.21/environment-setup-aarch64-poky-linux
Modify the macro in Makefile of PCIe card device driver
Eg. BASEDIR, KERNELDIR, DRIVERDIR and etc
Step3: Change the SW setting on T2H-EVB to enable PCIe I/F.
For PCIe RC Configuration (2-port & 1-lane)
Set SW2-8 (OFF) and SW15-1 (ON), SW15-2 (ON), SW15-5~8 (ON)
Step4: Insert PCIe card and power on T2H-EVB.
Step5: Power on T2H-EVB and use lspci to check information about PCI buses in the system and devices connected to them.
lspci output is as following

If lspci utility is not available, check whether PCIe adaptor can be found under /sys/bus/pci/devices (or /sys/bus/pci-express/devices) directory

Step6: Install the PCIe card device driver (*.ko) by insmod command.
Eg. insmod r8126.ko
Now the 5Gbps PCIe NIC is working on T2H-EVB and can be configured by Linux ifconfig command. Utilities (ethtool and iperf3) can be used to set ethernet band (eg. 2.5GBaseT, 5GBaseT and etc) and performance/throughput.
Using a 5Gbps PCIe NIC (Gen3 1-lane) as an example to explain the procedure, follow the below steps:
Step1: Modify the dts file (r9a09g077m44-dev.dts) to enable PCIe I/F as the root complex port.
Step2: Compile the in-box or out-of-box driver.
Step3: Change the SW setting on T2H-EVB to enable PCIe I/F.
Step4: Insert PCIe card and power on T2H-EVB.
Step5: Power on T2H-EVB and use lspci to check information about PCI buses in the system and devices connected to them.
Step6: Install the PCIe card device driver (*.ko) by insmod command.
Now the 5Gbps PCIe NIC is working on T2H-EVB and can be configured by Linux ifconfig command. Utilities (ethtool and iperf3) can be used to set ethernet band (eg. 2.5GBaseT, 5GBaseT and etc) and performance/throughput.
Suitable Products
RZ/T2H","['data/categories/rz_family/rzt2h_rzn2h/811c1c2702f2b6c084ff503d3efa38ed/images/3aa085b30caeeebb546f8cc3778ca28d.png', 'data/categories/rz_family/rzt2h_rzn2h/811c1c2702f2b6c084ff503d3efa38ed/images/93e8d38e4eca3761adec36088f2fcc3f.png', 'data/categories/rz_family/rzt2h_rzn2h/811c1c2702f2b6c084ff503d3efa38ed/images/4ba37b2b80ff69cd55ee3a80de8ab5bb.png']",[],['|  |\n|  |\n| RZ/T2H |'],"{'title': 'How to Use a PCIe card on the RZT2H-EVB', 'url': 'https://en-support.renesas.com/knowledgeBase/21727836', 'last_updated': None, 'extracted_at': '2025-03-08T23:49:40.104072'}","Question How do I use a PCIe card on the RZT2H-EVB. Answer Using a 5Gbps PCIe NIC (Gen3 1-lane) as an example to explain the procedure, follow the below steps Step1 Modify the dts file (r9a09g077m44-dev.dts) to enable PCIe I/F as the root complex port. Change SELETHSSPCIE from 1 (ETHSS/default) to 0 (PCIE) and compile the dts file. Step2 Compile the in-box or out-of-box driver. For in-box driver, reconfigure Linux kernel to enable it. Eg. MACHINErzt2h-dev bitbake linux-renesas -c menuconfig For out-of-box driver, use T2H Yocto SDK as the build env. to compile device driver module (.ko) of the specific PCIe card. Setup Yocto SDK env source /opt/poky/3.1.21/environment-setup-aarch64-poky-linux Modify the macro in Makefile of PCIe card device driver Eg. BASEDIR, KERNELDIR, DRIVERDIR and etc Step3 Change the SW setting on T2H-EVB to enable PCIe I/F. For PCIe RC Configuration (2-port  1-lane) Set SW2-8 (OFF) and SW15-1 (ON), SW15-2 (ON), SW15-58 (ON) Step4 Insert PCIe card and power on T2H-EVB. Step5 Power on T2H-EVB and use lspci to check information about PCI buses in the system and devices connected to them. lspci output is as following If lspci utility is not available, check whether PCIe adaptor can be found under /sys/bus/pci/devices (or /sys/bus/pci-express/devices) directory Step6 Install the PCIe card device driver (.ko) by insmod command. Eg. insmod r8126.ko Now the 5Gbps PCIe NIC is working on T2H-EVB and can be configured by Linux ifconfig command. Utilities (ethtool and iperf3) can be used to set ethernet band (eg. 2.5GBaseT, 5GBaseT and etc) and performance/throughput. Suitable Products RZ/T2H","[""The image shows a terminal window displaying a list of devices connected to a computer. The list includes:\n\n*   Renesas Technology Corp. Device\n*   Ethernet controller\n*   Realtek Semiconductor Co., Ltd. Device\n\nThe list is displayed in a terminal window with a black background and white text, indicating that the image was captured from a Linux or Unix-based system. The text is displayed in a monospaced font, which is typical of terminal windows.\n\nThe image suggests that the computer is running a Linux or Unix-based operating system and is connected to a network or other devices. The presence of the Ethernet controller and Realtek Semiconductor Co., Ltd. Device suggests that the computer is equipped with a network interface card (NIC) and may be connected to a local area network (LAN) or the internet.\n\nOverall, the image provides a snapshot of the computer's hardware configuration and network connections, which can be useful for troubleshooting or monitoring purposes."", 'The image shows a terminal window with a black background and white text. The text is a series of commands and their outputs, indicating that the user is interacting with the system.\n\nThe first line shows the current working directory, which is `/sys/bus/pci_express/devices/`. The second line shows the output of the command `ls -l /sys/bus/pci_express/devices/total 0`, which lists the files and directories in the current directory. The third line shows the output of the command `lrwxrwxrwx 1 root root 0 Sep 20 10:43 0000:00:00.0:pcie001 -> ...`, which is a symbolic link to a file or directory. The fourth line shows the output of the command `lrwxrwxrwx 1 root root 0 Sep 20 10:43 0000:00:00.0:pcie001 -> ...`, which is another symbolic link to a file or directory. The fifth line shows the output of the command `lrwxrwxrwx 1 root root 0 Sep 20 10:43 0000:00:00.0:pcie010 -> ...`, which is a symbolic link to a file or directory. The sixth line shows the output of the command `root@rzt2h-dev:~#`, which is the prompt indicating that the user is logged in as `root` on the machine `rzt2h-dev`.\n\nOverall, the image suggests that the user is exploring the contents of the `/sys/bus/pci_express/devices/` directory and interacting with the system using various commands.', 'The image shows a screenshot of a terminal window displaying a list of commands and their corresponding output. The commands are written in white text, while the output is displayed in black text. The background of the terminal window is black.\n\nThe commands appear to be related to network configuration and troubleshooting, with some of them displaying error messages or warnings. The output includes information about the network interface, IP addresses, and other technical details.\n\nOverall, the image suggests that the user is trying to troubleshoot or configure a network issue, and the terminal window is providing them with information and error messages to help them diagnose the problem.']"
5048b566c97e05a4aea81eda6f5acb7e,"Question:
What should I do with pins I don't use?
Answer:
Refer to the following chapter in the User’s Manual: Hardware to address unused pins. Note that measures differ depending on the pin.
17.6 Handling of Unused Pins
Suitable Products
RZ/T2H, RZ/N2H
What should I do with pins I don't use?
What should I do with pins I don't use?
Answer:
Refer to the following chapter in the User’s Manual: Hardware to address unused pins. Note that measures differ depending on the pin.
17.6 Handling of Unused Pins
Suitable Products
RZ/T2H, RZ/N2H
Refer to the following chapter in the User’s Manual: Hardware to address unused pins. Note that measures differ depending on the pin.
17.6 Handling of Unused Pins
Refer to the following chapter in the User’s Manual: Hardware to address unused pins. Note that measures differ depending on the pin.
17.6 Handling of Unused Pins
Suitable Products
RZ/T2H, RZ/N2H
日本語 中文
日本語
中文",['data/categories/rz_family/rzt2h_rzn2h/5048b566c97e05a4aea81eda6f5acb7e/images/bfaf8a7d7dc7f14cc870c51726af24d2.png'],[],"['|  |\n|  |\n| RZ/T2H, RZ/N2H |']","{'title': 'RZ/T2H, RZ/N2H: Handling of unused pins', 'url': 'https://en-support.renesas.com/knowledgeBase/21557040', 'last_updated': '2025-07-02', 'extracted_at': '2025-03-08T23:49:19.318848'}","Question What should I do with pins I don't use? Answer Refer to the following chapter in the Users Manual Hardware to address unused pins. Note that measures differ depending on the pin. 17.6 Handling of Unused Pins Suitable Products RZ/T2H, RZ/N2H    ","['The image presents a table with two columns and nine rows, detailing various items and their corresponding pin names and handling instructions. The table is divided into three sections: ""Item,"" ""Pin name,"" and ""Handling."" \n\nThe first section, ""Item,"" lists the following items:\n\n* Clock\n* Debug\n* System\n* ADC12\n* USB\n* PCIE\n* DDRSS\n* Other\n\nThe second section, ""Pin name,"" provides the specific pin names for each item, such as XTAL, EXTAL, EXTCLKIN, TRST#, TCK, TMS, TDI, TDO, RSTOUT#, MDX, BSCANP, AN000 to AN003, AN100 to AN103, AN200 to AN214, AVDDREF_ADC0, AVDDREF_ADC1, AVDDREF_ADC2, USB_QDP, USB_QDM, USB_OTG_ID, USB_VUBUSIN, USB_TXRTUNE, PCIE_REFCLK_P0, PCIE_REFCLK_N0, PCIE_REFCLK_P1, PCIE_REFCLK_N1, PCIE_RXDP_L0, PCIE_RXDN_L0, PCIE_RXDP_L1, PCIE_RXDN_L1, PCIE_TXDP_L0, PCIE_TXDN_L0, PCIE_TXDP_L1, PCIE_TXDN_L1, DDR_DTEST, DDR_ATEST, DDR_RESET_N, DDR_CKA_T, DDR_CKA_C, DDR_CKB_T, DDR_CKB_C, DDR_CKEA1:0, DDR_CKEB1:0, DDR_CSA1:0, DDR_CSB1:0, DDR_CAB5:0, DDR_DQA15:0, DDR_DQB15:0, DDR_DMIA1:0, DDR_DMIB1:0, DDR_DQSA_T1:0, DDR_DQSB_T1:0, DDR_DQSA_C1:0, DDR_DQSB_C1:0\n\nThe third section, ""Handling,"" provides instructions for handling each pin, such as keeping them open or connecting them to specific resistors or VSS.\n\nOverall, the table provides a comprehensive list of items, pin names, and handling instructions, which can be useful for understanding the pin configuration and handling requirements for various components in a system.']"
bda26d0e54eb84cd230f57eead9420df,"Question:
 How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK?
Answer:
To use the USB Ethernet Adapter that works as a CDC-ECM, configure the USB Host CDC and application program by following the steps below.
Step1: Choose the Configuration (by bConfigurationValue) contained the interface class (2: USB_CLASS_COMMUNICATIONS) and subclass (6: USB_CDC_ECM_SUBCLASS). The below log is an example produced by the lsusb utility. The bConfigurationValue is 3 in this example.
Step2: Choose the CDC Communication (2: USB_CLASS_COMMUNICATIONS) and Data (10: USB_CLASS_CDC_DATA) interfaces (by bInterfaceNumber and bAlternateSetting) contained the endpoints for the transaction of BULK-IN/OUT and INTR-IN. The below log is an example produced by lsusb utility. In this case, the bInterfaceNumber & bAlternateSetting are 0 & 0 and 1 & 1 for CDC Comm. and Data interfaces respectively.
Step3: Set no packet filter (0x43: SET_ETHERNET_PACKET_FILTER) to 0x1F.
The filter values are as the following
USB_CDC_PACKET_TYPE_PROMISCUOUS          0x01
USB_CDC_PACKET_TYPE_ALL_MULTICAST       0x02
USB_CDC_PACKET_TYPE_DIRECTED                  0x04
USB_CDC_PACKET_TYPE_BROADCAST               0x08
USB_CDC_PACKET_TYPE_MULTICAST               0x10
Step4: Get the notification of network connection and disconnection through CDC Communication Interface (INTR-IN EP).
USB_CDC_NETWORK_CONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x01, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
USB_CDC_NETWORK_DISCONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x00, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
Step5: Transmit and receive ethernet packets through CDC Data Interface (BULK-IN/OUT EPs).
Besides the above steps, there are several more points to be checked. The 1st one is to allocate USB buffer in non-cache area and the 2nd one is to check USB device enumeration process. Will it just use configuration 0 as default? Or it will check available configurations and choose the proper one. The last one is to make sure with different buffer location for INTR-IN and BULK-IN/OUT EPs. Finally, there are two CDC-ECM dongles (RTL8153 and AX88179A) with verified functionalities on T2M-RSK with FreeRTOS+TCP stack.
Suitable Products
RZ/T2M
How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK?
How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK?
Answer:
To use the USB Ethernet Adapter that works as a CDC-ECM, configure the USB Host CDC and application program by following the steps below.
Step1: Choose the Configuration (by bConfigurationValue) contained the interface class (2: USB_CLASS_COMMUNICATIONS) and subclass (6: USB_CDC_ECM_SUBCLASS). The below log is an example produced by the lsusb utility. The bConfigurationValue is 3 in this example.
Step2: Choose the CDC Communication (2: USB_CLASS_COMMUNICATIONS) and Data (10: USB_CLASS_CDC_DATA) interfaces (by bInterfaceNumber and bAlternateSetting) contained the endpoints for the transaction of BULK-IN/OUT and INTR-IN. The below log is an example produced by lsusb utility. In this case, the bInterfaceNumber & bAlternateSetting are 0 & 0 and 1 & 1 for CDC Comm. and Data interfaces respectively.
Step3: Set no packet filter (0x43: SET_ETHERNET_PACKET_FILTER) to 0x1F.
The filter values are as the following
USB_CDC_PACKET_TYPE_PROMISCUOUS          0x01
USB_CDC_PACKET_TYPE_ALL_MULTICAST       0x02
USB_CDC_PACKET_TYPE_DIRECTED                  0x04
USB_CDC_PACKET_TYPE_BROADCAST               0x08
USB_CDC_PACKET_TYPE_MULTICAST               0x10
Step4: Get the notification of network connection and disconnection through CDC Communication Interface (INTR-IN EP).
USB_CDC_NETWORK_CONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x01, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
USB_CDC_NETWORK_DISCONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x00, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
Step5: Transmit and receive ethernet packets through CDC Data Interface (BULK-IN/OUT EPs).
Besides the above steps, there are several more points to be checked. The 1st one is to allocate USB buffer in non-cache area and the 2nd one is to check USB device enumeration process. Will it just use configuration 0 as default? Or it will check available configurations and choose the proper one. The last one is to make sure with different buffer location for INTR-IN and BULK-IN/OUT EPs. Finally, there are two CDC-ECM dongles (RTL8153 and AX88179A) with verified functionalities on T2M-RSK with FreeRTOS+TCP stack.
Suitable Products
RZ/T2M
To use the USB Ethernet Adapter that works as a CDC-ECM, configure the USB Host CDC and application program by following the steps below.
Step1: Choose the Configuration (by bConfigurationValue) contained the interface class (2: USB_CLASS_COMMUNICATIONS) and subclass (6: USB_CDC_ECM_SUBCLASS). The below log is an example produced by the lsusb utility. The bConfigurationValue is 3 in this example.
Step2: Choose the CDC Communication (2: USB_CLASS_COMMUNICATIONS) and Data (10: USB_CLASS_CDC_DATA) interfaces (by bInterfaceNumber and bAlternateSetting) contained the endpoints for the transaction of BULK-IN/OUT and INTR-IN. The below log is an example produced by lsusb utility. In this case, the bInterfaceNumber & bAlternateSetting are 0 & 0 and 1 & 1 for CDC Comm. and Data interfaces respectively.
Step3: Set no packet filter (0x43: SET_ETHERNET_PACKET_FILTER) to 0x1F.
The filter values are as the following
USB_CDC_PACKET_TYPE_PROMISCUOUS          0x01
USB_CDC_PACKET_TYPE_ALL_MULTICAST       0x02
USB_CDC_PACKET_TYPE_DIRECTED                  0x04
USB_CDC_PACKET_TYPE_BROADCAST               0x08
USB_CDC_PACKET_TYPE_MULTICAST               0x10
Step4: Get the notification of network connection and disconnection through CDC Communication Interface (INTR-IN EP).
USB_CDC_NETWORK_CONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x01, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
USB_CDC_NETWORK_DISCONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x00, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
Step5: Transmit and receive ethernet packets through CDC Data Interface (BULK-IN/OUT EPs).
Besides the above steps, there are several more points to be checked. The 1st one is to allocate USB buffer in non-cache area and the 2nd one is to check USB device enumeration process. Will it just use configuration 0 as default? Or it will check available configurations and choose the proper one. The last one is to make sure with different buffer location for INTR-IN and BULK-IN/OUT EPs. Finally, there are two CDC-ECM dongles (RTL8153 and AX88179A) with verified functionalities on T2M-RSK with FreeRTOS+TCP stack.
To use the USB Ethernet Adapter that works as a CDC-ECM, configure the USB Host CDC and application program by following the steps below.
Step1: Choose the Configuration (by bConfigurationValue) contained the interface class (2: USB_CLASS_COMMUNICATIONS) and subclass (6: USB_CDC_ECM_SUBCLASS). The below log is an example produced by the lsusb utility. The bConfigurationValue is 3 in this example.
Step2: Choose the CDC Communication (2: USB_CLASS_COMMUNICATIONS) and Data (10: USB_CLASS_CDC_DATA) interfaces (by bInterfaceNumber and bAlternateSetting) contained the endpoints for the transaction of BULK-IN/OUT and INTR-IN. The below log is an example produced by lsusb utility. In this case, the bInterfaceNumber & bAlternateSetting are 0 & 0 and 1 & 1 for CDC Comm. and Data interfaces respectively.
Step3: Set no packet filter (0x43: SET_ETHERNET_PACKET_FILTER) to 0x1F.
The filter values are as the following
USB_CDC_PACKET_TYPE_PROMISCUOUS          0x01
USB_CDC_PACKET_TYPE_ALL_MULTICAST       0x02
USB_CDC_PACKET_TYPE_DIRECTED                  0x04
USB_CDC_PACKET_TYPE_BROADCAST               0x08
USB_CDC_PACKET_TYPE_MULTICAST               0x10
Step4: Get the notification of network connection and disconnection through CDC Communication Interface (INTR-IN EP).
USB_CDC_NETWORK_CONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x01, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
USB_CDC_NETWORK_DISCONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x00, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
Step5: Transmit and receive ethernet packets through CDC Data Interface (BULK-IN/OUT EPs).
Besides the above steps, there are several more points to be checked. The 1st one is to allocate USB buffer in non-cache area and the 2nd one is to check USB device enumeration process. Will it just use configuration 0 as default? Or it will check available configurations and choose the proper one. The last one is to make sure with different buffer location for INTR-IN and BULK-IN/OUT EPs. Finally, there are two CDC-ECM dongles (RTL8153 and AX88179A) with verified functionalities on T2M-RSK with FreeRTOS+TCP stack.
Suitable Products
RZ/T2M","['data/categories/rz_family/rzt2m/bda26d0e54eb84cd230f57eead9420df/images/3f8722265fad494f2ea9904ae91b8c90.png', 'data/categories/rz_family/rzt2m/bda26d0e54eb84cd230f57eead9420df/images/3e6d5c5000679bc2e60128a650ae91dd.png']",[],['|  |\n|  |\n| RZ/T2M |'],"{'title': 'RZ Family: How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK?', 'url': 'https://en-support.renesas.com/knowledgeBase/21698326', 'last_updated': None, 'extracted_at': '2025-03-08T23:50:23.316645'}","Question How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK? Answer To use the USB Ethernet Adapter that works as a CDC-ECM, configure the USB Host CDC and application program by following the steps below. Step1 Choose the Configuration (by bConfigurationValue) contained the interface class (2 USBCLASSCOMMUNICATIONS) and subclass (6 USBCDCECMSUBCLASS). The below log is an example produced by the lsusb utility. The bConfigurationValue is 3 in this example. Step2 Choose the CDC Communication (2 USBCLASSCOMMUNICATIONS) and Data (10 USBCLASSCDCDATA) interfaces (by bInterfaceNumber and bAlternateSetting) contained the endpoints for the transaction of BULK-IN/OUT and INTR-IN. The below log is an example produced by lsusb utility. In this case, the bInterfaceNumber  bAlternateSetting are 0  0 and 1  1 for CDC Comm. and Data interfaces respectively. Step3 Set no packet filter (0x43 SETETHERNETPACKETFILTER) to 0x1F. The filter values are as the following USBCDCPACKETTYPEPROMISCUOUS 0x01 USBCDCPACKETTYPEALLMULTICAST 0x02 USBCDCPACKETTYPEDIRECTED 0x04 USBCDCPACKETTYPEBROADCAST 0x08 USBCDCPACKETTYPEMULTICAST 0x10 Step4 Get the notification of network connection and disconnection through CDC Communication Interface (INTR-IN EP). USBCDCNETWORKCONNECT packet  0xA1, / bmRequestType / 0x00, / bRequest / 0x01, / wValue (lo) / 0x00, / wValue (hi) / 0x01, / wIndex (lo) / 0x00, / wIndex (hi) / 0x00, / wLength (lo) / 0x00 / wLength (hi) /  USBCDCNETWORKDISCONNECT packet 0x00, / wValue (lo) / Step5 Transmit and receive ethernet packets through CDC Data Interface (BULK-IN/OUT EPs). Besides the above steps, there are several more points to be checked. The 1st one is to allocate USB buffer in non-cache area and the 2nd one is to check USB device enumeration process. Will it just use configuration 0 as default? Or it will check available configurations and choose the proper one. The last one is to make sure with different buffer location for INTR-IN and BULK-IN/OUT EPs. Finally, there are two CDC-ECM dongles (RTL8153 and AX88179A) with verified functionalities on T2M-RSK with FreeRTOSTCP stack. Suitable Products RZ/T2M How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK?","['The image displays a screenshot of a computer program\'s configuration settings, with a red box highlighting specific values. The top-left corner shows the title ""Configuration Descriptor:"" followed by a list of settings and their corresponding values. The highlighted values are:\n\n*   bConfigurationValue: 3\n*   bInterfaceClass: 2\n*   bInterfaceSubClass: 6\n\nThe background of the image is white, suggesting that it may be a screenshot from a software development environment or a technical documentation page. Overall, the image appears to be a technical screenshot, likely from a software development environment or a technical documentation page.', 'The image presents a table with two rows of data, each containing a list of interface descriptors. The first row includes the following descriptors:\n\n* bLength\n* bDescriptorType\n* bInterfaceNumber\n* bAlternateSetting\n* bNumEndpoints\n* bInterfaceClass\n* bInterfaceSubClass\n* bInterfaceProtocol\n* iInterface\n\nThe second row contains the following descriptors:\n\n* bLength\n* bDescriptorType\n* bInterfaceNumber\n* bAlternateSetting\n* bNumEndpoints\n* bInterfaceClass\n* bInterfaceSubClass\n* bInterfaceProtocol\n* iInterface\n\nNotably, the first row has a red box highlighting the ""bInterfaceClass"" and ""bInterfaceSubClass"" descriptors, which are both set to 2 and 6, respectively. Additionally, the ""bInterfaceClass"" descriptor in the second row is highlighted in red, with a value of 10 and a CDC Data type.\n\nThe background of the image is white, providing a clean and neutral backdrop for the data. Overall, the image appears to be a screenshot of a computer program or software, possibly related to device management or interface configuration.']"
521cb8e6ba2a9fb702fbedc441c0ab26,"Question:
How should I handle unused pins?
Answer:
Be careful because the handling differs depending on the pin. 
Handle the unused pins in reference to the following table.
16.5 Handling of Unused Pins
Suitable Products
RZ/T2M
How should I handle unused pins?
How should I handle unused pins?
Answer:
Be careful because the handling differs depending on the pin. 
Handle the unused pins in reference to the following table.
16.5 Handling of Unused Pins
Suitable Products
RZ/T2M
Be careful because the handling differs depending on the pin. 
Handle the unused pins in reference to the following table.
16.5 Handling of Unused Pins
Be careful because the handling differs depending on the pin. 
Handle the unused pins in reference to the following table.
16.5 Handling of Unused Pins
Suitable Products
RZ/T2M
Go to Japanese Go to Chinese
Go to Japanese
Go to Chinese",['data/categories/rz_family/rzt2m/521cb8e6ba2a9fb702fbedc441c0ab26/images/cd54bce4709dfd7821d675d5ca7cb0ae.png'],[],['|  |\n|  |\n| RZ/T2M |'],"{'title': 'RZ/T2M: How should I handle unused pins?', 'url': 'https://en-support.renesas.com/knowledgeBase/20483526', 'last_updated': '2022-07-06', 'extracted_at': '2025-03-08T23:50:07.115956'}",Question How should I handle unused pins? Answer Be careful because the handling differs depending on the pin. Handle the unused pins in reference to the following table. 16.5 Handling of Unused Pins Suitable Products RZ/T2M Go to Japanese Go to Chinese Go to Japanese Go to Chinese,"['The image displays a table titled ""Handling of unused pins"" from the datasheet of a microcontroller. The table has two columns: ""Pin name"" and ""Handling"". The ""Pin name"" column lists various pin names, such as ""AN000 to AN007, AN100 to AN115"", ""VREFH0"", ""VREFH1"", ""XTAL"", ""EXTAL"", ""EXTCLKIN"", ""TRST#"", ""TCK (P02_7)"", ""TMS (P02_6)"", ""TDI (P02_5)"", ""TDO (P02_4)"", ""RSTOUT# (P17_5)"", ""MDX"", ""BSCANP"", ""USB_DP, USB_DM"", and ""USB_RREF"". The ""Handling"" column provides instructions for handling each pin, such as connecting them to a resistor or keeping them open.\n\nThe table is presented in a clear and concise manner, making it easy to read and understand. The use of a table format allows for quick comparison and reference of the different pin names and their corresponding handling instructions. Overall, the image provides a useful resource for individuals working with the microcontroller, helping them to properly handle and utilize the unused pins.']"
820abc84ea260a975d04191cca4b267e,"Question:
What power supply configuration is recommended for the RZ/T2M?
Answer:
Refer to the power supply combination of the following winning combo. 
JP191 Motor Control System with Industrial Network and FuSa
Suitable Products
RZ/T2M
What power supply configuration is recommended for the RZ/T2M?
What power supply configuration is recommended for the RZ/T2M?
Answer:
Refer to the power supply combination of the following winning combo. 
JP191 Motor Control System with Industrial Network and FuSa
Suitable Products
RZ/T2M
Refer to the power supply combination of the following winning combo. 
JP191 Motor Control System with Industrial Network and FuSa
Refer to the power supply combination of the following winning combo.
JP191 Motor Control System with Industrial Network and FuSa
Suitable Products
RZ/T2M
Go to Japanese Go to Chinese
Go to Japanese
Go to Chinese",['data/categories/rz_family/rzt2m/820abc84ea260a975d04191cca4b267e/images/69703acb22128bbcce4619f779e25c3d.png'],[],['|  |\n|  |\n| RZ/T2M |'],"{'title': 'What power supply configuration is recommended for the RZ/T2M?', 'url': 'https://en-support.renesas.com/knowledgeBase/20483524', 'last_updated': '2022-07-06', 'extracted_at': '2025-03-08T23:50:14.798348'}",Question What power supply configuration is recommended for the RZ/T2M? Answer Refer to the power supply combination of the following winning combo. JP191 Motor Control System with Industrial Network and FuSa Suitable Products RZ/T2M Refer to the power supply combination of the following winning combo. Go to Japanese Go to Chinese Go to Japanese Go to Chinese,"['The image presents a detailed block diagram of a complex electronic system, comprising various components and their interconnections. The diagram is divided into several sections, each representing a different functional block within the system.\n\n*   **Power Block**\n    *   The Power Block is located at the top-left corner of the diagram and consists of several components, including:\n        *   AC 100V-200V\n        *   PFC\n        *   5V\n        *   3.3V\n        *   1.8V\n        *   1.2V\n        *   0.9V\n        *   0.6V\n        *   0.3V\n        *   0.2V\n        *   0.1V\n        *   0.05V\n        *   0.01V\n        *   0.005V\n        *   0.001V\n        *   0.0005V\n        *   0.0001V\n        *   0.00005V\n        *   0.00001V\n        *   0.000005V\n        *   0.000001V\n        *   0.0000005V\n        *   0.0000001V\n        *   0.00000005V\n        *   0.00000001V\n        *   0.000000005V\n        *   0.000000001V\n        *   0.0000000005V\n        *   0.0000000001V\n        *   0.00000000005V\n        *   0.00000000001V\n        *   0.000000000005V\n        *   0.000000000001V\n        *   0.0000000000005V\n        *   0.0000000000001V\n        *   0.00000000000005V\n        *   0.00000000000001V\n        *   0.000000000000005V\n        *   0.000000000000001V\n        *   0.0000000000000005V\n        *   0.0000000000000001V\n        *   0.00000000000000005V\n        *   0.00000000000000001V\n        *   0.000000000000000005V\n        *   0.000000000000000001V\n        *   0.0000000000000000005V\n        *   0.0000000000000000001V\n        *   0.00000000000000000005V\n        *   0.00000000000000000001V\n        *   0.000000000000000000005V\n        *   0.000000000000000000001V\n        *   0.0000000000000000000005V\n        *   0.0000000000000000000001V\n        *   0.00000000000000000000005V\n        *   0.00000000000000000000001V\n        *   0.000000000000000000000005V\n        *   0.000000000000000000000001V\n        *   0.0000000000000000000000005V\n        *   0.0000000000000000000000001V\n        *   0.00000000000000000000000005V\n        *   0.00000000000000000000000001V\n        *   0.000000000000000000000000005V\n        *   0.000000000000000000000000001V\n        *   0.0000000000000000000000000005V\n        *   0.0000000000000000000000000001V\n        *   0.00000000000000000000000000005V\n        *   0.00000000000000000000000000001V\n        *   0.000000000000000000000000000005V\n        *   0.000000000000000000000000000001V\n        *   0.0000000000000000000000000000005V\n        *   0.0000000000000000000000000000001V\n        *   0.00000000000000000000000000000005V\n        *   0.00000000000000000000000000000001V\n        *   0.000000000000000000000000000000005V\n        *   0.000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.000000000000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000005V\n        *   0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000001V\n        *   0.000000000000000000000000000000000000000000000']"
da220d6b1410aa9a27624de30338af16,"Question:
Please tell me about the types of reset of the RZ/T2M, and their initialization targets.
Answer:
The RZ/T2M has the five types of reset shown in Table 5.1.
For the initialization targets of each reset, refer to Table 5.2.
Suitable Products
RZ/T2M
Please tell me about the types of reset of the RZ/T2M, and their initialization targets.
Please tell me about the types of reset of the RZ/T2M, and their initialization targets.
Answer:
The RZ/T2M has the five types of reset shown in Table 5.1.
For the initialization targets of each reset, refer to Table 5.2.
Suitable Products
RZ/T2M
The RZ/T2M has the five types of reset shown in Table 5.1.
For the initialization targets of each reset, refer to Table 5.2.
The RZ/T2M has the five types of reset shown in Table 5.1.
For the initialization targets of each reset, refer to Table 5.2.
Suitable Products
RZ/T2M
Go to Japanese Go to Chinese
Go to Japanese
Go to Chinese","['data/categories/rz_family/rzt2m/da220d6b1410aa9a27624de30338af16/images/4a2f9e3f6d7eac9bb05c33a4c21c1c96.png', 'data/categories/rz_family/rzt2m/da220d6b1410aa9a27624de30338af16/images/414993a67cb1a819ee5acb69422a4196.png']",[],['|  |\n|  |\n| RZ/T2M |'],"{'title': 'Please tell me about the types of reset of the RZ/T2M, and their initialization targets.', 'url': 'https://en-support.renesas.com/knowledgeBase/20483528', 'last_updated': '2022-07-06', 'extracted_at': '2025-03-08T23:50:20.282789'}","Question Please tell me about the types of reset of the RZ/T2M, and their initialization targets. Answer The RZ/T2M has the five types of reset shown in Table 5.1. For the initialization targets of each reset, refer to Table 5.2. Suitable Products RZ/T2M Go to Japanese Go to Chinese Go to Japanese Go to Chinese","['The image shows a table with two columns, ""Reset name"" and ""Source"". The table contains five rows, each representing a different reset name and its corresponding source. The reset names are:\n\n1. RES# pin reset\n2. System software reset\n3. CPU0 software reset\n4. CPU1 software reset\n5. Error reset\n\nThe sources for these resets are:\n\n1. The low level is applied to the RES# pin\n2. SWRSYS register setting\n3. SWRCPU0 register setting\n4. SWRCPU1 register setting\n5. Reset request from the ICU\n\nThis table provides a clear and concise overview of the different reset names and their corresponding sources, allowing for easy reference and understanding of the system\'s reset mechanisms.', 'The image presents a table with the title ""Targets to be initialized for each reset type (V; to be initialized, —; no change)"". The table is divided into two main sections: the left column lists various reset targets, and the right columns represent different reset types, including ""RES# pin reset"", ""System software reset"", ""CPU0 software reset"", ""CPU1 software reset"", and ""Error reset"".\n\n**Reset Targets:**\n\n*   RES# Pin Reset flag (RSTSR0.TRF)\n*   System Software Reset Defect flag (RSTSR0.SWRSF)\n*   CPU0/CPU1 Software Reset Detect flag (RSTSR0.SWROF, SWR1F)\n*   Error Reset Detect flag (RSTSR0.ERRF)\n*   Error Event Capture Status registers\n*   Pin state\n*   Operating mode\n*   CPU0\n*   WDT0 for CPU0\n*   CPU1\n*   WDT1 for CPU1\n*   System SRAM, TCM, cache\n*   Peripheral modules, registers and internal states other than listed\n*   RSTOUT# pin output\n\n**Reset Types:**\n\n*   RES# pin reset\n*   System software reset\n*   CPU0 software reset\n*   CPU1 software reset\n*   Error reset\n\n**Initialization Status:**\n\n*   A checkmark (V) indicates that the target is to be initialized for the corresponding reset type.\n*   A dash (-) indicates that the target is not to be initialized for the corresponding reset type.\n*   A low asterisk (*) indicates that the target is to be initialized with a low value for the corresponding reset type.\n\n**Observations:**\n\n*   The table shows that most reset targets are to be initialized for all reset types, except for the ""Error reset"" type, which has a few exceptions.\n*   The ""System software reset"" and ""CPU0 software reset"" types have similar initialization patterns, with some differences in the ""Error reset"" type.\n*   The ""CPU1 software reset"" type has a distinct initialization pattern, with some targets not being initialized for this type.\n*   The ""Error reset"" type has a unique initialization pattern, with some targets being initialized with a low value.\n\n**Conclusion:**\n\nThe table provides a detailed overview of the targets to be initialized for each reset type in a microcontroller. It highlights the differences in initialization patterns between various reset types and targets. The table can be used as a reference for understanding the reset behavior of the microcontroller and ensuring proper initialization of its components.']"
d4aab005aea43af76373abe7c614208e,"Question:
What combinations can be used simultaneously with Ethernet/EtherCAT communication of the RZ/T2M?
Answer:
The combinations that can be used simultaneously with the Ethernet/EtherCAT communication port of the RZ/T2M can be selected in MDOCTRL. 
The combinations that can be set are as shown in the following figure.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode and 26.2.2 MODCTRL: Mode Control Register in RZ/T2M Group User’s Manual: Hardware (r01uh0916ej0080-rzt2m)
Suitable Products
RZ/T2M
What combinations can be used simultaneously with Ethernet/EtherCAT communication of the RZ/T2M?
What combinations can be used simultaneously with Ethernet/EtherCAT communication of the RZ/T2M?
Answer:
The combinations that can be used simultaneously with the Ethernet/EtherCAT communication port of the RZ/T2M can be selected in MDOCTRL. 
The combinations that can be set are as shown in the following figure.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode and 26.2.2 MODCTRL: Mode Control Register in RZ/T2M Group User’s Manual: Hardware (r01uh0916ej0080-rzt2m)
Suitable Products
RZ/T2M
The combinations that can be used simultaneously with the Ethernet/EtherCAT communication port of the RZ/T2M can be selected in MDOCTRL. 
The combinations that can be set are as shown in the following figure.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode and 26.2.2 MODCTRL: Mode Control Register in RZ/T2M Group User’s Manual: Hardware (r01uh0916ej0080-rzt2m)
The combinations that can be used simultaneously with the Ethernet/EtherCAT communication port of the RZ/T2M can be selected in MDOCTRL. 
The combinations that can be set are as shown in the following figure.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode and 26.2.2 MODCTRL: Mode Control Register in RZ/T2M Group User’s Manual: Hardware (r01uh0916ej0080-rzt2m)
Suitable Products
RZ/T2M
Go to Japanese Go to Chinese
Go to Japanese
Go to Chinese",['data/categories/rz_family/rzt2m/d4aab005aea43af76373abe7c614208e/images/2e81d73589f7604fd234a1e565b04c51.png'],[],['|  |\n|  |\n| RZ/T2M |'],"{'title': 'What combinations can be used simultaneously with Ethernet/EtherCAT communication of the RZ/T2M?', 'url': 'https://en-support.renesas.com/knowledgeBase/20483523', 'last_updated': '2022-07-06', 'extracted_at': '2025-03-08T23:50:12.097934'}","Question What combinations can be used simultaneously with Ethernet/EtherCAT communication of the RZ/T2M? Answer The combinations that can be used simultaneously with the Ethernet/EtherCAT communication port of the RZ/T2M can be selected in MDOCTRL. The combinations that can be set are as shown in the following figure. For details, refer to the following items. Table 26.4 MAC-PHY interface mode and 26.2.2 MODCTRL Mode Control Register in RZ/T2M Group Users Manual Hardware (r01uh0916ej0080-rzt2m) Suitable Products RZ/T2M Go to Japanese Go to Chinese Go to Japanese Go to Chinese","['The image depicts a table titled ""MAC-PHY interface mode"" with a header row and six rows of data. The table is divided into four columns, labeled ""Combination,"" ""ETH0,"" ""ETH1,"" and ""ETH2."" The first column lists various combinations, while the subsequent columns detail the corresponding Ethernet switch ports and EtherCAT slave controller ports for each combination.\n\nThe table provides a clear and organized overview of the different MAC-PHY interface modes, making it easy to compare and contrast the various configurations. The use of a table format allows for a concise and easy-to-read presentation of the data, making it an effective tool for communication and analysis.']"
752b5f2bc6e3c76bc4cdaf68e35306ee,"Question:
RZ/V2H EVK - How to boot up from eMMC ?
Answer:
Hardware : RZ/V2H EVK
Software : AI SDK ver 5.00 (Release note)
Steps to boot up from eMMC :
Adjust the DIP switch on the CPU board to SCI download mode.

SW1(ON) : 1, 3, 5
SW2(ON) : 1, 2, 4

Download the flash writer (Flash_Writer_SCIF_RZV2H_DEV_INTERNAL_MEMORY.mot) to RZ/V2H, then program Arm trusted firmware (bl2_bp_emmc-rzv2h-evk-alpha.srec) via USB-CDC.

Sector number : 1
Program start address : 0x8101E00



Use the“SUP” command to change uart baurate to 921.6Kbps, then programming b31 firmware + uboot (fip-rzv2h-evk-alpha.srec) via USB-CDC.

Sector number : 0x300
Program start address : 0x44000000



Use the“EM_SECSD” command to set CSD attributes

Deploy the SD card using Ubuntu “bmaptool”. Adjust the SD device (e.g., sda, sdb) based on your Linux machine.

sudo bmaptool copy --bmap core-image-weston-rzv2h-evk-alpha.wic.bmap core-image-weston-rzv2h-evk-alpha.wic.gz /dev/sda

Power off RZ/V2H, then adjust the DIP switch on the CPU board to boot from eMMC.

SW1(ON) : 1, 3, 4, 5
SW2(ON) : 1, 2, 4

mmcblk1 is for SD card.



“/” mount at SD card



Use ""fdisk"" to partition the eMMC into two partitions, then deploy rootfs to eMMC.

Power off RZ/V2H, Remove SD card, then set U-boot for eMMC boot.

Now “/” mount at eMMC.

No SD card is mounted.



Suitable Products
RZ/V2H
RZ/V2H EVK - How to boot up from eMMC ?
Answer:
Hardware : RZ/V2H EVK
Software : AI SDK ver 5.00 (Release note)
Steps to boot up from eMMC :
Adjust the DIP switch on the CPU board to SCI download mode.

SW1(ON) : 1, 3, 5
SW2(ON) : 1, 2, 4

Download the flash writer (Flash_Writer_SCIF_RZV2H_DEV_INTERNAL_MEMORY.mot) to RZ/V2H, then program Arm trusted firmware (bl2_bp_emmc-rzv2h-evk-alpha.srec) via USB-CDC.

Sector number : 1
Program start address : 0x8101E00



Use the“SUP” command to change uart baurate to 921.6Kbps, then programming b31 firmware + uboot (fip-rzv2h-evk-alpha.srec) via USB-CDC.

Sector number : 0x300
Program start address : 0x44000000



Use the“EM_SECSD” command to set CSD attributes

Deploy the SD card using Ubuntu “bmaptool”. Adjust the SD device (e.g., sda, sdb) based on your Linux machine.

sudo bmaptool copy --bmap core-image-weston-rzv2h-evk-alpha.wic.bmap core-image-weston-rzv2h-evk-alpha.wic.gz /dev/sda

Power off RZ/V2H, then adjust the DIP switch on the CPU board to boot from eMMC.

SW1(ON) : 1, 3, 4, 5
SW2(ON) : 1, 2, 4

mmcblk1 is for SD card.



“/” mount at SD card



Use ""fdisk"" to partition the eMMC into two partitions, then deploy rootfs to eMMC.

Power off RZ/V2H, Remove SD card, then set U-boot for eMMC boot.

Now “/” mount at eMMC.

No SD card is mounted.



Suitable Products
RZ/V2H
Hardware : RZ/V2H EVK
Software : AI SDK ver 5.00 (Release note)
Steps to boot up from eMMC :
1
0x8101E00
0x300
0x44000000
sudo bmaptool copy --bmap core-image-weston-rzv2h-evk-alpha.wic.bmap core-image-weston-rzv2h-evk-alpha.wic.gz /dev/sda
4
Suitable Products
RZ/V2H","['data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/8eec000bcbe2091cfc8c04653d5e9d78.png', 'data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/e7783038faecfc033f17ad1ec58d5118.png', 'data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/5a439f27b1fe1342ce6f05d5791e402d.png', 'data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/2ceb717ff94f9f2ae4da02528a6e982a.png', 'data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/48977d68d10456bdb52a476b0fc9450d.png', 'data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/15cdfd9ebbae9de0b5d39f6bbe34f228.png']",[],['|  |\n|  |\n| RZ/V2H |'],"{'title': 'RZ/V2H EVK - How to boot up from eMMC', 'url': 'https://en-support.renesas.com/knowledgeBase/21727835', 'last_updated': None, 'extracted_at': '2025-03-08T23:51:38.757080'}","Question RZ/V2H EVK - How to boot up from eMMC ? Answer Hardware  RZ/V2H EVK Software  AI SDK ver 5.00 (Release note) Steps to boot up from eMMC  Adjust the DIP switch on the CPU board to SCI download mode. SW1(ON)  1, 3, 5 SW2(ON)  1, 2, 4 Download the flash writer (FlashWriterSCIFRZV2HDEVINTERNALMEMORY.mot) to RZ/V2H, then program Arm trusted firmware (bl2bpemmc-rzv2h-evk-alpha.srec) via USB-CDC. Sector number  1 Program start address  0x8101E00 Use theSUP command to change uart baurate to 921.6Kbps, then programming b31 firmware  uboot (fip-rzv2h-evk-alpha.srec) via USB-CDC. Sector number  0x300 Program start address  0x44000000 Use theEMSECSD command to set CSD attributes Deploy the SD card using Ubuntu bmaptool. Adjust the SD device (e.g., sda, sdb) based on your Linux machine. sudo bmaptool copy --bmap core-image-weston-rzv2h-evk-alpha.wic.bmap core-image-weston-rzv2h-evk-alpha.wic.gz /dev/sda Power off RZ/V2H, then adjust the DIP switch on the CPU board to boot from eMMC. SW1(ON)  1, 3, 4, 5 mmcblk1 is for SD card. / mount at SD card Use ""fdisk"" to partition the eMMC into two partitions, then deploy rootfs to eMMC. Power off RZ/V2H, Remove SD card, then set U-boot for eMMC boot. Now / mount at eMMC. No SD card is mounted. Suitable Products RZ/V2H 1 0x8101E00 0x300 0x44000000 4","['The image shows a screenshot of a computer terminal window displaying a command prompt with several lines of text. The text is in white and includes various commands and information related to the computer\'s operating system and hardware.\n\nThe first line of text reads ""COM27 - Tera Term vT"" in small white letters, indicating the name of the terminal emulator being used. Below this, there are several lines of text that appear to be output from a command prompt, including:\n\n* ""SCI Download mode (Normal SCI boot)""\n* ""Load Program to SRAM""\n* ""Start Boot Program on SRAM""\n* ""Flash writer for RZ/V2H Series V0.60 Jan.26,2023""\n* ""Product Code : RZ/V2H""\n* ""EM W Start""\n* ""Please select,eMMC Partition Area.""\n* ""0:User Partition Area : 62160896 KBytes""\n* ""eMMC Sector Cnt: H\'0 - H\'0768FFFF""\n* ""1:Boot Partition 1 : 32256 KBytes""\n* ""eMMC Sector Cnt: H\'0 - H\'0000FBFF""\n* ""2:Boot Partition 2 : 32256 KBytes""\n* ""eMMC Sector Cnt: H\'0 - H\'0000FBFF""\n* ""Select area(0-2) 1""\n* ""Boot Partition 1 Program""\n* ""Please Input Start Address in sector 1""\n* ""Please Input Program Start Address 8101E00""\n* ""Work RAM (H\'08200000-H\'085FFFF) Clear...""\n* ""Please send 1 (\'.\', \'& CR stop load)""\n* ""SAVE -FLASH...""\n* ""EM W Complete!""\n\nThe background of the image is a solid gray color, which helps to make the white text stand out. Overall, the image appears to be a screenshot of a computer terminal window displaying a command prompt with various commands and information related to the computer\'s operating system and hardware.', 'The image shows a screenshot of a computer terminal window displaying a series of commands and their outputs. The terminal window is open on a black background, with white text and red and blue highlights.\n\n*   **Title Bar**\n    *   The title bar at the top of the window reads ""COM32 - Tera Term VT"" in white text.\n*   **Menu Bar**\n    *   Below the title bar, there is a menu bar with options such as ""File"", ""Edit"", ""Setup"", ""Control"", ""Window"", and ""Help"".\n*   **Command Line**\n    *   The main body of the window displays a command line with a series of commands and their outputs.\n    *   The first command is ""SCI Download mode (Normal SCI boot)"".\n    *   The second command is ""Load Program to SRAM"".\n    *   The third command is ""Start Boot Program on SRAM"".\n    *   The fourth command is ""Flash writer for RZ/V2H Series V0.60 Jan.26,2023"".\n    *   The fifth command is ""Product Code : RZ/V2H"".\n    *   The sixth command is ""Scif speed UP"".\n    *   The seventh command is ""Please change to 921.6Kbps baud rate setting of the terminal."".\n    *   The eighth command is ""command not found"".\n    *   The ninth command is ""EM_W Start"".\n    *   The tenth command is ""Please select,eMMC Partition Area."".\n    *   The eleventh command is ""0:User Partition Area : 62160896 KBytes"".\n    *   The twelfth command is ""eMMC Sector Cnt : H\'0 - H\'0768FFFF"".\n    *   The thirteenth command is ""1:Boot Partition 1 : 32256 KBytes"".\n    *   The fourteenth command is ""eMMC Sector Cnt : H\'0 - H\'0000FBFF"".\n    *   The fifteenth command is ""2:Boot Partition 2 : 32256 KBytes"".\n    *   The sixteenth command is ""eMMC Sector Cnt : H\'0 - H\'0000FBFF"".\n    *   The seventeenth command is ""Select area(0-2)>1"".\n    *   The eighteenth command is ""Boot Partition 1 Program"".\n    *   The nineteenth command is ""Please Input Start Address in sector : 3600"".\n    *   The twentieth command is ""Please Input Program Start Address : 44000000"".\n    *   The twenty-first command is ""Work RAM (H\'08200000-H\'085FFFF) Clear..."".\n    *   The twenty-second command is ""Please send ! (\'.\', & CR stop load)"".\n    *   The twenty-third command is ""SAVE - FLASH..."".\n    *   The twenty-fourth command is ""EM_W Complete!"".\n*   **Red Highlights**\n    *   The words ""SUP"", ""EM_W Start"", ""EM_W Complete!"", and ""3600"" are highlighted in red.\n*   **Blue Highlight**\n    *   The word ""Complete!"" is highlighted in blue.\n\nOverall, the image appears to be a screenshot of a computer terminal window displaying a series of commands and their outputs related to flashing a program onto an eMMC device.', ""The image shows a computer screen displaying a series of lines of code in white text on a black background. The code is written in a programming language, possibly C or C++, and appears to be a function or method definition.\n\nThe code includes several lines of comments, which are denoted by the `//` symbol. These comments provide explanations or notes about the code, but do not affect its execution.\n\nThe code also includes several variables and data types, such as `H'00`, `H'1FF`, and `EXT_CSD`. These variables are likely used to store or manipulate data within the program.\n\nOverall, the image suggests that the code is part of a larger program or system, and is intended to perform a specific task or function. The use of comments and clear variable names indicates that the programmer has taken care to make the code readable and maintainable.\n\nThe image does not provide any additional context or information about the program or its purpose. It appears to be a screenshot of a code editor or IDE, and may have been taken during the development or debugging process."", 'The image shows a screenshot of a terminal window displaying a list of commands and their corresponding output. The commands are written in white text on a black background, and they appear to be related to disk management and partitioning.\n\nThe first command, ""mmc0: new HS200 MMC card at address 0001,"" indicates that a new MMC card has been detected and is being assigned an address of 0001.\n\nThe second command, ""mmcblk0: mmc0:0001 GIM15M 59.3 GiB,"" provides information about the MMC card, including its type (GIM15M), capacity (59.3 GiB), and address (0001).\n\nThe third command, ""mmcblk0boot0: mmc0:0001 GIM15M partition 1 31.5 MiB,"" shows that the MMC card has a single partition, which is 31.5 MiB in size.\n\nThe fourth command, ""mmcblk0boot1: mmc0:0001 GIM15M partition 2 31.5 MiB,"" indicates that there is another partition on the MMC card, also 31.5 MiB in size.\n\nThe fifth command, ""mmcblk0p1: mmc0:0001 GIM15M partition 3 4.00 MiB, chardev (242:0),"" provides information about the third partition, including its size (4.00 MiB) and the character device file associated with it (242:0).\n\nThe sixth command, ""mmcblk0: p1 p2,"" lists the partitions on the MMC card, which are p1 and p2.\n\nThe seventh command, ""mmc1: new ultra high speed SDHC card at address aaaa,"" indicates that a new SDHC card has been detected and is being assigned an address of aaaa.\n\nThe eighth command, ""mmcblk1: mmc1:aaaa SL1GG 14.8 GiB,"" provides information about the SDHC card, including its type (SL1GG), capacity (14.8 GiB), and address (aaaa).\n\nThe ninth command, ""mmcblk1: p1 p2,"" lists the partitions on the SDHC card, which are p1 and p2.\n\nOverall, the image suggests that the user is working with two types of memory cards: an MMC card and an SDHC card. The commands are used to detect and manage the partitions on these cards, as well as to provide information about their capacity and type.', 'The image shows a screenshot of a terminal window with a command prompt and a list of commands. The command prompt is in red text and reads ""root@rv2h-eyk-alpha:~# mount"". Below this, there are several lines of text in white, which appear to be the output of a command. The text includes information about the file system, such as the device name, file system type, and mount point.\n\nThe background of the image is a solid gray color, which helps to make the text stand out. Overall, the image appears to be a screenshot of a Linux terminal window, showing the output of a command related to file system management.', 'The image shows a computer screen displaying a terminal window with a command prompt and output. The top half of the image is a black box with white text, while the bottom half is a gray box with white text.\n\nThe top half of the image contains a list of commands and their corresponding outputs, including file sizes and other technical information. The commands are written in a programming language, likely Bash or another Unix-like shell.\n\nThe bottom half of the image contains a single line of code that appears to be a command or instruction. The code is written in a programming language, likely Bash or another Unix-like shell, and includes several variables and functions.\n\nOverall, the image suggests that the user is working with a computer system and is using the terminal to execute commands and view output. The code in the bottom half of the image may be related to a specific task or project that the user is working on.']"
d59bb9588a3224079421a4b9283844f3,"Question:
I get the error shown in the figure below when building a project created using RZ/T FSP v2.2.0. What does this look like?
e² studio：
EWARM：
Answer:
It is a configurator error. This occurs when a section placement is changed to a different area from the area generated by the code generation in the linker script of RZ/T FSP v2.2.0 and RZ/N FSP v2.1.0 or later. (e.g. from ATCM to System RAM)
If this error occurs, it will not be possible to create a secondary project for multi-core operation with that project as the primary project because .sbd file generated after the build will not be generated correctly.
As a countermeasure, the following changes suppress the occurrence of errors, so you can create a secondary project, but please evaluate it thoroughly in your environment because it may not work properly.
e² studio：Remove __ddsc_xxxx_END described at the end of linker script file in {project name}/script
EWARM：{project name}/rzt/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
{project name}/rzn/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
 Remove __ddsc_xxxx_END around #L756 (in the case of RZ/T FSP v2.2.0, RZ/N FSP v2.1.0)
(xxxx is the name of the memory area displayed in error.)
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
I get the error shown in the figure below when building a project created using RZ/T FSP v2.2.0. What does this look like?
e² studio：
EWARM：
I get the error shown in the figure below when building a project created using RZ/T FSP v2.2.0. What does this look like?
e² studio：
EWARM：
Answer:
It is a configurator error. This occurs when a section placement is changed to a different area from the area generated by the code generation in the linker script of RZ/T FSP v2.2.0 and RZ/N FSP v2.1.0 or later. (e.g. from ATCM to System RAM)
If this error occurs, it will not be possible to create a secondary project for multi-core operation with that project as the primary project because .sbd file generated after the build will not be generated correctly.
As a countermeasure, the following changes suppress the occurrence of errors, so you can create a secondary project, but please evaluate it thoroughly in your environment because it may not work properly.
e² studio：Remove __ddsc_xxxx_END described at the end of linker script file in {project name}/script
EWARM：{project name}/rzt/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
{project name}/rzn/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
 Remove __ddsc_xxxx_END around #L756 (in the case of RZ/T FSP v2.2.0, RZ/N FSP v2.1.0)
(xxxx is the name of the memory area displayed in error.)
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
It is a configurator error. This occurs when a section placement is changed to a different area from the area generated by the code generation in the linker script of RZ/T FSP v2.2.0 and RZ/N FSP v2.1.0 or later. (e.g. from ATCM to System RAM)
If this error occurs, it will not be possible to create a secondary project for multi-core operation with that project as the primary project because .sbd file generated after the build will not be generated correctly.
As a countermeasure, the following changes suppress the occurrence of errors, so you can create a secondary project, but please evaluate it thoroughly in your environment because it may not work properly.
e² studio：Remove __ddsc_xxxx_END described at the end of linker script file in {project name}/script
EWARM：{project name}/rzt/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
{project name}/rzn/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
 Remove __ddsc_xxxx_END around #L756 (in the case of RZ/T FSP v2.2.0, RZ/N FSP v2.1.0)
(xxxx is the name of the memory area displayed in error.)
It is a configurator error. This occurs when a section placement is changed to a different area from the area generated by the code generation in the linker script of RZ/T FSP v2.2.0 and RZ/N FSP v2.1.0 or later. (e.g. from ATCM to System RAM)
If this error occurs, it will not be possible to create a secondary project for multi-core operation with that project as the primary project because .sbd file generated after the build will not be generated correctly.
As a countermeasure, the following changes suppress the occurrence of errors, so you can create a secondary project, but please evaluate it thoroughly in your environment because it may not work properly.
e² studio：Remove __ddsc_xxxx_END described at the end of linker script file in {project name}/script
EWARM：{project name}/rzt/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
{project name}/rzn/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
 Remove __ddsc_xxxx_END around #L756 (in the case of RZ/T FSP v2.2.0, RZ/N FSP v2.1.0)
(xxxx is the name of the memory area displayed in error.)
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
日本語
日本語","['data/categories/rz_family/rzt2_rzn2_fsp/d59bb9588a3224079421a4b9283844f3/images/e081400097b52db48df817eb23bef824.png', 'data/categories/rz_family/rzt2_rzn2_fsp/d59bb9588a3224079421a4b9283844f3/images/87535df5e0568510ef8d96c2a9748f71.png', 'data/categories/rz_family/rzt2_rzn2_fsp/d59bb9588a3224079421a4b9283844f3/images/3114f01a3552653f639d3c5fbb158c83.png', 'data/categories/rz_family/rzt2_rzn2_fsp/d59bb9588a3224079421a4b9283844f3/images/99af35b8101980996357e21d818aff0f.png']",[],"['|  |\n|  |\n| RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L |']","{'title': 'RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L: Error regarding smart bundle occurs when building the project', 'url': 'https://en-support.renesas.com/knowledgeBase/21733883', 'last_updated': None, 'extracted_at': '2025-03-08T23:52:25.674120'}","Question I get the error shown in the figure below when building a project created using RZ/T FSP v2.2.0. What does this look like? e studio EWARM Answer It is a configurator error. This occurs when a section placement is changed to a different area from the area generated by the code generation in the linker script of RZ/T FSP v2.2.0 and RZ/N FSP v2.1.0 or later. (e.g. from ATCM to System RAM) If this error occurs, it will not be possible to create a secondary project for multi-core operation with that project as the primary project because .sbd file generated after the build will not be generated correctly. As a countermeasure, the following changes suppress the occurrence of errors, so you can create a secondary project, but please evaluate it thoroughly in your environment because it may not work properly. e studioRemove ddscxxxxEND described at the end of linker script file in project name/script EWARMproject name/rzt/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c project name/rzn/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c Remove ddscxxxxEND around L756 (in the case of RZ/T FSP v2.2.0, RZ/N FSP v2.1.0) (xxxx is the name of the memory area displayed in error.) Suitable Products RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L ","['The image shows a screenshot of a Windows error message. The error message is titled ""Problem Occurred"" and has a red circle with a white X in it, indicating an error. The message reads: ""\'Build Project\' has encountered a problem. Errors occurred during the build."" Below this, there are two buttons: ""OK"" and ""<< Details"". When the user clicks on the ""Details"" button, a pop-up window appears with more information about the error. This window is titled ""Errors occurred during the build."" and contains a list of errors, including the error message and the address of the partition where the error occurred. The background of the image is white, with black text and a gray border around the edges. Overall, the image suggests that there was an issue with building a project in Windows, and the user needs to investigate further to resolve the problem.', 'The image shows a pop-up window with an error message. The window is titled ""Usage Error"" and has a red circle with a white X in it, indicating an error. The message reads, ""Failed to run command line smart bundle generation."" Below this, there is a line of text that says, ""Address of partition \'ATCM_CR52_0_N\' out of range: 0x100f5a44."" At the bottom of the window, there is a button labeled ""OK"" in a blue box.\n\nThe background of the window is a light gray color, and the text is black. The overall design of the window suggests that it is a standard error message window, possibly from a software application or operating system.', 'The image shows a code snippet in a programming language, likely C or C++. The code is written in a text editor or IDE (Integrated Development Environment) and is displayed in a monospaced font.\n\nThe code is divided into two sections: the top section shows the code before a change, and the bottom section shows the code after the change. The changes are highlighted in yellow, indicating that they have been modified.\n\nThe code appears to be related to memory management, as it includes functions such as `malloc`, `free`, and `realloc`. It also includes variables and data structures, such as arrays and pointers.\n\nThe code is written in a clear and concise manner, with proper indentation and spacing. The use of comments and whitespace makes it easy to read and understand.\n\nOverall, the image suggests that the code has been modified to improve its performance or functionality, possibly by optimizing memory allocation or reducing memory usage.', 'The image shows a code snippet in a programming language, likely C or C++. The code is written in a text editor or IDE (Integrated Development Environment) and is displayed in a monospaced font.\n\nThe code is divided into several sections, each with its own set of variables and functions. The top section appears to be a function definition, with the function name ""BSP_DONT_REMOVE"" and a set of parameters. The middle section contains a series of if-else statements, which are used to control the flow of the program based on certain conditions. The bottom section contains a loop that iterates over a range of values.\n\nThe code also includes several comments, which are denoted by the ""#"" symbol. These comments provide additional information about the code and can be used to explain its purpose or behavior.\n\nOverall, the code appears to be a complex program that performs a specific task, such as managing system resources or handling user input. The use of if-else statements, loops, and functions suggests that the program is designed to be efficient and scalable.\n\n*Answer*: The code snippet appears to be a complex program that manages system resources and handles user input, using if-else statements, loops, and functions to achieve its goals.']"
88e6db58570d269662afcaa0397a468c,"Question:
Please tell me how to check the memory usage of RZ/T, RZ/N FSP project in e2 studio.
Answer:
The memory usage can be checked at Smart Bundle view.
It appears when you double-click on the bundle file({project name}/Debug/{project name}.sbd), which is created when you build the project.
Open the Memories tab of Smart Bundle view to see the memory placement and size for each core.
Sections that do not exist in FSP GCC linker script({project name}/script/fsp_XXXX.ld) will not be displayed. To add a new section, add the definition of ddsc symbols(__ddsc*_START and __ddsc*_END) to linker script.
Implementation Example）Add xSPI0_CS0 section
SECTIONS
{
    ...Omission of intermediate part...
    .xspi : AT (xSPI0_CS0_SPACE_PRV_START)
    {
        xspi_start = .;
        KEEP(*(.xspi))
        xspi_end = .;
    } > xSPI0_CS0_SPACE
}
    ...Omission of intermediate part...
__ddsc_xSPI0_CS0_SPACE_START = ORIGIN(xSPI0_CS0_SPACE);
__ddsc_xSPI0_CS0_SPACE_END = xspi_end;
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
Please tell me how to check the memory usage of RZ/T, RZ/N FSP project in e2 studio.
Please tell me how to check the memory usage of RZ/T, RZ/N FSP project in e2 studio.
Answer:
The memory usage can be checked at Smart Bundle view.
It appears when you double-click on the bundle file({project name}/Debug/{project name}.sbd), which is created when you build the project.
Open the Memories tab of Smart Bundle view to see the memory placement and size for each core.
Sections that do not exist in FSP GCC linker script({project name}/script/fsp_XXXX.ld) will not be displayed. To add a new section, add the definition of ddsc symbols(__ddsc*_START and __ddsc*_END) to linker script.
Implementation Example）Add xSPI0_CS0 section
SECTIONS
{
    ...Omission of intermediate part...
    .xspi : AT (xSPI0_CS0_SPACE_PRV_START)
    {
        xspi_start = .;
        KEEP(*(.xspi))
        xspi_end = .;
    } > xSPI0_CS0_SPACE
}
    ...Omission of intermediate part...
__ddsc_xSPI0_CS0_SPACE_START = ORIGIN(xSPI0_CS0_SPACE);
__ddsc_xSPI0_CS0_SPACE_END = xspi_end;
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
The memory usage can be checked at Smart Bundle view.
It appears when you double-click on the bundle file({project name}/Debug/{project name}.sbd), which is created when you build the project.
Open the Memories tab of Smart Bundle view to see the memory placement and size for each core.
Sections that do not exist in FSP GCC linker script({project name}/script/fsp_XXXX.ld) will not be displayed. To add a new section, add the definition of ddsc symbols(__ddsc*_START and __ddsc*_END) to linker script.
Implementation Example）Add xSPI0_CS0 section
SECTIONS
{
    ...Omission of intermediate part...
    .xspi : AT (xSPI0_CS0_SPACE_PRV_START)
    {
        xspi_start = .;
        KEEP(*(.xspi))
        xspi_end = .;
    } > xSPI0_CS0_SPACE
}
    ...Omission of intermediate part...
__ddsc_xSPI0_CS0_SPACE_START = ORIGIN(xSPI0_CS0_SPACE);
__ddsc_xSPI0_CS0_SPACE_END = xspi_end;
The memory usage can be checked at Smart Bundle view.
It appears when you double-click on the bundle file({project name}/Debug/{project name}.sbd), which is created when you build the project.
Open the Memories tab of Smart Bundle view to see the memory placement and size for each core.
Sections that do not exist in FSP GCC linker script({project name}/script/fsp_XXXX.ld) will not be displayed. To add a new section, add the definition of ddsc symbols(__ddsc*_START and __ddsc*_END) to linker script.
Implementation Example）Add xSPI0_CS0 section
SECTIONS
{
    ...Omission of intermediate part...
    .xspi : AT (xSPI0_CS0_SPACE_PRV_START)
    {
        xspi_start = .;
        KEEP(*(.xspi))
        xspi_end = .;
    } > xSPI0_CS0_SPACE
}
    ...Omission of intermediate part...
__ddsc_xSPI0_CS0_SPACE_START = ORIGIN(xSPI0_CS0_SPACE);
__ddsc_xSPI0_CS0_SPACE_END = xspi_end;
.xspi : AT (xSPI0_CS0_SPACE_PRV_START)
{
xspi_start = .;
KEEP(*(.xspi))
xspi_end = .;
} > xSPI0_CS0_SPACE
__ddsc_xSPI0_CS0_SPACE_START = ORIGIN(xSPI0_CS0_SPACE);
__ddsc_xSPI0_CS0_SPACE_END = xspi_end;
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
日本語
日本語","['data/categories/rz_family/rzt2_rzn2_fsp/88e6db58570d269662afcaa0397a468c/images/e78d60a443ff4ae54ccd889f90529a85.png', 'data/categories/rz_family/rzt2_rzn2_fsp/88e6db58570d269662afcaa0397a468c/images/0678de88cbeb0a31325be1dcbf94ef04.png']",[],"['|  |\n|  |\n| RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L |']","{'title': 'Display of memory usage for RZ/T, RZ/N FSP project', 'url': 'https://en-support.renesas.com/knowledgeBase/21733881', 'last_updated': None, 'extracted_at': '2025-03-08T23:52:34.541431'}","Question Please tell me how to check the memory usage of RZ/T, RZ/N FSP project in e2 studio. Answer The memory usage can be checked at Smart Bundle view. It appears when you double-click on the bundle file(project name/Debug/project name.sbd), which is created when you build the project. Open the Memories tab of Smart Bundle view to see the memory placement and size for each core. Sections that do not exist in FSP GCC linker script(project name/script/fspXXXX.ld) will not be displayed. To add a new section, add the definition of ddsc symbols(ddscSTART and ddscEND) to linker script. Implementation ExampleAdd xSPI0CS0 section SECTIONS  ...Omission of intermediate part... .xspi  AT (xSPI0CS0SPACEPRVSTART)  xspistart  .; KEEP((.xspi)) xspiend  .;   xSPI0CS0SPACE  ddscxSPI0CS0SPACESTART  ORIGIN(xSPI0CS0SPACE); ddscxSPI0CS0SPACEEND  xspiend; Suitable Products RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L .xspi  AT (xSPI0CS0SPACEPRVSTART) xspistart  .; KEEP((.xspi)) xspiend  .;   xSPI0CS0SPACE ","['The image shows a screenshot of a computer program, specifically the Project Explorer window in Visual Studio. The window is open on a Windows computer, and it displays a list of files and folders in the current project.\n\n*   **Project Explorer Window**\n    *   The Project Explorer window is open on the left side of the screen.\n    *   It displays a list of files and folders in the current project.\n    *   The list includes folders such as ""Blinky"", ""Debug"", and ""Blinky.sbd"".\n    *   Each folder has a series of files and subfolders listed underneath it.\n*   **File Menu**\n    *   The File menu is located at the top of the screen.\n    *   It includes options such as ""New"", ""Open"", ""Save"", and ""Exit"".\n*   **Edit Menu**\n    *   The Edit menu is also located at the top of the screen.\n    *   It includes options such as ""Undo"", ""Redo"", ""Cut"", ""Copy"", and ""Paste"".\n*   **Navigation Bar**\n    *   The navigation bar is located at the top of the screen.\n    *   It includes buttons for navigating through the project, such as ""Back"", ""Forward"", and ""Refresh"".\n*   **Status Bar**\n    *   The status bar is located at the bottom of the screen.\n    *   It displays information about the current file or folder, such as its name, size, and location.\n\nOverall, the image shows a typical Project Explorer window in Visual Studio, with a list of files and folders and various menus and buttons for navigating and editing the project.', 'The image shows a screenshot of a computer screen displaying a code editor with a red box highlighting a specific section of code. The code is written in C# and appears to be part of a larger program.\n\n*   The code editor is open on a Windows computer, as indicated by the Windows logo in the top-left corner.\n*   The code is written in C# and includes several lines of code, including variables, functions, and loops.\n*   The red box highlights a specific section of code that reads: `xspi_start = .; KEEP((xspi)); xspi_end = .; xspi_CS0_SPACE`.\n*   The code is likely part of a larger program that interacts with hardware or other systems.\n*   The use of the `xspi` variable and the `KEEP` function suggests that the code is related to serial peripheral interface (SPI) communication.\n*   The `xspi_CS0_SPACE` variable is likely a constant or a macro that represents a specific memory address or register.\n\nOverall, the image suggests that the code is part of a larger program that interacts with hardware or other systems using SPI communication. The highlighted section of code appears to be responsible for initializing and configuring the SPI interface.']"
153f60c2408d5bf988a443daf4a23364,"Question:
For multicore processing using RZ/T2M device, I create projects and build them in e2 studio with reference to RZ/T2,RZ/N2 Getting Started with Flexible Software Package. 
When I try to connect to the debugger in the secondary project with the debugger connected in the primary project, the following error occurs and the debugger does not start. What is the cause?
(The error message is ""Command ... is timed out"". Which command times out depends on the situation.)
Answer:
If the download does not finish within the GDB command timeout period, the startup may fail.
Please refer to the related FAQ: e² studio debugger failed with timeout error to extend the timeout period.
Suitable Products
RZ/T2M, RZ/T2ME, RZ/T2H
For multicore processing using RZ/T2M device, I create projects and build them in e2 studio with reference to RZ/T2,RZ/N2 Getting Started with Flexible Software Package. 
When I try to connect to the debugger in the secondary project with the debugger connected in the primary project, the following error occurs and the debugger does not start. What is the cause?
(The error message is ""Command ... is timed out"". Which command times out depends on the situation.)
For multicore processing using RZ/T2M device, I create projects and build them in e2 studio with reference to RZ/T2,RZ/N2 Getting Started with Flexible Software Package. 
When I try to connect to the debugger in the secondary project with the debugger connected in the primary project, the following error occurs and the debugger does not start. What is the cause?
(The error message is ""Command ... is timed out"". Which command times out depends on the situation.)
Answer:
If the download does not finish within the GDB command timeout period, the startup may fail.
Please refer to the related FAQ: e² studio debugger failed with timeout error to extend the timeout period.
Suitable Products
RZ/T2M, RZ/T2ME, RZ/T2H
If the download does not finish within the GDB command timeout period, the startup may fail.
Please refer to the related FAQ: e² studio debugger failed with timeout error to extend the timeout period.
If the download does not finish within the GDB command timeout period, the startup may fail.
Please refer to the related FAQ: e² studio debugger failed with timeout error to extend the timeout period.
Suitable Products
RZ/T2M, RZ/T2ME, RZ/T2H
日本語
日本語",['data/categories/rz_family/rzt2_rzn2_fsp/153f60c2408d5bf988a443daf4a23364/images/a3c76ad5aabee3a6e24636c6b898d6d7.png'],[],"['|  |\n|  |\n| RZ/T2M, RZ/T2ME, RZ/T2H |']","{'title': 'RZ/T2M: Cannot debug a secondary project for multicore processing with flash boot mode in e² studio.', 'url': 'https://en-support.renesas.com/knowledgeBase/21733880', 'last_updated': None, 'extracted_at': '2025-03-08T23:52:28.383648'}","Question For multicore processing using RZ/T2M device, I create projects and build them in e2 studio with reference to RZ/T2,RZ/N2 Getting Started with Flexible Software Package. When I try to connect to the debugger in the secondary project with the debugger connected in the primary project, the following error occurs and the debugger does not start. What is the cause? (The error message is ""Command ... is timed out"". Which command times out depends on the situation.) Answer If the download does not finish within the GDB command timeout period, the startup may fail. Please refer to the related FAQ e studio debugger failed with timeout error to extend the timeout period. Suitable Products RZ/T2M, RZ/T2ME, RZ/T2H ","['The image shows a screenshot of a computer error message. The error message is titled ""Problem Occurred"" and has a red circle with a white X in it to the left of the title. Below the title, there are two lines of text: ""Launching <Project name>"" and ""Debug has encountered a problem."" Below these lines, there is a line of text that reads ""Error in final launch sequence:"" followed by a command line with the text ""Command \'load C:\\# <Project path>YY<Project name> .elf 0x0\' is timed out.""\n\nAt the bottom of the window, there are two buttons: ""OK"" and ""Details"". The ""OK"" button is highlighted in blue, indicating that it is the default action. The background of the window is light gray.\n\nOverall, the image suggests that the computer has encountered an error while launching a project, and the user needs to take action to resolve the issue.']"
9cd77df4afd29800aac5905a344d1bfb,"Question:
Do I need any settings to use J-Link RTT with RZ/T2 and RZ/N2 (Cortex-R52) devices?
Answer:
RTT (Real time transfer) communication is performed by placing a “SEGGER RTT Control Block” and a “buffer for reading/writing data” in the memory.(https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/)
In case RZ/T2 devices, these data are placed in the SystemRAM area without cache for the following reasons.
 - The assigned addresses on each memory mapping of the CPU and AXI-AP is the same memory area. (e.g. ATCM cannot be used because the assigned addresses are different between the CPU and CoreSight (AXI-AP).)
 - No-cache areas are recommended because they are accessed by multiple bus masters.
To use J-Link RTT with Cortex-R52 core of RZ/T2 and RZ/N2 devices, make the following changes.
File to be changed
linker script(.ld) in {project name}/script
Chnages
Add the section definition for RTT to the .data_noncache section (SystemRAM area without cache) of the GCC linker script. Also, move the .data_noncache section before the .bss section, since the section for RTT is defined in the .bss section if it is after .bss.
1. Move .data_noncache section to the previous of .bss section(to avoid .data_noncache section being defined in .bss)
2. Add the following definitions in .data_noncache section.

    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
In the case of RZ/T FSP v2.2.0

.data_noncache DATA_NONCACHE_START : AT (DATA_NONCACHE_INIT_START)
{
    . = ((0 == HAS_SYSTEM_RAM_MIRROR) && (DEFINED(CR52_0) || DEFINED(CR52_1))) ? ALIGN(64) : ALIGN(8);
    _data_noncache_start = .;
    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
    KEEP(*(.data_noncache*))
    _data_noncache_end = .;
} > NONCACHE
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
Do I need any settings to use J-Link RTT with RZ/T2 and RZ/N2 (Cortex-R52) devices?
Do I need any settings to use J-Link RTT with RZ/T2 and RZ/N2 (Cortex-R52) devices?
Answer:
RTT (Real time transfer) communication is performed by placing a “SEGGER RTT Control Block” and a “buffer for reading/writing data” in the memory.(https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/)
In case RZ/T2 devices, these data are placed in the SystemRAM area without cache for the following reasons.
 - The assigned addresses on each memory mapping of the CPU and AXI-AP is the same memory area. (e.g. ATCM cannot be used because the assigned addresses are different between the CPU and CoreSight (AXI-AP).)
 - No-cache areas are recommended because they are accessed by multiple bus masters.
To use J-Link RTT with Cortex-R52 core of RZ/T2 and RZ/N2 devices, make the following changes.
File to be changed
linker script(.ld) in {project name}/script
Chnages
Add the section definition for RTT to the .data_noncache section (SystemRAM area without cache) of the GCC linker script. Also, move the .data_noncache section before the .bss section, since the section for RTT is defined in the .bss section if it is after .bss.
1. Move .data_noncache section to the previous of .bss section(to avoid .data_noncache section being defined in .bss)
2. Add the following definitions in .data_noncache section.

    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
In the case of RZ/T FSP v2.2.0

.data_noncache DATA_NONCACHE_START : AT (DATA_NONCACHE_INIT_START)
{
    . = ((0 == HAS_SYSTEM_RAM_MIRROR) && (DEFINED(CR52_0) || DEFINED(CR52_1))) ? ALIGN(64) : ALIGN(8);
    _data_noncache_start = .;
    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
    KEEP(*(.data_noncache*))
    _data_noncache_end = .;
} > NONCACHE
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
RTT (Real time transfer) communication is performed by placing a “SEGGER RTT Control Block” and a “buffer for reading/writing data” in the memory.(https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/)
In case RZ/T2 devices, these data are placed in the SystemRAM area without cache for the following reasons.
 - The assigned addresses on each memory mapping of the CPU and AXI-AP is the same memory area. (e.g. ATCM cannot be used because the assigned addresses are different between the CPU and CoreSight (AXI-AP).)
 - No-cache areas are recommended because they are accessed by multiple bus masters.
To use J-Link RTT with Cortex-R52 core of RZ/T2 and RZ/N2 devices, make the following changes.
File to be changed
linker script(.ld) in {project name}/script
Chnages
Add the section definition for RTT to the .data_noncache section (SystemRAM area without cache) of the GCC linker script. Also, move the .data_noncache section before the .bss section, since the section for RTT is defined in the .bss section if it is after .bss.
1. Move .data_noncache section to the previous of .bss section(to avoid .data_noncache section being defined in .bss)
2. Add the following definitions in .data_noncache section.

    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
In the case of RZ/T FSP v2.2.0

.data_noncache DATA_NONCACHE_START : AT (DATA_NONCACHE_INIT_START)
{
    . = ((0 == HAS_SYSTEM_RAM_MIRROR) && (DEFINED(CR52_0) || DEFINED(CR52_1))) ? ALIGN(64) : ALIGN(8);
    _data_noncache_start = .;
    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
    KEEP(*(.data_noncache*))
    _data_noncache_end = .;
} > NONCACHE
RTT (Real time transfer) communication is performed by placing a “SEGGER RTT Control Block” and a “buffer for reading/writing data” in the memory.(https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/)
In case RZ/T2 devices, these data are placed in the SystemRAM area without cache for the following reasons.
 - The assigned addresses on each memory mapping of the CPU and AXI-AP is the same memory area. (e.g. ATCM cannot be used because the assigned addresses are different between the CPU and CoreSight (AXI-AP).)
 - No-cache areas are recommended because they are accessed by multiple bus masters.
To use J-Link RTT with Cortex-R52 core of RZ/T2 and RZ/N2 devices, make the following changes.
File to be changed
linker script(.ld) in {project name}/script
Chnages
Add the section definition for RTT to the .data_noncache section (SystemRAM area without cache) of the GCC linker script. Also, move the .data_noncache section before the .bss section, since the section for RTT is defined in the .bss section if it is after .bss.
1. Move .data_noncache section to the previous of .bss section(to avoid .data_noncache section being defined in .bss)
2. Add the following definitions in .data_noncache section.

    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
*(.bss._SEGGER_RTT)
*(.bss._acDownBuffer)
*(.bss._acUpBuffer)
In the case of RZ/T FSP v2.2.0

.data_noncache DATA_NONCACHE_START : AT (DATA_NONCACHE_INIT_START)
{
    . = ((0 == HAS_SYSTEM_RAM_MIRROR) && (DEFINED(CR52_0) || DEFINED(CR52_1))) ? ALIGN(64) : ALIGN(8);
    _data_noncache_start = .;
    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
    KEEP(*(.data_noncache*))
    _data_noncache_end = .;
} > NONCACHE
*(.bss._SEGGER_RTT)
*(.bss._acDownBuffer)
*(.bss._acUpBuffer)
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
日本語
日本語",['data/categories/rz_family/rzt2_rzn2_fsp/9cd77df4afd29800aac5905a344d1bfb/images/71aab7ea9fd7135b3b2e4aab9120bf8b.png'],[],"['|  |\n|  |\n| RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L |']","{'title': 'How to use J-Link RTT with RZ/T2 and RZ/N2 (Cortex-R52) devices', 'url': 'https://en-support.renesas.com/knowledgeBase/21733882', 'last_updated': None, 'extracted_at': '2025-03-08T23:52:31.342371'}","Question Do I need any settings to use J-Link RTT with RZ/T2 and RZ/N2 (Cortex-R52) devices? Answer RTT (Real time transfer) communication is performed by placing a SEGGER RTT Control Block and a buffer for reading/writing data in the memory.(https//www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/) In case RZ/T2 devices, these data are placed in the SystemRAM area without cache for the following reasons. - The assigned addresses on each memory mapping of the CPU and AXI-AP is the same memory area. (e.g. ATCM cannot be used because the assigned addresses are different between the CPU and CoreSight (AXI-AP).) - No-cache areas are recommended because they are accessed by multiple bus masters. To use J-Link RTT with Cortex-R52 core of RZ/T2 and RZ/N2 devices, make the following changes. File to be changed linker script(.ld) in project name/script Chnages Add the section definition for RTT to the .datanoncache section (SystemRAM area without cache) of the GCC linker script. Also, move the .datanoncache section before the .bss section, since the section for RTT is defined in the .bss section if it is after .bss. 1. Move .datanoncache section to the previous of .bss section(to avoid .datanoncache section being defined in .bss) 2. Add the following definitions in .datanoncache section. (.bss.SEGGERRTT) (.bss.acDownBuffer) (.bss.acUpBuffer) In the case of RZ/T FSP v2.2.0 .datanoncache DATANONCACHESTART  AT (DATANONCACHEINITSTART)  .  ((0  HASSYSTEMRAMMIRROR)  (DEFINED(CR520)  DEFINED(CR521))) ? ALIGN(64)  ALIGN(8); datanoncachestart  .; KEEP((.datanoncache)) datanoncacheend  .;   NONCACHE Suitable Products RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L (.bss.SEGGERRTT) (.bss.acDownBuffer) (.bss.acUpBuffer) ","['The image shows a screenshot of a computer program in a code editor, with a red box highlighting a specific section of code. The code is written in C++ and appears to be part of a larger program.\n\nHere are the details of the image:\n\n*   **Code Editor:**\n    *   The code editor is open on a computer screen.\n    *   The editor has a gray background with black text.\n    *   The code is written in C++ and includes various keywords and symbols.\n*   **Highlighted Code:**\n    *   A red box highlights a specific section of code.\n    *   The highlighted code includes several lines of code that appear to be related to memory management.\n    *   The code includes variables, functions, and data types.\n*   **Background:**\n    *   The background of the image is a light gray color.\n    *   There are no other objects or elements in the background.\n\nOverall, the image appears to be a screenshot of a computer program in a code editor, with a specific section of code highlighted in red. The code is written in C++ and includes various keywords and symbols related to memory management.']"
1e7a6124b197aac1b88db40dfb0d8be2,"Question:
What are RL78 Family microcontrollers with minimal power consumption?
Answer:
The RL78/G22.
Power consumption is among the lowest in the industry at 37.5 µA in CPU RUN mode and 0.20 µA in STOP mode.
  Suitable Products
RL78/G22
What are RL78 Family microcontrollers with minimal power consumption?
What are RL78 Family microcontrollers with minimal power consumption?
Answer:
The RL78/G22.
Power consumption is among the lowest in the industry at 37.5 µA in CPU RUN mode and 0.20 µA in STOP mode.
  Suitable Products
RL78/G22
The RL78/G22.
Power consumption is among the lowest in the industry at 37.5 µA in CPU RUN mode and 0.20 µA in STOP mode.
  Suitable Products
The RL78/G22.
Power consumption is among the lowest in the industry at 37.5 µA in CPU RUN mode and 0.20 µA in STOP mode.
Suitable Products
RL78/G22
日本語 中文
日本語
中文",['data/categories/rl78_family/rl78g22/1e7a6124b197aac1b88db40dfb0d8be2/images/3a08ea13a8a3ef188c0538de5c9d16a4.png'],[],['|  |\n|  |\n| RL78/G22 |'],"{'title': 'RL78 Family microcontrollers with minimal power consumption', 'url': 'https://en-support.renesas.com/knowledgeBase/20788289', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:46.029267'}",Question What are RL78 Family microcontrollers with minimal power consumption? Answer The RL78/G22. Power consumption is among the lowest in the industry at 37.5 A in CPU RUN mode and 0.20 A in STOP mode. Suitable Products RL78/G22 Suitable Products    ,"[""The image presents a comparison of CPU run and stop times for various microprocessors, with a focus on their basic operation and RAM retention capabilities. The data is displayed in two bar graphs, each representing a different aspect of the microprocessors' performance.\n\n**CPU Run (Basic Operation)**\n\n*   **Microprocessors:**\n    *   M16C/62P\n    *   H8/300L 3802\n    *   R8C/38M\n    *   78K0/KF2\n    *   RL78/G13(128K)\n    *   RL78/G23(128K)\n    *   RL78/G22(64KB)\n*   **CPU Run Time (mA/MHz):**\n    *   M16C/62P: 37.5 μA/MHz\n    *   H8/300L 3802: 0.20 μA\n    *   R8C/38M: 0.1 μA\n    *   78K0/KF2: 0.2 μA\n    *   RL78/G13(128K): 0.3 μA\n    *   RL78/G23(128K): 0.4 μA\n    *   RL78/G22(64KB): 0.5 μA\n\n**STOP (RAM Retention)**\n\n*   **Microprocessors:**\n    *   R8C/38M\n    *   H8/300L 3802\n    *   78K0/KF2\n    *   M16C/62P\n    *   RL78/G13(128K)\n    *   RL78/G23(128K)\n    *   RL78/G22(64KB)\n*   **RAM Retention Time (μA):**\n    *   R8C/38M: 0.20 μA\n    *   H8/300L 3802: 0.1 μA\n    *   78K0/KF2: 0.2 μA\n    *   M16C/62P: 0.3 μA\n    *   RL78/G13(128K): 0.4 μA\n    *   RL78/G23(128K): 0.5 μA\n    *   RL78/G22(64KB): 0.6 μA\n\nIn summary, the image provides a detailed comparison of the CPU run and stop times for various microprocessors, highlighting their basic operation and RAM retention capabilities. The data is presented in two bar graphs, with the CPU run time measured in mA/MHz and the RAM retention time measured in μA. The results show that the M16C/62P has the highest CPU run time, while the RL78/G22(64KB) has the highest RAM retention time.""]"
536e04c610491bde7f77847a05f6effb,"Question:
How much current is consumed when measuring capacitive touch?
Answer:
SNOOZE mode sequencer (SMS) and multi-electrode connection function (MEC) reduce current consumption.
The average current consumption measured with a capacitive touch cycle of 100 ms is 9.7 μA (reference value for the RL78/G22).
  Figure 1: Current consumption results(Touch measurement using SMS/MEC function)
Please refer to this document for details.
RL78/G22 Capacitive Touch Low Power Guide (SMS / MEC function) (R01AN6847)
Suitable Products
RL78/G22
How much current is consumed when measuring capacitive touch?
How much current is consumed when measuring capacitive touch?
Answer:
SNOOZE mode sequencer (SMS) and multi-electrode connection function (MEC) reduce current consumption.
The average current consumption measured with a capacitive touch cycle of 100 ms is 9.7 μA (reference value for the RL78/G22).
  Figure 1: Current consumption results(Touch measurement using SMS/MEC function)
Please refer to this document for details.
RL78/G22 Capacitive Touch Low Power Guide (SMS / MEC function) (R01AN6847)
Suitable Products
RL78/G22
SNOOZE mode sequencer (SMS) and multi-electrode connection function (MEC) reduce current consumption.
The average current consumption measured with a capacitive touch cycle of 100 ms is 9.7 μA (reference value for the RL78/G22).
  Figure 1: Current consumption results(Touch measurement using SMS/MEC function)
Please refer to this document for details.
RL78/G22 Capacitive Touch Low Power Guide (SMS / MEC function) (R01AN6847)
Suitable Products
SNOOZE mode sequencer (SMS) and multi-electrode connection function (MEC) reduce current consumption.
The average current consumption measured with a capacitive touch cycle of 100 ms is 9.7 μA (reference value for the RL78/G22).
Figure 1: Current consumption results(Touch measurement using SMS/MEC function)
Please refer to this document for details.
RL78/G22 Capacitive Touch Low Power Guide (SMS / MEC function) (R01AN6847)
Suitable Products
RL78/G22
日本語 中文
日本語
中文",['data/categories/rl78_family/rl78g22/536e04c610491bde7f77847a05f6effb/images/6d889e5372360438633f9310ffc53244.png'],[],['|  |\n|  |\n| RL78/G22 |'],"{'title': 'RL78/G22: Current consumption when measuring capacitive touch', 'url': 'https://en-support.renesas.com/knowledgeBase/20982731', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:43.322021'}",Question How much current is consumed when measuring capacitive touch? Answer SNOOZE mode sequencer (SMS) and multi-electrode connection function (MEC) reduce current consumption. The average current consumption measured with a capacitive touch cycle of 100 ms is 9.7 A (reference value for the RL78/G22). Figure 1 Current consumption results(Touch measurement using SMS/MEC function) Please refer to this document for details. RL78/G22 Capacitive Touch Low Power Guide (SMS / MEC function) (R01AN6847) Suitable Products RL78/G22 Figure 1 Current consumption results(Touch measurement using SMS/MEC function)    ,"['The image presents a graph and a table, both of which are related to measurement data. The graph is a line graph with a black background, featuring a blue line that represents the data. The x-axis is labeled ""100ms"" and has a range of 0 to 0.24, while the y-axis is labeled ""0"" and has a range of 0 to 0.025. The graph also includes a purple line that represents the 100ms mark.\n\nBelow the graph is a table with a yellow header row that contains the following columns:\n\n*   **Measurement**: This column displays the measurement data, which is represented by the blue line in the graph.\n*   **Span**: This column shows the span of the measurement data, which is 10000.\n*   **Minimum**: This column displays the minimum value of the measurement data, which is -3.95730E-005.\n*   **Maximum**: This column shows the maximum value of the measurement data, which is 1.46082E-003.\n*   **Peak To Peak**: This column displays the peak-to-peak value of the measurement data, which is 1.50039E-003.\n*   **Standard Deviation**: This column shows the standard deviation of the measurement data, which is 9.43268E-005.\n*   **Mean**: This column displays the mean value of the measurement data, which is 9.68478E-006.\n*   **Median**: This column shows the median value of the measurement data, which is 7.57733E-007.\n\nOverall, the image provides a visual representation of the measurement data, along with various statistical metrics that can be used to analyze and understand the data.']"
1060b2aeacfc0b9c8616c6e2db45ff35,"Question:
How does the internal touch functionality of the RL78/G22 differ from that of the RL78/G23?
Answer:
Multiple electrode connection (MEC) functionality has been added to the CTSU2La featured on the RL78/G22.
Multiple touch channels can be connected to a single channel inside the MCU, and touch detection performed.
Figure 1: The CTSU2L (without MEC) and CTSU2La (with MEC)
Using MEC has the following benefits.
The unit can return from standby mode even when any of the touch channels have been touched.
Can be used as a single large proximity (contactless) sensor.
Touch channel measurement completes with a single scan, reducing power consumption compared to scanning a single channel at a time.
Figure 2: Comparison between measurement times for the RL78/G23 (without MEC) and the RL78/G22 (when using MEC)
Suitable Products
RL78/G22
How does the internal touch functionality of the RL78/G22 differ from that of the RL78/G23?
How does the internal touch functionality of the RL78/G22 differ from that of the RL78/G23?
Answer:
Multiple electrode connection (MEC) functionality has been added to the CTSU2La featured on the RL78/G22.
Multiple touch channels can be connected to a single channel inside the MCU, and touch detection performed.
Figure 1: The CTSU2L (without MEC) and CTSU2La (with MEC)
Using MEC has the following benefits.
The unit can return from standby mode even when any of the touch channels have been touched.
Can be used as a single large proximity (contactless) sensor.
Touch channel measurement completes with a single scan, reducing power consumption compared to scanning a single channel at a time.
Figure 2: Comparison between measurement times for the RL78/G23 (without MEC) and the RL78/G22 (when using MEC)
Suitable Products
RL78/G22
Multiple electrode connection (MEC) functionality has been added to the CTSU2La featured on the RL78/G22.
Multiple touch channels can be connected to a single channel inside the MCU, and touch detection performed.
Figure 1: The CTSU2L (without MEC) and CTSU2La (with MEC)
Using MEC has the following benefits.
The unit can return from standby mode even when any of the touch channels have been touched.
Can be used as a single large proximity (contactless) sensor.
Touch channel measurement completes with a single scan, reducing power consumption compared to scanning a single channel at a time.
Figure 2: Comparison between measurement times for the RL78/G23 (without MEC) and the RL78/G22 (when using MEC)
Suitable Products
Multiple electrode connection (MEC) functionality has been added to the CTSU2La featured on the RL78/G22.
Multiple touch channels can be connected to a single channel inside the MCU, and touch detection performed.
Figure 1: The CTSU2L (without MEC) and CTSU2La (with MEC)
Using MEC has the following benefits.
Figure 2: Comparison between measurement times for the RL78/G23 (without MEC) and the RL78/G22 (when using MEC)
Suitable Products
RL78/G22
日本語 中文
日本語
中文","['data/categories/rl78_family/rl78g22/1060b2aeacfc0b9c8616c6e2db45ff35/images/1b8fd22a17c2d1a537d0ab637d719628.png', 'data/categories/rl78_family/rl78g22/1060b2aeacfc0b9c8616c6e2db45ff35/images/3fe68907e911fbeffd7b22a77748ba54.png']",[],['|  |\n|  |\n| RL78/G22 |'],"{'title': 'Differences between the touch functionality of the RL78/G22 and RL78/G23', 'url': 'https://en-support.renesas.com/knowledgeBase/20824901', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:48.910151'}","Question How does the internal touch functionality of the RL78/G22 differ from that of the RL78/G23? Answer Multiple electrode connection (MEC) functionality has been added to the CTSU2La featured on the RL78/G22. Multiple touch channels can be connected to a single channel inside the MCU, and touch detection performed. Figure 1 The CTSU2L (without MEC) and CTSU2La (with MEC) Using MEC has the following benefits. The unit can return from standby mode even when any of the touch channels have been touched. Can be used as a single large proximity (contactless) sensor. Touch channel measurement completes with a single scan, reducing power consumption compared to scanning a single channel at a time. Figure 2 Comparison between measurement times for the RL78/G23 (without MEC) and the RL78/G22 (when using MEC) Suitable Products RL78/G22    ","['The image presents a comparison between two versions of a system, with the left side representing the older version (RL78/G23) and the right side representing the newer version (RL78/G22). The image is divided into two main sections, each containing a green rectangle with white text, accompanied by blue and yellow rectangles.\n\n**Left Side (RL78/G23):**\n\n*   **Green Rectangle:** CTSU2L\n*   **Blue Rectangle:** RL78/G23\n*   **Yellow Rectangles:** Four yellow rectangles are connected to the green rectangle, indicating the detection of touches in order on each channel, one at a time.\n\n**Right Side (RL78/G22):**\n\n*   **Green Rectangle:** New CTSU2La\n*   **Blue Rectangle:** RL78/G22\n*   **Yellow Rectangles:** Four yellow rectangles are connected to the green rectangle, indicating the connection of all channels and detection of touch as a single channel.\n\nThe image effectively illustrates the key differences between the two versions of the system, highlighting the improvements made in the newer version.', 'The image presents a flowchart illustrating the process of measuring time in a multiple electrode connection (MEC) functionality. The chart is divided into two sections, each representing a different scenario: G23 (CTSU2L) and G22 (CTSU2La).\n\n**G23 (CTSU2L) Scenario:**\n\n*   **Default Settings:** The process begins with default settings.\n*   **CH1 Measurement:** The first step involves measuring CH1.\n*   **CH2 Measurement:** Following CH1 measurement, CH2 is measured.\n*   **CH3 Measurement:** After CH2 measurement, CH3 is measured.\n*   **ON/OFF Decision:** The results of the measurements are used to make an ON/OFF decision.\n*   **Finish:** The process concludes with the finish step.\n\n**G22 (CTSU2La) Scenario:**\n\n*   **Default Settings:** The process starts with default settings.\n*   **CH1+CH2+CH3 Measurement:** A single measurement is taken for CH1, CH2, and CH3.\n*   **ON/OFF Decision:** The result of the measurement is used to make an ON/OFF decision.\n*   **Finish:** The process ends with the finish step.\n\n**Key Features:**\n\n*   **Multiple Electrode Connection (MEC) Functionality:** The chart highlights the MEC functionality, which reduces measurement time.\n*   **Reduced Measurement Time:** The use of MEC functionality results in reduced measurement time.\n*   **Default Settings:** Both scenarios begin with default settings.\n*   **Measurement Steps:** The measurement steps vary between the two scenarios, with G23 involving separate measurements for each channel and G22 combining the measurements into a single step.\n\nIn summary, the image illustrates the process of measuring time in a multiple electrode connection (MEC) functionality, highlighting the differences between two scenarios: G23 (CTSU2L) and G22 (CTSU2La). The chart emphasizes the use of MEC functionality to reduce measurement time and provides a clear visual representation of the measurement process.']"
779ed323d666d0c8134a0a37e52e5d91,"Question:
When using the Serial Array Unit (SAU) to perform UART communication, how are start bit detection and data detection conducted?
Answer:
UART communication uses a start bit to determine the timing of data detection. 
  Start bit detection
To detect the start bit, the receive signal must be sampled, and the start bit detected. This sampling uses the SAU operating clock (fMCK) which generates the baud rate. There may be a delay of one cycle of the sampling clock when taking in the received signal into the SAU. If the sampling result is at a low level, it proceeds to the next step in the process.
When a low level is detected in the received signal, the counter of the baud rate generator begins operation. The detection of the start bit is performed at a position that is half the width of one bit as determined by the baud rate setting, near the center of one bit width. If the sampling result is at a low level, it is determined to be a start bit, and data detection is carried out.
The sampling result is judged as noise if it is at a high level, and the process of detection of the start bit is started again.
  Data detection
Data detection uses sampling which  is conducted at intervals of one bit each, as determined by the baud rate setting, starting from the detection point of the start bit, which is near the middle of a 1-bit width.
Remark
fCLK :     CPU/peripheral hardware clock frequency
fMCK :     Sampling clock
fTCLK :    Transfer clock used in shift register
Suitable Products
RL78 Family
When using the Serial Array Unit (SAU) to perform UART communication, how are start bit detection and data detection conducted?
When using the Serial Array Unit (SAU) to perform UART communication, how are start bit detection and data detection conducted?
Answer:
UART communication uses a start bit to determine the timing of data detection. 
  Start bit detection
To detect the start bit, the receive signal must be sampled, and the start bit detected. This sampling uses the SAU operating clock (fMCK) which generates the baud rate. There may be a delay of one cycle of the sampling clock when taking in the received signal into the SAU. If the sampling result is at a low level, it proceeds to the next step in the process.
When a low level is detected in the received signal, the counter of the baud rate generator begins operation. The detection of the start bit is performed at a position that is half the width of one bit as determined by the baud rate setting, near the center of one bit width. If the sampling result is at a low level, it is determined to be a start bit, and data detection is carried out.
The sampling result is judged as noise if it is at a high level, and the process of detection of the start bit is started again.
  Data detection
Data detection uses sampling which  is conducted at intervals of one bit each, as determined by the baud rate setting, starting from the detection point of the start bit, which is near the middle of a 1-bit width.
Remark
fCLK :     CPU/peripheral hardware clock frequency
fMCK :     Sampling clock
fTCLK :    Transfer clock used in shift register
Suitable Products
RL78 Family
UART communication uses a start bit to determine the timing of data detection. 
  Start bit detection
To detect the start bit, the receive signal must be sampled, and the start bit detected. This sampling uses the SAU operating clock (fMCK) which generates the baud rate. There may be a delay of one cycle of the sampling clock when taking in the received signal into the SAU. If the sampling result is at a low level, it proceeds to the next step in the process.
When a low level is detected in the received signal, the counter of the baud rate generator begins operation. The detection of the start bit is performed at a position that is half the width of one bit as determined by the baud rate setting, near the center of one bit width. If the sampling result is at a low level, it is determined to be a start bit, and data detection is carried out.
The sampling result is judged as noise if it is at a high level, and the process of detection of the start bit is started again.
  Data detection
Data detection uses sampling which  is conducted at intervals of one bit each, as determined by the baud rate setting, starting from the detection point of the start bit, which is near the middle of a 1-bit width.
Remark
fCLK :     CPU/peripheral hardware clock frequency
fMCK :     Sampling clock
fTCLK :    Transfer clock used in shift register
UART communication uses a start bit to determine the timing of data detection.
Start bit detection
To detect the start bit, the receive signal must be sampled, and the start bit detected. This sampling uses the SAU operating clock (fMCK) which generates the baud rate. There may be a delay of one cycle of the sampling clock when taking in the received signal into the SAU. If the sampling result is at a low level, it proceeds to the next step in the process.
When a low level is detected in the received signal, the counter of the baud rate generator begins operation. The detection of the start bit is performed at a position that is half the width of one bit as determined by the baud rate setting, near the center of one bit width. If the sampling result is at a low level, it is determined to be a start bit, and data detection is carried out.
The sampling result is judged as noise if it is at a high level, and the process of detection of the start bit is started again.
Data detection
Data detection uses sampling which  is conducted at intervals of one bit each, as determined by the baud rate setting, starting from the detection point of the start bit, which is near the middle of a 1-bit width.
Remark
fCLK :     CPU/peripheral hardware clock frequency
fMCK :     Sampling clock
fTCLK :    Transfer clock used in shift register
Suitable Products
RL78 Family
日本語
日本語","['data/categories/rl78_family/communication_function/779ed323d666d0c8134a0a37e52e5d91/images/56f4fdda5157f926ed2ef6296aa3a952.png', 'data/categories/rl78_family/communication_function/779ed323d666d0c8134a0a37e52e5d91/images/3d232ebfcb80d615fadd3cdc4d169a11.png', 'data/categories/rl78_family/communication_function/779ed323d666d0c8134a0a37e52e5d91/images/d9362f4f7f703945cef78526fe060c61.png', 'data/categories/rl78_family/communication_function/779ed323d666d0c8134a0a37e52e5d91/images/a6802f75612c47fec22614d5280b16d2.png']",[],['|  |\n|  |\n| RL78 Family |'],"{'title': 'UART Reception Timing when using Serial Array Unit', 'url': 'https://en-support.renesas.com/knowledgeBase/21373720', 'last_updated': None, 'extracted_at': '2025-03-08T23:57:30.144946'}","Question When using the Serial Array Unit (SAU) to perform UART communication, how are start bit detection and data detection conducted? Answer UART communication uses a start bit to determine the timing of data detection. Start bit detection To detect the start bit, the receive signal must be sampled, and the start bit detected. This sampling uses the SAU operating clock (fMCK) which generates the baud rate. There may be a delay of one cycle of the sampling clock when taking in the received signal into the SAU. If the sampling result is at a low level, it proceeds to the next step in the process. When a low level is detected in the received signal, the counter of the baud rate generator begins operation. The detection of the start bit is performed at a position that is half the width of one bit as determined by the baud rate setting, near the center of one bit width. If the sampling result is at a low level, it is determined to be a start bit, and data detection is carried out. The sampling result is judged as noise if it is at a high level, and the process of detection of the start bit is started again. Data detection Data detection uses sampling which is conducted at intervals of one bit each, as determined by the baud rate setting, starting from the detection point of the start bit, which is near the middle of a 1-bit width. Remark fCLK  CPU/peripheral hardware clock frequency fMCK  Sampling clock fTCLK  Transfer clock used in shift register Suitable Products RL78 Family UART communication uses a start bit to determine the timing of data detection. Start bit detection Data detection ","['The image depicts a graph illustrating the relationship between sampling interval and delay due to synchronization. The graph features two axes: the x-axis represents the sampling interval, while the y-axis represents the delay due to synchronization.\n\n**Key Components:**\n\n*   **Received Signal:** A horizontal line at the top of the graph, representing the received signal.\n*   **Sampling Timing:** A series of vertical lines below the received signal, indicating the sampling timing.\n*   **Sampling Interval:** A horizontal line below the sampling timing, representing the sampling interval.\n*   **Delay Due to Synchronization:** A vertical line at the bottom of the graph, representing the delay due to synchronization.\n\n**Graphical Representation:**\n\nThe graph shows that as the sampling interval increases, the delay due to synchronization also increases. This is represented by the vertical line moving further to the right as the sampling interval increases.\n\n**Conclusion:**\n\nIn conclusion, the graph illustrates the relationship between sampling interval and delay due to synchronization. As the sampling interval increases, the delay due to synchronization also increases. This suggests that increasing the sampling interval can lead to a longer delay in synchronization, which may have implications for signal processing and analysis.', 'The image depicts a diagram of a signal transmission process, specifically focusing on the sampling timing and baud rate setting. The diagram is divided into two main sections: the ""Received signal"" and the ""Sampling timing.""\n\n**Received Signal:**\n\n*   The received signal is represented by a waveform that shows the amplitude of the signal over time.\n*   The waveform has a peak amplitude and a trough amplitude, indicating the maximum and minimum values of the signal.\n\n**Sampling Timing:**\n\n*   The sampling timing is represented by a vertical line that intersects the received signal waveform at a specific point.\n*   The point of intersection is determined by the baud rate setting, which is indicated by a label on the diagram.\n*   The baud rate setting is represented by a value, which is not specified in the diagram.\n\n**Baud Rate Setting:**\n\n*   The baud rate setting is determined by the half of 1-bit width, as indicated by the label on the diagram.\n*   This means that the baud rate is set to half of the width of a single bit, which is a common method for determining the baud rate in digital communication systems.\n\n**Determined as Start Bit:**\n\n*   The determined as start bit label indicates that the point of intersection between the received signal and the sampling timing is used to determine the start of a new bit.\n*   This is a common technique used in digital communication systems to synchronize the receiver with the transmitter.\n\nIn summary, the diagram shows the process of sampling a received signal at a specific point in time, determined by the baud rate setting. The baud rate is set to half of the width of a single bit, and the point of intersection is used to determine the start of a new bit. This technique is commonly used in digital communication systems to ensure accurate data transmission.', 'The image depicts a signal waveform with various annotations, including:\n\n*   **Received signal**: The waveform itself, which is a square wave with a flat top and bottom.\n*   **Sampling timing**: A horizontal line that intersects the waveform at several points, indicating where the signal is being sampled.\n*   **Half of 1-bit width determined by baud rate setting**: A vertical line that intersects the waveform at a point, indicating the width of the signal pulse.\n*   **Determined as noise**: A horizontal line that intersects the waveform at a point, indicating where the signal is determined to be noise.\n\nThe image appears to be a technical diagram illustrating the process of sampling a signal and determining its quality. The annotations provide additional information about the signal and the sampling process, such as the timing of the samples and the width of the signal pulse. Overall, the image suggests that the signal is being sampled at regular intervals and that the quality of the signal is being evaluated based on its amplitude and duration.', 'The image depicts a signal processing diagram, specifically illustrating the process of sampling a signal. The diagram is divided into two main sections: the top section shows the received signal, and the bottom section illustrates the sampling timing.\n\n**Top Section: Received Signal**\n\n*   The received signal is represented by a waveform that oscillates between positive and negative values.\n*   The signal has a clear peak and trough, indicating its amplitude and frequency.\n\n**Bottom Section: Sampling Timing**\n\n*   The sampling timing is determined by a 1-bit interval, which is set by the baud rate.\n*   The sampling points are marked by arrows, indicating when the signal is being sampled.\n*   The sampling interval is uniform, with equal spacing between each sample.\n\n**Key Features**\n\n*   The diagram highlights the importance of accurate sampling timing in signal processing.\n*   The use of a 1-bit interval ensures that the signal is sampled at regular intervals, allowing for precise analysis and processing.\n*   The diagram does not provide any additional information about the signal or its context, but it serves as a clear illustration of the sampling process.\n\n**Conclusion**\n\nIn conclusion, the image provides a clear and concise representation of the sampling process in signal processing. The diagram effectively illustrates the relationship between the received signal and the sampling timing, highlighting the importance of accurate sampling in signal analysis and processing.']"
354d396c714dcc1ee28a203db036a75f,"Last updated: 01 Nov 2024
Why do I get 'Section .bss cannot be placed on the TRACERAM area' error when trying to build the project ?
The .bss area overlaps with the trace RAM area which on R7F100GxN is F4300H to F46FFH.
The trace RAM area is an area in RAM which is used for the trace function of the debugger.
You can disable the trace function and the problem should be gone. Otherwise you need to reserve this space for trace RAM only
Alternatively, you can modify the start address of .bss section on linker settings to F4700H (right after the trace RAM area ends).
Suitable Products",['data/categories/rl78_family/rl78g23/354d396c714dcc1ee28a203db036a75f/images/c096aea49792f1b9c5e24c23ed0e23cd.png'],[],"['|  |\n|  |\n| RL78/G2x, RL78/F2x |']","{'title': 'Trace RAM area error', 'url': 'https://en-support.renesas.com/knowledgeBase/21662907', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:18.968576'}","Last updated 01 Nov 2024 Why do I get 'Section .bss cannot be placed on the TRACERAM area' error when trying to build the project ? The .bss area overlaps with the trace RAM area which on R7F100GxN is F4300H to F46FFH. The trace RAM area is an area in RAM which is used for the trace function of the debugger. You can disable the trace function and the problem should be gone. Otherwise you need to reserve this space for trace RAM only Alternatively, you can modify the start address of .bss section on linker settings to F4700H (right after the trace RAM area ends). Suitable Products","['The image shows a screenshot of a computer program\'s settings page, specifically the ""On-chip debug setting"" section. The page is divided into two columns, with the left column listing various settings and the right column displaying the corresponding options.\n\n**Left Column:**\n\n* On-chip debug operation setting\n* Emulator setting\n* Pseudo-RRM/DMM function setting\n* Start/Stop function setting\n* Monitoring point function setting\n* Trace function setting\n* Security ID setting\n* Security ID authentication failure setting\n\n**Right Column:**\n\n* Unused\n* Use emulator\n* COM Port\n* E2 Lite\n* Unused\n* Used\n* Unused\n* Used\n* 0x000000000000000000000000\n* Do not erase flash memory data\n* Erase flash memory data\n\nThe background of the page is white, with black text and gray icons. The overall design is clean and simple, making it easy to navigate and understand the various settings options.']"
ef3b2c005ab3fb7f98bc38d5711a77d2,"Question:
What are the differences between the RL78/G23, RL78/G22, and RL78/G13?
Answer:
Differences in functions and lineups are shown in the figure below. The RL78/G23 and RL78/G22 are new generation series in the RL78 Family and utilize new development processes to achieve low power consumption. In addition, they are equipped with new functions such as capacitive touch sensors and Event Link Controllers. The RL78/G22 features many touch channels, and has the lowest power consumption of any product in the RL78 Family.
Additionally, the RL78 Family lineup has been expanded with the RL78/G23, which is offered with a large-capacity ROM package of up to 768 KB, and the RL78/G22, which is available with a minimum 16-pin package.
Figure 1: Function comparison table
Figure 2: Lineup comparison table
Suitable Products
RL78/G22, RL78/G23, RL78/G13
What are the differences between the RL78/G23, RL78/G22, and RL78/G13?
What are the differences between the RL78/G23, RL78/G22, and RL78/G13?
Answer:
Differences in functions and lineups are shown in the figure below. The RL78/G23 and RL78/G22 are new generation series in the RL78 Family and utilize new development processes to achieve low power consumption. In addition, they are equipped with new functions such as capacitive touch sensors and Event Link Controllers. The RL78/G22 features many touch channels, and has the lowest power consumption of any product in the RL78 Family.
Additionally, the RL78 Family lineup has been expanded with the RL78/G23, which is offered with a large-capacity ROM package of up to 768 KB, and the RL78/G22, which is available with a minimum 16-pin package.
Figure 1: Function comparison table
Figure 2: Lineup comparison table
Suitable Products
RL78/G22, RL78/G23, RL78/G13
Differences in functions and lineups are shown in the figure below. The RL78/G23 and RL78/G22 are new generation series in the RL78 Family and utilize new development processes to achieve low power consumption. In addition, they are equipped with new functions such as capacitive touch sensors and Event Link Controllers. The RL78/G22 features many touch channels, and has the lowest power consumption of any product in the RL78 Family.
Additionally, the RL78 Family lineup has been expanded with the RL78/G23, which is offered with a large-capacity ROM package of up to 768 KB, and the RL78/G22, which is available with a minimum 16-pin package.
Figure 1: Function comparison table
Figure 2: Lineup comparison table
Differences in functions and lineups are shown in the figure below. The RL78/G23 and RL78/G22 are new generation series in the RL78 Family and utilize new development processes to achieve low power consumption. In addition, they are equipped with new functions such as capacitive touch sensors and Event Link Controllers. The RL78/G22 features many touch channels, and has the lowest power consumption of any product in the RL78 Family.
Additionally, the RL78 Family lineup has been expanded with the RL78/G23, which is offered with a large-capacity ROM package of up to 768 KB, and the RL78/G22, which is available with a minimum 16-pin package.
Figure 1: Function comparison table
Figure 2: Lineup comparison table
Suitable Products
RL78/G22, RL78/G23, RL78/G13
日本語 中文
日本語
中文","['data/categories/rl78_family/rl78g23/ef3b2c005ab3fb7f98bc38d5711a77d2/images/56f5968fd6a5e60c1aeccec79a8123af.png', 'data/categories/rl78_family/rl78g23/ef3b2c005ab3fb7f98bc38d5711a77d2/images/08b19e328398d685a16c3c67fe507025.png']",[],"['|  |\n|  |\n| RL78/G22, RL78/G23, RL78/G13 |']","{'title': 'Differences between the RL78/G23, RL78/G22, and RL78/G13', 'url': 'https://en-support.renesas.com/knowledgeBase/20824905', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:26.646466'}","Question What are the differences between the RL78/G23, RL78/G22, and RL78/G13? Answer Differences in functions and lineups are shown in the figure below. The RL78/G23 and RL78/G22 are new generation series in the RL78 Family and utilize new development processes to achieve low power consumption. In addition, they are equipped with new functions such as capacitive touch sensors and Event Link Controllers. The RL78/G22 features many touch channels, and has the lowest power consumption of any product in the RL78 Family. Additionally, the RL78 Family lineup has been expanded with the RL78/G23, which is offered with a large-capacity ROM package of up to 768 KB, and the RL78/G22, which is available with a minimum 16-pin package. Figure 1 Function comparison table Figure 2 Lineup comparison table Suitable Products RL78/G22, RL78/G23, RL78/G13    ","['The image presents a comprehensive comparison of three microcontrollers: RL78/G13, RL78/G22, and RL78/G23. The table is divided into two columns, with the left column listing the features of RL78/G13 and the right column listing the features of RL78/G22 and RL78/G23.\n\n**CPU Core**\n\n* RL78 S2 Core (RL78/G13)\n* RL78 S3 Core (RL78/G22 and RL78/G23)\n\n**Frequency Max.**\n\n* 32MHz (RL78/G13)\n* 32MHz (RL78/G22)\n* 32MHz (RL78/G23)\n\n**Operation Voltage**\n\n* 1.6 - 5.5V (RL78/G13)\n* 1.6 - 5.5V (RL78/G22)\n* 1.6 - 5.5V (RL78/G23)\n\n**Pin**\n\n* 20 - 128 pin (RL78/G13)\n* 16 - 48 pin (RL78/G22)\n* 30 - 128 pin (RL78/G23)\n\n**Code Flash memory**\n\n* 16KB - 512KB (RL78/G13)\n* 32 - 64KB (RL78/G22)\n* 96 - 768KB (RL78/G23)\n\n**Data Flash memory**\n\n* 4KB/8KB/None (RL78/G13)\n* 2KB (RL78/G22)\n* 8KB (RL78/G23)\n\n**RAM**\n\n* 2KB - 32KB (RL78/G13)\n* 4KB (RL78/G22)\n* 12 - 48 KB (RL78/G23)\n\n**Voltage of the flash memory writing**\n\n* 1.8 - 5.5V (RL78/G13)\n* 1.8 - 5.5V (RL78/G22)\n* 1.6 - 5.5V (RL78/G23)\n\n**Boot swap area**\n\n* 8KB (RL78/G13)\n* 8KB (RL78/G22)\n* 16KB (RL78/G23)\n\n**ADC resolution**\n\n* 10bit (RL78/G13)\n* 10bit (RL78/G22)\n* 12bit (RL78/G23)\n\n**Event link controller function**\n\n* - (RL78/G13)\n* ELC (Event Link Controller) (RL78/G22)\n* ELCL (Logic & Event Link Controller) (RL78/G23)\n\n**Data Transfer**\n\n* DMA Controller (4ch) (RL78/G13)\n* Data Transfer Controller (DTC) (RL78/G22)\n* Data Transfer Controller (DTC) (RL78/G23)\n\n**Low Speed Oscillator**\n\n* 15KHz(0.2μA) (RL78/G13)\n* 32KHz(0.2μA) (RL78/G22)\n* 32KHz(0.2μA) (RL78/G23)\n\n**Comparator**\n\n* - (RL78/G13)\n* - (RL78/G22)\n* 2 (RL78/G23)\n\n**8bit DA converter**\n\n* - (RL78/G13)\n* - (RL78/G22)\n* 2 (RL78/G23)\n\n**output current control pins**\n\n* - (RL78/G13)\n* - (RL78/G22)\n* 7 to 8 (RL78/G23)\n\n**Remote control signal receiver**\n\n* - (RL78/G13)\n* - (RL78/G22)\n* 1 (RL78/G23)\n\n**Capacitive Sensing Unit ch**\n\n* - (RL78/G13)\n* - (RL78/G22)\n* 3(7 ~ 8(16) (RL78/G23)\n\n**SNOOZE Mode Sequencer**\n\n* - (RL78/G13)\n* - (RL78/G22)\n* - (RL78/G23)\n\n**Security**\n\n* Flash writing protection\n* Flash shield window function\n* True Random Number Generator\n* Unique ID\n* Customer ID\n\n**Power Consumption**\n\n* Active : 2.1 mA\n* STOP : 0.23 μA\n\n**Active : 1.2 mA**\n**STOP : 0.20 μA**\n\n**Active : 1.3 mA**\n**STOP : 0.21 μA**\n\nThe image provides a detailed comparison of the features and specifications of the three microcontrollers, highlighting their differences in CPU core, frequency, operation voltage, pin count, code flash memory, data flash memory, RAM, voltage of the flash memory writing, boot swap area, ADC resolution, event link controller function, data transfer, low speed oscillator, comparator, 8bit DA converter, output current control pins, remote control signal receiver, capacitive sensing unit ch, SNOOZE Mode Sequencer, security, and power consumption.', 'The image presents a table with a grid layout, featuring a mix of text and graphics. The table is divided into two main sections: the top section contains a grid with numbers and letters, while the bottom section displays a list of packages.\n\n**Top Section:**\n\n* The top section features a grid with 16 rows and 13 columns, labeled with numbers from 16 to 128 and letters from A to M.\n* Each cell in the grid contains a number or a letter, with some cells displaying both.\n* The grid is overlaid with various graphics, including:\n\t+ Red dashed lines\n\t+ Blue arrows\n\t+ Green boxes\n\t+ Yellow boxes\n\t+ A blue rectangle with the text ""G23"" in white\n\t+ A green rectangle with the text ""G22"" in white\n\t+ A blue rectangle with the text ""Expand!"" in white\n\t+ A green rectangle with the text ""Expand!"" in white\n\n**Bottom Section:**\n\n* The bottom section lists various packages, each with a unique name and description.\n* The packages are organized into rows, with some rows containing multiple packages.\n* The packages are labeled with a combination of letters and numbers, such as ""HWQFN (3x3)"" or ""LQFP (10x10)"".\n\n**Overall:**\n\n* The image appears to be a technical diagram or chart, possibly related to electronics or computer hardware.\n* The grid layout and use of graphics suggest that the image is intended to convey complex information in a visual format.\n* The presence of packages and their descriptions in the bottom section suggests that the image may be related to product development or manufacturing.']"
7ff8ed6086d6386b20ac5bce6acbabe9,"Question:
How much current is consumed when measuring capacitive touch? Is there any reference information available?
Answer:
The average current consumption measured with a capacitive touch cycle of 100 ms is 15.8 μA (reference value for the RL78/G23).
Figure 1: Current consumption results
Current consumption can be reduced further when using the SNOOZE Mode Sequencer (SMS).
The average current consumption measured with a capacitive touch cycle of 100 ms and using SMS is 10.8 μA (reference value for the RL78/G23).
Figure 2: Current consumption results (touch measurement using SMS)
For details on measurement conditions, etc., please refer to this document.
https://www.renesas.com/document/apn/rl78g23-group-rl78g23-capacitive-touch-low-power-guide-sms-function-rev100?r=1496636
Suitable Products
RL78/G23
How much current is consumed when measuring capacitive touch? Is there any reference information available?
How much current is consumed when measuring capacitive touch? Is there any reference information available?
Answer:
The average current consumption measured with a capacitive touch cycle of 100 ms is 15.8 μA (reference value for the RL78/G23).
Figure 1: Current consumption results
Current consumption can be reduced further when using the SNOOZE Mode Sequencer (SMS).
The average current consumption measured with a capacitive touch cycle of 100 ms and using SMS is 10.8 μA (reference value for the RL78/G23).
Figure 2: Current consumption results (touch measurement using SMS)
For details on measurement conditions, etc., please refer to this document.
https://www.renesas.com/document/apn/rl78g23-group-rl78g23-capacitive-touch-low-power-guide-sms-function-rev100?r=1496636
Suitable Products
RL78/G23
The average current consumption measured with a capacitive touch cycle of 100 ms is 15.8 μA (reference value for the RL78/G23).
Figure 1: Current consumption results
Current consumption can be reduced further when using the SNOOZE Mode Sequencer (SMS).
The average current consumption measured with a capacitive touch cycle of 100 ms and using SMS is 10.8 μA (reference value for the RL78/G23).
Figure 2: Current consumption results (touch measurement using SMS)
For details on measurement conditions, etc., please refer to this document.
https://www.renesas.com/document/apn/rl78g23-group-rl78g23-capacitive-touch-low-power-guide-sms-function-rev100?r=1496636
Suitable Products
The average current consumption measured with a capacitive touch cycle of 100 ms is 15.8 μA (reference value for the RL78/G23).
Figure 1: Current consumption results
Current consumption can be reduced further when using the SNOOZE Mode Sequencer (SMS).
The average current consumption measured with a capacitive touch cycle of 100 ms and using SMS is 10.8 μA (reference value for the RL78/G23).
Figure 2: Current consumption results (touch measurement using SMS)
For details on measurement conditions, etc., please refer to this document.
https://www.renesas.com/document/apn/rl78g23-group-rl78g23-capacitive-touch-low-power-guide-sms-function-rev100?r=1496636
Suitable Products
RL78/G23
日本語 中文
日本語
中文","['data/categories/rl78_family/rl78g23/7ff8ed6086d6386b20ac5bce6acbabe9/images/d1c1623c64cc65ed0adcf0bf6fd93eb1.png', 'data/categories/rl78_family/rl78g23/7ff8ed6086d6386b20ac5bce6acbabe9/images/9c7d202b0fd04b654c8f8fc9cfd484d8.png']",[],['|  |\n|  |\n| RL78/G23 |'],"{'title': 'RL78/G23: Current consumption when measuring capacitive touch', 'url': 'https://en-support.renesas.com/knowledgeBase/20824903', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:10.929337'}","Question How much current is consumed when measuring capacitive touch? Is there any reference information available? Answer The average current consumption measured with a capacitive touch cycle of 100 ms is 15.8 A (reference value for the RL78/G23). Figure 1 Current consumption results Current consumption can be reduced further when using the SNOOZE Mode Sequencer (SMS). The average current consumption measured with a capacitive touch cycle of 100 ms and using SMS is 10.8 A (reference value for the RL78/G23). Figure 2 Current consumption results (touch measurement using SMS) For details on measurement conditions, etc., please refer to this document. https//www.renesas.com/document/apn/rl78g23-group-rl78g23-capacitive-touch-low-power-guide-sms-function-rev100?r1496636 Suitable Products RL78/G23    ","['The image presents a comprehensive display of measurement data, comprising a graph and a table. The graph, situated at the top, features a black background with white grid lines, showcasing a blue line that oscillates between 0 and 100,000 on the y-axis. A pink rectangle highlights a specific point on the graph, accompanied by the label ""100ms"" in white text.\n\nBelow the graph, a table is presented with a white background and a yellow border. The table is divided into two sections: the top section contains a list of measurement statistics, while the bottom section displays the measurement data. The measurement statistics include Span, Minimum, Maximum, Peak to Peak, Standard Deviation, Mean, and Median, each with its corresponding value. The measurement data is presented in a table format, with columns for Measurement, Span, Minimum, Maximum, Peak to Peak, Standard Deviation, Mean, and Median.\n\nA yellow arrow points to the table, drawing attention to the measurement data. The background of the image is white, providing a clean and neutral backdrop for the graph and table. Overall, the image effectively conveys a wealth of information about the measurement data, making it easy to understand and analyze.', 'The image presents a comprehensive analysis of measurement data, featuring a graph and a table that provide detailed insights into the data\'s characteristics.\n\n**Graph:**\n\n*   The graph is a line graph with a black background and white gridlines.\n*   It displays the measurement data over time, with the x-axis representing time in milliseconds (ms) and the y-axis representing the measurement values.\n*   The graph shows a single peak at approximately 10,000 ms, indicating a significant event or anomaly in the data.\n*   The peak is highlighted in pink, drawing attention to its importance.\n\n**Table:**\n\n*   The table is titled ""Cursor Statistics"" and provides a detailed breakdown of the measurement data.\n*   It includes various statistics such as:\n    *   **Measurement:** The raw measurement data.\n    *   **Span:** The range of values in the measurement data.\n    *   **Minimum:** The smallest value in the measurement data.\n    *   **Maximum:** The largest value in the measurement data.\n    *   **Peak to Peak:** The difference between the maximum and minimum values.\n    *   **Standard Deviation:** A measure of the spread of the data.\n    *   **Mean:** The average value of the measurement data.\n    *   **Median:** The middle value of the measurement data when it is sorted in ascending order.\n*   The table also includes additional information such as the number of data points (10000) and the time interval (100ms).\n\n**Key Takeaways:**\n\n*   The graph highlights a significant event or anomaly in the measurement data at approximately 10,000 ms.\n*   The table provides a detailed breakdown of the measurement data, including statistics such as span, minimum, maximum, peak to peak, standard deviation, mean, and median.\n*   The data suggests that the measurement values are relatively stable, with a small range of values and a low standard deviation.\n\nOverall, the image provides a comprehensive analysis of the measurement data, highlighting a significant event or anomaly and providing detailed statistics to understand the data\'s characteristics.']"
03331522dd20eff998b20d765a566138,"Question:
How to create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices ?
  Answer:
How to create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices ?
How to create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices ?
Answer:
To create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices, do the following steps:
1) Add the r_rfd_rl78_t01_dataflash and r_rfd_rl78_t01_common components on the Smart Configurator:
2) Set the following option to enable the data flash access:
3) Add the following sections in ROM and RAM memory which will be used by the Renesas Flash Driver RL78 Type 01.
4) Add the following -rom option for RFD_DATA_n section which will be copied into RAM.
5) Refer to the attached project for RL78/G23 FPB 64-pin board on how to add code to initialize the flash library and perform the basic data flash operations (blank check/erase/write).
You can find all information for the Renesas Flash Driver RL78 Type 01 User's Manual for RL78/G2x on the user's manual:
https://www.renesas.com/en/document/man/renesas-flash-driver-rl78-type-01-users-manual-rl78g23
Suitable Products
RL78/G23
RL78/G23","['data/categories/rl78_family/rl78g23/03331522dd20eff998b20d765a566138/images/4db65c38cf33c645f83de180a80b6f68.png', 'data/categories/rl78_family/rl78g23/03331522dd20eff998b20d765a566138/images/b681e3b990a3229d9da87b1e55c3e3ad.png', 'data/categories/rl78_family/rl78g23/03331522dd20eff998b20d765a566138/images/3494f51a5c7fb14e874b6f956a4af8f7.png', 'data/categories/rl78_family/rl78g23/03331522dd20eff998b20d765a566138/images/0f07395cc8db5f719f760ab76668e528.png']",[],[],"{'title': 'How to create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21757166', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:16.252267'}","Question How to create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices ? Answer Answer To create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices, do the following steps 1) Add the rrfdrl78t01dataflash and rrfdrl78t01common components on the Smart Configurator 2) Set the following option to enable the data flash access 3) Add the following sections in ROM and RAM memory which will be used by the Renesas Flash Driver RL78 Type 01. 4) Add the following -rom option for RFDDATAn section which will be copied into RAM. 5) Refer to the attached project for RL78/G23 FPB 64-pin board on how to add code to initialize the flash library and perform the basic data flash operations (blank check/erase/write). You can find all information for the Renesas Flash Driver RL78 Type 01 User's Manual for RL78/G2x on the user's manual https//www.renesas.com/en/document/man/renesas-flash-driver-rl78-type-01-users-manual-rl78g23 Suitable Products RL78/G23","['The image shows a screenshot of a computer program, specifically a software component selection window. The window is titled ""Software Component Selection"" and has a list of components on the left side, with a search bar at the top. The components are organized into categories, such as ""All"", ""Function"", and ""Filter"". \n\nThe main body of the window displays a table with columns for ""Components"", ""Short Name"", ""Type"", and ""Version"". The table contains a list of components, including ""A/D Converter"", ""Board Support Packages - v1.70"", ""Capacitive Sensing Unit driver."", ""Clock Output /Buzzer Output Controller"", ""Comparator"", ""D/A Converter"", ""Data Transfer Controller"", ""Delay Counter"", ""Divider Function"", ""ELCL AND"", ""External Event Counter"", ""Flash Driver[Renetas Flash Driver RL78 Ty..."", ""Flash Driver[Renetas Flash Driver RL78 Ty..."", ""Flash Driver[Renetas Flash Driver RL78 Ty..."", ""Flash Driver[Renetas Flash Driver RL78 Ty..."", ""FS1015 Sensor Middleware"", and ""FS2012 Sensor Middleware"".\n\nAt the bottom of the window, there are buttons for ""Next"" and ""Finish"", as well as a checkbox for ""Download RL78 Software Integration System modules"" and a link to ""Configure general settings..."". The background of the window is white, with a gray border around the edges. Overall, the image appears to be a screenshot of a software development tool, possibly used for selecting and configuring components for a specific project.', 'The image shows a screenshot of a computer program with a white background and black text. The program is titled ""Software component configuration"" and has a menu bar at the top with options such as ""Components"", ""Type filter text"", ""Start up"", ""Generic"", ""r_bsp"", ""Middleware"", ""Generic"", ""r_rfd_r178_t01_common"", and ""r_rfd_r178_t01_dataflash"". \n\n*   The left side of the window has a list of components, including ""type filter text"", ""Startup"", ""Generic"", ""r_bsp"", ""Middleware"", ""Generic"", ""r_rfd_r178_t01_common"", and ""r_rfd_r178_t01_dataflash"".\n*   The right side of the window has a table with two columns: ""Property"" and ""Value"". The ""Property"" column lists various properties, such as ""Configurations"", ""Start up select"", ""Control of illicit memory access detection(AWEN)"", ""Protected area in the RAM(GRAM1-0)"", ""Protection of the port control registers(GRT)"", ""Protection of the interrupt control registers(GINT)"", ""Protection of the clock, voltage detector, and RAM parity error detection control"", ""Data flash memory area/extra area access control(DFLEN)"", ""Initialization of peripheral functions by Code Generator/Smart Configurator"", ""API functions disable(R_BSP_StartClock, R_BSP_StopClock)"", ""API functions disable(R_BSP_GetFclkFreqHz)"", ""API functions disable(R_BSP_SetClockSource)"", ""API functions disable(R_BSP_ChangeClockSetting)"", ""API functions disable(R_BSP_SoftwareDelay)"", ""Parameter check enable"", ""Enable user warm start callback (PRE)"", ""User warm start callback function name (PRE)"", ""Enable user warm start callback (POST)"", ""User warm start callback function name (POST)"", and ""Watchdog Timer refresh enable"".\n*   The ""Value"" column lists the corresponding values for each property, which are mostly ""Enable"" or ""Disable"".\n*   There is a red box around the ""Data flash memory area/extra area access control(DFLEN)"" property, indicating that it is currently enabled.\n*   At the bottom of the window, there is a section labeled ""Macro definition"" with two lines of text: ""BSP_CFG_DATA_FLASH_ACCESS_ENABLE 0 = Access to the data flash memory area and extra area is disabled. 1 = Access to the data flash memory area and extra area is enabled.""\n\nOverall, the image appears to be a screenshot of a software configuration tool, where the user can select and configure various properties related to the software\'s behavior and functionality.', 'The image shows a screenshot of a computer program with a window open, displaying a list of files and folders. The window is titled ""Section Viewer"" and has a white background with black text.\n\n*   The window is divided into two sections: a left-hand column and a right-hand column.\n    *   The left-hand column contains a list of files and folders, with each item represented by an icon and a label.\n        *   The icons are yellow and blue, and the labels are in black text.\n        *   The list includes items such as ""Source"", ""Object"", ""User"", ""Common"", ""CPU"", ""Device"", ""Miscellaneous"", ""Compiler"", ""Language"", ""Object"", ""Optimization"", ""Output Code"", ""Miscellaneous"", ""MISRA C Rule Check"", ""User"", ""Assembler"", ""Source"", ""Language"", ""Object"", ""Optimization"", ""Miscellaneous"", ""User"", ""Linker"", ""Input"", ""Advanced"", ""List"", ""Optimization"", ""Section"", ""Device"", ""Output"", ""Advanced"", ""Miscellaneous"", ""User"", ""Library Generator"", ""Standard Library"", ""Advanced"", ""User"", ""Converter"", ""Output"", ""Hex format"", ""CRC Operation"", ""Miscellaneous"", ""User"".\n    *   The right-hand column contains a table with several columns, including ""Address"", ""Section Name"", and ""Remove Section"".\n        *   The table has several rows, each representing a different file or folder.\n        *   The ""Remove Section"" column has a checkbox next to each row, allowing the user to select which sections to remove.\n*   At the top of the window, there are several menus and buttons, including ""Tool Settings"", ""Toolchain"", ""Device"", ""Build Steps"", ""Build Artifact"", ""Binary Parsers"", and ""Error Parsers"".\n    *   The ""Tool Settings"" menu has several options, including ""SMS Assembler"", ""Source"", ""Object"", ""User"", ""Common"", ""CPU"", ""Device"", ""Miscellaneous"", ""Compiler"", ""Language"", ""Object"", ""Optimization"", ""Output Code"", ""Miscellaneous"", ""MISRA C Rule Check"", ""User"", ""Assembler"", ""Source"", ""Language"", ""Object"", ""Optimization"", ""Miscellaneous"", ""User"", ""Linker"", ""Input"", ""Advanced"", ""List"", ""Optimization"", ""Section"", ""Device"", ""Output"", ""Advanced"", ""Miscellaneous"", ""User"", ""Library Generator"", ""Standard Library"", ""Advanced"", ""User"", ""Converter"", ""Output"", ""Hex format"", ""CRC Operation"", ""Miscellaneous"", ""User"".\n    *   The ""Toolchain"" menu has several options, including ""SMS Assembler"", ""Source"", ""Object"", ""User"", ""Common"", ""CPU"", ""Device"", ""Miscellaneous"", ""Compiler"", ""Language"", ""Object"", ""Optimization"", ""Output Code"", ""Miscellaneous"", ""MISRA C Rule Check"", ""User"", ""Assembler"", ""Source"", ""Language"", ""Object"", ""Optimization"", ""Miscellaneous"", ""User"", ""Linker"", ""Input"", ""Advanced"", ""List"", ""Optimization"", ""Section"", ""Device"", ""Output"", ""Advanced"", ""Miscellaneous"", ""User"", ""Library Generator"", ""Standard Library"", ""Advanced"", ""User"", ""Converter"", ""Output"", ""Hex format"", ""CRC Operation"", ""Miscellaneous"", ""User"".\n    *   The ""Device"" menu has several options, including ""SMS Assembler"", ""Source"", ""Object"", ""User"", ""Common"", ""CPU"", ""Device"", ""Miscellaneous"", ""Compiler"", ""Language"", ""Object"", ""Optimization"", ""Output Code"", ""Miscellaneous"", ""MISRA C Rule Check"", ""User"", ""Assembler"", ""Source"", ""Language"", ""Object"", ""Optimization"", ""Miscellaneous"", ""User"", ""Linker"", ""Input"", ""Advanced"", ""List"", ""Optimization"", ""Section"", ""Device"", ""Output"", ""Advanced"", ""Miscellaneous"", ""User"", ""Library Generator"", ""Standard Library"", ""Advanced"", ""User"", ""Converter"", ""Output"", ""Hex format"", ""CRC Operation"", ""Miscellaneous"", ""User"".\n    *   The ""Build Steps"" menu has several options, including ""SMS Assembler"", ""Source"", ""Object"", ""User"", ""Common"", ""CPU"", ""Device"", ""Miscellaneous"", ""Compiler"", ""Language"", ""Object"", ""Optimization"", ""Output Code"", ""Miscellaneous"", ""MISRA C Rule Check"", ""User"", ""Assembler"", ""Source"", ""Language"", ""Object"", ""Optimization"", ""Miscellaneous"", ""User"", ""Linker"", ""Input"", ""Advanced"", ""List"", ""Optimization"", ""Section"", ""Device"", ""Output"", ""Advanced"", ""Miscellaneous"", ""User"", ""Library Generator"", ""Standard Library"", ""Advanced"", ""User"", ""Converter"", ""Output"", ""Hex format"", ""CRC Operation"", ""Miscellaneous"", ""User"".\n    *   The ""Build Artifact"" menu has several options, including ""SMS Assembler"", ""Source"", ""Object"", ""User"", ""Common"", ""CPU"", ""Device"", ""Miscellaneous"", ""Compiler"", ""Language"", ""Object"", ""Optimization"", ""Output Code"", ""Miscellaneous"", ""MISRA C Rule Check"", ""User"", ""Assembler"", ""Source"", ""Language"", ""Object"", ""Optimization"", ""Miscellaneous"", ""User"", ""Linker"", ""Input"", ""Advanced"", ""List"", ""Optimization"", ""Section"", ""Device"", ""Output"", ""Advanced"", ""Miscellaneous"", ""User"", ""Library Generator"", ""Standard Library"", ""Advanced"", ""User"", ""Converter"", ""Output"", ""Hex format"", ""CRC Operation"", ""Miscellaneous"", ""User"".\n    *   The ""Binary Parsers"" menu has several options, including ""SMS Assembler"", ""Source"", ""Object"", ""User"", ""Common"", ""CPU"", ""Device"", ""Miscellaneous"", ""Compiler"", ""Language"", ""Object"", ""Optimization"", ""Output Code"", ""Miscellaneous"", ""MISRA C Rule Check"", ""User"", ""Assembler"", ""Source"", ""Language"", ""Object"", ""Optimization"", ""Miscellaneous"", ""User"", ""Linker"", ""Input"", ""Advanced"", ""List"", ""Optimization"", ""Section"", ""Device"", ""Output"", ""Advanced"", ""Miscellaneous"", ""User"", ""Library Generator"", ""Standard Library"", ""Advanced"", ""User"", ""Converter"", ""Output"", ""Hex format"", ""CRC Operation"", ""Miscellaneous"", ""User"".\n    *   The ""Error Parsers"" menu has several options, including ""SMS Assembler"", ""Source"", ""Object"", ""User"", ""Common"", ""CPU"", ""Device"", ""Miscellaneous"", ""Compiler"", ""Language"", ""Object"", ""Optimization"", ""Output Code"", ""Miscellaneous"", ""MISRA C Rule Check"", ""User"", ""Assembler"", ""Source"", ""Language"", ""Object"", ""Optimization"", ""Miscellaneous"", ""User"", ""Linker"", ""Input"", ""Advanced"", ""List"", ""Optimization"", ""Section"", ""Device"", ""Output"", ""Advanced"", ""Miscellaneous"", ""User"", ""Library Generator"", ""Standard Library"", ""Advanced"", ""User"", ""Converter"", ""Output"", ""Hex format"", ""CRC Operation"", ""Miscellaneous"", ""User"".\n\nOverall, the image shows a complex interface with many menus and options, suggesting that it is a tool for managing and optimizing code. The presence of various menus and options implies that the tool is designed to be highly customizable and flexible, allowing users to tailor their workflow to their specific needs.', 'The image shows a screenshot of a computer program with a white background and black text. The program is likely a software development tool, given the presence of various menus and options.\n\n*   **Menu Bar**\n    *   The menu bar at the top of the screen features several options, including ""Tool Settings,"" ""Toolchain,"" ""Device,"" ""Build Steps,"" ""Build Artifact,"" ""Binary Parsers,"" and ""Error Parsers.""\n    *   The ""Tool Settings"" menu is currently selected, indicating that the user is in the process of configuring the tool.\n*   **Left-Side Menu**\n    *   The left-side menu lists various categories, including ""SMS Assembler,"" ""Source,"" ""Object,"" ""User,"" ""Common,"" ""CPU,"" ""Device,"" ""Miscellaneous,"" ""Compiler,"" ""Source,"" ""Language,"" ""Object,"" ""Optimization,"" ""Output Code,"" ""Miscellaneous,"" ""MISRA C Rule Check,"" ""User,"" ""Assembler,"" ""Source,"" ""Language,"" ""Object,"" ""Optimization,"" ""Miscellaneous,"" ""User,"" ""Linker,"" ""Input,"" ""Advanced,"" ""List,"" ""Optimization,"" ""Section,"" ""Device,"" ""Output,"" ""Advanced,"" ""Miscellaneous,"" ""User,"" ""Library Generator,"" ""Standard Library,"" ""Advanced,"" ""User,"" ""Converter,"" ""Output,"" ""Hex format,"" ""CRC Operation,"" ""Miscellaneous,"" and ""User.""\n    *   The ""SMS Assembler"" category is currently selected, indicating that the user is working with SMS assembler files.\n*   **Right-Side Panel**\n    *   The right-side panel displays a list of options related to the selected category, including ""Type of output file (-form),"" ""Absolute,"" ""ROM to RAM mapped section (-rom),"" and ""Section that outputs external defined symbols to the file (-fsymbol).""\n    *   The ""Type of output file (-form)"" option is currently selected, and the user has chosen ""Absolute"" as the output file type.\n*   **Text Box**\n    *   A text box at the bottom of the screen allows the user to enter additional information or settings.\n    *   The text box is currently empty, indicating that the user has not yet entered any information.\n\nOverall, the image suggests that the user is in the process of configuring a software development tool, specifically the SMS assembler. The user has selected the ""SMS Assembler"" category and is working with absolute output files. The image provides a clear and organized interface for the user to navigate and configure the tool.']"
96412b0e4b5dfee9d8c0b8096b03c211,"Question:
How to enable real time refresh of variables during debugging with RL78/G15
Answer:
To enable real time refresh of variables, it is required to enable the Pseudo-RRM/DMM function setting and to allocate 4 bytes of memory in RAM.
Pre-requisite of IDE and compiler for RL78/G15–
IDE:
e2studio: 2023-01 (23.1.0) or later
CS+: CC V8.09.00 or later.

Compiler:
CC-RL V1.12.00 or later.
Configuration setting for pseudo-RRM/DMM function and allocation of 4 bytes of memory in RAM -
Using e2studio:
Enable the Real-time Refresh on specified variable.


Select Pseudo-RRM/DMM function setting.


Provide the address for 4 bytes of RAM memory required for the RRM/DMM function.


Using CS+:
Enable “Access by stopping execution” option in the Debug Tool Settings.


Enable “Set debug monitor area”, “Reserve working memory for RRM/DMM function” and “Start address of working memory for RRM/DMM function”.


Note: Allocate the 4 bytes memory on top of RAM to allow maximum RAM available to the user application.
Suitable Products
RL78/G15
How to enable real time refresh of variables during debugging with RL78/G15
Answer:
To enable real time refresh of variables, it is required to enable the Pseudo-RRM/DMM function setting and to allocate 4 bytes of memory in RAM.
Pre-requisite of IDE and compiler for RL78/G15–
IDE:
e2studio: 2023-01 (23.1.0) or later
CS+: CC V8.09.00 or later.

Compiler:
CC-RL V1.12.00 or later.
Configuration setting for pseudo-RRM/DMM function and allocation of 4 bytes of memory in RAM -
Using e2studio:
Enable the Real-time Refresh on specified variable.


Select Pseudo-RRM/DMM function setting.


Provide the address for 4 bytes of RAM memory required for the RRM/DMM function.


Using CS+:
Enable “Access by stopping execution” option in the Debug Tool Settings.


Enable “Set debug monitor area”, “Reserve working memory for RRM/DMM function” and “Start address of working memory for RRM/DMM function”.


Note: Allocate the 4 bytes memory on top of RAM to allow maximum RAM available to the user application.
Suitable Products
RL78/G15
To enable real time refresh of variables, it is required to enable the Pseudo-RRM/DMM function setting and to allocate 4 bytes of memory in RAM.
Pre-requisite of IDE and compiler for RL78/G15–
Configuration setting for pseudo-RRM/DMM function and allocation of 4 bytes of memory in RAM -
Note: Allocate the 4 bytes memory on top of RAM to allow maximum RAM available to the user application.
Suitable Products
RL78/G15","['data/categories/rl78_family/rl78g15/96412b0e4b5dfee9d8c0b8096b03c211/images/fa8ae2c72a11f0ec5b08f14f2e906934.png', 'data/categories/rl78_family/rl78g15/96412b0e4b5dfee9d8c0b8096b03c211/images/b544d48adf95d4160b12d6a066e08974.png', 'data/categories/rl78_family/rl78g15/96412b0e4b5dfee9d8c0b8096b03c211/images/edf2b5ed67775f78e4a4af06a5b273da.png', 'data/categories/rl78_family/rl78g15/96412b0e4b5dfee9d8c0b8096b03c211/images/54f4969681c7ba3cf2fc498aa088b53b.png', 'data/categories/rl78_family/rl78g15/96412b0e4b5dfee9d8c0b8096b03c211/images/b52c4928746de361cc48e5dfeffc5279.png']",[],['|  |\n|  |\n| RL78/G15 |'],"{'title': 'How to enable real time refresh of variables during debugging with RL78/G15', 'url': 'https://en-support.renesas.com/knowledgeBase/21056458', 'last_updated': None, 'extracted_at': '2025-03-08T23:54:09.332088'}","Question How to enable real time refresh of variables during debugging with RL78/G15 Answer To enable real time refresh of variables, it is required to enable the Pseudo-RRM/DMM function setting and to allocate 4 bytes of memory in RAM. Pre-requisite of IDE and compiler for RL78/G15 IDE e2studio 2023-01 (23.1.0) or later CS CC V8.09.00 or later. Compiler CC-RL V1.12.00 or later. Configuration setting for pseudo-RRM/DMM function and allocation of 4 bytes of memory in RAM - Using e2studio Enable the Real-time Refresh on specified variable. Select Pseudo-RRM/DMM function setting. Provide the address for 4 bytes of RAM memory required for the RRM/DMM function. Using CS Enable Access by stopping execution option in the Debug Tool Settings. Enable Set debug monitor area, Reserve working memory for RRM/DMM function and Start address of working memory for RRM/DMM function. Note Allocate the 4 bytes memory on top of RAM to allow maximum RAM available to the user application. Suitable Products RL78/G15","['The image shows a screenshot of a computer program with a menu open, displaying various options. The menu is titled ""Expression"" and has several sub-options, including ""Select All,"" ""Copy Expressions,"" ""Remove,"" ""Remove All,"" ""Number Format,"" ""Add Expression Group,"" ""Find...,"" ""Show Details As,"" ""Add Watch Expression...,"" ""Disable,"" ""Enable,"" ""Edit Watch Expression...,"" ""Add Watchpoint (C/C++)...,"" ""Cast To Type...,"" ""Display As Array...,"" ""Disable Real-time Refresh,"" and ""Add To Chart."" \n\nThe menu is open on a white background with a grid pattern, suggesting that it is a spreadsheet or data analysis program. The overall atmosphere of the image is one of productivity and efficiency, as the user is likely using the program to manage and analyze data.', 'The image shows a screenshot of a computer system configuration page, with a red box highlighting the ""Pseudo-RRM/DMM function setting"" option. The page is titled ""System configuration"" and has a dropdown menu labeled ""On-chip debug setting"". The ""Pseudo-RRM/DMM function setting"" option is selected, and the ""Used"" radio button is checked.\n\n*   **Title and Dropdown Menu**\n    *   The title of the page is ""System configuration"".\n    *   The dropdown menu is labeled ""On-chip debug setting"".\n*   **Pseudo-RRM/DMM Function Setting**\n    *   The ""Pseudo-RRM/DMM function setting"" option is selected.\n    *   The ""Used"" radio button is checked.\n*   **Other Options**\n    *   There are several other options on the page, including ""On-chip debug operation setting"", ""Emulator setting"", ""Start/Stop function setting"", ""Monitoring point function setting"", and ""Security ID setting"".\n    *   Some of these options have radio buttons or checkboxes that can be used to select different settings.\n*   **Red Box**\n    *   A red box highlights the ""Pseudo-RRM/DMM function setting"" option.\n    *   The red box also highlights the ""Used"" radio button.\n\nOverall, the image shows a computer system configuration page with a dropdown menu and several options for setting up the system. The ""Pseudo-RRM/DMM function setting"" option is selected, and the ""Used"" radio button is checked.', 'The image shows a screenshot of a computer program with a list of settings on the left and a list of options on the right. The program is likely a software development tool, given the presence of terms like ""C/C++ Build"" and ""Linker."" \n\n*   **Settings**\n    *   The settings are organized into categories, such as ""C/C++ Build,"" ""Linker,"" and ""Device.""\n    *   Each category has a list of options that can be selected or modified.\n    *   Some options have checkboxes next to them, while others have dropdown menus or text fields.\n*   **Options**\n    *   The options are listed in a table format, with columns for the option name, description, and value.\n    *   The options include things like ""Source Language,"" ""Object Optimization,"" and ""User option byte value.""\n    *   Some options have default values, while others require manual input.\n*   **Values**\n    *   The values are displayed in a text field or dropdown menu next to each option.\n    *   Some values are numerical, while others are text-based.\n    *   The values can be edited by typing in a new value or selecting an option from a dropdown menu.\n\nOverall, the image suggests that the program is designed to help users configure and customize their software development environment. The various settings and options allow users to tailor the program to their specific needs and preferences.', 'The image shows a screenshot of a computer program with a red box highlighting the ""Debug Tool Settings"" option. The program is open on a Windows computer, and the screenshot is taken from the ""Project Tree"" window.\n\n*   **Project Tree Window**\n    *   The Project Tree window is open on the left side of the screen.\n    *   It displays a list of files and folders in the current project.\n    *   The files and folders are organized in a hierarchical structure, with folders containing subfolders and files.\n    *   The window has a blue title bar with the text ""Project Tree"" in white letters.\n*   **Debug Tool Settings Option**\n    *   The Debug Tool Settings option is highlighted in a red box.\n    *   It is located in the ""RL78 E2 Lite Property"" window, which is open on the right side of the screen.\n    *   The option is a dropdown menu with several sub-options, including ""Connect Settings"", ""Download File Settings"", and ""Hook Transaction Settings"".\n    *   The selected option is ""Connect Settings"".\n*   **RL78 E2 Lite Property Window**\n    *   The RL78 E2 Lite Property window is open on the right side of the screen.\n    *   It displays various properties of the RL78 E2 Lite device, including memory mappings, access memory while running, and debug tool settings.\n    *   The window has a white background with black text and blue headings.\n*   **Computer Screen**\n    *   The computer screen is visible in the background of the screenshot.\n    *   It shows the desktop with several icons and windows open.\n    *   The screen has a beige background with a blue taskbar at the bottom.\n\nIn summary, the image shows a screenshot of a computer program with a red box highlighting the ""Debug Tool Settings"" option. The program is open on a Windows computer, and the screenshot is taken from the ""Project Tree"" window. The RL78 E2 Lite Property window is open on the right side of the screen, displaying various properties of the RL78 E2 Lite device. The computer screen is visible in the background, showing the desktop with several icons and windows open.', 'The image shows a screenshot of a computer program with a red box highlighting specific parts of the interface. The program appears to be a development environment, possibly for a programming language like C or C++.\n\n*   **Left side of the screen:**\n    *   A menu bar with various options such as ""File"", ""Edit"", ""View"", and ""Help"".\n    *   A list of files and folders in the current directory, including a file named ""main.c"".\n    *   A toolbar with icons for common actions like ""New"", ""Open"", ""Save"", and ""Compile"".\n*   **Right side of the screen:**\n    *   A large window displaying the contents of the ""main.c"" file, which appears to be a C program.\n    *   A red box highlighting a specific line of code that reads ""Set debug monitor area"".\n    *   A dropdown menu with options for setting the debug monitor area, including ""Range of debug monitor area"" and ""Set user option byte"".\n    *   A checkbox labeled ""Reserve working memory for RRM/DMM function"" with a red box around it.\n    *   A dropdown menu with options for setting the output code, including ""Yes(-RRM)"" and ""FFEDC"".\n*   **Bottom of the screen:**\n    *   A status bar displaying information about the current project, including the file name, line number, and column number.\n    *   A toolbar with icons for common actions like ""Compile"", ""Assemble"", and ""Link"".\n\nOverall, the image suggests that the user is working on a C program and is using a development environment to set up the debug monitor area and reserve working memory for a specific function. The red boxes highlight important parts of the interface, such as the line of code being edited and the options for setting the debug monitor area.']"
f640e0c1852d1e90ce56c400fc4f1d44,"Last updated: 10/10/2023
How to setup a FDL T04 project on a RL78/x1x device ?
The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on: 
https://www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120 
  This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided. 
  Download Data Flash Library T04 for RL78 family from: https://www.renesas.com/us/en/software-tool/data-flash-libraries 
    Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL): 
        Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section: 
      Import the library files into the project. The project should now have the following files: 
pfdl_types.h  
pfdl.h  
pfdl.inc 
pfdl.lib 
    Go to Linker -> Settings and open the Section Viewer after disabling the automatic section layout: 
  On e2studio: 
    On CS+: 
    If the section ‘PFDL_COD’ does not already exist as a section already, create a new section with this name: 
  ‘PFDL_COD’ contains the code of data flash library functions. It can be placed to ROM or RAM. 
    Import the ‘pfdl.lib’ library file that already exists in the project folder from linker’s input settings: 
On e2studio: 
          On CS+: 
        The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker. 
  Locate your device in self-RAM list document: 
https://www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305 
  If your device has no dedicated area for FDL T04 library (for example R5F100xA), no action is required, and you can proceed to the next step. 
  If your device requires a dedicated area to be allocated (for example R5F100xE), you need to make sure no other data is placed in this area. There are 2 ways to do this:  
  Go to Linker -> Device and select the ‘self-RAM area’ option. 
  On e2studio: 
    On CS+: 
    This option will reserve the needed self-RAM area, but it will by default allocate the maximum self-RAM area of all flash libraries which is 1Kbytes (FSL T01 self-RAM size). 
  To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to ‘None’. 
On e2studio: 
        On CS+: 
      Next, add these lines in your source code: 
  #pragma address self_ram_area = <starting address of self-RAM area for FDL T04> 
volatile char self_ram_area[136] 
  For example, for R5F100xE device: 
  #pragma address self_ram_area = 0xFEF00  
volatile char self_ram_area[136] 
      In the attached example project all 5 data flash library commands are implemented. The example project is targeted for a device with dedicated self-RAM area.
Open -> Erase -> Blank check -> Write -> Internal verification -> Read -> Close
The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on: 
https://www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120 
  This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided. 
  Download Data Flash Library T04 for RL78 family from: https://www.renesas.com/us/en/software-tool/data-flash-libraries
The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on:
The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on:
https://www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120
https://www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120
This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided.
This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided.
Download Data Flash Library T04 for RL78 family from: https://www.renesas.com/us/en/software-tool/data-flash-libraries
Download Data Flash Library T04 for RL78 family from: https://www.renesas.com/us/en/software-tool/data-flash-libraries
Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL):
Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL):
Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL):
Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section: 
      Import the library files into the project. The project should now have the following files: 
pfdl_types.h  
pfdl.h
Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section:
Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section:
Import the library files into the project. The project should now have the following files:
Import the library files into the project. The project should now have the following files:
pfdl_types.h
pfdl_types.h
pfdl.h
pfdl.h
pfdl.inc 
pfdl.lib 
    Go to Linker -> Settings and open the Section Viewer after disabling the automatic section layout:
pfdl.inc
pfdl.inc
pfdl.lib
pfdl.lib
Go to Linker -> Settings and open the Section Viewer after disabling the automatic section layout:
Go to Linker -> Settings and open the Section Viewer after disabling the automatic section layout:
On e2studio:
On e2studio:
On CS+:
On CS+:
If the section ‘PFDL_COD’ does not already exist as a section already, create a new section with this name:
If the section ‘PFDL_COD’ does not already exist as a section already, create a new section with this name:
‘PFDL_COD’ contains the code of data flash library functions. It can be placed to ROM or RAM.
‘PFDL_COD’ contains the code of data flash library functions. It can be placed to ROM or RAM.
Import the ‘pfdl.lib’ library file that already exists in the project folder from linker’s input settings: 
On e2studio:
Import the ‘pfdl.lib’ library file that already exists in the project folder from linker’s input settings:
Import the ‘pfdl.lib’ library file that already exists in the project folder from linker’s input settings:
On e2studio:
On e2studio:
On CS+:
On CS+:
The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker. 
  Locate your device in self-RAM list document: 
https://www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305
The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker.
The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker.
Locate your device in self-RAM list document:
Locate your device in self-RAM list document:
https://www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305
https://www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305
If your device has no dedicated area for FDL T04 library (for example R5F100xA), no action is required, and you can proceed to the next step.
If your device has no dedicated area for FDL T04 library (for example R5F100xA), no action is required, and you can proceed to the next step.
If your device requires a dedicated area to be allocated (for example R5F100xE), you need to make sure no other data is placed in this area. There are 2 ways to do this:
If your device requires a dedicated area to be allocated (for example R5F100xE), you need to make sure no other data is placed in this area. There are 2 ways to do this:
Go to Linker -> Device and select the ‘self-RAM area’ option. 
  On e2studio:
Go to Linker -> Device and select the ‘self-RAM area’ option.
Go to Linker -> Device and select the ‘self-RAM area’ option.
On e2studio:
On e2studio:
On CS+:
On CS+:
This option will reserve the needed self-RAM area, but it will by default allocate the maximum self-RAM area of all flash libraries which is 1Kbytes (FSL T01 self-RAM size).
This option will reserve the needed self-RAM area, but it will by default allocate the maximum self-RAM area of all flash libraries which is 1Kbytes (FSL T01 self-RAM size).
To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to ‘None’. 
On e2studio:
To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to ‘None’.
To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to ‘None’.
On e2studio:
On e2studio:
On CS+:
On CS+:
Next, add these lines in your source code:
Next, add these lines in your source code:
#pragma address self_ram_area = <starting address of self-RAM area for FDL T04> 
volatile char self_ram_area[136]
#pragma address self_ram_area = <starting address of self-RAM area for FDL T04> 
volatile char self_ram_area[136]
For example, for R5F100xE device:
For example, for R5F100xE device:
#pragma address self_ram_area = 0xFEF00  
volatile char self_ram_area[136]
#pragma address self_ram_area = 0xFEF00  
volatile char self_ram_area[136]
In the attached example project all 5 data flash library commands are implemented. The example project is targeted for a device with dedicated self-RAM area.
In the attached example project all 5 data flash library commands are implemented. The example project is targeted for a device with dedicated self-RAM area.
Open -> Erase -> Blank check -> Write -> Internal verification -> Read -> Close
Open -> Erase -> Blank check -> Write -> Internal verification -> Read -> Close","['data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/d6931ddceac57defd1f2f6074f115784.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/3c5a851ab4989520d023c4ccdb6c0881.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/008468b2d7a09dd842259ef244135988.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/9b7ce4c34545f10a1f8a7f53e176c454.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/8fa4a41ef08f4b333df6de4c0d51ceab.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/0cbcef07d871a63b8fa31f916836208a.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/5a03c6e97ece70e4374467d52847a7ac.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/35c0277498d1c446d9e46bc79f62482a.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/b8baf077a35a3fcf56c9cf883042aff2.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/c2068acb584a81fec2bf953627d74af1.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/8e6c5b485d1cf029a9c2655d881cfc9e.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/6ad7d654f237aff173f34da69368081d.png']",[],[],"{'title': 'How to setup a FDL T04 project on a RL78/x1x device ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21092507', 'last_updated': None, 'extracted_at': '2025-03-08T23:59:53.261431'}","Last updated 10/10/2023 How to setup a FDL T04 project on a RL78/x1x device ? The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on https//www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120 This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided. Download Data Flash Library T04 for RL78 family from https//www.renesas.com/us/en/software-tool/data-flash-libraries Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL) Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section Import the library files into the project. The project should now have the following files pfdltypes.h pfdl.h pfdl.inc pfdl.lib Go to Linker - Settings and open the Section Viewer after disabling the automatic section layout On e2studio On CS If the section PFDLCOD does not already exist as a section already, create a new section with this name PFDLCOD contains the code of data flash library functions. It can be placed to ROM or RAM. Import the pfdl.lib library file that already exists in the project folder from linkers input settings On e2studio On CS The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker. Locate your device in self-RAM list document https//www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305 If your device has no dedicated area for FDL T04 library (for example R5F100xA), no action is required, and you can proceed to the next step. If your device requires a dedicated area to be allocated (for example R5F100xE), you need to make sure no other data is placed in this area. There are 2 ways to do this Go to Linker - Device and select the self-RAM area option. This option will reserve the needed self-RAM area, but it will by default allocate the maximum self-RAM area of all flash libraries which is 1Kbytes (FSL T01 self-RAM size). To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to None. On CS Next, add these lines in your source code pragma address selframarea  starting address of self-RAM area for FDL T04 volatile char selframarea136 For example, for R5F100xE device pragma address selframarea  0xFEF00 In the attached example project all 5 data flash library commands are implemented. The example project is targeted for a device with dedicated self-RAM area. Open - Erase - Blank check - Write - Internal verification - Read - Close Download Data Flash Library T04 for RL78 family from https//www.renesas.com/us/en/software-tool/data-flash-libraries The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on https//www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120 This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided. Download Data Flash Library T04 for RL78 family from https//www.renesas.com/us/en/software-tool/data-flash-libraries Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL) Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section pfdl.h Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section Import the library files into the project. The project should now have the following files pfdltypes.h Go to Linker - Settings and open the Section Viewer after disabling the automatic section layout pfdl.inc pfdl.lib Go to Linker - Settings and open the Section Viewer after disabling the automatic section layout On e2studio On CS If the section PFDLCOD does not already exist as a section already, create a new section with this name PFDLCOD contains the code of data flash library functions. It can be placed to ROM or RAM. Import the pfdl.lib library file that already exists in the project folder from linkers input settings Import the pfdl.lib library file that already exists in the project folder from linkers input settings The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker. https//www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305 The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker. Locate your device in self-RAM list document If your device has no dedicated area for FDL T04 library (for example R5F100xA), no action is required, and you can proceed to the next step. If your device requires a dedicated area to be allocated (for example R5F100xE), you need to make sure no other data is placed in this area. There are 2 ways to do this Go to Linker - Device and select the self-RAM area option. On e2studio Go to Linker - Device and select the self-RAM area option. This option will reserve the needed self-RAM area, but it will by default allocate the maximum self-RAM area of all flash libraries which is 1Kbytes (FSL T01 self-RAM size). To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to None. To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to None. Next, add these lines in your source code pragma address selframarea  starting address of self-RAM area for FDL T04 volatile char selframarea136 For example, for R5F100xE device pragma address selframarea  0xFEF00 In the attached example project all 5 data flash library commands are implemented. The example project is targeted for a device with dedicated self-RAM area.","['The image shows a screenshot of a webpage with a list of downloadable files. The page is titled ""Downloads"" and has a blue bar at the top with white text that reads ""Title"", ""Type"", and ""Date"". Below this, there are four rows of information, each representing a different file.\n\n*   **RH850 - Data Flash Libraries**\n    *   **Title:** RH850 - Data Flash Libraries\n    *   **Type:** Library\n    *   **Date:** Jun 10, 2019\n    *   **Related Files:** Manual - Software\n*   **Data Flash Library Type04 Package Ver.2.00 for the RL78 Family**\n    *   **Title:** Data Flash Library Type04 Package Ver.2.00 for the RL78 Family\n    *   **Type:** Upgrade - Programmer\n    *   **Date:** Jan 21, 2019\n    *   **ZIP:** 1.64 MB\n    *   **Japanese characters:** \n*   **EEPROM Emulation Library Pack01 Package Ver.2.10 for RL78 Family**\n    *   **Title:** EEPROM Emulation Library Pack01 Package Ver.2.10 for RL78 Family\n    *   **Type:** Upgrade - Programmer\n    *   **Date:** Jan 22, 2018\n    *   **ZIP:** 1.67 MB\n    *   **Japanese characters:** \n*   **EEPROM Emulation Library Pack02 Package Ver.2.00 for RL78 Family**\n    *   **Title:** EEPROM Emulation Library Pack02 Package Ver.2.00 for RL78 Family\n    *   **Type:** Upgrade - Programmer\n    *   **Date:** Sep 21, 2017\n    *   **ZIP:** 7.57 MB\n    *   **Japanese characters:** \n\nThe page also has a blue bar at the bottom with white text that reads ""4 items"". Overall, the image appears to be a screenshot of a webpage that allows users to download various files related to programming and software development.', 'The image shows a screenshot of the ""Choose Components"" window for the RL78 Data Flash Library (FDL) - T04 Setup. The window is titled ""Choose Components"" and has a subtitle that reads, ""Choose which features of RL78 Data Flash Library (FDL) - T04 you want to install."" \n\n*   **Title and Subtitle**\n    *   The title is ""Choose Components"" and the subtitle is ""Choose which features of RL78 Data Flash Library (FDL) - T04 you want to install.""\n*   **Logo**\n    *   The logo for Renesas is displayed in the top-right corner of the window.\n*   **Components List**\n    *   A list of components is displayed, including:\n        *   Renesas CA78K0R compiler version 1.10\n        *   Renesas CC-RL compiler version 1.00\n        *   IAR compiler version 2.10\n        *   IAR compiler version 1.40\n        *   IAR compiler version 1.20\n        *   GNU compiler version 13.01\n*   **Select Components to Install**\n    *   A checkbox is provided next to each component, allowing the user to select which components to install.\n*   **Space Required**\n    *   The space required for the selected components is displayed as 51.0KB.\n*   **Support Information**\n    *   A link to support information is provided at the bottom of the window.\n*   **Buttons**\n    *   Two buttons are provided at the bottom of the window: ""Back"" and ""Next >"". The ""Next >"" button is highlighted in blue, indicating that it is the default button.\n\nOverall, the image shows a screenshot of the ""Choose Components"" window for the RL78 Data Flash Library (FDL) - T04 Setup, which allows the user to select which components to install and view the space required for the selected components.', 'The image shows a screenshot of a computer program with a menu bar at the top and a list of options below it. The menu bar has several tabs, including ""Peripheral Functions,"" ""Pin assignment,"" ""Clock setting,"" ""Block diagram,"" ""On-chip debug setting,"" ""Confirming reset source,"" ""Safety functions,"" and ""Data flash."" The ""Data flash"" tab is currently selected.\n\nBelow the menu bar, there are several options listed, including:\n\n* ""Data flash access control setting""\n* ""Disables data flash access""\n* ""Enables data flash access""\n* ""Setting of data flash library""\n* ""Used""\n* ""Unused""\n\nThe ""Used"" option is currently selected, and there is a checkbox next to it. The checkbox is checked, indicating that the ""Used"" option is currently enabled.\n\nOverall, the image appears to be a screenshot of a computer program that allows users to configure settings for a data flash device. The program has a menu bar with various tabs, and the user can select options from the list below the menu bar. The ""Used"" option is currently enabled, suggesting that the user has chosen to use the data flash device.', 'The image shows a screenshot of a computer program with a white background and black text. The program is titled ""Configuration"" and has a menu bar at the top with options such as ""Tool Settings,"" ""Toolchain,"" ""Device,"" ""Build Steps,"" ""Build Artifact,"" ""Binary Parsers,"" and ""Error Parsers."" \n\n*   **Menu Bar**\n    *   The menu bar is located at the top of the window and contains several options.\n    *   The options are:\n        *   Tool Settings\n        *   Toolchain\n        *   Device\n        *   Build Steps\n        *   Build Artifact\n        *   Binary Parsers\n        *   Error Parsers\n*   **Configuration Window**\n    *   The configuration window is the main area of the program where users can configure settings.\n    *   It contains several sections, including:\n        *   Common\n        *   CPU\n        *   Device\n        *   Compiler\n        *   Source\n        *   Language\n        *   Object\n        *   Optimization\n        *   Output Code\n        *   MISRA C Rule Check\n        *   User\n        *   Assembler\n        *   Source\n        *   Language\n        *   Object\n        *   Optimization\n        *   Miscellaneous\n        *   User\n        *   Linker\n        *   Input\n        *   Advanced\n        *   List\n        *   Optimization\n        *   Section\n        *   Device\n        *   Output\n        *   Advanced\n        *   Miscellaneous\n        *   User\n        *   Converter\n        *   Output\n        *   Hex format\n        *   CRC Operation\n        *   Miscellaneous\n        *   User\n*   **Settings**\n    *   The settings are located in the configuration window and can be adjusted by the user.\n    *   The settings include:\n        *   Specify execution start address (-entry)\n        *   Execution start address (-entry=<symbol>)\n        *   Layout sections automatically (-auto_section_layout)\n        *   Allocate sections per each module with automatic section layout (-split_section)\n        *   Sections (-start)\n        *   Allocate FAA memory area automatically (-dsp_memory_area)\n*   **Buttons**\n    *   The buttons are located at the bottom of the window and allow users to perform actions.\n    *   The buttons include:\n        *   Restore Defaults\n        *   Apply\n\nOverall, the image shows a computer program with a configuration window that allows users to adjust various settings. The program has a menu bar with several options, and the configuration window contains several sections with settings that can be adjusted. The buttons at the bottom of the window allow users to perform actions such as restoring defaults or applying changes.', 'The image shows a screenshot of a computer program with a list of options and settings. The program appears to be a development environment or an IDE (Integrated Development Environment) for programming.\n\n*   **Menu Bar**\n    *   The menu bar is located at the top of the window and contains several options, including ""Debug Information"", ""Optimization"", ""Input File"", ""Output File"", ""Library"", ""Device"", ""Output Code"", ""Variables/Functions Information"", and ""Section"".\n    *   Each option has a dropdown menu with sub-options.\n*   **Debug Information**\n    *   This section allows users to set debug information options, such as output debug information, compress debug information, and delete local symbol name information.\n    *   There are checkboxes for each option, and users can select or deselect them as needed.\n*   **Optimization**\n    *   This section allows users to set optimization options, such as optimization type, input file, object file, binary file, symbol definition, and output file.\n    *   There are dropdown menus for each option, and users can select from a list of available options.\n*   **Input File**\n    *   This section allows users to set input file options, such as object file, binary file, and symbol definition.\n    *   There are dropdown menus for each option, and users can select from a list of available options.\n*   **Output File**\n    *   This section allows users to set output file options, such as output folder, output file name, and library.\n    *   There are dropdown menus for each option, and users can select from a list of available options.\n*   **Library**\n    *   This section allows users to set library options, such as using libraries, system libraries, and check memory smashing on releasing memory.\n    *   There are checkboxes for each option, and users can select or deselect them as needed.\n*   **Device**\n    *   This section allows users to set device options, such as specify execution start address, fill with padding data at the end of a section, address setting for specified area of vector table, address setting for unused vector area, generate function list used for detecting illegal indirect function call, and split vector table sections.\n    *   There are dropdown menus for each option, and users can select from a list of available options.\n*   **Output Code**\n    *   This section allows users to set output code options, such as specify execution start address, fill with padding data at the end of a section, address setting for specified area of vector table, address setting for unused vector area, generate function list used for detecting illegal indirect function call, and split vector table sections.\n    *   There are dropdown menus for each option, and users can select from a list of available options.\n*   **Variables/Functions Information**\n    *   This section allows users to set variables/functions information options, such as layout sections automatically, section name address, output external defined symbols to the file, and ROM to RAM mapped section.\n    *   There are checkboxes for each option, and users can select or deselect them as needed.\n*   **Section**\n    *   This section allows users to set section options, such as layout sections automatically, section name address, output external defined symbols to the file, and ROM to RAM mapped section.\n    *   There are checkboxes for each option, and users can select or deselect them as needed.\n\nOverall, the image shows a comprehensive set of options and settings for a programming environment. The menu bar provides easy access to various sections, and each section has its own set of options and sub-options. The checkboxes and dropdown menus allow users to customize their settings according to their needs.', 'The image shows a screenshot of a computer program, specifically a section viewer. The program is open on a Windows computer, as indicated by the title bar at the top of the window.\n\n*   **Title Bar**\n    *   The title bar is located at the top of the window and displays the text ""Section Viewer"".\n    *   There is a small icon in the top-left corner of the title bar, which appears to be a folder or directory icon.\n*   **Menu Bar**\n    *   Below the title bar is a menu bar with several options.\n    *   The options include ""Add Section"", ""New Overlay"", ""Remove Section"", ""Move Up"", ""Move Down"", ""Import..."", and ""Export..."".\n    *   The ""Add Section"" option is highlighted in red, indicating that it is the currently selected option.\n*   **Section Viewer Window**\n    *   The main window of the program is divided into two columns.\n    *   The left column displays a list of sections, with each section represented by a line of text.\n    *   The right column displays a list of options for the selected section.\n    *   The selected section is highlighted in red, and the options for that section are displayed in the right column.\n*   **Buttons**\n    *   At the bottom of the window are several buttons.\n    *   The buttons include ""Re-Apply"", ""OK"", and ""Cancel"".\n    *   The ""Re-Apply"" button is highlighted in red, indicating that it is the currently selected option.\n\nOverall, the image shows a screenshot of a computer program that allows users to view and manage sections of data. The program has a menu bar with several options, a section viewer window with two columns, and several buttons at the bottom of the window.', 'The image shows a screenshot of a computer program with a menu and a window for adding a file. The menu is on the left side of the screen, and it has several options such as ""Logging"", ""Settings"", ""Stack Analysis"", ""Tool Chain Editor"", ""C/C++ General"", ""Project Natures"", ""Project References"", ""Renessas QE"", ""Run/Debug Settings"", ""Task Tags"", and ""Validation"". \n\nThe main window is in the center of the screen, and it has a title bar that says ""Add file..."". Below the title bar, there are several fields where you can enter information about the file you want to add. These fields include ""Format:"", ""File name:"", ""Module name:"", ""Section name:"", ""Boundary alignment:"", ""Section attribute:"", and ""Symbol name:"". \n\nThere are also several buttons at the bottom of the window, including ""OK"", ""Cancel"", ""Restore Defaults"", and ""Apply and Close"". The background of the image is white, and the text and icons are in shades of gray and blue. Overall, the image appears to be a screenshot of a computer program used for managing files and projects.', 'The image shows a screenshot of a computer program with a menu bar at the top and a list of options on the left side. The menu bar has several tabs, including ""Debug Information"", ""Optimization"", ""Input File"", ""Output File"", ""Link"", ""Device"", ""Output Code"", ""Variables/functions information"", and ""Using Libraries"". \n\nThe ""Using Libraries"" tab is highlighted in blue, indicating that it is the current selection. Below the menu bar, there is a list of options related to the selected tab, including ""System libraries"", ""Use standard mathematical libraries"", ""Check memory smashing on releasing memory"", and ""Use inline libraries"". \n\nThe background of the image is a light gray color, with a darker gray border around the edges. Overall, the image appears to be a screenshot of a computer program used for debugging or optimizing code.', 'The image shows a screenshot of the ""Settings"" window in Visual Studio, with the ""Tool Settings"" tab selected. The window is divided into two main sections: the left side lists various settings categories, and the right side displays the settings for the currently selected category.\n\n*   **Left Side:**\n    *   The left side of the window lists various settings categories, including:\n        *   Common\n        *   CPU\n        *   Device\n        *   Miscellaneous\n        *   Compiler\n        *   Source\n        *   Language\n        *   Object\n        *   Optimization\n        *   Output Code\n        *   Miscellaneous\n        *   MISRA C Rule Check\n        *   User\n        *   Assembler\n        *   Source\n        *   Language\n        *   Object\n        *   Optimization\n        *   Miscellaneous\n        *   User\n        *   Linker\n        *   Input\n        *   Advanced\n        *   List\n        *   Optimization\n        *   Section\n        *   Device\n        *   Output\n        *   Advanced\n        *   Miscellaneous\n        *   User\n        *   Converter\n        *   Output\n        *   Hex format\n        *   CRC Operation\n        *   Miscellaneous\n*   **Right Side:**\n    *   The right side of the window displays the settings for the currently selected category, which is ""Device"".\n    *   The settings include:\n        *   Security ID value (-security_id)\n        *   Reserve working memory for RRM/DMM function (-rrm)\n        *   Start address area (-rrm= <value>)\n        *   Secure memory area of OCD monitor (-debug_monitor)\n        *   Memory area (-debug_monitor= <start address> - <end address>)\n        *   Set user option byte (-user_opt_byte)\n        *   User option byte value (-user_opt_byte= <value>)\n        *   Set enable/disable on-chip debug by link option (-ocdbg)\n        *   On-chip debug control value (-ocdbg= <value>)\n        *   RAM area without section (-self/-ocdtr/-ocdhpi)\n        *   Output a warning message when a section is allocated to the RAM area (-selfw/-ocdtrw/-ocdhpiw)\n        *   Check specifications of device (-check_device)\n        *   Suppress checking section allocation that crosses (64KB-1) boundary (-check_64k_only)\n        *   Do not check memory allocation of sections (-no_check_section_layout)\n        *   Address range of memory type (-cpu)\n\nThe image shows a screenshot of the ""Settings"" window in Visual Studio, with the ""Tool Settings"" tab selected. The window is divided into two main sections: the left side lists various settings categories, and the right side displays the settings for the currently selected category, which is ""Device"". The settings include security ID value, reserve working memory for RRM/DMM function, start address area, secure memory area of OCD monitor, memory area, set user option byte, user option byte value, set enable/disable on-chip debug by link option, on-chip debug control value, RAM area without section, output a warning message when a section is allocated to the RAM area, check specifications of device, suppress checking section allocation that crosses (64KB-1) boundary, and do not check memory allocation of sections.', 'The image shows a screenshot of a computer program with a list of options and settings. The program appears to be a development environment or a tool for working with code.\n\n*   **Menu Bar**\n    *   The menu bar is located at the top of the window and contains several options, including ""Debug Information"", ""Optimization"", ""Input File"", ""Output File"", ""Library"", ""Device"", and ""Control allocation to self RAM area"".\n    *   Each option has a dropdown menu with sub-options.\n*   **Settings**\n    *   The settings are organized into sections, with each section having its own set of options.\n    *   The ""Debug Information"" section has options for output debug information, compressing debug information, and deleting local symbol name information.\n    *   The ""Optimization"" section has options for optimization type, input file, output file, and library.\n    *   The ""Input File"" section has options for object file, binary file, symbol definition, and output folder.\n    *   The ""Output File"" section has options for output folder, output file name, and using libraries.\n    *   The ""Library"" section has options for system libraries, using libraries, and using standard mathematical libraries.\n    *   The ""Device"" section has options for set enable/disable on-chip debug by link option, option byte values for OCD, set debug monitor area, and set user option byte.\n    *   The ""Control allocation to self RAM area"" section has options for output code, specific execution start address, fill with padding data at the end of a section, address setting for specified area of vector table, address setting for unused vector area, generate function list used for detecting illegal indirect function call, and split vector table sections.\n*   **Code Editor**\n    *   The code editor is located below the menu bar and settings.\n    *   It appears to be a text editor with syntax highlighting and code completion.\n    *   The code editor has a scrollbar on the right side, indicating that there is more code than can be displayed in the current window.\n*   **Status Bar**\n    *   The status bar is located at the bottom of the window and displays information about the current state of the program.\n    *   It shows the current file being edited, the line number, and the column number.\n\nOverall, the image suggests that the program is a development environment or a tool for working with code, and it provides a range of options and settings for customizing the behavior of the program.', 'The image shows a screenshot of the ""Configuration"" window in Visual Studio, which is used to configure various settings for a project or solution. The window is divided into several sections, each with its own set of options and settings.\n\n*   **Tool Settings**\n    *   **Common**\n        *   **CPU**: This option allows you to select the type of CPU that will be used for debugging. The default is ""Any CPU"".\n        *   **Device**: This option allows you to select the type of device that will be used for debugging. The default is ""Local Machine"".\n        *   **Miscellaneous**: This option allows you to select additional settings for debugging. The default is ""None"".\n    *   **Compiler**\n        *   **Secure memory area of OCD monitor (-debug_monitor)**: This option allows you to enable or disable the secure memory area of the OCD monitor. The default is ""None"".\n        *   **Memory area (-debug_monitor=<start address>-<end address>)**: This option allows you to specify the memory area that will be used for debugging. The default is ""7FE00-7FFFF"".\n    *   **Source**\n        *   **Language**: This option allows you to select the programming language that will be used for debugging. The default is ""C++"".\n        *   **Object**: This option allows you to select the type of object that will be used for debugging. The default is ""None"".\n        *   **Optimization**: This option allows you to select the level of optimization that will be used for debugging. The default is ""None"".\n        *   **Output Code**: This option allows you to select the type of output code that will be generated for debugging. The default is ""None"".\n        *   **Miscellaneous**: This option allows you to select additional settings for debugging. The default is ""None"".\n    *   **MISRA C Rule Check**\n        *   **User**: This option allows you to select the user who will be used for debugging. The default is ""None"".\n        *   **Assembler**: This option allows you to select the assembler that will be used for debugging. The default is ""None"".\n        *   **Source**: This option allows you to select the source code that will be used for debugging. The default is ""None"".\n        *   **Language**: This option allows you to select the programming language that will be used for debugging. The default is ""C++"".\n        *   **Object**: This option allows you to select the type of object that will be used for debugging. The default is ""None"".\n        *   **Optimization**: This option allows you to select the level of optimization that will be used for debugging. The default is ""None"".\n        *   **Output Code**: This option allows you to select the type of output code that will be generated for debugging. The default is ""None"".\n        *   **Miscellaneous**: This option allows you to select additional settings for debugging. The default is ""None"".\n    *   **Linker**\n        *   **Input**: This option allows you to select the input files that will be used for debugging. The default is ""None"".\n        *   **Advanced**: This option allows you to select additional settings for debugging. The default is ""None"".\n    *   **Output**\n        *   **Advanced**: This option allows you to select additional settings for debugging. The default is ""None"".\n    *   **Miscellaneous**\n        *   **User**: This option allows you to select the user who will be used for debugging. The default is ""None"".\n        *   **List**: This option allows you to select the list of files that will be used for debugging. The default is ""None"".\n        *   **Converter**: This option allows you to select the converter that will be used for debugging. The default is ""None"".\n        *   **Output**: This option allows you to select the output files that will be generated for debugging. The default is ""None"".\n        *   **Hex format**: This option allows you to select the hex format that will be used for debugging. The default is ""None"".\n        *   **CRC Operation**: This option allows you to select the CRC operation that will be used for debugging. The default is ""None"".\n        *   **Miscellaneous**: This option allows you to select additional settings for debugging. The default is ""None"".\n\nIn summary, the ""Configuration"" window in Visual Studio provides a wide range of options and settings for configuring various aspects of a project or solution, including tool settings, compiler settings, source code settings, linker settings, output settings, and miscellaneous settings. By adjusting these settings, developers can customize the behavior of their code and optimize its performance.', 'The image shows a screenshot of a computer program with a list of options and settings. The program appears to be a development environment or a tool for working with code.\n\n*   **Menu Bar**\n    *   The menu bar is located at the top of the window and contains several options, including ""Debug Information"", ""Optimization"", ""Input File"", ""Output File"", ""Library"", ""Device"", and ""Control allocate to self RAM area"".\n    *   Each option has a dropdown menu with sub-options.\n*   **Settings**\n    *   The settings are organized into sections, with each section having its own set of options.\n    *   The ""Debug Information"" section has options for output debug information, compressing debug information, and deleting local symbol name information.\n    *   The ""Optimization"" section has options for optimization type, input file, output file, library, and device.\n    *   The ""Input File"" section has options for object file, binary file, symbol definition, and output folder.\n    *   The ""Output File"" section has options for output folder, output file name, and using libraries.\n    *   The ""Library"" section has options for system libraries, using libraries, and using standard mathematical libraries.\n    *   The ""Device"" section has options for set enable/disable on-chip debug by link option, option byte values for OCD, set debug monitor area, and set user option byte.\n    *   The ""Control allocate to self RAM area"" section has options for output code, control allocate to self RAM area, and list variables/functions information.\n*   **Code Editor**\n    *   The code editor is located below the menu bar and contains a list of code snippets or examples.\n    *   The code snippets are organized into sections, with each section having its own set of code examples.\n    *   The code examples are written in a programming language, possibly C or C++.\n*   **Status Bar**\n    *   The status bar is located at the bottom of the window and displays information about the current state of the program.\n    *   The status bar shows the current file being edited, the line number, and the column number.\n\nOverall, the image suggests that the program is a development environment or a tool for working with code, and it provides a range of options and settings for customizing the behavior of the program. The code editor is the main area where users can write and edit code, and the status bar provides information about the current state of the program.']"
9fdab48172f9db4b11a4bd41ad5838e4,"Last updated: 19/07/2024
How to initialize RAM to avoid RAM parity errors  ?
During startup some parts of RAM (.bss, .dataR , stack sections) are initialized but others do not. As a result there are uninitialized parts in RAM that can cause RAM parity errors.
To avoid these errors, RAM must be initialized manually during initialization. To do this, the cstart.asm file should be modified as per the following example:
The RAM start address and size are according to below address range so please modify according to your device.","['data/categories/rl78_family/memory/9fdab48172f9db4b11a4bd41ad5838e4/images/13627864c40b6c1d0d1209898dd2cfba.png', 'data/categories/rl78_family/memory/9fdab48172f9db4b11a4bd41ad5838e4/images/3b710b79de43fabc87a0fa2e89451b59.png']",[],[],"{'title': '[RL78] How to initialize RAM to avoid RAM parity errors ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21483964', 'last_updated': None, 'extracted_at': '2025-03-09T00:00:00.766864'}","Last updated 19/07/2024 How to initialize RAM to avoid RAM parity errors ? During startup some parts of RAM (.bss, .dataR , stack sections) are initialized but others do not. As a result there are uninitialized parts in RAM that can cause RAM parity errors. To avoid these errors, RAM must be initialized manually during initialization. To do this, the cstart.asm file should be modified as per the following example The RAM start address and size are according to below address range so please modify according to your device.","['The image shows a code snippet in a programming language, likely C or C++. The code is written in a monospaced font and is displayed on a white background.\n\nThe code snippet appears to be a function that initializes a memory block. It includes several lines of code that allocate memory, copy data into the memory block, and perform other operations. The code also includes comments and labels to help explain what each section of the code is doing.\n\nHere is a breakdown of the code:\n\n*   The first line of code allocates a block of memory using the `malloc` function. The size of the block is specified as 16KB (16 * 1024 bytes).\n*   The second line of code copies data from a string literal into the allocated memory block. The string literal is defined as a sequence of characters enclosed in double quotes.\n*   The third line of code sets the value of a variable to the address of the allocated memory block.\n*   The fourth line of code sets the value of another variable to the size of the allocated memory block.\n*   The fifth line of code calls a function named `loop_s` with the address of the allocated memory block as an argument.\n*   The sixth line of code calls a function named `loop_s` with the size of the allocated memory block as an argument.\n\nOverall, the code appears to be initializing a memory block and performing some operations on it. The specific details of the code will depend on the context in which it is being used.\n\nIn summary, the image shows a code snippet that initializes a memory block and performs some operations on it. The code includes several lines of code that allocate memory, copy data into the memory block, and perform other operations. The code also includes comments and labels to help explain what each section of the code is doing.', 'The image depicts a memory map, specifically Figure 3-7, which is part of Chapter 3: CPU Architecture in the RL78/D1A manual. The memory map is divided into several sections, each representing a different type of memory or register.\n\n*   **Special function register (SFR)**: This section contains 256 bytes of memory, with addresses ranging from FFFFH to FFFFH.\n*   **General-purpose register**: This section has 32 bytes of memory, with addresses ranging from FFE0H to FFE0H.\n*   **RAM**: This section has 16 KB of memory, with addresses ranging from FFE0H to FFE0H.\n*   **Mirror**: This section has 35.75 KB of memory, with addresses ranging from FFE0H to FFE0H.\n*   **Data flash memory**: This section has 8 KB of memory, with addresses ranging from FFE0H to FFE0H.\n*   **Reserved**: This section has no memory allocated, with addresses ranging from FFE0H to FFE0H.\n*   **Special function register (2nd SFR)**: This section has 2 KB of memory, with addresses ranging from FFE0H to FFE0H.\n\nThe memory map also includes several other sections, such as the Program area, On-chip debug security ID setting area, Option byte area, CALT table area, and Boot cluster 1. These sections are not explicitly labeled with memory sizes or addresses.\n\nOverall, the memory map provides a detailed view of the different types of memory and registers available in the RL78/D1A microcontroller, along with their corresponding addresses and sizes.']"
ba1d37fb897f8aab88b9201ad7cf4b25,"Last updated: 18/01/2024
How can I read the flash contents of a RL78 device ?
The RL78 programming interface does not permit reading flash memory at all.
The RL78 debugging interface does under the following conditions:
1. The debugging is enabled on the device.
2. The debug monitor area (small piece of code installed to the flash memory downloaded when debugging the device) is installed on the device.
3. Both points above are not typical of released devices - only the user can answer whether they have devices in this state.
4. The user will need to ensure they have matching security ID's (if the user has changed it at all, again he will need to know this in advance).
The above points can be summarized with the question: With the binary the device was flashed with, was debugging enabled?
If it was, the subsequent information is relevant.. If it was not, there is no retrieving program data without corruption of flash.
Assuming debugging was enabled on the binary the following can be done:
1. Create an empty project for a device which they would like to communicate.
2. Disable flash erase in the debug tool settings.
3.Then also uncheck the program binary in ""Load image and symbols"":
4. Then launch a debug session connecting to your device.
5. You will be presented with something like this i.e., no source or symbols (because you have no program data or symbols):
6.From here you can use the memory view:
7. Then use the ""export tool"" (circled in red in top right of first image below) to export the entire flash memory range for your device (I am using the rl78/g22 (R7F102GxE) with 64k code flash as an example):
This will output the program binary in S3 SREC format, fixed 32bit width for the entire code flash - but again please specify the code flash memory range for your device.
If you do not have debugging enabled on the device already, the only way to connect to the device would be the corrupt the code flash by re-writing it with debugging code, which will make the output useless.
This is the best we can do - but it's worth noting that if the device is in the right state for connection and the result is to get the binary output – this won't give any code symbols, it's just post-compilation binary data, with which the user will not be able to reverse compile the project to get the code back.","['data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/03f040f6bfef2e5b153ea94d113980e9.png', 'data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/c08c7f283e01c4b5806a6eddb61e8550.png', 'data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/bc0b20170dcf6248c5fbc47517743868.png', 'data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/53810cec90a6abaedc8b88f973d62b9e.png', 'data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/573b90bfd5e4297d2127e7a69c466133.png', 'data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/ff4e7ed59a434105231ea05a9aac3fa4.png']",[],[],"{'title': 'How can I read the flash contents of a RL78 device ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21204937', 'last_updated': None, 'extracted_at': '2025-03-08T23:59:57.857640'}","Last updated 18/01/2024 How can I read the flash contents of a RL78 device ? The RL78 programming interface does not permit reading flash memory at all. The RL78 debugging interface does under the following conditions 1. The debugging is enabled on the device. 2. The debug monitor area (small piece of code installed to the flash memory downloaded when debugging the device) is installed on the device. 3. Both points above are not typical of released devices - only the user can answer whether they have devices in this state. 4. The user will need to ensure they have matching security ID's (if the user has changed it at all, again he will need to know this in advance). The above points can be summarized with the question With the binary the device was flashed with, was debugging enabled? If it was, the subsequent information is relevant.. If it was not, there is no retrieving program data without corruption of flash. Assuming debugging was enabled on the binary the following can be done 1. Create an empty project for a device which they would like to communicate. 2. Disable flash erase in the debug tool settings. 3.Then also uncheck the program binary in ""Load image and symbols"" 4. Then launch a debug session connecting to your device. 5. You will be presented with something like this i.e., no source or symbols (because you have no program data or symbols) 6.From here you can use the memory view 7. Then use the ""export tool"" (circled in red in top right of first image below) to export the entire flash memory range for your device (I am using the rl78/g22 (R7F102GxE) with 64k code flash as an example) This will output the program binary in S3 SREC format, fixed 32bit width for the entire code flash - but again please specify the code flash memory range for your device. If you do not have debugging enabled on the device already, the only way to connect to the device would be the corrupt the code flash by re-writing it with debugging code, which will make the output useless. This is the best we can do - but it's worth noting that if the device is in the right state for connection and the result is to get the binary output  this won't give any code symbols, it's just post-compilation binary data, with which the user will not be able to reverse compile the project to get the code back.","['The image shows a screenshot of a computer program, specifically the ""Debug Configurations"" window in Eclipse, a popular integrated development environment (IDE) for software development. The window is open on a Windows computer, as indicated by the Windows logo in the top-right corner.\n\n**Window Layout**\n\nThe window is divided into two main sections: the left-hand side and the right-hand side. The left-hand side contains a list of filter text options, which are used to narrow down the list of debug configurations. The right-hand side displays the main debug configurations window, which is organized into several sections.\n\n**Main Debug Configurations Window**\n\nThe main debug configurations window is divided into several sections, each with its own set of options and settings. The sections include:\n\n* **Name**: This section displays the name of the debug configuration.\n* **Main**: This section contains general settings for the debug configuration, such as the target device and the debug tool settings.\n* **Connection with Target Board**: This section allows users to configure the connection settings for the target board, including the emulator and power target from the emulator (MAX 200mA).\n* **Flash**: This section allows users to configure the flash settings, including the current security ID (HEX), current serial programming security ID (HEX), permit rewrite the serial programming security ID, permit flash programming, use wide voltage mode, erase flash ROM when starting, program uses flash self-programming, and fill unused area with 0xFF when writing flash memory.\n\n**Filter Text Options**\n\nThe left-hand side of the window contains a list of filter text options, which are used to narrow down the list of debug configurations. The filter text options include:\n\n* **C/C++ Application**\n* **C/C++ Remote Application**\n* **EASE Script**\n* **GDB Hardware Debugging**\n* **GDB Simulator Debugging (RHI)**\n* **Launch Group**\n* **Renesas GDB Hardware Debugs**\n* **g22 read flash HardwareDet**\n* **Renesas Simulator Debugging**\n\n**Button Bar**\n\nAt the bottom of the window, there is a button bar with several buttons, including:\n\n* **Debug**: This button is used to start the debug session.\n* **Revert**: This button is used to revert any changes made to the debug configuration.\n* **Apply**: This button is used to apply any changes made to the debug configuration.\n* **Close**: This button is used to close the debug configurations window.\n\nOverall, the image shows a screenshot of the ""Debug Configurations"" window in Eclipse, which is used to configure and manage debug sessions for software development. The window is divided into several sections, each with its own set of options and settings, and includes a button bar with several buttons for starting, reverting, applying, and closing the debug configuration.', 'The image shows a screenshot of a computer program, specifically the ""Debug Configurations"" window in Visual Studio. The window is open on a Windows computer, and it appears to be a development environment for creating, managing, and running configurations for debugging purposes.\n\nHere are the key elements in the image:\n\n*   **Window Title**: The title of the window is ""Debug Configurations,"" which indicates that this is a window for managing and configuring debugging settings.\n*   **Menu Bar**: The menu bar at the top of the window has several options, including ""File,"" ""Edit,"" ""View,"" ""Debug,"" and ""Tools."" These menus provide access to various features and functions within the program.\n*   **Toolbar**: Below the menu bar is a toolbar with several icons, including a magnifying glass, a bug, and a gear. These icons likely represent different tools and features available in the program.\n*   **Workspace**: The main area of the window is divided into two sections: a left-hand panel and a right-hand panel. The left-hand panel lists various configurations, while the right-hand panel displays the details of the selected configuration.\n*   **Configuration List**: In the left-hand panel, there is a list of configurations, including ""C/C++ Application,"" ""EASE Script,"" ""GDB Hardware Debugging,"" and ""Renesas GDB Hardware Debugging."" Each configuration has a checkbox next to it, indicating whether it is currently selected or not.\n*   **Configuration Details**: In the right-hand panel, there are several sections that display the details of the selected configuration. These sections include ""Name,"" ""Main,"" ""Debugger,"" ""Common,"" and ""Source."" Each section has its own set of options and settings that can be adjusted.\n*   **Buttons**: At the bottom of the window, there are several buttons, including ""Debug,"" ""Apply,"" ""Revert,"" and ""Close."" These buttons allow users to perform various actions, such as starting the debugger, applying changes, reverting to a previous state, and closing the window.\n\nOverall, the image suggests that this is a powerful tool for developers who need to debug and test their code. The various menus, tools, and settings available in the program provide a high degree of customization and control over the debugging process.', 'The image shows a screenshot of a computer screen displaying a code editor with a terminal window open. The code editor is on the left side of the screen, and the terminal window is on the right side.\n\n*   **Code Editor:**\n    *   The code editor is open to a file with the name ""g2_read_Flash_HardwareDebug"" and has several lines of code visible.\n    *   The code appears to be written in C++ and includes comments and variable declarations.\n    *   There are several tabs at the top of the code editor, including ""Debug"", ""Variables"", ""Breakpoints"", ""Project"", ""Express"", ""Events"", ""PC"", ""0x0A:0/2"", and ""Count"".\n    *   The ""Debug"" tab is currently selected, and it shows a list of breakpoints and their corresponding line numbers.\n*   **Terminal Window:**\n    *   The terminal window is open to a command prompt with the title ""g2_read_Flash_HardwareDebug"".\n    *   The command prompt shows a list of commands that have been executed, including ""g2_read_Flash_HardwareDebug [Renitas GDB Hardware Debugging] [5]"".\n    *   The terminal window also shows a list of variables and their values, including ""Version 9.2.0.v20230724-103743 [F3aeb054] (Jul 14 2023 13:41:09)"".\n    *   There is a ""Project"" tab at the top of the terminal window, which allows the user to manage projects and files.\n*   **Other Elements:**\n    *   There are several other elements on the screen, including a menu bar at the top with options such as ""File"", ""Edit"", ""View"", and ""Help"".\n    *   There is also a toolbar with buttons for common actions such as ""New"", ""Open"", ""Save"", and ""Exit"".\n    *   In the bottom-right corner of the screen, there is a status bar that shows information about the current file and project.\n\nOverall, the image suggests that the user is working on a project in a code editor and using a terminal window to execute commands and manage files. The presence of a menu bar, toolbar, and status bar indicates that the user is using a graphical user interface (GUI) to interact with the code editor and terminal window.', 'The image shows a screenshot of the Visual Studio Code (VS Code) interface, with the ""Window"" menu open and the ""Memory"" section highlighted. The ""Window"" menu is located in the top-left corner of the screen and has several sub-menus, including ""New Window"", ""Editor"", ""Appearance"", ""Show View"", ""Perspective"", ""Navigation"", and ""Preferences"". The ""Show View"" sub-menu is currently selected, and it contains several options, including ""Breakpoints"", ""CapTouch Workflow (QE)"", ""Console"", ""Debug"", ""Debugger Console"", ""Debug Sources"", ""Disassembly"", ""Error Log"", ""Executables"", ""Expressions"", ""Memory"", ""Modules"", ""Outline"", ""Problems"", ""Progress"", ""Project Explorer"", ""Registers"", ""Signals"", ""Smart Browser"", ""Smart Manual"", ""Templates"", ""Terminal"", and ""Variables"".\n\nThe ""Memory"" section is highlighted in blue and has several sub-options, including ""Alt+Shift+Q, O"", ""Alt+Shift+Q, X"", ""Hex Int"", and ""Other..."". The ""Hex Int"" option is currently selected, and it displays a list of hexadecimal integers in the right-hand pane of the window.\n\nOverall, the image suggests that the user is working with the VS Code interface and has opened the ""Window"" menu to access various features and tools. The highlighted ""Memory"" section indicates that the user is interested in working with memory-related functions, such as debugging and inspecting memory values.', 'The image shows a screenshot of a computer program, likely a debugger or memory editor, with a table displaying memory addresses and their corresponding values. The table is divided into several columns, including ""Address"", ""0 - 3"", ""4 - 7"", ""8 - 9"", and ""C - F"". Each row represents a different memory address, and the columns show the hexadecimal values for each byte of the address.\n\nThe table appears to be displaying the contents of a specific memory region, possibly a program\'s data or code. The values in the table are all zeros, suggesting that the memory region is currently empty or uninitialized.\n\nAt the top of the window, there are several menus and buttons, including ""Console"", ""Registers"", ""Problems"", ""Smart Browser"", ""Debugger Console"", ""Memory Usage"", ""Memory"", and ""Peripherals"". These menus likely provide additional functionality for the program, such as debugging tools, memory management options, and peripheral control.\n\nOverall, the image suggests that the program is being used to inspect and manipulate memory, possibly for debugging or testing purposes.', 'The image shows a screenshot of a computer program, specifically an export memory dialog box. The dialog box is titled ""Export Memory"" and has several fields for inputting information.\n\n*   **Format:** The format field is set to ""SRecord"" and has a dropdown menu with other options such as ""Intel Hex"" and ""Binary"".\n*   **Start address:** The start address field is set to ""0x0"" and has a text box for entering a hexadecimal value.\n*   **End address:** The end address field is set to ""0xFFFF"" and has a text box for entering a hexadecimal value.\n*   **Length:** The length field is set to ""65535"" and has a text box for entering a decimal value.\n*   **File name:** The file name field is set to ""C:\\Users\\a5126135\\Desktop\\memory.srec"" and has a text box for entering a file path.\n*   **OK:** The OK button is highlighted in yellow and is located at the bottom of the dialog box.\n*   **Cancel:** The Cancel button is located next to the OK button and is also highlighted in yellow.\n\nOverall, the image shows a dialog box that allows users to export memory data in various formats, including SRecord, Intel Hex, and Binary. The user can specify the start and end addresses of the memory range to be exported, as well as the file name and path for the exported file.']"
e68d4fcf20d6e7d5f0002ab23d3bd1bc,"Last updated: 17 Oct 2024
How can I issue a software reset on a RL78 device ?
Most RL78 devices do not have a software reset as reset source. The reset sources are usually as following:
The user can take advantage of the internal reset due to execution of illegal instruction and use it as 'software' reset.
This is what R_RFD_ForceReset function of the code flash programming library also does:
For example the .DB 255 command on CC-RL will reset the device due to illegal instruction but it can be used as a forced software reset too.
Note: The illegal instruction is generated when instruction code FFH is executed.
Reset by the illegal instruction execution not issued by emulation with the in-circuit emulator or on-chip debug emulator.
Suitable Products","['data/categories/rl78_family/reset/e68d4fcf20d6e7d5f0002ab23d3bd1bc/images/85abc75a10d450c71021c9a8b8eb6ac2.png', 'data/categories/rl78_family/reset/e68d4fcf20d6e7d5f0002ab23d3bd1bc/images/f8235e0cc36bb2b99c79bbd1bf502875.png']",[],['|  |\n|  |\n| RL78 |'],"{'title': '[RL78] How can I issue a software reset on a RL78 device ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21633589', 'last_updated': None, 'extracted_at': '2025-03-09T00:00:43.339593'}",Last updated 17 Oct 2024 How can I issue a software reset on a RL78 device ? Most RL78 devices do not have a software reset as reset source. The reset sources are usually as following The user can take advantage of the internal reset due to execution of illegal instruction and use it as 'software' reset. This is what RRFDForceReset function of the code flash programming library also does For example the .DB 255 command on CC-RL will reset the device due to illegal instruction but it can be used as a forced software reset too. Note The illegal instruction is generated when instruction code FFH is executed. Reset by the illegal instruction execution not issued by emulation with the in-circuit emulator or on-chip debug emulator. Suitable Products,"['The image displays a list of seven operations that are available to generate a reset signal. The list is numbered from 1 to 7 and includes the following operations:\n\n1. External reset input via RESET pin\n2. Internal reset by watchdog timer program loop detection\n3. Internal reset by comparison of supply voltage and detection voltage of power-on-reset (POR) circuit\n4. Internal reset by comparison of supply voltage of the voltage detector (LVD) and detection voltage\n5. Internal reset by execution of illegal instruction Note\n6. Internal reset by RAM parity error\n7. Internal reset by illegal-memory access\n\nThe list is presented in a clear and concise manner, making it easy to read and understand. The use of numbers and bullet points helps to organize the information and make it more visually appealing. Overall, the image effectively communicates the different operations that can be used to generate a reset signal.', 'The image shows a screenshot of a code snippet in a programming environment, likely Visual Studio. The code is written in C# and appears to be part of a larger program.\n\nHere are the details of the code:\n\n*   The code starts with a comment that reads `// Set illegal instruction to request internal reset * /`. This suggests that the code is intended to trigger an internal reset of the system.\n*   The next line of code is `#if (COMPILER_CC == COMPILER)`. This is a preprocessor directive that checks if the compiler being used is the same as the one specified in the `COMPILER_CC` constant.\n*   If the condition is true, the code inside the `#if` block is compiled. In this case, the code is `DB 255`. This is a directive to the compiler to insert a byte of value 255 into the generated code.\n*   The next line of code is `#elif (COMPILER_IAR == COMPILER)`. This is another preprocessor directive that checks if the compiler being used is the same as the one specified in the `COMPILER_IAR` constant.\n*   If the condition is true, the code inside the `#elif` block is compiled. In this case, the code is `_asm(""DC8 0xFF"");`. This is an assembly language instruction that inserts a byte of value 0xFF into the generated code.\n*   The final line of code is `#endif`. This marks the end of the `#if` and `#elif` blocks.\n\nOverall, the code appears to be designed to trigger an internal reset of the system by inserting a specific byte of value 255 or 0xFF into the generated code, depending on the compiler being used.']"
77f89a4d1ced35ba59e117d120fe08a8,"Question:
Please tell me the points to be aware of when using the RL78 Code Generator with the WDT.
Answer:
In the RL78 Code Generator, the Watchdog Timer (WDT) is set to 'Enabled' by default, as shown in the diagram below. To avoid unintended resets by the WDT, please either select 'Disabled' for the 'Watchdog Timer Operation Setting' or add a program to clear the Watchdog Timer counter.
Suitable Products
RL78/D1A, RL78/F12, RL78/F13, RL78/F14, RL78/F15, RL78/G10, RL78/G11, RL78/G12, RL78/G13, RL78/G13A, RL78/G14, RL78/G1A, RL78/G1C, RL78/G1D, RL78/G1E, RL78/G1F, RL78/G1G, RL78/G1H, RL78/H1D, RL78/I1A, RL78/I1B, RL78/I1C, RL78/I1D, RL78/I1E, RL78/L12, RL78/L13, RL78/L1A, RL78/L1C
Please tell me the points to be aware of when using the RL78 Code Generator with the WDT.
Please tell me the points to be aware of when using the RL78 Code Generator with the WDT.
Answer:
In the RL78 Code Generator, the Watchdog Timer (WDT) is set to 'Enabled' by default, as shown in the diagram below. To avoid unintended resets by the WDT, please either select 'Disabled' for the 'Watchdog Timer Operation Setting' or add a program to clear the Watchdog Timer counter.
Suitable Products
RL78/D1A, RL78/F12, RL78/F13, RL78/F14, RL78/F15, RL78/G10, RL78/G11, RL78/G12, RL78/G13, RL78/G13A, RL78/G14, RL78/G1A, RL78/G1C, RL78/G1D, RL78/G1E, RL78/G1F, RL78/G1G, RL78/G1H, RL78/H1D, RL78/I1A, RL78/I1B, RL78/I1C, RL78/I1D, RL78/I1E, RL78/L12, RL78/L13, RL78/L1A, RL78/L1C
In the RL78 Code Generator, the Watchdog Timer (WDT) is set to 'Enabled' by default, as shown in the diagram below. To avoid unintended resets by the WDT, please either select 'Disabled' for the 'Watchdog Timer Operation Setting' or add a program to clear the Watchdog Timer counter.
In the RL78 Code Generator, the Watchdog Timer (WDT) is set to 'Enabled' by default, as shown in the diagram below. To avoid unintended resets by the WDT, please either select 'Disabled' for the 'Watchdog Timer Operation Setting' or add a program to clear the Watchdog Timer counter.
Suitable Products
RL78/D1A, RL78/F12, RL78/F13, RL78/F14, RL78/F15, RL78/G10, RL78/G11, RL78/G12, RL78/G13, RL78/G13A, RL78/G14, RL78/G1A, RL78/G1C, RL78/G1D, RL78/G1E, RL78/G1F, RL78/G1G, RL78/G1H, RL78/H1D, RL78/I1A, RL78/I1B, RL78/I1C, RL78/I1D, RL78/I1E, RL78/L12, RL78/L13, RL78/L1A, RL78/L1C
日本語
日本語",['data/categories/rl78_family/others/77f89a4d1ced35ba59e117d120fe08a8/images/215e8b1e35b939dad9757ca246bd5d18.png'],[],"['|  |\n|  |\n| RL78/D1A, RL78/F12, RL78/F13, RL78/F14, RL78/F15, RL78/G10, RL78/G11, RL78/G12, RL78/G13, RL78/G13A, RL78/G14, RL78/G1A, RL78/G1C, RL78/G1D, RL78/G1E, RL78/G1F, RL78/G1G, RL78/G1H, RL78/H1D, RL78/I1A, RL78/I1B, RL78/I1C, RL78/I1D, RL78/I1E, RL78/L12, RL78/L13, RL78/L1A, RL78/L1C |']","{'title': 'Tell me the points to be aware of when using the RL78 Code Generator with the WDT.', 'url': 'https://en-support.renesas.com/knowledgeBase/21715566', 'last_updated': '2024-10-12', 'extracted_at': '2025-03-09T00:01:25.089871'}","Question Please tell me the points to be aware of when using the RL78 Code Generator with the WDT. Answer In the RL78 Code Generator, the Watchdog Timer (WDT) is set to 'Enabled' by default, as shown in the diagram below. To avoid unintended resets by the WDT, please either select 'Disabled' for the 'Watchdog Timer Operation Setting' or add a program to clear the Watchdog Timer counter. Suitable Products RL78/D1A, RL78/F12, RL78/F13, RL78/F14, RL78/F15, RL78/G10, RL78/G11, RL78/G12, RL78/G13, RL78/G13A, RL78/G14, RL78/G1A, RL78/G1C, RL78/G1D, RL78/G1E, RL78/G1F, RL78/G1G, RL78/G1H, RL78/H1D, RL78/I1A, RL78/I1B, RL78/I1C, RL78/I1D, RL78/I1E, RL78/L12, RL78/L13, RL78/L1A, RL78/L1C ","['The image shows a screenshot of a computer program\'s settings window, specifically the ""Code Generator"" section. The window is divided into two main sections: the top section contains various icons and menus, while the bottom section displays a list of settings with corresponding input fields.\n\n**Top Section:**\n\n*   A blue bar at the top of the window with the words ""Property"" and ""Code Generator"" in white text.\n*   A menu bar with several icons, including a folder icon, a clock icon, a gear icon, and a speaker icon.\n*   A dropdown menu labeled ""Reflect in Pin"" with options to select from.\n*   A dropdown menu labeled ""Generate Code"" with options to select from.\n\n**Bottom Section:**\n\n*   A list of settings with corresponding input fields, including:\n    *   ""Watchdog timer operation setting""\n        *   A checkbox labeled ""Unused"" and a dropdown menu labeled ""Used"" with options to select from.\n    *   ""Operation in HALT/STOP/SNOOZE mode setting""\n        *   A dropdown menu labeled ""Enabled"" with options to select from.\n    *   ""Overflow time setting""\n        *   A text field labeled ""Overflow time"" with a value of 4369.07 (2^16/fIL) and a dropdown menu labeled ""(ms)"" with options to select from.\n    *   ""Window open period setting""\n        *   A dropdown menu labeled ""Window open period"" with options to select from.\n    *   ""Interrupt setting""\n        *   A checkbox labeled ""Enable interval interrupt when 75% + 1/2fIL of overflow time (INTWDI)"" and a dropdown menu labeled ""Priority"" with options to select from.\n\nOverall, the image shows a detailed settings window for a computer program, allowing users to customize various parameters such as watchdog timer operation, overflow time, and window open period.']"
5730b1afab0205f7a297ca241eae09f1,"Question:
What are the concerns with inserting a resistor between the REGC pin and the capacitor?
Answer:
The voltage applied to the REGC pin is crucial for the internal circuits of RL78 products. 
We would like to inform you that inserting a resistor between the REGC pin and the capacitor can cause the voltage supplied to the internal circuit of the RL78 product to become unstable, potentially impacting the device's performance. Therefore, we do not recommend inserting a resistor for stable operation of RL78 products.
However, if you require resistor insertion for some reason, please ensure that the following criteria are met and assess whether resistor insertion is acceptable or not.
Select a resistor with a resistance value of 50 Ω or less, and as small a value as possible.
Voltage fluctuations on the REGC pin should always be within ± 0.1 V.
Caution:
The voltage applied to the REGC pin (regulator output voltage) varies depending on the RL78 microcontroller and flash operation mode.
For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
RL78/G13
LS (Low-speed main) mode, LV (Low-voltage main) mode: 1.8V
HS (high speed main) mode: 2.1V
RL78/G23
1.5V
Remark:
To prevent noise from affecting the internal circuits of RL78 products through the capacitor connected to the REGC pin, it is recommended to strengthen the power supply by adding bypass capacitors near the device. 
If noise is applied to the GND side, it may be transmitted to the internal circuits, so taking these measures can be effective in reducing its impact.
Suitable Products
RL78 Family
What are the concerns with inserting a resistor between the REGC pin and the capacitor?
What are the concerns with inserting a resistor between the REGC pin and the capacitor?
Answer:
The voltage applied to the REGC pin is crucial for the internal circuits of RL78 products. 
We would like to inform you that inserting a resistor between the REGC pin and the capacitor can cause the voltage supplied to the internal circuit of the RL78 product to become unstable, potentially impacting the device's performance. Therefore, we do not recommend inserting a resistor for stable operation of RL78 products.
However, if you require resistor insertion for some reason, please ensure that the following criteria are met and assess whether resistor insertion is acceptable or not.
Select a resistor with a resistance value of 50 Ω or less, and as small a value as possible.
Voltage fluctuations on the REGC pin should always be within ± 0.1 V.
Caution:
The voltage applied to the REGC pin (regulator output voltage) varies depending on the RL78 microcontroller and flash operation mode.
For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
RL78/G13
LS (Low-speed main) mode, LV (Low-voltage main) mode: 1.8V
HS (high speed main) mode: 2.1V
RL78/G23
1.5V
Remark:
To prevent noise from affecting the internal circuits of RL78 products through the capacitor connected to the REGC pin, it is recommended to strengthen the power supply by adding bypass capacitors near the device. 
If noise is applied to the GND side, it may be transmitted to the internal circuits, so taking these measures can be effective in reducing its impact.
Suitable Products
RL78 Family
The voltage applied to the REGC pin is crucial for the internal circuits of RL78 products. 
We would like to inform you that inserting a resistor between the REGC pin and the capacitor can cause the voltage supplied to the internal circuit of the RL78 product to become unstable, potentially impacting the device's performance. Therefore, we do not recommend inserting a resistor for stable operation of RL78 products.
However, if you require resistor insertion for some reason, please ensure that the following criteria are met and assess whether resistor insertion is acceptable or not.
Select a resistor with a resistance value of 50 Ω or less, and as small a value as possible.
Voltage fluctuations on the REGC pin should always be within ± 0.1 V.
Caution:
The voltage applied to the REGC pin (regulator output voltage) varies depending on the RL78 microcontroller and flash operation mode.
For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
RL78/G13
LS (Low-speed main) mode, LV (Low-voltage main) mode: 1.8V
HS (high speed main) mode: 2.1V
RL78/G23
1.5V
Remark:
To prevent noise from affecting the internal circuits of RL78 products through the capacitor connected to the REGC pin, it is recommended to strengthen the power supply by adding bypass capacitors near the device. 
If noise is applied to the GND side, it may be transmitted to the internal circuits, so taking these measures can be effective in reducing its impact.
The voltage applied to the REGC pin is crucial for the internal circuits of RL78 products. 
We would like to inform you that inserting a resistor between the REGC pin and the capacitor can cause the voltage supplied to the internal circuit of the RL78 product to become unstable, potentially impacting the device's performance. Therefore, we do not recommend inserting a resistor for stable operation of RL78 products.
However, if you require resistor insertion for some reason, please ensure that the following criteria are met and assess whether resistor insertion is acceptable or not.
Caution:
The voltage applied to the REGC pin (regulator output voltage) varies depending on the RL78 microcontroller and flash operation mode.
For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
Remark:
To prevent noise from affecting the internal circuits of RL78 products through the capacitor connected to the REGC pin, it is recommended to strengthen the power supply by adding bypass capacitors near the device. 
If noise is applied to the GND side, it may be transmitted to the internal circuits, so taking these measures can be effective in reducing its impact.
Suitable Products
RL78 Family
日本語
日本語",['data/categories/rl78_family/others/5730b1afab0205f7a297ca241eae09f1/images/cbd80ea6cb946652c96b61d100d15ca1.png'],[],['|  |\n|  |\n| RL78 Family |'],"{'title': 'Noise countermeasures to the REGC pin', 'url': 'https://en-support.renesas.com/knowledgeBase/20916011', 'last_updated': '2023-11-05', 'extracted_at': '2025-03-09T00:01:32.575371'}","Question What are the concerns with inserting a resistor between the REGC pin and the capacitor? Answer The voltage applied to the REGC pin is crucial for the internal circuits of RL78 products. We would like to inform you that inserting a resistor between the REGC pin and the capacitor can cause the voltage supplied to the internal circuit of the RL78 product to become unstable, potentially impacting the device's performance. Therefore, we do not recommend inserting a resistor for stable operation of RL78 products. However, if you require resistor insertion for some reason, please ensure that the following criteria are met and assess whether resistor insertion is acceptable or not. Select a resistor with a resistance value of 50  or less, and as small a value as possible. Voltage fluctuations on the REGC pin should always be within  0.1 V. Caution The voltage applied to the REGC pin (regulator output voltage) varies depending on the RL78 microcontroller and flash operation mode. For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product. Example of regulator output voltage RL78/G13 LS (Low-speed main) mode, LV (Low-voltage main) mode 1.8V HS (high speed main) mode 2.1V RL78/G23 1.5V Remark To prevent noise from affecting the internal circuits of RL78 products through the capacitor connected to the REGC pin, it is recommended to strengthen the power supply by adding bypass capacitors near the device. If noise is applied to the GND side, it may be transmitted to the internal circuits, so taking these measures can be effective in reducing its impact. Suitable Products RL78 Family ","['The image depicts a simple electronic circuit diagram, featuring a resistor (R) and a voltage source (VSS). The resistor is represented by a zigzag line, while the voltage source is denoted by a horizontal line with an arrowhead at one end. The circuit is connected to a ground plane, which is not explicitly labeled but implied by the presence of the voltage source.\n\nThe circuit is labeled ""Insert Resistor"" in the top-left corner, indicating that the resistor is intended to be inserted into the circuit at this point. The diagram also includes a dashed rectangle surrounding the resistor, suggesting that it may be a component that can be removed or replaced.\n\nOverall, the image provides a clear and concise visual representation of a basic electronic circuit, highlighting the key components and their connections.']"
07ef99b5d7a7eaabf982c5966ea3dade,"Question:
I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is +-3% for the grade K (up to 125°C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator.
Answer:
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
This is available on the document section of the product landing page.
  This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
Suitable Products
RL78
Question:
I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is +-3% for the grade K (up to 125°C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator.
Answer:
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
This is available on the document section of the product landing page.
  This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
Suitable Products
RL78
I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is +-3% for the grade K (up to 125°C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator.
I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is +-3% for the grade K (up to 125°C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator.
I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is +-3% for the grade K (up to 125°C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator.
Answer:
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
This is available on the document section of the product landing page.
  This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
Suitable Products
RL78
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
This is available on the document section of the product landing page.
  This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
This is available on the document section of the product landing page.
This is available on the document section of the product landing page.
This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
This should show the variation across the temperature range.
These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
Suitable Products
RL78",['data/categories/rl78_family/electrical_characteristics/07ef99b5d7a7eaabf982c5966ea3dade/images/6b82dcbba8fc503dfae2e2b7964c843e.png'],[],['|  |\n|  |\n| RL78 |'],"{'title': 'RL78 F13/14/15 electrical characteristics', 'url': 'https://en-support.renesas.com/knowledgeBase/21671335', 'last_updated': None, 'extracted_at': '2025-03-08T23:58:33.182333'}","Question I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is -3 for the grade K (up to 125C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator. Answer Please check the following application RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer  Renesashttps//www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer. This is available on the document section of the product landing page. This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached. Suitable Products RL78 This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached. This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.","['The image shows a graph with the title ""RL78/F13, F14, F15 Characteristics Reference Value Quick"" at the top. The graph is a line graph that displays the oscillation accuracy of a high-speed on-chip oscillator as a function of temperature.\n\n*   **Title and Graph**\n    *   The title is displayed in black text at the top of the image.\n    *   Below the title, there is a dropdown menu with options for ""Product"", ""Specifica"", and ""TA"".\n    *   The graph is a line graph with a white background and a light blue border.\n    *   The x-axis represents temperature in degrees Celsius, ranging from -40°C to 120°C.\n    *   The y-axis represents oscillation accuracy as a percentage, ranging from -6% to 6%.\n*   **Lines and Data Points**\n    *   There are three lines on the graph: a black line, a blue line, and a purple line.\n    *   The black line represents the sample data, which shows a slight increase in oscillation accuracy as the temperature increases.\n    *   The blue line represents the HighSPEC(Grade-K) data, which shows a consistent oscillation accuracy of around 2% across all temperatures.\n    *   The purple line represents the LowSPEC(Grade-K) data, which shows a consistent oscillation accuracy of around 1% across all temperatures.\n*   **Note and Conditions**\n    *   A note at the bottom of the image states that the figure is a reference data.\n    *   The conditions for the data are listed as VDD = 5.0V and Vss = 0V.\n\nOverall, the graph shows that the oscillation accuracy of the high-speed on-chip oscillator increases slightly as the temperature increases, but remains relatively consistent across all temperatures. The HighSPEC(Grade-K) data shows a higher oscillation accuracy than the LowSPEC(Grade-K) data, indicating that the former is more accurate.']"
99247d54bf98c2ad7d8d7c4620385a29,"Question:
Is there any characteristics about power supply voltage rising slope?
Is there any characteristics about power supply voltage rising slope?
Answer:
Please refer to the ""Power supply voltage rising slope characteristics"" section in the ""ELECTRICAL SPECIFICATIONS"" section of the RL78 User's Manual Hardware of each product.
The RL78 family has a built-in regulator for operating the device with a constant voltage. To obtain a stable regulator output voltage, power supply voltage rising slope spec of MAX. 54 V/ms is specified.
If the spec of power supply voltage rising slope is satisfied, there will be no negative effect on the device even if the supply voltage rises slowly. However, please maintain the reset state by using a voltage detector or external reset until VDD reaches within the operating voltage range shown in the ""AC Characteristics"" chapter of the ""ELECTRICAL SPECIFICATIONS"" section.
If the spec of power supply voltage rising slope is not satisfied, it may cause device malfunction or degradation. However, the slope until the VDD becomes the specified regulator output voltage at power-on does not matter. If the supply voltage meets the spec of power supply voltage rising slope when above the specified regulator output voltage, there will be no negative effect on the device.
Note: The regulator output voltage varies depending on the RL78 microcontroller and flash operation mode.
           For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
RL78/G13
LS (Low-speed main) mode, LV (Low-voltage main) mode: 1.8V
HS (high speed main) mode: 2.1V
RL78/G23
1.5V
Suitable Products
RL78 Family
Please refer to the ""Power supply voltage rising slope characteristics"" section in the ""ELECTRICAL SPECIFICATIONS"" section of the RL78 User's Manual Hardware of each product.
The RL78 family has a built-in regulator for operating the device with a constant voltage. To obtain a stable regulator output voltage, power supply voltage rising slope spec of MAX. 54 V/ms is specified.
If the spec of power supply voltage rising slope is satisfied, there will be no negative effect on the device even if the supply voltage rises slowly. However, please maintain the reset state by using a voltage detector or external reset until VDD reaches within the operating voltage range shown in the ""AC Characteristics"" chapter of the ""ELECTRICAL SPECIFICATIONS"" section.
If the spec of power supply voltage rising slope is not satisfied, it may cause device malfunction or degradation. However, the slope until the VDD becomes the specified regulator output voltage at power-on does not matter. If the supply voltage meets the spec of power supply voltage rising slope when above the specified regulator output voltage, there will be no negative effect on the device.
Note: The regulator output voltage varies depending on the RL78 microcontroller and flash operation mode.
           For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
RL78/G13
LS (Low-speed main) mode, LV (Low-voltage main) mode: 1.8V
HS (high speed main) mode: 2.1V
RL78/G23
1.5V
Please refer to the ""Power supply voltage rising slope characteristics"" section in the ""ELECTRICAL SPECIFICATIONS"" section of the RL78 User's Manual Hardware of each product.
The RL78 family has a built-in regulator for operating the device with a constant voltage. To obtain a stable regulator output voltage, power supply voltage rising slope spec of MAX. 54 V/ms is specified.
If the spec of power supply voltage rising slope is satisfied, there will be no negative effect on the device even if the supply voltage rises slowly. However, please maintain the reset state by using a voltage detector or external reset until VDD reaches within the operating voltage range shown in the ""AC Characteristics"" chapter of the ""ELECTRICAL SPECIFICATIONS"" section.
If the spec of power supply voltage rising slope is not satisfied, it may cause device malfunction or degradation. However, the slope until the VDD becomes the specified regulator output voltage at power-on does not matter. If the supply voltage meets the spec of power supply voltage rising slope when above the specified regulator output voltage, there will be no negative effect on the device.
Note: The regulator output voltage varies depending on the RL78 microcontroller and flash operation mode.
           For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
Suitable Products
RL78 Family
Go to Japanese
Go to Japanese",['data/categories/rl78_family/electrical_characteristics/99247d54bf98c2ad7d8d7c4620385a29/images/621e0782d187d26c9ad1abfd5f0b406d.png'],[],['|  |\n|  |\n| RL78 Family |'],"{'title': 'About power supply voltage rising slope', 'url': 'https://en-support.renesas.com/knowledgeBase/20282330', 'last_updated': '2023-11-05', 'extracted_at': '2025-03-08T23:58:36.166277'}","Question Is there any characteristics about power supply voltage rising slope? Answer Please refer to the ""Power supply voltage rising slope characteristics"" section in the ""ELECTRICAL SPECIFICATIONS"" section of the RL78 User's Manual Hardware of each product. The RL78 family has a built-in regulator for operating the device with a constant voltage. To obtain a stable regulator output voltage, power supply voltage rising slope spec of MAX. 54 V/ms is specified. If the spec of power supply voltage rising slope is satisfied, there will be no negative effect on the device even if the supply voltage rises slowly. However, please maintain the reset state by using a voltage detector or external reset until VDD reaches within the operating voltage range shown in the ""AC Characteristics"" chapter of the ""ELECTRICAL SPECIFICATIONS"" section. If the spec of power supply voltage rising slope is not satisfied, it may cause device malfunction or degradation. However, the slope until the VDD becomes the specified regulator output voltage at power-on does not matter. If the supply voltage meets the spec of power supply voltage rising slope when above the specified regulator output voltage, there will be no negative effect on the device. Note The regulator output voltage varies depending on the RL78 microcontroller and flash operation mode. For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product. Example of regulator output voltage RL78/G13 LS (Low-speed main) mode, LV (Low-voltage main) mode 1.8V HS (high speed main) mode 2.1V RL78/G23 1.5V Suitable Products RL78 Family Go to Japanese","['The image presents a graph illustrating the relationship between time and voltage for a regulator output. The graph features a curved line that begins at the origin (0, 0) and increases as time progresses, eventually reaching a maximum value of 54 V/ms.\n\n**Key Features:**\n\n*   **Time Axis:** The x-axis represents time, with no specific units provided.\n*   **Voltage Axis:** The y-axis represents voltage, with the unit ""V"" (volts) indicated.\n*   **Regulator Output Voltage:** The graph shows the regulator output voltage over time, with the curve starting at 0 V and increasing to a maximum value of 54 V/ms.\n*   **Note:** A note is included at the top-left corner of the graph, which reads ""Regulator output voltage Note.""\n*   **Does Not Matter:** A label at the bottom-left corner of the graph states ""Does not matter.""\n*   **54 V/ms MAX.:** A label at the bottom-center of the graph indicates that the maximum value of the regulator output voltage is 54 V/ms.\n\n**Overall:**\n\nThe graph provides a visual representation of the regulator output voltage over time, highlighting its increase from 0 V to a maximum value of 54 V/ms. The inclusion of notes and labels adds context to the graph, providing additional information about the regulator output voltage.']"
e33237919facfaf9a388fa69e3bb087a,"Question:
How is touch development performed with the RL78 microcontroller?
Also, please tell me about tuning and parameter adjustment.
Answer:
We offer “QE for Capacitive Touch” as a touch development support tool.
QE for Capacitive Touch can be used to perform the initial setting and sensitivity adjustment of the touch interface required for touch development.
QE for Capacitive Touch is available as a plug-in used in the e2 studio integrated development environment and as a standalone version that operates independently. It can be used in the “e2 studio” Renesas Electronics development environment or in “CS+”.
Figure: QE for Capacitive Touch development screen
When using e2 studio for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-qe-and-sis-develop-capacitive-touch-applications?r=1170071
The above setting methods are also explained in a video.
https://www.renesas.com/video/qe-capacitive-touch-tutorial-settings-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-tuning-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-serial-monitoring-rl78
When using CS+ for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-standalone-version-qe-develop-capacitive-touch-applications-rev100?r=1170071
Refer to the following application note for information on parameters used when monitoring touch functionality in QE for Capacitive Touch.
https://www.renesas.com/document/apn/rl78-family-touch-module-software-integration-system?r=1521766
Click here to install e2 studio:
https://www.renesas.com/software-tool/e2studio-information-rl78-family
Click here to install CS+:
https://www.renesas.com/software-tool/cs
*When using CS+, please also install Smart Configurator:
https://www.renesas.com/software-tool/rl78-smart-configurator#overview
Click here to install QE for Capacitive Touch:
https://www.renesas.com/software-tool/qe-capacitive-touch-development-assistance-tool-capacitive-touch-sensors#download
Suitable Products
RL78/G22, RL78/G23
How is touch development performed with the RL78 microcontroller?
Also, please tell me about tuning and parameter adjustment.
How is touch development performed with the RL78 microcontroller?
Also, please tell me about tuning and parameter adjustment.
Answer:
We offer “QE for Capacitive Touch” as a touch development support tool.
QE for Capacitive Touch can be used to perform the initial setting and sensitivity adjustment of the touch interface required for touch development.
QE for Capacitive Touch is available as a plug-in used in the e2 studio integrated development environment and as a standalone version that operates independently. It can be used in the “e2 studio” Renesas Electronics development environment or in “CS+”.
Figure: QE for Capacitive Touch development screen
When using e2 studio for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-qe-and-sis-develop-capacitive-touch-applications?r=1170071
The above setting methods are also explained in a video.
https://www.renesas.com/video/qe-capacitive-touch-tutorial-settings-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-tuning-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-serial-monitoring-rl78
When using CS+ for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-standalone-version-qe-develop-capacitive-touch-applications-rev100?r=1170071
Refer to the following application note for information on parameters used when monitoring touch functionality in QE for Capacitive Touch.
https://www.renesas.com/document/apn/rl78-family-touch-module-software-integration-system?r=1521766
Click here to install e2 studio:
https://www.renesas.com/software-tool/e2studio-information-rl78-family
Click here to install CS+:
https://www.renesas.com/software-tool/cs
*When using CS+, please also install Smart Configurator:
https://www.renesas.com/software-tool/rl78-smart-configurator#overview
Click here to install QE for Capacitive Touch:
https://www.renesas.com/software-tool/qe-capacitive-touch-development-assistance-tool-capacitive-touch-sensors#download
Suitable Products
RL78/G22, RL78/G23
We offer “QE for Capacitive Touch” as a touch development support tool.
QE for Capacitive Touch can be used to perform the initial setting and sensitivity adjustment of the touch interface required for touch development.
QE for Capacitive Touch is available as a plug-in used in the e2 studio integrated development environment and as a standalone version that operates independently. It can be used in the “e2 studio” Renesas Electronics development environment or in “CS+”.
Figure: QE for Capacitive Touch development screen
When using e2 studio for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-qe-and-sis-develop-capacitive-touch-applications?r=1170071
The above setting methods are also explained in a video.
https://www.renesas.com/video/qe-capacitive-touch-tutorial-settings-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-tuning-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-serial-monitoring-rl78
When using CS+ for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-standalone-version-qe-develop-capacitive-touch-applications-rev100?r=1170071
Refer to the following application note for information on parameters used when monitoring touch functionality in QE for Capacitive Touch.
https://www.renesas.com/document/apn/rl78-family-touch-module-software-integration-system?r=1521766
Click here to install e2 studio:
https://www.renesas.com/software-tool/e2studio-information-rl78-family
Click here to install CS+:
https://www.renesas.com/software-tool/cs
*When using CS+, please also install Smart Configurator:
https://www.renesas.com/software-tool/rl78-smart-configurator#overview
Click here to install QE for Capacitive Touch:
https://www.renesas.com/software-tool/qe-capacitive-touch-development-assistance-tool-capacitive-touch-sensors#download
We offer “QE for Capacitive Touch” as a touch development support tool.
QE for Capacitive Touch can be used to perform the initial setting and sensitivity adjustment of the touch interface required for touch development.
QE for Capacitive Touch is available as a plug-in used in the e2 studio integrated development environment and as a standalone version that operates independently. It can be used in the “e2 studio” Renesas Electronics development environment or in “CS+”.
Figure: QE for Capacitive Touch development screen
When using e2 studio for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-qe-and-sis-develop-capacitive-touch-applications?r=1170071
The above setting methods are also explained in a video.
https://www.renesas.com/video/qe-capacitive-touch-tutorial-settings-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-tuning-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-serial-monitoring-rl78
When using CS+ for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-standalone-version-qe-develop-capacitive-touch-applications-rev100?r=1170071
Refer to the following application note for information on parameters used when monitoring touch functionality in QE for Capacitive Touch.
https://www.renesas.com/document/apn/rl78-family-touch-module-software-integration-system?r=1521766
Click here to install e2 studio:
https://www.renesas.com/software-tool/e2studio-information-rl78-family
Click here to install CS+:
https://www.renesas.com/software-tool/cs
*When using CS+, please also install Smart Configurator:
https://www.renesas.com/software-tool/rl78-smart-configurator#overview
Click here to install QE for Capacitive Touch:
https://www.renesas.com/software-tool/qe-capacitive-touch-development-assistance-tool-capacitive-touch-sensors#download
Suitable Products
RL78/G22, RL78/G23
日本語 中文
日本語
中文","['data/categories/rl78_family/capacitive_touch/e33237919facfaf9a388fa69e3bb087a/images/c635af90f3a2a9ef29a16d1c45b5b9b4.png', 'data/categories/rl78_family/capacitive_touch/e33237919facfaf9a388fa69e3bb087a/images/8487d97fd42112e2f1e8e27800637883.png']",[],"['|  |\n|  |\n| RL78/G22, RL78/G23 |']","{'title': 'Touch development with the RL78 microcontroller', 'url': 'https://en-support.renesas.com/knowledgeBase/20824902', 'last_updated': None, 'extracted_at': '2025-03-08T23:57:07.644181'}","Question How is touch development performed with the RL78 microcontroller? Also, please tell me about tuning and parameter adjustment. Answer We offer QE for Capacitive Touch as a touch development support tool. QE for Capacitive Touch can be used to perform the initial setting and sensitivity adjustment of the touch interface required for touch development. QE for Capacitive Touch is available as a plug-in used in the e2 studio integrated development environment and as a standalone version that operates independently. It can be used in the e2 studio Renesas Electronics development environment or in CS. Figure QE for Capacitive Touch development screen When using e2 studio for development, please refer to this document. https//www.renesas.com/document/apn/rl78-family-using-qe-and-sis-develop-capacitive-touch-applications?r1170071 The above setting methods are also explained in a video. https//www.renesas.com/video/qe-capacitive-touch-tutorial-settings-rl78 https//www.renesas.com/video/qe-capacitive-touch-tutorial-tuning-rl78 https//www.renesas.com/video/qe-capacitive-touch-tutorial-serial-monitoring-rl78 When using CS for development, please refer to this document. https//www.renesas.com/document/apn/rl78-family-using-standalone-version-qe-develop-capacitive-touch-applications-rev100?r1170071 Refer to the following application note for information on parameters used when monitoring touch functionality in QE for Capacitive Touch. https//www.renesas.com/document/apn/rl78-family-touch-module-software-integration-system?r1521766 Click here to install e2 studio https//www.renesas.com/software-tool/e2studio-information-rl78-family Click here to install CS https//www.renesas.com/software-tool/cs When using CS, please also install Smart Configurator https//www.renesas.com/software-tool/rl78-smart-configuratoroverview Click here to install QE for Capacitive Touch https//www.renesas.com/software-tool/qe-capacitive-touch-development-assistance-tool-capacitive-touch-sensorsdownload Suitable Products RL78/G22, RL78/G23    ","['The image shows a workflow diagram for a CapTouch Main / Sensor Tuner (QE) application. The diagram is divided into four sections, each representing a different stage in the workflow.\n\n*   **Preparing**\n    *   To Prepare Project: Prepare a project that uses the touch interfaces.\n    *   To Select Project: Select or create a touch interface configuration.\n*   **Tuning**\n    *   QE will automatically perform tuning processing for each touch sensor.\n    *   To Connect Target Board: Connect your target board and PC via an emulator.\n    *   To Start Tuning: Follow instructions in the dialog.\n    *   To Output Parameter Files: Generate parameter files from a tuning result.\n*   **Coding**\n    *   Implement a program using the touch interfaces.\n*   **Monitoring**\n    *   You can monitor an operation of touch interfaces and make adjustments.\n    *   To Launch Debug: Launch debugging for your target project and execute the program.\n    *   To Enable Monitoring: Show monitoring views and enable a monitoring function.\n\nThe diagram provides a clear and concise overview of the workflow, highlighting the key steps involved in preparing, tuning, coding, and monitoring the application. By following this workflow, developers can ensure that their application is properly configured and optimized for use with the CapTouch Main / Sensor Tuner (QE) device.', ""The image presents a comprehensive overview of a computer program designed for monitoring and controlling touch sensors. The program is displayed on a computer screen, with various windows and menus open, showcasing its features and functionality.\n\n**Key Features:**\n\n* **Touch Sensor Monitoring:** The program allows users to select and monitor touch sensors, providing real-time data on their status and performance.\n* **Graphical Display:** A graph is displayed, showing the intensity of input through the touch sensors in chronological order. This visual representation helps users understand the patterns and trends of the touch sensor data.\n* **Threshold Settings:** The program enables users to set present thresholds, which are used to determine the intensity of input through the touch sensors. This feature allows for precise control over the system's response to different levels of input.\n* **Average Values:** The program presents average values without input through the touch sensors, providing a baseline for comparison with actual input data.\n* **Confirmation by MCU:** The state of confirmation by the MCU (Microcontroller Unit) of input through the touch sensors is displayed, ensuring that the system is functioning correctly and accurately detecting input.\n* **Tuning Parameters:** The program allows users to activate tuning parameters and adjust the values, enabling fine-tuning of the system's performance and sensitivity.\n* **Condition of Input:** The condition of input through the touch sensors is displayed as it is confirmed by the MCU, providing a clear indication of the system's status and performance.\n\n**Overall:**\n\nThe image effectively illustrates the capabilities and features of the touch sensor monitoring program, highlighting its ability to provide real-time data, set thresholds, and adjust tuning parameters. The program's user-friendly interface and comprehensive display make it an essential tool for monitoring and controlling touch sensors in various applications.""]"
33114193511a8fc78428a290c4a4e122,"Question:
How can we adjust the sensitivity?
Answer:
Button sensitivity adjustment uses QE for Capacitive Touch. The sensitivity adjustment method is as follows.
The method using monitoring function of QE for Capacitive Touch
Follow the tutorial from the ""CapTouch Workflow (QE)"" of QE for Capacitive Touch.

Real-time change method using monitoring function of QE for Capacitive Touch
Display the Cap Touch parameter list of QE for Capacitive Touch and adjust it by the following steps.

Select the touch I/F corresponding to the button you want to adjust.
Click [Enable Monitoring] icon to start monitoring. When monitoring is enabled, the CapTouch parameter item is displayed.
Click [Write Value to the Target Board] to enable.
Change the value of [Touch Threshold].
Repeat steps 4 to adjust the sensitivity. After completing the sensitivity adjustment, reflect the adjustment result in the source code by the following steps.
Click [Output Parameter Files] to generate the parameter file.
Build the project using the IDE (e2 studio as an example).
Write the program to the MCU using the IDE (e2 studio as an example).

How to view the CapTouch Parameter List screen is as follows.
How to change the code manually
It can be adjusted by changing member variables of structure variable g_qe_touch_button_cfg_config01 to 03. The variables to change are:
・ threshold : Touch detection threshold
Reference Application Notes:
RL78/G22 Capacitive Touch Evaluation System Sample Code (R01AN6803)
RL78 Family Using QE and SIS to Develop Capacitive Touch Applications (R01AN5512)
Suitable Products
RL78/G23, RL78/G22, RL78/G16
How can we adjust the sensitivity?
Answer:
Button sensitivity adjustment uses QE for Capacitive Touch. The sensitivity adjustment method is as follows.
The method using monitoring function of QE for Capacitive Touch
Follow the tutorial from the ""CapTouch Workflow (QE)"" of QE for Capacitive Touch.

Real-time change method using monitoring function of QE for Capacitive Touch
Display the Cap Touch parameter list of QE for Capacitive Touch and adjust it by the following steps.

Select the touch I/F corresponding to the button you want to adjust.
Click [Enable Monitoring] icon to start monitoring. When monitoring is enabled, the CapTouch parameter item is displayed.
Click [Write Value to the Target Board] to enable.
Change the value of [Touch Threshold].
Repeat steps 4 to adjust the sensitivity. After completing the sensitivity adjustment, reflect the adjustment result in the source code by the following steps.
Click [Output Parameter Files] to generate the parameter file.
Build the project using the IDE (e2 studio as an example).
Write the program to the MCU using the IDE (e2 studio as an example).

How to view the CapTouch Parameter List screen is as follows.
How to change the code manually
It can be adjusted by changing member variables of structure variable g_qe_touch_button_cfg_config01 to 03. The variables to change are:
・ threshold : Touch detection threshold
Reference Application Notes:
RL78/G22 Capacitive Touch Evaluation System Sample Code (R01AN6803)
RL78 Family Using QE and SIS to Develop Capacitive Touch Applications (R01AN5512)
Suitable Products
RL78/G23, RL78/G22, RL78/G16
Button sensitivity adjustment uses QE for Capacitive Touch. The sensitivity adjustment method is as follows.
The method using monitoring function of QE for Capacitive Touch
Follow the tutorial from the ""CapTouch Workflow (QE)"" of QE for Capacitive Touch.

Real-time change method using monitoring function of QE for Capacitive Touch
Display the Cap Touch parameter list of QE for Capacitive Touch and adjust it by the following steps.

Select the touch I/F corresponding to the button you want to adjust.
Click [Enable Monitoring] icon to start monitoring. When monitoring is enabled, the CapTouch parameter item is displayed.
Click [Write Value to the Target Board] to enable.
Change the value of [Touch Threshold].
Repeat steps 4 to adjust the sensitivity. After completing the sensitivity adjustment, reflect the adjustment result in the source code by the following steps.
Click [Output Parameter Files] to generate the parameter file.
Build the project using the IDE (e2 studio as an example).
Write the program to the MCU using the IDE (e2 studio as an example).

How to view the CapTouch Parameter List screen is as follows.
How to change the code manually
It can be adjusted by changing member variables of structure variable g_qe_touch_button_cfg_config01 to 03. The variables to change are:
・ threshold : Touch detection threshold
Reference Application Notes:
RL78/G22 Capacitive Touch Evaluation System Sample Code (R01AN6803)
RL78 Family Using QE and SIS to Develop Capacitive Touch Applications (R01AN5512)
Button sensitivity adjustment uses QE for Capacitive Touch. The sensitivity adjustment method is as follows.
Reference Application Notes:
RL78/G22 Capacitive Touch Evaluation System Sample Code (R01AN6803)
RL78 Family Using QE and SIS to Develop Capacitive Touch Applications (R01AN5512)
Suitable Products
RL78/G23, RL78/G22, RL78/G16
日本語 中文
日本語
中文","['data/categories/rl78_family/capacitive_touch/33114193511a8fc78428a290c4a4e122/images/51cb533a6c1eb00f1d5c0c94dcdb85f9.png', 'data/categories/rl78_family/capacitive_touch/33114193511a8fc78428a290c4a4e122/images/1a10bc17fd6835bb8ad19243096badd6.png']",[],"['|  |\n|  |\n| RL78/G23, RL78/G22, RL78/G16 |']","{'title': 'How to adjust sensitivity', 'url': 'https://en-support.renesas.com/knowledgeBase/20977341', 'last_updated': None, 'extracted_at': '2025-03-08T23:56:53.027692'}","Question How can we adjust the sensitivity? Answer Button sensitivity adjustment uses QE for Capacitive Touch. The sensitivity adjustment method is as follows. The method using monitoring function of QE for Capacitive Touch Follow the tutorial from the ""CapTouch Workflow (QE)"" of QE for Capacitive Touch. Real-time change method using monitoring function of QE for Capacitive Touch Display the Cap Touch parameter list of QE for Capacitive Touch and adjust it by the following steps. Select the touch I/F corresponding to the button you want to adjust. Click Enable Monitoring icon to start monitoring. When monitoring is enabled, the CapTouch parameter item is displayed. Click Write Value to the Target Board to enable. Change the value of Touch Threshold. Repeat steps 4 to adjust the sensitivity. After completing the sensitivity adjustment, reflect the adjustment result in the source code by the following steps. Click Output Parameter Files to generate the parameter file. Build the project using the IDE (e2 studio as an example). Write the program to the MCU using the IDE (e2 studio as an example). How to view the CapTouch Parameter List screen is as follows. How to change the code manually It can be adjusted by changing member variables of structure variable gqetouchbuttoncfgconfig01 to 03. The variables to change are  threshold  Touch detection threshold Reference Application Notes RL78/G22 Capacitive Touch Evaluation System Sample Code (R01AN6803) RL78 Family Using QE and SIS to Develop Capacitive Touch Applications (R01AN5512) Suitable Products RL78/G23, RL78/G22, RL78/G16    ","['The image depicts a screenshot of a computer program, specifically a settings page for a CapTouch workflow. The page is divided into two main sections: the top section displays the title ""CapTouch Workflow (QE)"" and the bottom section contains a table with various settings.\n\n**Top Section:**\n\n* The title ""CapTouch Workflow (QE)"" is displayed in black text at the top of the page.\n* Below the title, there are two tabs: ""CapTouch Parameters (QE)"" and ""CapTouch Workflow (QE)"". The ""CapTouch Parameters (QE)"" tab is currently selected.\n\n**Bottom Section:**\n\n* The table has four columns: ""Item"", ""Value"", ""Drift Correction Interval"", and ""Long Touch Cancel Cycle"".\n* The ""Item"" column lists various settings, including ""Drift Correction Interval"", ""Long Touch Cancel Cycle"", ""Positive Noise Filter Cycle"", ""Negative Noise Filter Cycle"", ""Moving Average Filter Depth"", ""Touch Threshold"", ""Hysteresis"", ""CTSUSO"", and ""CTSUSNUM"".\n* The ""Value"" column displays the corresponding values for each setting.\n* The ""Drift Correction Interval"" setting has a value of 255.\n* The ""Long Touch Cancel Cycle"" setting has a value of 0.\n* The ""Positive Noise Filter Cycle"" setting has a value of 3.\n* The ""Negative Noise Filter Cycle"" setting has a value of 3.\n* The ""Moving Average Filter Depth"" setting has a value of 4.\n* The ""Touch Threshold"" setting has a value of 522.\n* The ""Hysteresis"" setting has a value of 26.\n* The ""CTSUSO"" setting has a value of 41.\n* The ""CTSUSNUM"" setting has a value of 7.\n\n**Red Circles and Numbers:**\n\n* There are six red circles with numbers inside them, ranging from 1 to 6.\n* Each circle corresponds to a specific part of the page, such as the title, tabs, or table columns.\n* The numbers inside the circles likely represent the order in which the settings should be applied or the priority of each setting.\n\n**Overall:**\n\n* The image shows a screenshot of a computer program with a settings page for a CapTouch workflow.\n* The page has a table with various settings and their corresponding values.\n* The red circles and numbers provide additional information about the settings and their order of application.', 'The image depicts a screenshot of a computer program with a white background and a blue border around the main window. The window is titled ""CapTouch Parameters RA, RL78 (QE)"" and features a red box with the text ""Select the touch interface."" in the top-left corner. A green box with a list of options is situated below this, including ""Enable Monitoring,"" ""Display in Advanced Mode,"" ""Read Value from the Target Board,"" ""Write Value to the Target Board,"" ""Enable Auto Writing,"" and ""Output Parameter Files.""\n\nIn the center of the window, a table displays various parameters, such as ""Drift Correction Interval,"" ""Long Touch Cancel Cycle,"" ""Positive Noise Filter Cycle,"" ""Negative Noise Filter Cycle,"" ""Moving Average Filter Depth,"" and ""Touch Threshold."" The ""Touch Threshold"" value is highlighted in blue, with a description below it that reads: ""Set a value of touch threshold. Touch Threshold is a parameter used for determining whether the button / key pad button switches from touch OFF to ON. The button / key pad button is judged to be touch ON when the count value exceeds the value specified in [Touch Threshold]. Input a value between 0 and 65535. This setting item will be applied for each button.""\n\nA green arrow points to a green box labeled ""Touch Parameters"" in the middle of the window, accompanied by a green box with the text ""A description is displayed for the selected touch parameter."" in the bottom-right corner. The background of the image is white, providing a clean and neutral backdrop for the program\'s interface. Overall, the image effectively illustrates the various components and settings of the CapTouch Parameters RA, RL78 (QE) program, making it easy to understand and navigate.']"
29966c0f65f5233670864e6f7df25742,"Question:
Which RL78 MCUs have touch functionality?
Answer:
RL78/G23, RL78/G22, and RL78/G16 have.
Please refer to the figure below regarding the lineup by memory and pin count.
Figure 1: RL78 Touch MCU Lineup
Also, please refer to the table below for the differences in each touch function.
Figure 2: Comparison between RL78/G23, RL78/G22 and RL78/G16
Suitable Products
RL78/G23, RL78/G22, RL78/G16
Which RL78 MCUs have touch functionality?
Which RL78 MCUs have touch functionality?
Answer:
RL78/G23, RL78/G22, and RL78/G16 have.
Please refer to the figure below regarding the lineup by memory and pin count.
Figure 1: RL78 Touch MCU Lineup
Also, please refer to the table below for the differences in each touch function.
Figure 2: Comparison between RL78/G23, RL78/G22 and RL78/G16
Suitable Products
RL78/G23, RL78/G22, RL78/G16
RL78/G23, RL78/G22, and RL78/G16 have.
Please refer to the figure below regarding the lineup by memory and pin count.
Figure 1: RL78 Touch MCU Lineup
Also, please refer to the table below for the differences in each touch function.
Figure 2: Comparison between RL78/G23, RL78/G22 and RL78/G16
RL78/G23, RL78/G22, and RL78/G16 have.
Please refer to the figure below regarding the lineup by memory and pin count.
Figure 1: RL78 Touch MCU Lineup
Also, please refer to the table below for the differences in each touch function.
Figure 2: Comparison between RL78/G23, RL78/G22 and RL78/G16
Suitable Products
RL78/G23, RL78/G22, RL78/G16
日本語 中文
日本語
中文","['data/categories/rl78_family/capacitive_touch/29966c0f65f5233670864e6f7df25742/images/4034592102df7fcef09a958280e20553.png', 'data/categories/rl78_family/capacitive_touch/29966c0f65f5233670864e6f7df25742/images/99a2f01850a46470647e4e3a0246ce4b.png']",[],"['|  |\n|  |\n| RL78/G23, RL78/G22, RL78/G16 |']","{'title': 'RL78 Touch MCU', 'url': 'https://en-support.renesas.com/knowledgeBase/20977336', 'last_updated': None, 'extracted_at': '2025-03-08T23:56:58.837534'}","Question Which RL78 MCUs have touch functionality? Answer RL78/G23, RL78/G22, and RL78/G16 have. Please refer to the figure below regarding the lineup by memory and pin count. Figure 1 RL78 Touch MCU Lineup Also, please refer to the table below for the differences in each touch function. Figure 2 Comparison between RL78/G23, RL78/G22 and RL78/G16 Suitable Products RL78/G23, RL78/G22, RL78/G16    ","['The image presents a chart illustrating the number of touch channels for various pins, with the title ""The number indicates the number of touch channels."" The chart is divided into two sections: the top section displays the pin numbers, while the bottom section shows the corresponding number of touch channels.\n\n**Top Section: Pin Numbers**\n\n*   The top section of the chart lists the pin numbers, ranging from 10 to 128, in increments of 4 (10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62, 66, 70, 74, 78, 82, 86, 90, 94, 98, 102, 106, 110, 114, 118, 122, and 126).\n\n**Bottom Section: Number of Touch Channels**\n\n*   The bottom section of the chart displays the corresponding number of touch channels for each pin number.\n*   The number of touch channels ranges from 3 to 32, with the following distribution:\n    *   3 touch channels: pins 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62, 66, 70, 74, 78, 82, 86, 90, 94, 98, 102, 106, 110, 114, 118, 122, and 126.\n    *   5 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n    *   7 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n    *   9 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n    *   11 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n    *   12 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n    *   15 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n    *   17 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n    *   21 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n    *   23 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n    *   25 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n    *   29 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n    *   32 touch channels: pins 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, and 124.\n\nIn summary, the chart provides a clear visual representation of the number of touch channels for each pin number, ranging from 3 to 32. The distribution of touch channels varies across the different pin numbers, with some pins having as few as 3 touch channels and others having as many as 32.', 'The image presents a table comparing the specifications of three microcontrollers: RL78/G23, RL78/G22, and RL78/G16. The table is divided into two columns, with the left column listing the item names and the right column providing the corresponding specifications for each microcontroller.\n\n**Item Names:**\n\n* CPU Core\n* Operating frequency (MHz)\n* Supply voltage(V)\n* Program Memory (KB)\n* Data Flash (KB)\n* RAM (KB)\n* Capacitive sensor type\n* Touch channel\n* Self-capacitance method\n* Mutual-capacitance method\n* Multi-frequency measurement\n* Active shield\n* Automatic judgment\n* Automatic correction\n* Multiple Electrode Connection (MEC)\n* Temperature correction\n\n**Specifications:**\n\n* **CPU Core:**\n\t+ RL78/G23: RL78-S3\n\t+ RL78/G22: RL78-S3\n\t+ RL78/G16: RL78-S2\n* **Operating frequency (MHz):**\n\t+ RL78/G23: 32\n\t+ RL78/G22: 32\n\t+ RL78/G16: 16\n* **Supply voltage(V):**\n\t+ RL78/G23: 1.6 - 5.5\n\t+ RL78/G22: 1.6 - 5.5\n\t+ RL78/G16: 2.4 - 5.5\n* **Program Memory (KB):**\n\t+ RL78/G23: 96, 128, 192, 256, 384, 512, 768\n\t+ RL78/G22: 32, 64\n\t+ RL78/G16: 16, 32\n* **Data Flash (KB):**\n\t+ RL78/G23: 8\n\t+ RL78/G22: 2\n\t+ RL78/G16: 1\n* **RAM (KB):**\n\t+ RL78/G23: 12, 16, 20, 24, 32, 48\n\t+ RL78/G22: 4\n\t+ RL78/G16: 2\n* **Capacitive sensor type:**\n\t+ RL78/G23: CTSU2L\n\t+ RL78/G22: CTSU2La\n\t+ RL78/G16: CTSUb\n* **Touch channel:**\n\t+ RL78/G23: 32\n\t+ RL78/G22: 29\n\t+ RL78/G16: 15\n* **Self-capacitance method:**\n\t+ RL78/G23: ✓\n\t+ RL78/G22: ✓\n\t+ RL78/G16: ✓\n* **Mutual-capacitance method:**\n\t+ RL78/G23: ✓\n\t+ RL78/G22: ✓\n\t+ RL78/G16: ✓\n* **Multi-frequency measurement:**\n\t+ RL78/G23: ✓\n\t+ RL78/G22: ✓\n\t+ RL78/G16: -\n* **Active shield:**\n\t+ RL78/G23: ✓\n\t+ RL78/G22: ✓\n\t+ RL78/G16: -\n* **Automatic judgment:**\n\t+ RL78/G23: ✓\n\t+ RL78/G22: ✓\n\t+ RL78/G16: ✓\n* **Automatic correction:**\n\t+ RL78/G23: ✓\n\t+ RL78/G22: ✓\n\t+ RL78/G16: ✓\n* **Multiple Electrode Connection (MEC):**\n\t+ RL78/G23: -\n\t+ RL78/G22: ✓\n\t+ RL78/G16: ✓\n* **Temperature correction:**\n\t+ RL78/G23: ✓\n\t+ RL78/G22: ✓\n\t+ RL78/G16: ✓\n\nIn summary, the table provides a detailed comparison of the specifications of three microcontrollers: RL78/G23, RL78/G22, and RL78/G16. The specifications include CPU core, operating frequency, supply voltage, program memory, data flash, RAM, capacitive sensor type, touch channel, self-capacitance method, mutual-capacitance method, multi-frequency measurement, active shield, automatic judgment, automatic correction, multiple electrode connection (MEC), and temperature correction. The table allows for easy comparison of the specifications of each microcontroller, making it a useful resource for selecting the appropriate microcontroller for a specific application.']"
d3418a81006d6c7b069e207077ce3cda,"Question:
Are there any precautions when using the CC-RL free evaluation version (V1.12.00 or later) for touch development?
Answer:
Serial tuning cannot be performed if you are using RL78 family and CC-RL compiler (V1.12.00 or later) and the optimization level of CC-RL compiler is set to ""-Olite"".
To perform serial tuning, set the CC-RL compiler optimization level to ""-Onothing"".
For details, please refer to the following document on p. 38.
RL78 Family Using QE (standalone ver.) to Develop Touch Applications for FPB board
Please refer to the following guide for the details specifications of the optimization level option of the CC-RL free evaluation version (V1.12.00).
[Notification] C Compiler Package for RL78 Family (CC-RL) Changes in Specifications of Free Evaluation Edition
Suitable Products
RL78/G23, RL78/G22, RL78/G16
Are there any precautions when using the CC-RL free evaluation version (V1.12.00 or later) for touch development?
Are there any precautions when using the CC-RL free evaluation version (V1.12.00 or later) for touch development?
Answer:
Serial tuning cannot be performed if you are using RL78 family and CC-RL compiler (V1.12.00 or later) and the optimization level of CC-RL compiler is set to ""-Olite"".
To perform serial tuning, set the CC-RL compiler optimization level to ""-Onothing"".
For details, please refer to the following document on p. 38.
RL78 Family Using QE (standalone ver.) to Develop Touch Applications for FPB board
Please refer to the following guide for the details specifications of the optimization level option of the CC-RL free evaluation version (V1.12.00).
[Notification] C Compiler Package for RL78 Family (CC-RL) Changes in Specifications of Free Evaluation Edition
Suitable Products
RL78/G23, RL78/G22, RL78/G16
Serial tuning cannot be performed if you are using RL78 family and CC-RL compiler (V1.12.00 or later) and the optimization level of CC-RL compiler is set to ""-Olite"".
To perform serial tuning, set the CC-RL compiler optimization level to ""-Onothing"".
For details, please refer to the following document on p. 38.
RL78 Family Using QE (standalone ver.) to Develop Touch Applications for FPB board
Please refer to the following guide for the details specifications of the optimization level option of the CC-RL free evaluation version (V1.12.00).
[Notification] C Compiler Package for RL78 Family (CC-RL) Changes in Specifications of Free Evaluation Edition
Serial tuning cannot be performed if you are using RL78 family and CC-RL compiler (V1.12.00 or later) and the optimization level of CC-RL compiler is set to ""-Olite"".
To perform serial tuning, set the CC-RL compiler optimization level to ""-Onothing"".
For details, please refer to the following document on p. 38.
RL78 Family Using QE (standalone ver.) to Develop Touch Applications for FPB board
Please refer to the following guide for the details specifications of the optimization level option of the CC-RL free evaluation version (V1.12.00).
[Notification] C Compiler Package for RL78 Family (CC-RL) Changes in Specifications of Free Evaluation Edition
Suitable Products
RL78/G23, RL78/G22, RL78/G16
日本語 中文
日本語
中文",['data/categories/rl78_family/capacitive_touch/d3418a81006d6c7b069e207077ce3cda/images/74bdbb7fce363641e345f41c2241f84c.png'],[],"['|  |\n|  |\n| RL78/G23, RL78/G22, RL78/G16 |']","{'title': 'Notes for touch development using CC-RL free evaluation version (V1.12.00 or later) (Optimization option)', 'url': 'https://en-support.renesas.com/knowledgeBase/20977340', 'last_updated': None, 'extracted_at': '2025-03-08T23:56:55.835312'}","Question Are there any precautions when using the CC-RL free evaluation version (V1.12.00 or later) for touch development? Answer Serial tuning cannot be performed if you are using RL78 family and CC-RL compiler (V1.12.00 or later) and the optimization level of CC-RL compiler is set to ""-Olite"". To perform serial tuning, set the CC-RL compiler optimization level to ""-Onothing"". For details, please refer to the following document on p. 38. RL78 Family Using QE (standalone ver.) to Develop Touch Applications for FPB board Please refer to the following guide for the details specifications of the optimization level option of the CC-RL free evaluation version (V1.12.00). Notification C Compiler Package for RL78 Family (CC-RL) Changes in Specifications of Free Evaluation Edition Suitable Products RL78/G23, RL78/G22, RL78/G16    ","['The image shows a screenshot of a computer screen with a window open, displaying a list of options and a text box at the top. The window is titled ""Figure 8-24. Selecting level of optimization"" and has a blue bar at the top with the words ""Level of optimization"" in white text.\n\n*   The window has a list of options on the left side, including:\n    *   Optimization\n    *   Level of optimization\n    *   Debug precedence(-onothing)\n    *   Optimization(Details)\n    *   Preprocess\n    *   Source\n    *   Quality Improvement\n    *   Memory Model\n    *   C Language\n    *   Character Encoding\n    *   Output Code\n    *   Output File\n*   The text box at the top of the window contains instructions for using the CC-RL free evaluation edition V1.12.00 or later, including:\n    *   Double-click ""Optimization"" of ""Compile Options"", and then click ""Level of optimization"".\n    *   Click (drop-down arrow) on the right, and select ""debug precedence(-onothing)"".\n*   The background of the image is a light gray color, with a darker gray border around the edges of the window.\n\nOverall, the image appears to be a screenshot of a computer program or software application, possibly related to coding or programming. The instructions at the top of the window suggest that the user is being guided through a process of selecting optimization levels for their code.']"
0c38fc0eac324c42940a0c8505a84755,"Question:
How can I download a SIS module from the Renesas website (not from e² studio or CS+) and use it?
Answer:
See the List of SIS Modules and download the module you need from Renesas Web site.
Unzip the downloaded file (*.zip), and then copy the contents (*.xml, *.zip, and *.mdf, if any) to the SIS module download folder.
The following are the default download folders.
e² studio :  %USERPROFILE%\.eclipse\com.renesas.platform_download\RL78_Modules\GenericModules
CS+  :  %USERPROFILE%\.eclipse\com.renesas.smc.rcp.product_download\RL78_Modules\GenericModules
Copying and pasting the strings to the Windows File Explorer address bar will open the folder.
  If the folder cannot be found or has been moved, find the folder as follows.
e² studio :
    Select [Window], [Preferences], [Renesas], and then check [Module Download].
CS+ :
    Start Smart Configurator, select [Window], [Preferences], and then check [Module Download].

Note: The [GenericModules] folder is created when the first Smart Configurator project is made. If the [GenericModules] folder does not exist, create the folder, and then copy the files to it.
E.g., e² studio [Preferences]:

Example: e² studio [GenericModules] folder with copied files. (There might be no [Downloaded] folder, but this is not a problem. The contents are very similar in CS+.)

After placing the files in the destination folder, start Smart Configurator, and then click the [Add component] button as shown below.


Make sure that the added SIS module is available in the dialog box below.

  Suitable Products
RL78/G23, RL78/G22, RL78/G16
How can I download a SIS module from the Renesas website (not from e² studio or CS+) and use it?
How can I download a SIS module from the Renesas website (not from e² studio or CS+) and use it?
Answer:
See the List of SIS Modules and download the module you need from Renesas Web site.
Unzip the downloaded file (*.zip), and then copy the contents (*.xml, *.zip, and *.mdf, if any) to the SIS module download folder.
The following are the default download folders.
e² studio :  %USERPROFILE%\.eclipse\com.renesas.platform_download\RL78_Modules\GenericModules
CS+  :  %USERPROFILE%\.eclipse\com.renesas.smc.rcp.product_download\RL78_Modules\GenericModules
Copying and pasting the strings to the Windows File Explorer address bar will open the folder.
  If the folder cannot be found or has been moved, find the folder as follows.
e² studio :
    Select [Window], [Preferences], [Renesas], and then check [Module Download].
CS+ :
    Start Smart Configurator, select [Window], [Preferences], and then check [Module Download].

Note: The [GenericModules] folder is created when the first Smart Configurator project is made. If the [GenericModules] folder does not exist, create the folder, and then copy the files to it.
E.g., e² studio [Preferences]:

Example: e² studio [GenericModules] folder with copied files. (There might be no [Downloaded] folder, but this is not a problem. The contents are very similar in CS+.)

After placing the files in the destination folder, start Smart Configurator, and then click the [Add component] button as shown below.


Make sure that the added SIS module is available in the dialog box below.

  Suitable Products
RL78/G23, RL78/G22, RL78/G16
See the List of SIS Modules and download the module you need from Renesas Web site.
Unzip the downloaded file (*.zip), and then copy the contents (*.xml, *.zip, and *.mdf, if any) to the SIS module download folder.
The following are the default download folders.
e² studio :  %USERPROFILE%\.eclipse\com.renesas.platform_download\RL78_Modules\GenericModules
CS+  :  %USERPROFILE%\.eclipse\com.renesas.smc.rcp.product_download\RL78_Modules\GenericModules
Copying and pasting the strings to the Windows File Explorer address bar will open the folder.
  If the folder cannot be found or has been moved, find the folder as follows.
e² studio :
    Select [Window], [Preferences], [Renesas], and then check [Module Download].
CS+ :
    Start Smart Configurator, select [Window], [Preferences], and then check [Module Download].

Note: The [GenericModules] folder is created when the first Smart Configurator project is made. If the [GenericModules] folder does not exist, create the folder, and then copy the files to it.
E.g., e² studio [Preferences]:

Example: e² studio [GenericModules] folder with copied files. (There might be no [Downloaded] folder, but this is not a problem. The contents are very similar in CS+.)

After placing the files in the destination folder, start Smart Configurator, and then click the [Add component] button as shown below.


Make sure that the added SIS module is available in the dialog box below.
See the List of SIS Modules and download the module you need from Renesas Web site.
Unzip the downloaded file (*.zip), and then copy the contents (*.xml, *.zip, and *.mdf, if any) to the SIS module download folder.
The following are the default download folders.
e² studio :  %USERPROFILE%\.eclipse\com.renesas.platform_download\RL78_Modules\GenericModules
CS+  :  %USERPROFILE%\.eclipse\com.renesas.smc.rcp.product_download\RL78_Modules\GenericModules
Copying and pasting the strings to the Windows File Explorer address bar will open the folder.
If the folder cannot be found or has been moved, find the folder as follows.
e² studio :
    Select [Window], [Preferences], [Renesas], and then check [Module Download].
CS+ :
    Start Smart Configurator, select [Window], [Preferences], and then check [Module Download].

Note: The [GenericModules] folder is created when the first Smart Configurator project is made. If the [GenericModules] folder does not exist, create the folder, and then copy the files to it.
E.g., e² studio [Preferences]:
Example: e² studio [GenericModules] folder with copied files. (There might be no [Downloaded] folder, but this is not a problem. The contents are very similar in CS+.)
After placing the files in the destination folder, start Smart Configurator, and then click the [Add component] button as shown below.
Make sure that the added SIS module is available in the dialog box below.
Suitable Products
RL78/G23, RL78/G22, RL78/G16
日本語 中文
日本語
中文","['data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/5657ae0054503aae3352121bd6b666bd.png', 'data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/0ae2664d95b166195254ef5b709124f2.png', 'data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/75786d68092a2d551305023268937fc9.png', 'data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/830cc14e0f626c3ca818209cd6ae8455.png', 'data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/d8decd5ad5818eda4000213005fdbe70.png', 'data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/f93c5286147373bc2c5cae866054994a.png']",[],"['|  |\n|  |\n| RL78/G23, RL78/G22, RL78/G16 |']","{'title': 'How to Download and Use a SIS Modules', 'url': 'https://en-support.renesas.com/knowledgeBase/20977342', 'last_updated': None, 'extracted_at': '2025-03-08T23:56:50.034556'}","Question How can I download a SIS module from the Renesas website (not from e studio or CS) and use it? Answer See the List of SIS Modules and download the module you need from Renesas Web site. Unzip the downloaded file (.zip), and then copy the contents (.xml, .zip, and .mdf, if any) to the SIS module download folder. The following are the default download folders. e studio  USERPROFILE.eclipsecom.renesas.platformdownloadRL78ModulesGenericModules CS  USERPROFILE.eclipsecom.renesas.smc.rcp.productdownloadRL78ModulesGenericModules Copying and pasting the strings to the Windows File Explorer address bar will open the folder. If the folder cannot be found or has been moved, find the folder as follows. e studio  Select Window, Preferences, Renesas, and then check Module Download. CS  Start Smart Configurator, select Window, Preferences, and then check Module Download. Note The GenericModules folder is created when the first Smart Configurator project is made. If the GenericModules folder does not exist, create the folder, and then copy the files to it. E.g., e studio Preferences Example e studio GenericModules folder with copied files. (There might be no Downloaded folder, but this is not a problem. The contents are very similar in CS.) After placing the files in the destination folder, start Smart Configurator, and then click the Add component button as shown below. Make sure that the added SIS module is available in the dialog box below. Suitable Products RL78/G23, RL78/G22, RL78/G16 If the folder cannot be found or has been moved, find the folder as follows. Suitable Products    ","['The image shows a screenshot of a file explorer window with a red box highlighting three files. The top of the window has a navigation bar with the current directory path displayed, which is ""r11an0484xx0130-rl78-sis > r11an0484xx0130-rl78-sis > RL78_Modules > GenericModules"". Below the navigation bar, there is a list of files and folders in the current directory. The three files highlighted in the red box are:\n\n*   r_ctsu_v1.30.xml\n*   r_ctsu_v1.30.zip\n*   r_ctsu_v1.30_extend.mdf\n\nAt the bottom of the image, there is a message in red text that says ""Copy all files in this folder"". The background of the image is white.\n\nOverall, the image appears to be a screenshot of a file explorer window showing a directory containing three files related to RL78 modules. The highlighted files are likely important for the user\'s work or project, and the message at the bottom suggests that the user may want to copy all of these files to another location.', 'The image shows a screenshot of a web browser with a URL in the address bar. The URL is:\n\n""%USERPROFILE%\\.eclipse\\.com.renesas.platform_download\\.RL78_Modules\\.GenericModules|""\n\nThe URL is written in black text on a white background, with a blue border around the address bar. There is a small blue star icon to the left of the URL, and a gray arrow icon to the right. The background of the image is white.\n\nThe image appears to be a screenshot of a web browser, possibly Internet Explorer, with a URL that is likely a link to a specific webpage or resource. The URL is quite long and contains several special characters, which may indicate that it is a complex or technical URL.', 'The image shows a screenshot of the ""Module Download"" page in the Renesas Eclipse IDE. The page is divided into two sections: the left side lists various options, and the right side displays the settings for each option.\n\n*   **Left Side:**\n    *   The left side of the page features a list of options, including:\n        *   ""Renesas""\n        *   ""Breakpoints""\n        *   ""Device add-ins Support""\n        *   ""Launch Settings""\n        *   ""Logging""\n        *   ""Module Download""\n        *   ""My Renesas""\n        *   ""Renesas QE""\n        *   ""Renesas Toolchain Management""\n        *   ""Smart Browser""\n        *   ""Smart Configurator""\n        *   ""Smart Manual""\n        *   ""Support Folders""\n        *   ""Tracealyzer""\n*   **Right Side:**\n    *   The right side of the page displays the settings for each option.\n    *   The ""Location (RL78):"" field is highlighted in red, indicating that it is the current focus.\n    *   The ""Location (RX):"" field is also highlighted in red, suggesting that it is related to the current focus.\n    *   The ""Location (RTOS):"" field is highlighted in blue, indicating that it is a different type of location.\n    *   The ""Location (generic):"" field is highlighted in blue, suggesting that it is a generic location.\n    *   The ""Browse..."" button is highlighted in red, indicating that it is the current focus.\n    *   The ""Apply and Close"" button is highlighted in blue, suggesting that it is a button that can be clicked to apply the changes and close the page.\n\nIn summary, the image shows a screenshot of the ""Module Download"" page in the Renesas Eclipse IDE, which allows users to configure various settings related to module downloads. The page is divided into two sections, with the left side listing options and the right side displaying the settings for each option. The highlighted fields and buttons indicate the current focus and suggest that the user is in the process of configuring the settings.', 'The image shows a screenshot of a file explorer window, with the title ""GenericModules"" at the top. The window is open on a Windows computer, and it displays a list of files and folders in a directory.\n\n*   **Title Bar**\n    *   The title bar at the top of the window reads ""GenericModules"".\n    *   There are several icons and buttons on the right side of the title bar, including a minimize button, a maximize button, and a close button.\n*   **File Explorer Window**\n    *   The file explorer window is open on a Windows computer.\n    *   The window displays a list of files and folders in a directory.\n    *   The list includes several files and folders, including ""Downloaded"", ""r_ctsu_v1.30.xml"", ""r_ctsu_v1.30.zip"", and ""r_ctsu_v1.30_extend.mdf"".\n    *   Each file and folder has a name, size, and date modified.\n    *   The files and folders are listed in a column on the left side of the window.\n    *   The right side of the window displays information about the selected file or folder.\n*   **Icons and Buttons**\n    *   There are several icons and buttons on the right side of the title bar.\n    *   The icons include a minimize button, a maximize button, and a close button.\n    *   The buttons allow the user to interact with the file explorer window.\n*   **Language**\n    *   The language of the file explorer window is Japanese.\n    *   The text on the window is written in Japanese characters.\n    *   The language of the file explorer window can be changed by selecting a different language from the options menu.\n\nOverall, the image shows a screenshot of a file explorer window on a Windows computer, displaying a list of files and folders in a directory. The window includes several icons and buttons, and the language of the window is Japanese.', 'The image shows a screenshot of a computer program with a pop-up window titled ""Software component configuration."" The pop-up window has a gray background and black text, with a white box in the center that says ""Add component"" in gray text. There are two tabs at the top of the window: ""Components"" and ""Configure."" The ""Components"" tab is selected, and there is a red circle around a small icon of a gear with a plus sign inside it.\n\nBelow the tabs, there is a list of components, including ""Startup,"" ""Generic,"" and ""r_bsp."" The ""Startup"" component is selected, and there is a dropdown menu next to it that says ""Generic."" At the bottom of the window, there are several buttons, including ""Overview,"" ""Board,"" ""Clocks,"" ""System,"" ""Components,"" ""Pins,"" and ""Interrupts.""\n\nThe background of the image is white, suggesting that this is a screenshot of a computer program or software application. Overall, the image appears to be a screenshot of a software development tool or IDE (Integrated Development Environment) that allows users to configure and manage software components.', 'The image shows a screenshot of a computer program with a white background and black text. The title at the top reads ""Software Component Selection"" in bold, black font. Below the title, there is a dropdown menu labeled ""Category"" with the option ""All"" selected. To the right of this menu, another dropdown menu labeled ""Function"" also has ""All"" selected.\n\nBelow these menus, there is a table with three columns: ""Components"", ""Short Name"", and ""Type"". The ""Components"" column lists various software components, including ""Capacitive Sensing Unit driver"", ""Clock Output /Buzzer Output Controller"", ""Comparator"", ""D/A Converter"", ""Data Transfer Controller"", ""Delay Counter"", ""Divider Function"", and ""External Event Counter"". The ""Short Name"" column contains abbreviations for each component, such as ""r_ctsu"" for the ""Capacitive Sensing Unit driver"". The ""Type"" column indicates that all components are of type ""RL78 Software I..."" with a version number of 1.30.\n\nAt the bottom of the window, there are several buttons and links. A checkbox labeled ""Show only latest version"" is checked, and a link to ""Download ELCL modules"" is provided. Additionally, there is a link to ""Download RL78 Software Integration System modules"" and a button labeled ""Finish"".\n\nOverall, the image appears to be a screenshot of a software component selection tool, allowing users to browse and select components for their project.']"
15e47175b2c701227c8e774332360856,"Question:
What is the difference between the RL78/G16 and other RL78 MCUs such as RL78/G15?
Answer:
RL78/G16 is “RL78/G15 + capacitive touch sensor and safety functions” with larger memory and pin package lineup. Also, it has pin-compatible with the RL78/G15 and RL78/G12 (20pin).
Furthermore, as well as RL78/G15, RL78/G16 supports an operating ambient temperature of up to 125°C. Therefore, RL78/G16 is designed to be stable even in high-temperature environments.
Figure 1: The RL78/G16 position in RL78 Family
Figure 2: Specification comparison between RL78/G16 and existing products
Figure 3: RL78/G16 and RL78/G15 Package Lineup
The RL78/G16 has the following four major features.
RL78/G16 is optimized for 8-bit MCU applications as well as G15. Including capacitive touch sensor and safety functions make it suitable for a wide range of applications, including home appliances.
Smallest-pin package touch MCU, realizing touch functions in a small space.
Application notes and sample codes to support the acquisition of functional safety IEC60730 certification, which is mandatory for home appliances.
Enhanced built-in peripheral functions to reduce overall device cost.
Wide operating ambient temperature range to simplify the thermal design.
Figure 4: 4 Key Features of RL78/G16 MCU
Suitable Products
RL78/G16
What is the difference between the RL78/G16 and other RL78 MCUs such as RL78/G15?
What is the difference between the RL78/G16 and other RL78 MCUs such as RL78/G15?
Answer:
RL78/G16 is “RL78/G15 + capacitive touch sensor and safety functions” with larger memory and pin package lineup. Also, it has pin-compatible with the RL78/G15 and RL78/G12 (20pin).
Furthermore, as well as RL78/G15, RL78/G16 supports an operating ambient temperature of up to 125°C. Therefore, RL78/G16 is designed to be stable even in high-temperature environments.
Figure 1: The RL78/G16 position in RL78 Family
Figure 2: Specification comparison between RL78/G16 and existing products
Figure 3: RL78/G16 and RL78/G15 Package Lineup
The RL78/G16 has the following four major features.
RL78/G16 is optimized for 8-bit MCU applications as well as G15. Including capacitive touch sensor and safety functions make it suitable for a wide range of applications, including home appliances.
Smallest-pin package touch MCU, realizing touch functions in a small space.
Application notes and sample codes to support the acquisition of functional safety IEC60730 certification, which is mandatory for home appliances.
Enhanced built-in peripheral functions to reduce overall device cost.
Wide operating ambient temperature range to simplify the thermal design.
Figure 4: 4 Key Features of RL78/G16 MCU
Suitable Products
RL78/G16
RL78/G16 is “RL78/G15 + capacitive touch sensor and safety functions” with larger memory and pin package lineup. Also, it has pin-compatible with the RL78/G15 and RL78/G12 (20pin).
Furthermore, as well as RL78/G15, RL78/G16 supports an operating ambient temperature of up to 125°C. Therefore, RL78/G16 is designed to be stable even in high-temperature environments.
Figure 1: The RL78/G16 position in RL78 Family
Figure 2: Specification comparison between RL78/G16 and existing products
Figure 3: RL78/G16 and RL78/G15 Package Lineup
The RL78/G16 has the following four major features.
RL78/G16 is optimized for 8-bit MCU applications as well as G15. Including capacitive touch sensor and safety functions make it suitable for a wide range of applications, including home appliances.
Smallest-pin package touch MCU, realizing touch functions in a small space.
Application notes and sample codes to support the acquisition of functional safety IEC60730 certification, which is mandatory for home appliances.
Enhanced built-in peripheral functions to reduce overall device cost.
Wide operating ambient temperature range to simplify the thermal design.
Figure 4: 4 Key Features of RL78/G16 MCU
RL78/G16 is “RL78/G15 + capacitive touch sensor and safety functions” with larger memory and pin package lineup. Also, it has pin-compatible with the RL78/G15 and RL78/G12 (20pin).
Furthermore, as well as RL78/G15, RL78/G16 supports an operating ambient temperature of up to 125°C. Therefore, RL78/G16 is designed to be stable even in high-temperature environments.
Figure 1: The RL78/G16 position in RL78 Family
Figure 2: Specification comparison between RL78/G16 and existing products
Figure 3: RL78/G16 and RL78/G15 Package Lineup
The RL78/G16 has the following four major features.
RL78/G16 is optimized for 8-bit MCU applications as well as G15. Including capacitive touch sensor and safety functions make it suitable for a wide range of applications, including home appliances.
Figure 4: 4 Key Features of RL78/G16 MCU
Suitable Products
RL78/G16
日本語 中文
日本語
中文","['data/categories/rl78_family/rl78g16/15e47175b2c701227c8e774332360856/images/54e60126b54074c9030a138b26622f10.png', 'data/categories/rl78_family/rl78g16/15e47175b2c701227c8e774332360856/images/e1f90bcc8144750bd91e01d8c0288b83.png', 'data/categories/rl78_family/rl78g16/15e47175b2c701227c8e774332360856/images/16f27c8b1230f2183be3d4de01b6e73c.png', 'data/categories/rl78_family/rl78g16/15e47175b2c701227c8e774332360856/images/6957f4b26b7950b7c5f9e34a0dbdab0b.png']",[],['|  |\n|  |\n| RL78/G16 |'],"{'title': 'The RL78/G16 position in the RL78 family', 'url': 'https://en-support.renesas.com/knowledgeBase/20919983', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:57.469859'}","Question What is the difference between the RL78/G16 and other RL78 MCUs such as RL78/G15? Answer RL78/G16 is RL78/G15  capacitive touch sensor and safety functions with larger memory and pin package lineup. Also, it has pin-compatible with the RL78/G15 and RL78/G12 (20pin). Furthermore, as well as RL78/G15, RL78/G16 supports an operating ambient temperature of up to 125C. Therefore, RL78/G16 is designed to be stable even in high-temperature environments. Figure 1 The RL78/G16 position in RL78 Family Figure 2 Specification comparison between RL78/G16 and existing products Figure 3 RL78/G16 and RL78/G15 Package Lineup The RL78/G16 has the following four major features. RL78/G16 is optimized for 8-bit MCU applications as well as G15. Including capacitive touch sensor and safety functions make it suitable for a wide range of applications, including home appliances. Smallest-pin package touch MCU, realizing touch functions in a small space. Application notes and sample codes to support the acquisition of functional safety IEC60730 certification, which is mandatory for home appliances. Enhanced built-in peripheral functions to reduce overall device cost. Wide operating ambient temperature range to simplify the thermal design. Figure 4 4 Key Features of RL78/G16 MCU Suitable Products RL78/G16    ","['The image presents a graph illustrating the relationship between flash density and performance for various generations of memory chips. The graph features a horizontal axis labeled ""Flash Density"" and a vertical axis labeled ""Performance."" The x-axis is divided into two sections: the left side, which ranges from 2.0-5.5V to 20 MHz, and the right side, which ranges from 1.6-5.5V to 32 MHz. The y-axis is divided into two sections: the top section, which ranges from 2.4-5.5V to 16 MHz, and the bottom section, which ranges from 1.8-5.5V to 24 MHz.\n\nThe graph includes several data points, each represented by a gray box with a label indicating the generation of the memory chip (G10, G1M, G1N, G12, G15, G16, G22, G23). Each box contains information about the voltage range (in volts) and frequency (in megahertz) for that particular generation. The graph also includes a yellow box labeled ""G16"" with a voltage range of 2.4-5.5V and a frequency of 16 MHz.\n\nThe graph provides a visual representation of how the performance of memory chips changes as the flash density increases. The data points are scattered across the graph, with some generations showing higher performance at lower flash densities and others showing higher performance at higher flash densities. Overall, the graph suggests that there is a trade-off between flash density and performance, and that different generations of memory chips have different strengths and weaknesses in this regard.', 'The image presents a table comparing the specifications of four microcontrollers: RL78/G10, RL78/G15, RL78/G12, and RL78/G16. The table is divided into two main sections: the left side lists the items being compared, and the right side provides the specifications for each microcontroller.\n\n**Items:**\n\n* CPU-Core\n* Maximum Operating Frequency\n* Code Flash\n* Data Flash\n* RAM\n* Operating Voltage Range\n* Pin Number\n* I/O Port (20-pin package)\n* Capacitor For Internal Power Supply\n* Writing Flash Voltage\n* Self Programming (w/, w/o BGO)\n* Programing /Debugging at 3.3V\n* Cap. Touch\n* ADC\n* Comparator\n* DAC\n* Safety\n* Maximum Operating Temperature Range\n\n**Specifications:**\n\n* **CPU-Core:**\n\t+ RL78/G10: RL78 S1-core\n\t+ RL78/G15: RL78 S2-core\n\t+ RL78/G12: RL78 S2-core\n\t+ RL78/G16: RL78 S2-core\n* **Maximum Operating Frequency:**\n\t+ RL78/G10: 20MHz\n\t+ RL78/G15: 16MHz\n\t+ RL78/G12: 24MHz\n\t+ RL78/G16: 16MHz\n* **Code Flash:**\n\t+ RL78/G10: 1KB to 4KB\n\t+ RL78/G15: 4KB to 8KB\n\t+ RL78/G12: 2KB to 16KB\n\t+ RL78/G16: 16KB / 32KB\n* **Data Flash:**\n\t+ RL78/G10: -\n\t+ RL78/G15: 1KB\n\t+ RL78/G12: 2KB\n\t+ RL78/G16: 1KB\n* **RAM:**\n\t+ RL78/G10: 128B to 512B\n\t+ RL78/G15: 1KB\n\t+ RL78/G12: 256B to 2KB\n\t+ RL78/G16: 2KB\n* **Operating Voltage Range:**\n\t+ RL78/G10: 2.0V to 5.5V\n\t+ RL78/G15: 2.4V to 5.5V\n\t+ RL78/G12: 1.8V to 5.5V\n\t+ RL78/G16: 2.4V to 5.5V\n* **Pin Number:**\n\t+ RL78/G10: 10-pin to 16-pin\n\t+ RL78/G15: 8-pin to 20-pin\n\t+ RL78/G12: 20-pin to 30-pin\n\t+ RL78/G16: 10-pin to 32-pin\n* **I/O Port (20-pin package):**\n\t+ RL78/G10: -\n\t+ RL78/G15: 18-pin\n\t+ RL78/G12: 18-pin\n\t+ RL78/G16: 18-pin\n* **Capacitor For Internal Power Supply:**\n\t+ RL78/G10: No REGC\n\t+ RL78/G15: No REGC\n\t+ RL78/G12: No REGC(20,24-pin)\n\t+ RL78/G16: No REGC\n* **Writing Flash Voltage:**\n\t+ RL78/G10: 4.5 to 5.5V\n\t+ RL78/G15: 2.4 to 5.5V\n\t+ RL78/G12: 1.8 to 5.5V\n\t+ RL78/G16: 2.4 to 5.5V\n* **Self Programming (w/, w/o BGO):**\n\t+ RL78/G10: -\n\t+ RL78/G15: w/o BGO\n\t+ RL78/G12: w/ BGO\n\t+ RL78/G16: w/o BGO\n* **Programing /Debugging at 3.3V:**\n\t+ RL78/G10: -\n\t+ RL78/G15: Yes\n\t+ RL78/G12: Yes\n\t+ RL78/G16: Yes\n* **Cap. Touch:**\n\t+ RL78/G10: -\n\t+ RL78/G15: -\n\t+ RL78/G12: -\n\t+ RL78/G16: 3ch to 15ch\n* **ADC:**\n\t+ RL78/G10: 10,8-bit 4ch to 7ch\n\t+ RL78/G15: 10,8-bit 3ch to 11ch\n\t+ RL78/G12: 10,8-bit 8ch to 11ch\n\t+ RL78/G16: 10,8-bit 4ch to 11ch\n* **Comparator:**\n\t+ RL78/G10: 0ch to 1ch\n\t+ RL78/G15: 1ch to 2ch\n\t+ RL78/G12: -\n\t+ RL78/G16: 1ch to 2ch\n* **DAC:**\n\t+ RL78/G10: -\n\t+ RL78/G15: -\n\t+ RL78/G12: -\n\t+ RL78/G16: -\n* **Safety:**\n\t+ RL78/G10: TRAP Only\n\t+ RL78/G15: -\n\t+ RL78/G12: Yes\n\t+ RL78/G16: Yes\n* **Maximum Operating Temperature Range:**\n\t+ RL78/G10: -40 to 85\n\t+ RL78/G15: -40 to 125\n\t+ RL78/G12: -40 to 105\n\t+ RL78/G16: -40 to 125\n\nIn summary, the table provides a comprehensive comparison of the specifications of four microcontrollers: RL78/G10, RL78/G15, RL78/G12, and RL78/G16. The table covers various aspects, including CPU-core, maximum operating frequency, code flash, data flash, RAM, operating voltage range, pin number, I/O port, capacitor for internal power supply, writing flash voltage, self-programming, programming/debugging, cap. touch, ADC, comparator, DAC, safety, and maximum operating temperature range. Each microcontroller has its unique set of specifications, making it suitable for different applications.', 'The image presents a table that compares the pin count and code flash of various microcontrollers. The table is divided into two main sections: the top section lists the pin counts, and the bottom section lists the code flash sizes.\n\n**Top Section: Pin Counts**\n\n*   The top section of the table lists the pin counts for each microcontroller, ranging from 8 to 32 pins.\n*   Each pin count is represented by a column in the table, with the corresponding microcontroller listed in the row below.\n\n**Bottom Section: Code Flash Sizes**\n\n*   The bottom section of the table lists the code flash sizes for each microcontroller, ranging from 1 KB to 32 KB.\n*   Each code flash size is represented by a row in the table, with the corresponding microcontroller listed in the column to the left.\n\n**Microcontrollers Compared**\n\n*   The table compares the following microcontrollers:\n    *   WDFN (3mmx3mm)\n    *   LSSOP (4.4mmx3.6mm)\n    *   SSOP (4.4mmx5mm)\n    *   HWQFN (3mmx3mm)\n    *   LSSOP (4.4mmx6.5mm)\n    *   HWQFN (4mmx4mm)\n    *   LQFP (7mmx7mm)\n    *   HWQFN (5mmx5mm)\n\n**Key Features**\n\n*   The table highlights the key features of each microcontroller, including the pin count and code flash size.\n*   The table also includes a key that explains the abbreviations used in the table, such as ""WDFN"" and ""LSSOP"".\n\n**Conclusion**\n\nThe table provides a clear and concise comparison of the pin counts and code flash sizes of various microcontrollers. It is a useful tool for engineers and developers who need to select the appropriate microcontroller for their project.', 'The image presents a comprehensive overview of the Renesas RL78 microcontroller, highlighting its key features and applications. The image is divided into four sections, each focusing on a specific aspect of the RL78.\n\n*   **Smallest Touch Key MCU in Renesas**\n    *   The RL78/G16 is the smallest touch key MCU in Renesas.\n    *   It has a 3-ch@10pin and 5-ch@16pin configuration.\n    *   It is part of the RL78/G22 and RL78/G23 RA2 Series RX Family.\n*   **Rich Safety Functions RL78 Support**\n    *   The RL78 supports rich safety functions, including Class A, Class B, and Class C.\n    *   Class A includes timer, LED, etc.\n    *   Class B includes washing machine, etc.\n    *   Class C includes water heater, etc.\n*   **Extensive Peripheral Functions**\n    *   The RL78 has extensive peripheral functions, including:\n        *   Cap. Touch\n        *   Data Flash\n        *   Comparator\n        *   CSI\n        *   UART\n        *   I2C\n        *   ±1% HOCO\n*   **Wide Operating Temperature**\n    *   The RL78 has a wide operating temperature range of -40°C to 125°C.\n    *   It is suitable for use in various applications, including motor control and device control.\n\nIn summary, the RL78 microcontroller is a versatile and reliable solution for a wide range of applications, offering rich safety functions, extensive peripheral functions, and a wide operating temperature range. Its compact size and low power consumption make it an ideal choice for battery-powered devices and other applications where space and energy efficiency are critical.']"
c16698da0408a214bcadc398c7d4e79f,"Question:
Are there any precautions when developing touch functions on the RL78/G16?
Answer:
Tuning and monitoring functions by QE for Capacitive Touch must be executed using serial communication (UART). (They cannot be executed via the E2/E2 Lite emulator.)
Also, monitoring via serial communication (UART) cannot be executed with variable values registered in IDE functions (e2 studio: Expression View, CS+: watch-expression).
Please also refer to the table below.
  Suitable Products
RL78/G16
Are there any precautions when developing touch functions on the RL78/G16?
Are there any precautions when developing touch functions on the RL78/G16?
Answer:
Tuning and monitoring functions by QE for Capacitive Touch must be executed using serial communication (UART). (They cannot be executed via the E2/E2 Lite emulator.)
Also, monitoring via serial communication (UART) cannot be executed with variable values registered in IDE functions (e2 studio: Expression View, CS+: watch-expression).
Please also refer to the table below.
  Suitable Products
RL78/G16
Tuning and monitoring functions by QE for Capacitive Touch must be executed using serial communication (UART). (They cannot be executed via the E2/E2 Lite emulator.)
Also, monitoring via serial communication (UART) cannot be executed with variable values registered in IDE functions (e2 studio: Expression View, CS+: watch-expression).
Please also refer to the table below.
Tuning and monitoring functions by QE for Capacitive Touch must be executed using serial communication (UART). (They cannot be executed via the E2/E2 Lite emulator.)
Also, monitoring via serial communication (UART) cannot be executed with variable values registered in IDE functions (e2 studio: Expression View, CS+: watch-expression).
Please also refer to the table below.
Suitable Products
RL78/G16
日本語 中文
日本語
中文",['data/categories/rl78_family/rl78g16/c16698da0408a214bcadc398c7d4e79f/images/6df500e8e194807dee4b1120e8ec4eeb.png'],[],['|  |\n|  |\n| RL78/G16 |'],"{'title': 'Precautions when Developing Touch Functions with the RL78/G16', 'url': 'https://en-support.renesas.com/knowledgeBase/20977337', 'last_updated': None, 'extracted_at': '2025-03-08T23:54:00.310568'}","Question Are there any precautions when developing touch functions on the RL78/G16? Answer Tuning and monitoring functions by QE for Capacitive Touch must be executed using serial communication (UART). (They cannot be executed via the E2/E2 Lite emulator.) Also, monitoring via serial communication (UART) cannot be executed with variable values registered in IDE functions (e2 studio Expression View, CS watch-expression). Please also refer to the table below. Suitable Products RL78/G16 Suitable Products    ","['The image presents a table comparing the features of two versions of the e² studio: the Smart Configurator (SC) and the QE for Capacitive Touch. The table is divided into three columns, with the first column listing the tool name/version/function, the second column indicating whether the feature is supported or not, and the third column providing additional information.\n\n**Tool Name/Version/Function**\n\n*   Smart Configurator (SC)\n*   QE for Capacitive Touch\n\n**Supported/Not Supported**\n\n*   e² studio plug-in ver.\n    *   Supported\n*   e² studio plug-in ver.\n    *   Not supported\n*   e² studio plug-in ver.\n    *   Supported\n*   e² studio plug-in ver.\n    *   Not supported\n*   e² studio plug-in ver.\n    *   Supported\n*   e² studio plug-in ver.\n    *   Not supported\n\n**Additional Information**\n\n*   Note 1: If you monitor the touch performance without starting e2 studio after the touch application development is completed, you can also use QE (stand-alone ver.).\n*   Note 2: During monitoring via serial communication (UART), it is not possible to check variable values with the IDE functions.\n\nThe table provides a clear comparison of the features of the two versions of the e² studio, highlighting the differences in their capabilities and limitations.']"
d28a079bd8b7b0321819324bbe19d5ac,"Question:
I need more information about ADC module in µC R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ?
CPU and peripheral clock is 24MH.
Answer:
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. 
   Figure 1: Conversion time electrical specs
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
Figure 2: Conversion clock electrical spec
  A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
Suitable Products
RL78
Question:
I need more information about ADC module in µC R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ?
CPU and peripheral clock is 24MH.
Answer:
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. 
   Figure 1: Conversion time electrical specs
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
Figure 2: Conversion clock electrical spec
  A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
Suitable Products
RL78
I need more information about ADC module in µC R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ?
CPU and peripheral clock is 24MH.
I need more information about ADC module in µC R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ?
I need more information about ADC module in µC
R5F10BGGCKFB.
Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ?
CPU and peripheral clock is 24MH.
CPU and peripheral clock is 24MH.
Answer:
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. 
   Figure 1: Conversion time electrical specs
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
Figure 2: Conversion clock electrical spec
  A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
Suitable Products
RL78
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. 
   Figure 1: Conversion time electrical specs
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
Figure 2: Conversion clock electrical spec
  A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs.
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs.
Figure 1: Conversion time electrical specs
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
Figure 2: Conversion clock electrical spec
A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
Suitable Products
RL78","['data/categories/rl78_family/ad_converter/d28a079bd8b7b0321819324bbe19d5ac/images/11238e947e14beea8eeb87e2ce670825.png', 'data/categories/rl78_family/ad_converter/d28a079bd8b7b0321819324bbe19d5ac/images/7d4903223de989d3f9130dc9bd73ccaf.png']",[],['|  |\n|  |\n| RL78 |'],"{'title': 'RL78 ADC Sampling time', 'url': 'https://en-support.renesas.com/knowledgeBase/21205011', 'last_updated': None, 'extracted_at': '2025-03-08T23:56:13.605929'}","Question I need more information about ADC module in C R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ? CPU and peripheral clock is 24MH. Answer The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. Figure 1 Conversion time electrical specs Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz. But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. For 24MHz the min sample time will be a round 3us Figure 2 Conversion clock electrical spec A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle. Suitable Products RL78 I need more information about ADC module in C R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ? The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. Figure 1 Conversion time electrical specs A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.","['The image displays a table of information about analog characteristics and A/D converter characteristics. The table is divided into two main sections: ""Analog Characteristics"" and ""A/D Converter Characteristics."" \n\n*   **Analog Characteristics**\n    *   The first section lists various parameters, including:\n        *   Reference voltage (-) = AVREFM = 0 V\n        *   Parameter: Symbol: Conditions: MIN.: TYF:\n        *   Resolution: RES: 8: 1.2\n        *   Overall error: Note 1: AINL: 4.0 V ≤ VDD ≤ 5.5 V: 1.2\n        *   Conversion time: tconv: 10-bit resolution: 4.0 V ≤ VDD ≤ 5.5 V: 2.125\n        *   Zero-scale error: Notes 1,2: EZS: 10-bit resolution: 2.7 V < VDD < 4.0 V: 3.1875\n\nThe table provides detailed information about the analog characteristics and A/D converter characteristics of a specific device or system. The parameters listed include reference voltage, resolution, overall error, conversion time, and zero-scale error. The conditions for each parameter are also specified, along with the minimum and typical values. This information can be useful for designers and engineers who need to understand the performance characteristics of the device or system.', 'The image presents a table titled ""Table 12-3. A/D Conversion Time Selection (4/4)"" with the subtitle ""(4) 2.7 V ≤ VDD < 4.0 V."" The table is divided into two main sections: the left side lists various settings, and the right side displays corresponding conversion times.\n\n**Left Side:**\n\n*   **A/D Converter Mode**\n    *   Register 0 (ADMO)\n    *   FR2\n    *   FR1\n    *   FRO\n    *   LV1\n    *   LVO\n*   **Mode**\n    *   Normal\n    *   1\n    *   0\n    *   0\n    *   0\n    *   0\n*   **Conversion Clock (fclk)**\n    *   fclk/64\n    *   fclk/32\n    *   fclk/16\n    *   fclk/8\n    *   fclk/6\n    *   fclk/5\n    *   fclk/4\n    *   fclk/2\n    *   fclk/64\n    *   fclk/32\n    *   fclk/16\n    *   fclk/8\n    *   fclk/6\n    *   fclk/5\n    *   fclk/4\n    *   fclk/2\n*   **Number of Conversion Clocks**\n    *   19\n    *   1216\n    *   304\n    *   152\n    *   114\n    *   95\n    *   76\n    *   38\n    *   17\n    *   544\n    *   272\n    *   136\n*   **Conversion Time**\n    *   3,166us\n    *   3,166us\n    *   6MHz\n    *   6MHz\n    *   6MHz\n    *   6MHz\n    *   6MHz\n    *   6MHz\n    *   6MHz\n    *   6MHz\n    *   6MHz\n    *   6MHz\n    *   6MHz\n    *   6MHz\n    *   6MHz\n    *   6MHz\n\n**Right Side:**\n\n*   **Conversion Time Selection**\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n    *   fclk = 8 MHz\n    *   fclk = 16 M\n    *   fclk = 1 MHz\n    *   fclk = 2 MHz\n    *   fclk = 4 MHz\n']"
