document_id,text,image_paths,pdf_paths,tables,metadata,cleaned_text,image_descriptions
f95dbeb26c41257522a18c8f6463c248,"Question:
I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file.
Answer:
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
  C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
  It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
If your device is not listed here, please check that you are using the latest version of CS+:    CS+
Suitable Products
RH850
Question:
I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file.
Answer:
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
  C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
  It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
If your device is not listed here, please check that you are using the latest version of CS+:    CS+
Suitable Products
RH850
I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file.
I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file.
I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file.
Answer:
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
  C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
  It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
If your device is not listed here, please check that you are using the latest version of CS+:    CS+
Suitable Products
RH850
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
  C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
  It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
If your device is not listed here, please check that you are using the latest version of CS+:    CS+
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS+ You can find the dvf file in the install directory in the path shown like below.
C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
C:\Program Files (x86)\Renesas Electronics\CS+\CC\Device\RH850\Devicefile\
It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS+ Device Selection dialogue:
If your device is not listed here, please check that you are using the latest version of CS+:    CS+
If your device is not listed here, please check that you are using the latest version of CS+:
CS+
CS+
Suitable Products
RH850","['data/categories/rh850_family/rh850_general/f95dbeb26c41257522a18c8f6463c248/images/8e30aea5eface8fc259d997da34bfae4.png', 'data/categories/rh850_family/rh850_general/f95dbeb26c41257522a18c8f6463c248/images/b50f0e66167a52551bbe298e915639da.png']",[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850 find dvf file for CS+', 'url': 'https://en-support.renesas.com/knowledgeBase/21153486', 'last_updated': None, 'extracted_at': '2025-03-09T00:29:11.225703'}","Question I am unable to find rh850 device file mentioned in the subject could you please let me know how I can access the device file. Answer The '.dvf' ' is binary file called 'device file'. It describes the device and the header-files for a C-compiler and other files (e.g. the linker control file) are created from the device file. For CS You can find the dvf file in the install directory in the path shown like below. CProgram Files (x86)Renesas ElectronicsCSCCDeviceRH850Devicefile It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS Device Selection dialogue If your device is not listed here, please check that you are using the latest version of CS CS Suitable Products RH850 CProgram Files (x86)Renesas ElectronicsCSCCDeviceRH850Devicefile It is not necessary to select a DVF manually, it is done automatically if a device is selected in the CS Device Selection dialogue If your device is not listed here, please check that you are using the latest version of CS CS",[]
85b897523834211bbbc3b0fe00a067a4,"Question:
I am using RH850 with CS+ IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM?
Answer:
Answer:
If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below.
  Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively.
    Prepare a separate routine for transfer that will lead to the following actions and include it in your program.
Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined _INITSCT_RH function provided by CC-RH)
Call the target routines from RAM.
In the process of building your program, run the optimizing linker with the following settings for such code.
As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated.
As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run.
    Sample Code:
#include <_h_c_lib.h>
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
    extern void my_ram_function(void);
  /* import sections to get start/end addresses */
extern char _Smysection_rom_text;
extern char _Emysection_rom_text;
extern char _Smysection_ram_text;
  /* define type for copy table entry. See doc --> _INITSCT_RH */
struct SectionTableEntry {
    void *rom_s;
    void *rom_e;
    void *ram_s;
};
      /* Initialize the array with our section addresses */
#define M 1
struct SectionTableEntry _C_DSEC[M] = {
    { (void *)&_Smysection_rom_text, (void *)&_Emysection_rom_text, (void *)&_Smysection_ram_text, }
};
    void main(void);
void main(void)
{
            /* copy function contents to RAM */
            _INITSCT_RH((void *)_C_DSEC, (void *)(_C_DSEC+M),(void *)0,(void *)0);
                        /* call RAM function */
            my_ram_function();
}

Suitable Products
RH850
Question:
I am using RH850 with CS+ IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM?
Answer:
Answer:
If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below.
  Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively.
    Prepare a separate routine for transfer that will lead to the following actions and include it in your program.
Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined _INITSCT_RH function provided by CC-RH)
Call the target routines from RAM.
In the process of building your program, run the optimizing linker with the following settings for such code.
As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated.
As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run.
    Sample Code:
#include <_h_c_lib.h>
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
    extern void my_ram_function(void);
  /* import sections to get start/end addresses */
extern char _Smysection_rom_text;
extern char _Emysection_rom_text;
extern char _Smysection_ram_text;
  /* define type for copy table entry. See doc --> _INITSCT_RH */
struct SectionTableEntry {
    void *rom_s;
    void *rom_e;
    void *ram_s;
};
      /* Initialize the array with our section addresses */
#define M 1
struct SectionTableEntry _C_DSEC[M] = {
    { (void *)&_Smysection_rom_text, (void *)&_Emysection_rom_text, (void *)&_Smysection_ram_text, }
};
    void main(void);
void main(void)
{
            /* copy function contents to RAM */
            _INITSCT_RH((void *)_C_DSEC, (void *)(_C_DSEC+M),(void *)0,(void *)0);
                        /* call RAM function */
            my_ram_function();
}

Suitable Products
RH850
I am using RH850 with CS+ IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM?
I am using RH850 with CS+ IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM?
I am using RH850 with CS+ IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM?
Answer:
Answer:
If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below.
  Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively.
    Prepare a separate routine for transfer that will lead to the following actions and include it in your program.
Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined _INITSCT_RH function provided by CC-RH)
Call the target routines from RAM.
In the process of building your program, run the optimizing linker with the following settings for such code.
As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated.
As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run.
    Sample Code:
#include <_h_c_lib.h>
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
    extern void my_ram_function(void);
  /* import sections to get start/end addresses */
extern char _Smysection_rom_text;
extern char _Emysection_rom_text;
extern char _Smysection_ram_text;
  /* define type for copy table entry. See doc --> _INITSCT_RH */
struct SectionTableEntry {
    void *rom_s;
    void *rom_e;
    void *ram_s;
};
      /* Initialize the array with our section addresses */
#define M 1
struct SectionTableEntry _C_DSEC[M] = {
    { (void *)&_Smysection_rom_text, (void *)&_Emysection_rom_text, (void *)&_Smysection_ram_text, }
};
    void main(void);
void main(void)
{
            /* copy function contents to RAM */
            _INITSCT_RH((void *)_C_DSEC, (void *)(_C_DSEC+M),(void *)0,(void *)0);
                        /* call RAM function */
            my_ram_function();
}

Suitable Products
RH850
Answer:
Answer:
If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below.
If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below.
Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively.
Prepare a separate routine for transfer that will lead to the following actions and include it in your program.
Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined _INITSCT_RH function provided by CC-RH)
Call the target routines from RAM.
In the process of building your program, run the optimizing linker with the following settings for such code.
As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated.
As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run.
    Sample Code:
#include <_h_c_lib.h>
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
    extern void my_ram_function(void);
  /* import sections to get start/end addresses */
extern char _Smysection_rom_text;
extern char _Emysection_rom_text;
extern char _Smysection_ram_text;
  /* define type for copy table entry. See doc --> _INITSCT_RH */
struct SectionTableEntry {
    void *rom_s;
    void *rom_e;
    void *ram_s;
};
      /* Initialize the array with our section addresses */
#define M 1
struct SectionTableEntry _C_DSEC[M] = {
    { (void *)&_Smysection_rom_text, (void *)&_Emysection_rom_text, (void *)&_Smysection_ram_text, }
};
    void main(void);
void main(void)
{
            /* copy function contents to RAM */
            _INITSCT_RH((void *)_C_DSEC, (void *)(_C_DSEC+M),(void *)0,(void *)0);
                        /* call RAM function */
            my_ram_function();
}
Prepare a separate routine for transfer that will lead to the following actions and include it in your program.
Copy the target routines from the ROM sections to the corresponding RAM sections.(
Code use pre-defined _INITSCT_RH function provided by CC-RH)
Call the target routines from RAM.
In the process of building your program, run the optimizing linker with the following settings for such code.
As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated.
As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run.
Sample Code:
Sample Code:
#include <_h_c_lib.h>
#include
<_h_c_lib.h>
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
/* void _INITSCT_RH(void * datatbl_start, void * datatbl_end, void * bsstbl_start, void * bsstbl_end) */
extern void my_ram_function(void);
extern
void
my_ram_function(
void
);
/* import sections to get start/end addresses */
/* import sections to get start/end addresses */
extern char _Smysection_rom_text;
extern
char
_Smysection_rom_text;
extern char _Emysection_rom_text;
extern
char
_Emysection_rom_text;
extern char _Smysection_ram_text;
extern
char
_Smysection_ram_text;
/* define type for copy table entry. See doc --> _INITSCT_RH */
/* define type for copy table entry. See doc --> _INITSCT_RH */
struct SectionTableEntry {
struct
SectionTableEntry {
void *rom_s;
void
*
rom_s;
void *rom_e;
void
*
rom_e;
void *ram_s;
void
*
ram_s;
};
};
/* Initialize the array with our section addresses */
/* Initialize the array with our section addresses */
#define M 1
#define
M 1
struct SectionTableEntry _C_DSEC[M] = {
struct
SectionTableEntry _C_DSEC[M]
=
{
{ (void *)&_Smysection_rom_text, (void *)&_Emysection_rom_text, (void *)&_Smysection_ram_text, }
{ (
void
*
)
&
_Smysection_rom_text, (
void
*
)
&
_Emysection_rom_text, (
void
*
)
&
_Smysection_ram_text, }
};
};
void main(void);
void
main(
void
);
void main(void)
void
main(
void
)
{
{
/* copy function contents to RAM */
/* copy function contents to RAM */
_INITSCT_RH((void *)_C_DSEC, (void *)(_C_DSEC+M),(void *)0,(void *)0);
_INITSCT_RH((
void
*
)_C_DSEC, (
void
*
)(_C_DSEC
+
M),(
void
*
)0,(
void
*
)0);
/* call RAM function */
/* call RAM function */
my_ram_function();
my_ram_function();
}
}
Suitable Products
RH850","['data/categories/rh850_family/rh850_general/85b897523834211bbbc3b0fe00a067a4/images/198d45ba348f46df5f05c47eb602ca1e.png', 'data/categories/rh850_family/rh850_general/85b897523834211bbbc3b0fe00a067a4/images/b1a996cd92b432d64e4c1a7869df6e50.png']",[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850: CC-RH Execution of a routine from RAM', 'url': 'https://en-support.renesas.com/knowledgeBase/21476371', 'last_updated': None, 'extracted_at': '2025-03-09T00:28:39.925390'}","Question I am using RH850 with CS IDE. CC-RH's -rom command can map the data and const areas, but it seems that it cannot map the text area. Can it map the text area? How to execute a routine from RAM? Answer If you wish to have specific routines in your program, be executed from RAM, use the -rom option of the optimizing linker as in the procedure described below. Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively. Prepare a separate routine for transfer that will lead to the following actions and include it in your program. Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined INITSCTRH function provided by CC-RH) Call the target routines from RAM. In the process of building your program, run the optimizing linker with the following settings for such code. As parameter ROMsection of the -rom option, specify the name of the ROM section where the target routine for copying is to be allocated. As parameter RAMsection of the -rom option, specify the name of the RAM section from which you wish the target routine to be run. Sample Code include hclib.h / void INITSCTRH(void  datatblstart, void  datatblend, void  bsstblstart, void  bsstblend) / extern void myramfunction(void); / import sections to get start/end addresses / extern char Smysectionromtext; extern char Emysectionromtext; extern char Smysectionramtext; / define type for copy table entry. See doc -- INITSCTRH / struct SectionTableEntry  void roms; void rome; void rams; ; / Initialize the array with our section addresses / define M 1 struct SectionTableEntry CDSECM    (void )Smysectionromtext, (void )Emysectionromtext, (void )Smysectionramtext,  void main(void); void main(void)  / copy function contents to RAM / INITSCTRH((void )CDSEC, (void )(CDSECM),(void )0,(void )0); / call RAM function / myramfunction();  Suitable Products RH850 Allocate sections to addresses in ROM where you wish to place the routines and the corresponding addresses in RAM, respectively. Prepare a separate routine for transfer that will lead to the following actions and include it in your program. Copy the target routines from the ROM sections to the corresponding RAM sections.( Code use pre-defined INITSCTRH function provided by CC-RH) Sample Code include hclib.h extern void myramfunction(void); extern void myramfunction( ); / import sections to get start/end addresses / char Smysectionromtext; Emysectionromtext; Smysectionramtext; / define type for copy table entry. See doc -- INITSCTRH / struct SectionTableEntry  void roms;  roms; void rome; rome; void rams; rams; / Initialize the array with our section addresses / define M 1 SectionTableEntry CDSECM   (void )Smysectionromtext, (void )Emysectionromtext, (void )Smysectionramtext,   ( )  Smysectionromtext, ( Emysectionromtext, ( Smysectionramtext,  void main(void); main( / copy function contents to RAM / INITSCTRH((void )CDSEC, (void )(CDSECM),(void )0,(void )0); INITSCTRH(( )CDSEC, ( )(CDSEC  M),( )0,( )0); / call RAM function / myramfunction();",[]
aef18c1527e32753e293578beff82f85,"Question:
How do I dump the RH850 whole IOR registers in the debug mode of CS+ IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers.
Answer:
In CS+, you have the option to export any window as either text or CSV.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
Suitable Products
RH850
Question:
How do I dump the RH850 whole IOR registers in the debug mode of CS+ IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers.
Answer:
In CS+, you have the option to export any window as either text or CSV.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
Suitable Products
RH850
How do I dump the RH850 whole IOR registers in the debug mode of CS+ IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers.
How do I dump the RH850 whole IOR registers in the debug mode of CS+ IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers.
How do I dump the RH850 whole IOR registers in the debug mode of CS+ IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers.
Answer:
In CS+, you have the option to export any window as either text or CSV.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
Suitable Products
RH850
In CS+, you have the option to export any window as either text or CSV.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
In CS+, you have the option to export any window as either text or CSV.
In CS+, you have the option to export any window as either text or CSV.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
For your specific needs, please open the IOR window(if not visible View->IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer.
Suitable Products
RH850",['data/categories/rh850_family/rh850_general/aef18c1527e32753e293578beff82f85/images/8a1c4d4b373a89027dc6bc425b274e02.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850 IOR dump in CS+', 'url': 'https://en-support.renesas.com/knowledgeBase/21671338', 'last_updated': None, 'extracted_at': '2025-03-09T00:28:45.063199'}","Question How do I dump the RH850 whole IOR registers in the debug mode of CS IDE? Is there any tool that help to dump whole IOR registers and save them as a text file? I need compare those dump data between two SDK source code regarding their IOR registers. Answer In CS, you have the option to export any window as either text or CSV. For your specific needs, please open the IOR window(if not visible View-IOR) and make sure it is focused (click inside the window). Then, go to the File menu, select ""Save IOR Data As,"" and choose the format you prefer. Suitable Products RH850",[]
3cf13711a6bd31149acc5c5f5f248702,"Question:
We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause?
Answer:
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
  For the PG-FP6 the default option is to write those data and this needs to be changed.
  Suitable Products
RH850
Question:
We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause?
Answer:
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
  For the PG-FP6 the default option is to write those data and this needs to be changed.
  Suitable Products
RH850
We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause?
We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause?
We have a programming production line using the E1 programmer.
We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause?
Answer:
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
  For the PG-FP6 the default option is to write those data and this needs to be changed.
  Suitable Products
RH850
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
  For the PG-FP6 the default option is to write those data and this needs to be changed.
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot:
For the PG-FP6 the default option is to write those data and this needs to be changed.
For the PG-FP6 the default option is to write those data and this needs to be changed.
Suitable Products
RH850","['data/categories/rh850_family/rh850_general/3cf13711a6bd31149acc5c5f5f248702/images/09125fd2cf3a331544009492b477e5fc.png', 'data/categories/rh850_family/rh850_general/3cf13711a6bd31149acc5c5f5f248702/images/60d23586801f542a79f7e1a162290526.png']",[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850: Programmer change from E1 to PG-FP6', 'url': 'https://en-support.renesas.com/knowledgeBase/21490047', 'last_updated': None, 'extracted_at': '2025-03-09T00:28:30.258891'}",Question We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause? Answer One thing to check is default programming settings. RFP is using by default the 'minimum' programming that is parts of the Data Flash which are not present in the hex file will not be written. The option for the RFP is the shown in the screen shot For the PG-FP6 the default option is to write those data and this needs to be changed. Suitable Products RH850 We have a programming production line using the E1 programmer. We are trying to move this script to use PG-FP6 programmer instead but all modules programmed with the PF-FP6 is failing on our test. We are using same programming scripts too. What can be the cause? For the PG-FP6 the default option is to write those data and this needs to be changed. Suitable Products,[]
0becf452098654551210915e6bf307b8,"Question:
I am using RH850 device with CS+. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup.
Answer:
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. 
  If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
  With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
    #pragma section r0_disp32 ""NO_INIT_TEST""
  int my_var;
  #pragma section default
  Additionally, sections should be defined on the Linker tab as below.
  Figure 1: Section Settings window
  NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
Suitable Products
RH850
Question:
I am using RH850 device with CS+. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup.
Answer:
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. 
  If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
  With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
    #pragma section r0_disp32 ""NO_INIT_TEST""
  int my_var;
  #pragma section default
  Additionally, sections should be defined on the Linker tab as below.
  Figure 1: Section Settings window
  NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
Suitable Products
RH850
I am using RH850 device with CS+. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup.
I am using RH850 device with CS+. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup.
I am using RH850 device with CS+.
Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup.
Answer:
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. 
  If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
  With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
    #pragma section r0_disp32 ""NO_INIT_TEST""
  int my_var;
  #pragma section default
  Additionally, sections should be defined on the Linker tab as below.
  Figure 1: Section Settings window
  NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
Suitable Products
RH850
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. 
  If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
  With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
    #pragma section r0_disp32 ""NO_INIT_TEST""
  int my_var;
  #pragma section default
  Additionally, sections should be defined on the Linker tab as below.
  Figure 1: Section Settings window
  NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified.
To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified.
If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used.
With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference.
#pragma section r0_disp32 ""NO_INIT_TEST""
#pragma section r0_disp32 ""NO_INIT_TEST""
int my_var;
int my_var;
#pragma section default
#pragma section default
Additionally, sections should be defined on the Linker tab as below.
Additionally, sections should be defined on the Linker tab as below.
Figure 1: Section Settings window
NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
NO_INIT_TEST.data.R and NO_INIT_TEST.bss are the sections inside retention RAM.
Suitable Products
RH850",['data/categories/rh850_family/rh850_general/0becf452098654551210915e6bf307b8/images/b2e5fd14f6b5c407de10b99726bd360b.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850: Prevent variable from updating on software reset', 'url': 'https://en-support.renesas.com/knowledgeBase/21124767', 'last_updated': None, 'extracted_at': '2025-03-09T00:28:57.511121'}","Question I am using RH850 device with CS. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup. Answer To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used. With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference. pragma section r0disp32 ""NOINITTEST"" int myvar; pragma section default Additionally, sections should be defined on the Linker tab as below. Figure 1 Section Settings window NOINITTEST.data.R and NOINITTEST.bss are the sections inside retention RAM. Suitable Products RH850 I am using RH850 device with CS. Is it possible to define a section, which can be used to locate uninitialized variables? An example use-case would be for a variable to be able to preserve its data after a software reset has been undertaken. So, this variable is not cleared or initialized at startup. To store uninitialized variable, you may have to modify the startup-code so that the particular section is not modified. If you are interested in not initializing the RAM on software reset ( or situations like deep sleep) you can try to keep the variables in retention ram area. Apart from PORST the values of the variables are un-affected. But you need to make sure that at startup depending on the reset cause, the variable is not updated in the startup code. To understand the cause for reset RESF register could be used. With respect to startup code, you can make sure that the variable is placed in the required area using the following pragma as reference. pragma section r0disp32 ""NOINITTEST"" int myvar; pragma section default Additionally, sections should be defined on the Linker tab as below. Figure 1 Section Settings window NOINITTEST.data.R and NOINITTEST.bss are the sections inside retention RAM.",[]
dddff4ada4040ac8c679f99c156c51de,"Question:
Where can I find the BSDL and IBIS files for RH850 devices
Answer:
The BSDL and IBIS files for RH850 devices are now available on the website.
    Step 1: Go to the product landing page of the device family.
Figure 1: Product Landing page RH850/F1KM-S1
    Step 2: One the page click on the Design& Development section
Figure 2: Design & Development tab
    Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
Suitable Products
RH850
Question:
Where can I find the BSDL and IBIS files for RH850 devices
Answer:
The BSDL and IBIS files for RH850 devices are now available on the website.
    Step 1: Go to the product landing page of the device family.
Figure 1: Product Landing page RH850/F1KM-S1
    Step 2: One the page click on the Design& Development section
Figure 2: Design & Development tab
    Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
Suitable Products
RH850
Where can I find the BSDL and IBIS files for RH850 devices
Where can I find the BSDL and IBIS files for RH850 devices
Where can I find the BSDL and IBIS files for RH850 devices
Answer:
The BSDL and IBIS files for RH850 devices are now available on the website.
    Step 1: Go to the product landing page of the device family.
Figure 1: Product Landing page RH850/F1KM-S1
    Step 2: One the page click on the Design& Development section
Figure 2: Design & Development tab
    Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
Suitable Products
RH850
The BSDL and IBIS files for RH850 devices are now available on the website.
    Step 1: Go to the product landing page of the device family.
Figure 1: Product Landing page RH850/F1KM-S1
    Step 2: One the page click on the Design& Development section
Figure 2: Design & Development tab
    Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
The BSDL and IBIS files for RH850 devices are now available on the website.
The BSDL and IBIS files for RH850 devices are now available on the website.
Step 1: Go to the product landing page of the device family.
Step 1: Go to the product landing page of the device family.
Figure 1: Product Landing page RH850/F1KM-S1
Step 2: One the page click on the Design& Development section
Step 2: One the page click on the Design& Development section
Figure 2: Design & Development tab
Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
Step 3: Under the Modes tab, you can see both BSDL files and IBIS files.
Suitable Products
RH850","['data/categories/rh850_family/rh850_general/dddff4ada4040ac8c679f99c156c51de/images/91891e9d00ffaaa483d7b98010f595ec.png', 'data/categories/rh850_family/rh850_general/dddff4ada4040ac8c679f99c156c51de/images/c39197eebde2e332712e54241889980d.png']",[],['|  |\n|  |\n| RH850 |'],"{'title': 'BSDL and IBIS files for RH850 devices', 'url': 'https://en-support.renesas.com/knowledgeBase/21124706', 'last_updated': None, 'extracted_at': '2025-03-09T00:29:04.718843'}","Question Where can I find the BSDL and IBIS files for RH850 devices Answer The BSDL and IBIS files for RH850 devices are now available on the website. Step 1 Go to the product landing page of the device family. Figure 1 Product Landing page RH850/F1KM-S1 Step 2 One the page click on the Design Development section Figure 2 Design  Development tab Step 3 Under the Modes tab, you can see both BSDL files and IBIS files. Suitable Products RH850 Step 1 Go to the product landing page of the device family. Step 2 One the page click on the Design Development section Step 3 Under the Modes tab, you can see both BSDL files and IBIS files.",[]
67f32524284fb38b192efcfaebf9a1e0,"Question:
We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue.
can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know.
Answer:
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
  If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
Suitable Products
RH850
Question:
We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue.
can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know.
Answer:
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
  If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
Suitable Products
RH850
We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue.
can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know.
We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue.
We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue.
can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know.
can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know.
Answer:
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
  If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
Suitable Products
RH850
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
  If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs.  If you have manually changed it before, you may have to use the new value.
If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
If you have forgotten the security ID, you may try to use
Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.
Suitable Products
RH850",['data/categories/rh850_family/rh850_general/67f32524284fb38b192efcfaebf9a1e0/images/3412fe575648e0769784f9cd4b7c261b.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850: GHS Code Flash security ID is not specified.', 'url': 'https://en-support.renesas.com/knowledgeBase/21153491', 'last_updated': None, 'extracted_at': '2025-03-09T00:29:14.713533'}","Question We are working on RH850-P1MC controller using GHS compiler and E1 emulator. when we tried connecting with target board, we are facing an -cfapw security issue. can you please let us know the way to get out of this and successfully download on target. attached you the issue screenshot check it and let us know. Answer The error shown occurs when there is a mismatch in the security ID. Please use the Security ID used before to program again. MCUs from Renesas factory by default have the authentication ID set to all 0xFFs. If you have manually changed it before, you may have to use the new value. If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that. Suitable Products RH850 If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that. If you have forgotten the security ID, you may try to use Renesas RFP (Renesas Flash Programmer) to connect to the device and perform code flash erase or reset the security ID using Renesas Flash Programmer for Devices like RH850 P1x-C where the debug ID is not part of code flash, but in the configuration area. Please try to program and debug the device after that.",[]
cd824a26233e5724b09e9622882ed837,"Question:
We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting.
Answer:
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
Figure 1: List of security settings data


In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable.
Suitable Products
RH850
Question:
We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting.
Answer:
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
Figure 1: List of security settings data


In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable.
Suitable Products
RH850
We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting.
We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting.
We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting.
Answer:
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
Figure 1: List of security settings data


In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable.
Suitable Products
RH850
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
Figure 1: List of security settings data


In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable.
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available.
Figure 1: List of security settings data
In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable.
Suitable Products
RH850",['data/categories/rh850_family/rh850_general/cd824a26233e5724b09e9622882ed837/images/5ea00ef8458b56aeed4d2a5dd6a66433.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850: Is Security Settings reversible?', 'url': 'https://en-support.renesas.com/knowledgeBase/21130250', 'last_updated': None, 'extracted_at': '2025-03-09T00:29:17.612966'}","Question We are disabling Serial programming by using the serial programming connection disabled option which is part of Security Settings of RH850KMS1. Not sure why it is not possible to revert this setting. Answer The security function area can be used to configure different security functions of the device. See Figure 1 to understand the options available. Figure 1 List of security settings data In the above Settings list, 'Serial Programming Disable' and the 'Block Erase Disable' cannot be reversed. The other settings, like 'Read Disable' can be reversed via the serial programming interface. There is a dedicated command called configuration clear which allows this. This command will be executed by the RFP if the 'Erase Chip' option is selected. The two mentioned protection cannot be removed, as the configuration clear requires the serial programming interface and a successful erase to be executable. Suitable Products RH850",[]
621270c94bee070308c576d4b9bcc6b7,"Question:
What is the difference between R7F7010183AFP#KA4 and R7F7010183AFP#AA4? Are they interchangeable? What does the suffix mean?
Answer:
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The #xAx refers to Pb-free / Sn plating.
The #xx4 refers to silicon revision 4
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
Suitable Products
RH850
Question:
What is the difference between R7F7010183AFP#KA4 and R7F7010183AFP#AA4? Are they interchangeable? What does the suffix mean?
Answer:
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The #xAx refers to Pb-free / Sn plating.
The #xx4 refers to silicon revision 4
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
Suitable Products
RH850
What is the difference between R7F7010183AFP#KA4 and R7F7010183AFP#AA4? Are they interchangeable? What does the suffix mean?
What is the difference between R7F7010183AFP#KA4 and R7F7010183AFP#AA4? Are they interchangeable? What does the suffix mean?
What is the difference between
R7F7010183AFP#KA4 and R7F7010183AFP#AA4? Are they interchangeable?
What does the suffix mean?
Answer:
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The #xAx refers to Pb-free / Sn plating.
The #xx4 refers to silicon revision 4
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
Suitable Products
RH850
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The #xAx refers to Pb-free / Sn plating.
The #xx4 refers to silicon revision 4
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The P/N suffix #Axx refers to tray, #Kxx is tape & reel.
The #xAx refers to Pb-free / Sn plating.
The #xAx refers to Pb-free / Sn plating.
The #xx4 refers to silicon revision 4
The #xx4 refers to silicon revision 4
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery.
Suitable Products
RH850",['data/categories/rh850_family/rh850_general/621270c94bee070308c576d4b9bcc6b7/images/985a524ae5c63a1c1e3d50c28c145584.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850 part number suffix', 'url': 'https://en-support.renesas.com/knowledgeBase/21153494', 'last_updated': None, 'extracted_at': '2025-03-09T00:29:29.861265'}","Question What is the difference between R7F7010183AFPKA4 and R7F7010183AFPAA4? Are they interchangeable? What does the suffix mean? Answer The P/N suffix Axx refers to tray, Kxx is tape  reel. The xAx refers to Pb-free / Sn plating. The xx4 refers to silicon revision 4 The suffix at the end has nothing to do with the electrical properties of the parts but only how the samples are packaged differently for delivery. Suitable Products RH850 What is the difference between R7F7010183AFPKA4 and R7F7010183AFPAA4? Are they interchangeable? What does the suffix mean?",[]
37f0da015a74510a0e8d600cb61be3b8,"Question:
Unable to connect the E2 to MCU RH850 U2A16 using Renesas Flash Programmer
I see the error (E3000105): The device is not responding when I am tryng connect the debugger using Renesas Flash Programmer.
And when I try with CS+ I found this error Set the SVR parameter (E0617024)
Answer:
Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device.
Suitable Products
RH850
Unable to connect the E2 to MCU RH850 U2A16 using Renesas Flash Programmer
I see the error (E3000105): The device is not responding when I am tryng connect the debugger using Renesas Flash Programmer.
And when I try with CS+ I found this error Set the SVR parameter (E0617024)
Unable to connect the E2 to MCU RH850 U2A16 using Renesas Flash Programmer
I see the error (E3000105): The device is not responding when I am tryng connect the debugger using Renesas Flash Programmer.
Unable to connect the E2 to MCU RH850 U2A16 using Renesas Flash Programmer
I see the error (E3000105): The device is not responding when I am tryng connect the debugger using Renesas Flash Programmer.
And when I try with CS+ I found this error Set the SVR parameter (E0617024)
And when I try with CS+ I found this error Set the SVR parameter (E0617024)
Answer:
Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device.
Suitable Products
RH850
Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device.
Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device.
Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device.
Suitable Products
RH850",['data/categories/rh850_family/rh850u2a/37f0da015a74510a0e8d600cb61be3b8/images/f273ab6a6e14ea080c010b8041f75572.png'],[],['|  |\n|  |\n| RH850 |'],"{'title': 'RH850 U2A SVR parameter error', 'url': 'https://en-support.renesas.com/knowledgeBase/21671339', 'last_updated': '2024-07-11', 'extracted_at': '2025-03-09T00:28:11.964430'}",Question Unable to connect the E2 to MCU RH850 U2A16 using Renesas Flash Programmer I see the error (E3000105) The device is not responding when I am tryng connect the debugger using Renesas Flash Programmer. And when I try with CS I found this error Set the SVR parameter (E0617024) Answer Try disabling the Set SVR Parameter option on the debug tool connect settings option and see if you are able to connect to the device. Suitable Products RH850,
6f6d3177d8b7687637ccd6111f8a6e45,"In some cases it is required inside the application to change the SCI_UART parameters runtime. Users can do this in FSP by declaring a new configuration structure variable, that will contain the new desired settings and then re-initialize UART with the new settings. This should be done of course after de-initializing the UART before.
In some cases it is required inside the application to change the SCI_UART parameters runtime. Users can do this in FSP by declaring a new configuration structure variable, that will contain the new desired settings and then re-initialize UART with the new settings. This should be done of course after de-initializing the UART before.
The code inside the application should look like this:
The code inside the application should look like this:
As example, a project developed in FSP 5.6.0 and EK-RA6M3 is attached in which the UART channel is changed runtime, by using only one UART instance in the application project.
As example, a project developed in FSP 5.6.0 and EK-RA6M3 is attached in which the UART channel is changed runtime, by using only one UART instance in the application project.
With the same way a new configuration structure is declared to hold the new configurations for SCI9. And inside the project as soon as UART instance is de-initialized for SCI0 by calling the close() API, the UART instance re-initializes by calling the open() API and passing now as second argument a pointer to the new configuration structure containing the new settings.
With the same way a new configuration structure is declared to hold the new configurations for SCI9. And inside the project as soon as UART instance is de-initialized for SCI0 by calling the close() API, the UART instance re-initializes by calling the open() API and passing now as second argument a pointer to the new configuration structure containing the new settings.
To change UART channel runtime and use only one instance it is also important to add in Interrupts Tab these events related with these interrupts, so that UART peripheral will work properly.
To change UART channel runtime and use only one instance it is also important to add in Interrupts Tab these events related with these interrupts, so that UART peripheral will work properly.
And the example is initially transmitting 10 test messages through UART SCI0 (Pins:TXD:P411,RXD:P410) and the rest of the messages are transmitted through UART SCI9 (Pins: TXD:P203, RXD:P202).
And the example is initially transmitting 10 test messages through UART SCI0 (Pins:TXD:P411,RXD:P410) and the rest of the messages are transmitted through UART SCI9 (Pins: TXD:P203, RXD:P202).
For further details check the project sci_uart_change_parameters_runtime.zip attached.
For further details check the project sci_uart_change_parameters_runtime.zip attached.
Suitable Products
Suitable Products
RA Family, FSP
RA Family, FSP","['data/categories/ra_family/rafsp_software/6f6d3177d8b7687637ccd6111f8a6e45/images/d4396d5c501a2cc392d19f63ead65e46.png', 'data/categories/ra_family/rafsp_software/6f6d3177d8b7687637ccd6111f8a6e45/images/f8674810b4b278e8c70e8208754d1f92.png']",[],[],"{'title': 'RA Family: How to change SCI_UART parameters runtime-FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/21690669', 'last_updated': None, 'extracted_at': '2025-03-08T23:16:28.204358'}","In some cases it is required inside the application to change the SCIUART parameters runtime. Users can do this in FSP by declaring a new configuration structure variable, that will contain the new desired settings and then re-initialize UART with the new settings. This should be done of course after de-initializing the UART before. The code inside the application should look like this As example, a project developed in FSP 5.6.0 and EK-RA6M3 is attached in which the UART channel is changed runtime, by using only one UART instance in the application project. With the same way a new configuration structure is declared to hold the new configurations for SCI9. And inside the project as soon as UART instance is de-initialized for SCI0 by calling the close() API, the UART instance re-initializes by calling the open() API and passing now as second argument a pointer to the new configuration structure containing the new settings. To change UART channel runtime and use only one instance it is also important to add in Interrupts Tab these events related with these interrupts, so that UART peripheral will work properly. And the example is initially transmitting 10 test messages through UART SCI0 (PinsTXDP411,RXDP410) and the rest of the messages are transmitted through UART SCI9 (Pins TXDP203, RXDP202). For further details check the project sciuartchangeparametersruntime.zip attached. Suitable Products RA Family, FSP",
f756c4e1bf322ed1671fe4c62478b884,"Question:
On customized boards and on newer versions of FSP, where external clock source for sub-clock is not setup the project gets stuck on FSP_HARDWARE_REGISTER_WAIT(R_RTC->RCR2_b.RESET, 0);
Answer:
Set the 'Subclock Populated' value to 'Not populated on BSP settings on FSP configurator.
  Suitable Products
RA Family
On customized boards and on newer versions of FSP, where external clock source for sub-clock is not setup the project gets stuck on FSP_HARDWARE_REGISTER_WAIT(R_RTC->RCR2_b.RESET, 0);
On customized boards and on newer versions of FSP, where external clock source for sub-clock is not setup the project gets stuck on FSP_HARDWARE_REGISTER_WAIT(R_RTC->RCR2_b.RESET, 0);
On customized boards and on newer versions of FSP, where external clock source for sub-clock is not setup the project gets stuck on FSP_HARDWARE_REGISTER_WAIT(R_RTC->RCR2_b.RESET, 0);
Answer:
Set the 'Subclock Populated' value to 'Not populated on BSP settings on FSP configurator.
  Suitable Products
RA Family
Set the 'Subclock Populated' value to 'Not populated on BSP settings on FSP configurator.
Set the 'Subclock Populated' value to 'Not populated on BSP settings on FSP configurator.
Set the 'Subclock Populated' value to 'Not populated on BSP settings on FSP configurator.
Suitable Products
RA Family
 

",['data/categories/ra_family/rafsp_software/f756c4e1bf322ed1671fe4c62478b884/images/58bc226fe0c51f5efb99e339049be97b.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'SubClock configuration during FSP for customized boards for RA Family', 'url': 'https://en-support.renesas.com/knowledgeBase/21094268', 'last_updated': '2023-12-10', 'extracted_at': '2025-03-08T23:17:07.705393'}","Question On customized boards and on newer versions of FSP, where external clock source for sub-clock is not setup the project gets stuck on FSPHARDWAREREGISTERWAIT(RRTC-RCR2b.RESET, 0); Answer Set the 'Subclock Populated' value to 'Not populated on BSP settings on FSP configurator. Suitable Products RA Family Suitable Products    ",
0b8504a5b9dc96d02b4177eb55cef291,"During debug it is sometimes useful to capture a time delay between two different debug events. Measuring the delay between two breakpoints, for example, can help identify processing bottlenecks. In e2 studio you can use the DWT report to see the delay in time as well as in clock cycles.
The DWT report needs to know the CPU frequency, so this needs to be set in the debug configuration.
Make sure this frequency reflects the operating frequency of the MCU during debug.
Once this is set, simply use the DWT report, shown at information ribbon at the bottom of the e2 studio window.
Suitable Products
e2 studio
e2 studio
e2 studio","['data/categories/ra_family/rafsp_software/0b8504a5b9dc96d02b4177eb55cef291/images/1ee8a36e62fdc2ca001e67e138bb6d26.png', 'data/categories/ra_family/rafsp_software/0b8504a5b9dc96d02b4177eb55cef291/images/2c3fb4bb7d153b86cae83cba754ac1a2.png']",[],['|  |\n|  |\n| e2 studio |'],"{'title': 'RA Family: Measure Time Interval Between Debug Events in e2 studio', 'url': 'https://en-support.renesas.com/knowledgeBase/19575558', 'last_updated': None, 'extracted_at': '2025-03-08T23:16:07.690627'}","During debug it is sometimes useful to capture a time delay between two different debug events. Measuring the delay between two breakpoints, for example, can help identify processing bottlenecks. In e2 studio you can use the DWT report to see the delay in time as well as in clock cycles. The DWT report needs to know the CPU frequency, so this needs to be set in the debug configuration. Make sure this frequency reflects the operating frequency of the MCU during debug. Once this is set, simply use the DWT report, shown at information ribbon at the bottom of the e2 studio window. Suitable Products e2 studio",
1a335228fcd63ba0f4b90bdb286989ba,"Question:
How to change the settings in FreeRTOSConfig.h ?
Answer:
The FreeRTOS settings defined in FreeRTOSConfig.h can be changed in the thread properties as shown below. If you would like to add any additional macros to the FreeRTOSConfig.h file then add them to a new file and add that file to the ""Custom FreeRTOSConfig.h"" parameter in the configurator.
  Suitable Products
RA/FSP
How to change the settings in FreeRTOSConfig.h ?
How to change the settings in FreeRTOSConfig.h ?
Answer:
The FreeRTOS settings defined in FreeRTOSConfig.h can be changed in the thread properties as shown below. If you would like to add any additional macros to the FreeRTOSConfig.h file then add them to a new file and add that file to the ""Custom FreeRTOSConfig.h"" parameter in the configurator.
  Suitable Products
RA/FSP
The FreeRTOS settings defined in FreeRTOSConfig.h can be changed in the thread properties as shown below. If you would like to add any additional macros to the FreeRTOSConfig.h file then add them to a new file and add that file to the ""Custom FreeRTOSConfig.h"" parameter in the configurator.
The FreeRTOS settings defined in FreeRTOSConfig.h can be changed in the thread properties as shown below. If you would like to add any additional macros to the FreeRTOSConfig.h file then add them to a new file and add that file to the ""Custom FreeRTOSConfig.h"" parameter in the configurator.
Suitable Products
RA/FSP",['data/categories/ra_family/ra_hardware/1a335228fcd63ba0f4b90bdb286989ba/images/e8ec4e0b15b0412b79cd4a38091dbb77.png'],[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'RA Family: How to change the settings in FreeRTOSConfig.h ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21177411', 'last_updated': None, 'extracted_at': '2025-03-08T23:14:14.612953'}","Question How to change the settings in FreeRTOSConfig.h ? Answer The FreeRTOS settings defined in FreeRTOSConfig.h can be changed in the thread properties as shown below. If you would like to add any additional macros to the FreeRTOSConfig.h file then add them to a new file and add that file to the ""Custom FreeRTOSConfig.h"" parameter in the configurator. Suitable Products RA/FSP Suitable Products",
1a278ce457f18fabab435b5c64477aab,"How to handle the MD pin, when using E2 or E2 Lite emulators on a custom RA2 board?
The RA2 devices use a Cortex-M23 core and they do not support DLM transitions or Trustzone. So, there is no need to connect the MD pin to SWCLK/TCK/MD in order to be able to drive it to low to change the device lifecycle state or set the TrustZone Boundaries.
Also the MD pin is by default pulled-up, since the initial value of PFS register for P201 is 0x00000010 which means that PCR bit is set to 1.
And there is no need to add also an external pull-up resistor.
In case you want to place the MCU to SCI boot mode (the MD pin needs to be driven low) the recommended circuit for MD pin is:
Open-circuit: MD pin (P201) is high level and the MCU is in Single-chip mode (for debugging).
Short-Circuit: MD pin (P201) is low level and MCU will enter SCI boot mode after reset state (#RES pin released).
Resources:
RA2E1 Group User's Manual: Hardware
RA2L1 Group User's Manual: Hardware
RA2E2 Group User's Manual: Hardware
RA2A1 Group User's Manual: Hardware
RA2E3 Group User's Manual: Hardware
RA2A2 Group User's Manual: Hardware
E2 Emulator, E2 Emulator Lite Additional Document for Users Manual (Notes on Connection of RA Devices)
Suitable Products
RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2
RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2","['data/categories/ra_family/ra_hardware/1a278ce457f18fabab435b5c64477aab/images/660acab83bb2e3e7b33dbf64ae4daa1c.png', 'data/categories/ra_family/ra_hardware/1a278ce457f18fabab435b5c64477aab/images/d42c2b1ec85e8abccf4dda62110b7c83.png', 'data/categories/ra_family/ra_hardware/1a278ce457f18fabab435b5c64477aab/images/65700b0b2b0d955c40e99cea7a5bea94.png']",[],[],"{'title': 'How to handle the MD pin, when using E2 or E2 Lite emulators on a custom RA2 board?', 'url': 'https://en-support.renesas.com/knowledgeBase/21671697', 'last_updated': None, 'extracted_at': '2025-03-08T23:14:03.238606'}","How to handle the MD pin, when using E2 or E2 Lite emulators on a custom RA2 board? The RA2 devices use a Cortex-M23 core and they do not support DLM transitions or Trustzone. So, there is no need to connect the MD pin to SWCLK/TCK/MD in order to be able to drive it to low to change the device lifecycle state or set the TrustZone Boundaries. Also the MD pin is by default pulled-up, since the initial value of PFS register for P201 is 0x00000010 which means that PCR bit is set to 1. And there is no need to add also an external pull-up resistor. In case you want to place the MCU to SCI boot mode (the MD pin needs to be driven low) the recommended circuit for MD pin is Open-circuit MD pin (P201) is high level and the MCU is in Single-chip mode (for debugging). Short-Circuit MD pin (P201) is low level and MCU will enter SCI boot mode after reset state (RES pin released). Resources RA2E1 Group User's Manual Hardware RA2L1 Group User's Manual Hardware RA2E2 Group User's Manual Hardware RA2A1 Group User's Manual Hardware RA2E3 Group User's Manual Hardware RA2A2 Group User's Manual Hardware E2 Emulator, E2 Emulator Lite Additional Document for Users Manual (Notes on Connection of RA Devices) Suitable Products RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2",
2bed78d04899c936b6e2e1aa93932a2b,"Question:
CPU Performance Difference when C-/S-caches are on/off
Answer:
For Renesas Cortex-M33 RA6M4 and RA6M5 MCUs, there are system level caches for both instruction cache and data cache, which help to improve instruction and data fetch speed. The data cache is named S-Cache in the Renesas RA6M4/RA6M5 MCU Hardware Users Manual, and its on the MCUs system bus. The instruction cache is named C-Cache, and its on the code bus. The Cache detail specifications, which includes Capacity, Way, Line Size, Write Way, Cache Support Area, etc., can be found through the Renesas RA6M4/RA6M5 MCU Hardware Users Manual Table 14.9. Basically, this article briefly showcases how the RA6M4 or RA6M5 CPU performance is influenced based on different combinations of C-cache, and S-cache configuration. The relevant information about benchmark testing conditions as well as the result comparison is described below.
The environment of Benchmark testing:
MCU and the runtime environment initialization (SystemInit) is based on FSPv5.0.0
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize More)
System Clock configuration: ICLK=200MHz
Board: EK-RA6M4
The first method of CPU performance measurement:
A simple For loop with accumulation operation
Toggling GPIO before and after the calculation


The CPU process time measurement from output level change:
Config Option S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 820us
2 Disable Enable Enable 1.47ms
3 Disable Disable*1 Enable 2.46ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
According to the above result, enabling the S-Cache can significantly improve MCU performance because the measured operation basically focuses on the SRAM write access. When the S-Cache is enabled, the access cycle of SRAM write is reduced from 2 cycles to 1 cycle. Especially if the system clock ICLK is configured to 100MHz or less, accessing SRAM is always 0 wait state. At such condition, enabling the S-Cache to reduce the required cycle of SRAM write access can obviously improve the performance.
The second method of CPU performance measurement:
Fixed point iteration method for locating the real roots of an equation within a specified iteration cycle
Toggling GPIO before and after the calculation

The CPU process time measurement from output level change:
  S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 3.125ms
2 Disable Enable Enable 3.81ms
3 Disable Disable*1 Enable 6.97ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
For this measured operation, enabling the C-Cache, which reduces the required access cycle of instruction fetch, can significantly improve the MCU performance. When the C-cache is enabled and the cacheable access is from CPU, the read access is one cycle if C-cache is hit. For the C-Cache is missed while C-Cache operation is enabled, or C-cache is disabled, the read access is three cycles.
Reference Attachments:
Example project on EK-RA6M4 for above benchmark testing (below)
Example project on EK-RA6M5 for above benchmark testing (below)
Suitable Products
RA6M4, RA6M5
CPU Performance Difference when C-/S-caches are on/off
CPU Performance Difference when C-/S-caches are on/off
Answer:
For Renesas Cortex-M33 RA6M4 and RA6M5 MCUs, there are system level caches for both instruction cache and data cache, which help to improve instruction and data fetch speed. The data cache is named S-Cache in the Renesas RA6M4/RA6M5 MCU Hardware Users Manual, and its on the MCUs system bus. The instruction cache is named C-Cache, and its on the code bus. The Cache detail specifications, which includes Capacity, Way, Line Size, Write Way, Cache Support Area, etc., can be found through the Renesas RA6M4/RA6M5 MCU Hardware Users Manual Table 14.9. Basically, this article briefly showcases how the RA6M4 or RA6M5 CPU performance is influenced based on different combinations of C-cache, and S-cache configuration. The relevant information about benchmark testing conditions as well as the result comparison is described below.
The environment of Benchmark testing:
MCU and the runtime environment initialization (SystemInit) is based on FSPv5.0.0
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize More)
System Clock configuration: ICLK=200MHz
Board: EK-RA6M4
The first method of CPU performance measurement:
A simple For loop with accumulation operation
Toggling GPIO before and after the calculation


The CPU process time measurement from output level change:
Config Option S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 820us
2 Disable Enable Enable 1.47ms
3 Disable Disable*1 Enable 2.46ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
According to the above result, enabling the S-Cache can significantly improve MCU performance because the measured operation basically focuses on the SRAM write access. When the S-Cache is enabled, the access cycle of SRAM write is reduced from 2 cycles to 1 cycle. Especially if the system clock ICLK is configured to 100MHz or less, accessing SRAM is always 0 wait state. At such condition, enabling the S-Cache to reduce the required cycle of SRAM write access can obviously improve the performance.
The second method of CPU performance measurement:
Fixed point iteration method for locating the real roots of an equation within a specified iteration cycle
Toggling GPIO before and after the calculation

The CPU process time measurement from output level change:
  S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 3.125ms
2 Disable Enable Enable 3.81ms
3 Disable Disable*1 Enable 6.97ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
For this measured operation, enabling the C-Cache, which reduces the required access cycle of instruction fetch, can significantly improve the MCU performance. When the C-cache is enabled and the cacheable access is from CPU, the read access is one cycle if C-cache is hit. For the C-Cache is missed while C-Cache operation is enabled, or C-cache is disabled, the read access is three cycles.
Reference Attachments:
Example project on EK-RA6M4 for above benchmark testing (below)
Example project on EK-RA6M5 for above benchmark testing (below)
Suitable Products
RA6M4, RA6M5
For Renesas Cortex-M33 RA6M4 and RA6M5 MCUs, there are system level caches for both instruction cache and data cache, which help to improve instruction and data fetch speed. The data cache is named S-Cache in the Renesas RA6M4/RA6M5 MCU Hardware Users Manual, and its on the MCUs system bus. The instruction cache is named C-Cache, and its on the code bus. The Cache detail specifications, which includes Capacity, Way, Line Size, Write Way, Cache Support Area, etc., can be found through the Renesas RA6M4/RA6M5 MCU Hardware Users Manual Table 14.9. Basically, this article briefly showcases how the RA6M4 or RA6M5 CPU performance is influenced based on different combinations of C-cache, and S-cache configuration. The relevant information about benchmark testing conditions as well as the result comparison is described below.
The environment of Benchmark testing:
MCU and the runtime environment initialization (SystemInit) is based on FSPv5.0.0
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize More)
System Clock configuration: ICLK=200MHz
Board: EK-RA6M4
The first method of CPU performance measurement:
A simple For loop with accumulation operation
Toggling GPIO before and after the calculation


The CPU process time measurement from output level change:
Config Option S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 820us
2 Disable Enable Enable 1.47ms
3 Disable Disable*1 Enable 2.46ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
According to the above result, enabling the S-Cache can significantly improve MCU performance because the measured operation basically focuses on the SRAM write access. When the S-Cache is enabled, the access cycle of SRAM write is reduced from 2 cycles to 1 cycle. Especially if the system clock ICLK is configured to 100MHz or less, accessing SRAM is always 0 wait state. At such condition, enabling the S-Cache to reduce the required cycle of SRAM write access can obviously improve the performance.
The second method of CPU performance measurement:
Fixed point iteration method for locating the real roots of an equation within a specified iteration cycle
Toggling GPIO before and after the calculation

The CPU process time measurement from output level change:
  S-Cache control C-Cache control F-Cache control Process time
1 Enable*1 Enable Enable 3.125ms
2 Disable Enable Enable 3.81ms
3 Disable Disable*1 Enable 6.97ms
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
For this measured operation, enabling the C-Cache, which reduces the required access cycle of instruction fetch, can significantly improve the MCU performance. When the C-cache is enabled and the cacheable access is from CPU, the read access is one cycle if C-cache is hit. For the C-Cache is missed while C-Cache operation is enabled, or C-cache is disabled, the read access is three cycles.
Reference Attachments:
Example project on EK-RA6M4 for above benchmark testing (below)
Example project on EK-RA6M5 for above benchmark testing (below)
For Renesas Cortex-M33 RA6M4 and RA6M5 MCUs, there are system level caches for both instruction cache and data cache, which help to improve instruction and data fetch speed. The data cache is named S-Cache in the Renesas RA6M4/RA6M5 MCU Hardware Users Manual, and its on the MCUs system bus. The instruction cache is named C-Cache, and its on the code bus. The Cache detail specifications, which includes Capacity, Way, Line Size, Write Way, Cache Support Area, etc., can be found through the Renesas RA6M4/RA6M5 MCU Hardware Users Manual Table 14.9. Basically, this article briefly showcases how the RA6M4 or RA6M5 CPU performance is influenced based on different combinations of C-cache, and S-cache configuration. The relevant information about benchmark testing conditions as well as the result comparison is described below.
The environment of Benchmark testing:
The first method of CPU performance measurement:
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
According to the above result, enabling the S-Cache can significantly improve MCU performance because the measured operation basically focuses on the SRAM write access. When the S-Cache is enabled, the access cycle of SRAM write is reduced from 2 cycles to 1 cycle. Especially if the system clock ICLK is configured to 100MHz or less, accessing SRAM is always 0 wait state. At such condition, enabling the S-Cache to reduce the required cycle of SRAM write access can obviously improve the performance.
The second method of CPU performance measurement:
Note1: Change at the beginning of the application. Others are default setting after FSP SystemInit.
For this measured operation, enabling the C-Cache, which reduces the required access cycle of instruction fetch, can significantly improve the MCU performance. When the C-cache is enabled and the cacheable access is from CPU, the read access is one cycle if C-cache is hit. For the C-Cache is missed while C-Cache operation is enabled, or C-cache is disabled, the read access is three cycles.
Reference Attachments:
Suitable Products
RA6M4, RA6M5","['data/categories/ra_family/ra_hardware/2bed78d04899c936b6e2e1aa93932a2b/images/ccc102eeb158ae50086aaf6f534cdff2.png', 'data/categories/ra_family/ra_hardware/2bed78d04899c936b6e2e1aa93932a2b/images/7c8e9f9013a637dafa927d9060c959ca.png', 'data/categories/ra_family/ra_hardware/2bed78d04899c936b6e2e1aa93932a2b/images/53b450079879257082d5f3e6107402c6.jpg']",[],"['|  |\n|  |\n| Config Option | S-Cache control | C-Cache control | F-Cache control | Process time |\n| 1 | Enable*1 | Enable | Enable | 820us |\n| 2 | Disable | Enable | Enable | 1.47ms |\n| 3 | Disable | Disable*1 | Enable | 2.46ms |', '|  |\n|  |\n|  | S-Cache control | C-Cache control | F-Cache control | Process time |\n| 1 | Enable*1 | Enable | Enable | 3.125ms |\n| 2 | Disable | Enable | Enable | 3.81ms |\n| 3 | Disable | Disable*1 | Enable | 6.97ms |', '|  |\n|  |\n| RA6M4, RA6M5 |']","{'title': 'RA6M4/RA6M5: CPU Performance Difference when C-/S-caches are on/off', 'url': 'https://en-support.renesas.com/knowledgeBase/21177407', 'last_updated': None, 'extracted_at': '2025-03-08T23:14:18.098153'}","Question CPU Performance Difference when C-/S-caches are on/off Answer For Renesas Cortex-M33 RA6M4 and RA6M5 MCUs, there are system level caches for both instruction cache and data cache, which help to improve instruction and data fetch speed. The data cache is named S-Cache in the Renesas RA6M4/RA6M5 MCU Hardware Users Manual, and its on the MCUs system bus. The instruction cache is named C-Cache, and its on the code bus. The Cache detail specifications, which includes Capacity, Way, Line Size, Write Way, Cache Support Area, etc., can be found through the Renesas RA6M4/RA6M5 MCU Hardware Users Manual Table 14.9. Basically, this article briefly showcases how the RA6M4 or RA6M5 CPU performance is influenced based on different combinations of C-cache, and S-cache configuration. The relevant information about benchmark testing conditions as well as the result comparison is described below. The environment of Benchmark testing MCU and the runtime environment initialization (SystemInit) is based on FSPv5.0.0 Compiler GCC10.3.1 Compiler Optimization Level O2 (Optimize More) System Clock configuration ICLK200MHz Board EK-RA6M4 The first method of CPU performance measurement A simple For loop with accumulation operation Toggling GPIO before and after the calculation The CPU process time measurement from output level change Config Option S-Cache control C-Cache control F-Cache control Process time 1 Enable1 Enable Enable 820us 2 Disable Enable Enable 1.47ms 3 Disable Disable1 Enable 2.46ms Note1 Change at the beginning of the application. Others are default setting after FSP SystemInit. According to the above result, enabling the S-Cache can significantly improve MCU performance because the measured operation basically focuses on the SRAM write access. When the S-Cache is enabled, the access cycle of SRAM write is reduced from 2 cycles to 1 cycle. Especially if the system clock ICLK is configured to 100MHz or less, accessing SRAM is always 0 wait state. At such condition, enabling the S-Cache to reduce the required cycle of SRAM write access can obviously improve the performance. The second method of CPU performance measurement Fixed point iteration method for locating the real roots of an equation within a specified iteration cycle S-Cache control C-Cache control F-Cache control Process time 1 Enable1 Enable Enable 3.125ms 2 Disable Enable Enable 3.81ms 3 Disable Disable1 Enable 6.97ms For this measured operation, enabling the C-Cache, which reduces the required access cycle of instruction fetch, can significantly improve the MCU performance. When the C-cache is enabled and the cacheable access is from CPU, the read access is one cycle if C-cache is hit. For the C-Cache is missed while C-Cache operation is enabled, or C-cache is disabled, the read access is three cycles. Reference Attachments Example project on EK-RA6M4 for above benchmark testing (below) Example project on EK-RA6M5 for above benchmark testing (below) Suitable Products RA6M4, RA6M5",
c4c4ce18c55c3d890ac5327a7d635d14,"Answer:
The RA6T2 General PWM Timer (GPT) supports Complementary the PWM mode, which can generate a three-phase PWM waveform with dead time and ensure the linearity in the vicinity of duty 0% and 100%. Therefore, this article takes Complementary PWM mode 3 (transfer at both crests and troughs) as an example to illustrate how to enable this operating mode based upon the FSP General PWM Timer Driver* (r_gpt).
*As Complementary PWM operating mode is not generally supported by other RA MCU General PWM Timer (GPT) peripheral, the configuration of FSP General PWM Timer Driver (r_gpt) does not support it as default.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output:
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.
  Step 1: Create a Renesas RA C/C++ Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective.
From the toolbar of e2studio, select File > New > RA C/C++ Project > Renesas RA
Flat (Non-TrustZone) Project is selected
RTOS selection is No RTOS.
Bare Metal (Minimal) is selected.
Step 2: In the Stacks option of FSP configuration window, first we add Three-Phase PWM module (r_gpt_three_phase) in the HAL/Common Stacks. The Three-Phase PWM module can be found under the Timer category.
New Stack > Timers > Three-Phase PWM (r_gpt_three_phase)
  Step 3: After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers.
Select one of the r_gpt modules and configure Pin Output Support property to Enabled with Extra Features
Step 4: Configure Three-Phase PWM module (r_gpt_three_phase) with the settings below. The default value of other properties is kept.
General > Period: 10
General > Period Unit: Kilohertz
General > GPT U-Channel: 4
General > GPT V-Channel: 5
General > GPT W-Channel: 6
Extra Features > Dead Time > Dead Time Count Up (Raw Counts): 240
In complementary PWM mode, the GTDVD register is invalid and the GTDVU register is used as the dead time value during both up-counting and down-counting. Therefore, we only need to configure Dead Time Count Up (Raw Counts).
  Step 5: Configure the g_timer1, which is used for U signal output, with the setting below through FSP configuration.
Interrupts > Callback: gpt_u_callback
Interrupts > Overflow/Crest Interrupt Priority: Priority 1
Interrupts > Underflow/Trough Interrupt Priority: Priority 1
Because the GPT callback channel is set to U channel, we should register a user callback function to the U channel GPT. In addition, we will use Complementary PWM mode 3 to transfer the data count at both crest and trough sections, so both Crest Interrupt and Trough Interrupt are enabled.
  Step 6: Assign the required MCU Pins for running this example
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT
GTCPPO4: PB10 (used as PWM Synchronous Output Pin)
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT4
GTIOC4A: PB04
GTIOC4B: PB05
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT5
GTIOC5A: PB06
GTIOC5B: PB07
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT6
GTIOC6A: PB08
GTIOC6B: PB09
  Step 7: Add the below initialization function, which enables Complementary PWM mode 3 usage, in the hal_entry.c.
static fsp_err_t gpt_complementary_pwm_mode_3_init (void)
{
    fsp_err_t err = FSP_SUCCESS;
    /* Initializes the module. */
    err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);
    /* Handle any errors. This function should be defined by the user. */
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    R_GPT4->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT5->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT6->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    /*
     * GTBER: General PWM Timer Buffer Enable
     * - BD0: GTCCR Buffer Operation
     * - BD1: GTPR Buffer Operation
     * - BD2: GTADTRA/GTADTRB Buffer Operation
     * - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)
     */
    R_GPT4->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT4->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT4->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT5->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT5->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT5->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT6->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT6->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT6->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT4->GTPDBR = 6000;
    R_GPT5->GTPDBR = 6000;
    R_GPT6->GTPDBR = 6000;
    /*
     * GTIOR : General PWM Timer I/O Control Register
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b
     * GTIOA = 0x09
     *  - Initial output is Low (Active level is High),
     *  - High output in up count compare match
     *  - Low output in down count compare match
     * GTIOB = 0x06
     *  - Initial output is Low (Active level is High),
     *  - Low output in up count compare match
     *  - High output in down count compare match
     */
    R_GPT4->GTIOR_b.GTIOA = 0x09;
    R_GPT5->GTIOR_b.GTIOA = 0x09;
    R_GPT6->GTIOR_b.GTIOA = 0x09;
    R_GPT4->GTIOR_b.GTIOB = 0x06;
    R_GPT5->GTIOR_b.GTIOB = 0x06;
    R_GPT6->GTIOR_b.GTIOB = 0x06;
    /*PSYE: PWM Synchronous output Enable:
     * Enable GTCPPOT4 output */
    R_GPT4->GTIOR_b.PSYE = 1;
    /*
     * GTBER2: General PWM Timer Buffer Enable 2
     * - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4
     * - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select
     * - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select
     */
    R_GPT4->GTBER2_b.CP3DB = 0;
    R_GPT4->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.CP3DB = 0;
    R_GPT5->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.CP3DB = 0;
    R_GPT6->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    /* Start the timer. */
    err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    return FSP_SUCCESS;
}
  Step 8: Add the below code, which includes the implementation of gpt_u_callback, in the hal_entry.c
static volatile int direction = 1; // 1 for incrementing, -1 for decrementing
static volatile int u2_count_u = 0U;
static void rm_motor_driver_set_uvw_duty_test (void)
{
    u2_count_u += direction;
    // Check if the counter needs to change direction
    if (u2_count_u == 6240) {
        direction = -1; // Switch to decrementing
    } else if (u2_count_u == 0) {
        direction = 1; // Switch to incrementing
    }
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
}
  #define DEBUG_OUTPUT_PD00_ENABLE 1
void gpt_u_callback(timer_callback_args_t *p_args)
{
    /* TODO: add your own code here */
    if(p_args->event == TIMER_EVENT_CREST)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_LOW);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
      if(p_args->event == TIMER_EVENT_TROUGH)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_HIGH);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
}
  Step 9: Add below code in the beginning of hal_entry.c
enum e_gpt_three_phase_prv_gtccr
{
    GPT_THREE_PHASE_PRV_GTCCRA = 0U,
    GPT_THREE_PHASE_PRV_GTCCRB,
    GPT_THREE_PHASE_PRV_GTCCRC,
    GPT_THREE_PHASE_PRV_GTCCRE,
    GPT_THREE_PHASE_PRV_GTCCRD,
    GPT_THREE_PHASE_PRV_GTCCRF
};
static fsp_err_t gpt_complementary_pwm_mode_3_init (void);
  Step 10: In the hal_entry(), make a call to gpt_complementary_pwm_mode_3_init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTn_OVF and GPTn_UDF interrupts.
GPTn_OVF: In complementary PWM mode, these interrupts request are enabled at crests (GTCNT counter value of master channel changes from GTPR register to GTPR register value minus 1)
GPTn_UDF: In complementary PWM mode, these interrupt requests are enabled at troughs (GTCNT counter value of master channel changes from 0 to 1)
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t err = FSP_SUCCESS;
    /* Complementary PWM mode Setting */
    err = gpt_complementary_pwm_mode_3_init();
    assert(err == FSP_SUCCESS);
    while(1)
    {
    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}
  Step 11: Do a quick measurement to verify whether the result matches our target operation.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output: 
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.


    Suitable Products
RA6T2
Answer:
The RA6T2 General PWM Timer (GPT) supports Complementary the PWM mode, which can generate a three-phase PWM waveform with dead time and ensure the linearity in the vicinity of duty 0% and 100%. Therefore, this article takes Complementary PWM mode 3 (transfer at both crests and troughs) as an example to illustrate how to enable this operating mode based upon the FSP General PWM Timer Driver* (r_gpt).
*As Complementary PWM operating mode is not generally supported by other RA MCU General PWM Timer (GPT) peripheral, the configuration of FSP General PWM Timer Driver (r_gpt) does not support it as default.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output:
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.
  Step 1: Create a Renesas RA C/C++ Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective.
From the toolbar of e2studio, select File > New > RA C/C++ Project > Renesas RA
Flat (Non-TrustZone) Project is selected
RTOS selection is No RTOS.
Bare Metal (Minimal) is selected.
Step 2: In the Stacks option of FSP configuration window, first we add Three-Phase PWM module (r_gpt_three_phase) in the HAL/Common Stacks. The Three-Phase PWM module can be found under the Timer category.
New Stack > Timers > Three-Phase PWM (r_gpt_three_phase)
  Step 3: After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers.
Select one of the r_gpt modules and configure Pin Output Support property to Enabled with Extra Features
Step 4: Configure Three-Phase PWM module (r_gpt_three_phase) with the settings below. The default value of other properties is kept.
General > Period: 10
General > Period Unit: Kilohertz
General > GPT U-Channel: 4
General > GPT V-Channel: 5
General > GPT W-Channel: 6
Extra Features > Dead Time > Dead Time Count Up (Raw Counts): 240
In complementary PWM mode, the GTDVD register is invalid and the GTDVU register is used as the dead time value during both up-counting and down-counting. Therefore, we only need to configure Dead Time Count Up (Raw Counts).
  Step 5: Configure the g_timer1, which is used for U signal output, with the setting below through FSP configuration.
Interrupts > Callback: gpt_u_callback
Interrupts > Overflow/Crest Interrupt Priority: Priority 1
Interrupts > Underflow/Trough Interrupt Priority: Priority 1
Because the GPT callback channel is set to U channel, we should register a user callback function to the U channel GPT. In addition, we will use Complementary PWM mode 3 to transfer the data count at both crest and trough sections, so both Crest Interrupt and Trough Interrupt are enabled.
  Step 6: Assign the required MCU Pins for running this example
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT
GTCPPO4: PB10 (used as PWM Synchronous Output Pin)
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT4
GTIOC4A: PB04
GTIOC4B: PB05
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT5
GTIOC5A: PB06
GTIOC5B: PB07
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT6
GTIOC6A: PB08
GTIOC6B: PB09
  Step 7: Add the below initialization function, which enables Complementary PWM mode 3 usage, in the hal_entry.c.
static fsp_err_t gpt_complementary_pwm_mode_3_init (void)
{
    fsp_err_t err = FSP_SUCCESS;
    /* Initializes the module. */
    err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);
    /* Handle any errors. This function should be defined by the user. */
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    R_GPT4->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT5->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT6->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    /*
     * GTBER: General PWM Timer Buffer Enable
     * - BD0: GTCCR Buffer Operation
     * - BD1: GTPR Buffer Operation
     * - BD2: GTADTRA/GTADTRB Buffer Operation
     * - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)
     */
    R_GPT4->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT4->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT4->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT5->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT5->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT5->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT6->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT6->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT6->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT4->GTPDBR = 6000;
    R_GPT5->GTPDBR = 6000;
    R_GPT6->GTPDBR = 6000;
    /*
     * GTIOR : General PWM Timer I/O Control Register
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b
     * GTIOA = 0x09
     *  - Initial output is Low (Active level is High),
     *  - High output in up count compare match
     *  - Low output in down count compare match
     * GTIOB = 0x06
     *  - Initial output is Low (Active level is High),
     *  - Low output in up count compare match
     *  - High output in down count compare match
     */
    R_GPT4->GTIOR_b.GTIOA = 0x09;
    R_GPT5->GTIOR_b.GTIOA = 0x09;
    R_GPT6->GTIOR_b.GTIOA = 0x09;
    R_GPT4->GTIOR_b.GTIOB = 0x06;
    R_GPT5->GTIOR_b.GTIOB = 0x06;
    R_GPT6->GTIOR_b.GTIOB = 0x06;
    /*PSYE: PWM Synchronous output Enable:
     * Enable GTCPPOT4 output */
    R_GPT4->GTIOR_b.PSYE = 1;
    /*
     * GTBER2: General PWM Timer Buffer Enable 2
     * - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4
     * - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select
     * - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select
     */
    R_GPT4->GTBER2_b.CP3DB = 0;
    R_GPT4->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.CP3DB = 0;
    R_GPT5->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.CP3DB = 0;
    R_GPT6->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    /* Start the timer. */
    err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    return FSP_SUCCESS;
}
  Step 8: Add the below code, which includes the implementation of gpt_u_callback, in the hal_entry.c
static volatile int direction = 1; // 1 for incrementing, -1 for decrementing
static volatile int u2_count_u = 0U;
static void rm_motor_driver_set_uvw_duty_test (void)
{
    u2_count_u += direction;
    // Check if the counter needs to change direction
    if (u2_count_u == 6240) {
        direction = -1; // Switch to decrementing
    } else if (u2_count_u == 0) {
        direction = 1; // Switch to incrementing
    }
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
}
  #define DEBUG_OUTPUT_PD00_ENABLE 1
void gpt_u_callback(timer_callback_args_t *p_args)
{
    /* TODO: add your own code here */
    if(p_args->event == TIMER_EVENT_CREST)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_LOW);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
      if(p_args->event == TIMER_EVENT_TROUGH)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_HIGH);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
}
  Step 9: Add below code in the beginning of hal_entry.c
enum e_gpt_three_phase_prv_gtccr
{
    GPT_THREE_PHASE_PRV_GTCCRA = 0U,
    GPT_THREE_PHASE_PRV_GTCCRB,
    GPT_THREE_PHASE_PRV_GTCCRC,
    GPT_THREE_PHASE_PRV_GTCCRE,
    GPT_THREE_PHASE_PRV_GTCCRD,
    GPT_THREE_PHASE_PRV_GTCCRF
};
static fsp_err_t gpt_complementary_pwm_mode_3_init (void);
  Step 10: In the hal_entry(), make a call to gpt_complementary_pwm_mode_3_init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTn_OVF and GPTn_UDF interrupts.
GPTn_OVF: In complementary PWM mode, these interrupts request are enabled at crests (GTCNT counter value of master channel changes from GTPR register to GTPR register value minus 1)
GPTn_UDF: In complementary PWM mode, these interrupt requests are enabled at troughs (GTCNT counter value of master channel changes from 0 to 1)
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t err = FSP_SUCCESS;
    /* Complementary PWM mode Setting */
    err = gpt_complementary_pwm_mode_3_init();
    assert(err == FSP_SUCCESS);
    while(1)
    {
    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}
  Step 11: Do a quick measurement to verify whether the result matches our target operation.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output: 
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.


    Suitable Products
RA6T2
The RA6T2 General PWM Timer (GPT) supports Complementary the PWM mode, which can generate a three-phase PWM waveform with dead time and ensure the linearity in the vicinity of duty 0% and 100%. Therefore, this article takes Complementary PWM mode 3 (transfer at both crests and troughs) as an example to illustrate how to enable this operating mode based upon the FSP General PWM Timer Driver* (r_gpt).
*As Complementary PWM operating mode is not generally supported by other RA MCU General PWM Timer (GPT) peripheral, the configuration of FSP General PWM Timer Driver (r_gpt) does not support it as default.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output:
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.
  Step 1: Create a Renesas RA C/C++ Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective.
From the toolbar of e2studio, select File > New > RA C/C++ Project > Renesas RA
Flat (Non-TrustZone) Project is selected
RTOS selection is No RTOS.
Bare Metal (Minimal) is selected.
Step 2: In the Stacks option of FSP configuration window, first we add Three-Phase PWM module (r_gpt_three_phase) in the HAL/Common Stacks. The Three-Phase PWM module can be found under the Timer category.
New Stack > Timers > Three-Phase PWM (r_gpt_three_phase)
  Step 3: After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers.
Select one of the r_gpt modules and configure Pin Output Support property to Enabled with Extra Features
Step 4: Configure Three-Phase PWM module (r_gpt_three_phase) with the settings below. The default value of other properties is kept.
General > Period: 10
General > Period Unit: Kilohertz
General > GPT U-Channel: 4
General > GPT V-Channel: 5
General > GPT W-Channel: 6
Extra Features > Dead Time > Dead Time Count Up (Raw Counts): 240
In complementary PWM mode, the GTDVD register is invalid and the GTDVU register is used as the dead time value during both up-counting and down-counting. Therefore, we only need to configure Dead Time Count Up (Raw Counts).
  Step 5: Configure the g_timer1, which is used for U signal output, with the setting below through FSP configuration.
Interrupts > Callback: gpt_u_callback
Interrupts > Overflow/Crest Interrupt Priority: Priority 1
Interrupts > Underflow/Trough Interrupt Priority: Priority 1
Because the GPT callback channel is set to U channel, we should register a user callback function to the U channel GPT. In addition, we will use Complementary PWM mode 3 to transfer the data count at both crest and trough sections, so both Crest Interrupt and Trough Interrupt are enabled.
  Step 6: Assign the required MCU Pins for running this example
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT
GTCPPO4: PB10 (used as PWM Synchronous Output Pin)
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT4
GTIOC4A: PB04
GTIOC4B: PB05
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT5
GTIOC5A: PB06
GTIOC5B: PB07
FSP Configuration > Pins > Peripherals > Timers:GPT > GPT6
GTIOC6A: PB08
GTIOC6B: PB09
  Step 7: Add the below initialization function, which enables Complementary PWM mode 3 usage, in the hal_entry.c.
static fsp_err_t gpt_complementary_pwm_mode_3_init (void)
{
    fsp_err_t err = FSP_SUCCESS;
    /* Initializes the module. */
    err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);
    /* Handle any errors. This function should be defined by the user. */
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    R_GPT4->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT5->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    R_GPT6->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
    /*
     * GTBER: General PWM Timer Buffer Enable
     * - BD0: GTCCR Buffer Operation
     * - BD1: GTPR Buffer Operation
     * - BD2: GTADTRA/GTADTRB Buffer Operation
     * - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)
     */
    R_GPT4->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT4->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT4->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT5->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT5->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT5->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT6->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
    R_GPT6->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
    R_GPT6->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
    R_GPT4->GTPDBR = 6000;
    R_GPT5->GTPDBR = 6000;
    R_GPT6->GTPDBR = 6000;
    /*
     * GTIOR : General PWM Timer I/O Control Register
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b
     * - In complementary PWM mode,
     * the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b
     * GTIOA = 0x09
     *  - Initial output is Low (Active level is High),
     *  - High output in up count compare match
     *  - Low output in down count compare match
     * GTIOB = 0x06
     *  - Initial output is Low (Active level is High),
     *  - Low output in up count compare match
     *  - High output in down count compare match
     */
    R_GPT4->GTIOR_b.GTIOA = 0x09;
    R_GPT5->GTIOR_b.GTIOA = 0x09;
    R_GPT6->GTIOR_b.GTIOA = 0x09;
    R_GPT4->GTIOR_b.GTIOB = 0x06;
    R_GPT5->GTIOR_b.GTIOB = 0x06;
    R_GPT6->GTIOR_b.GTIOB = 0x06;
    /*PSYE: PWM Synchronous output Enable:
     * Enable GTCPPOT4 output */
    R_GPT4->GTIOR_b.PSYE = 1;
    /*
     * GTBER2: General PWM Timer Buffer Enable 2
     * - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4
     * - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select
     * - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select
     */
    R_GPT4->GTBER2_b.CP3DB = 0;
    R_GPT4->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.CP3DB = 0;
    R_GPT5->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT5->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.CP3DB = 0;
    R_GPT6->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT6->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
    /* Start the timer. */
    err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);
    if(FSP_SUCCESS != err)
    {
        return err;
    }
    return FSP_SUCCESS;
}
  Step 8: Add the below code, which includes the implementation of gpt_u_callback, in the hal_entry.c
static volatile int direction = 1; // 1 for incrementing, -1 for decrementing
static volatile int u2_count_u = 0U;
static void rm_motor_driver_set_uvw_duty_test (void)
{
    u2_count_u += direction;
    // Check if the counter needs to change direction
    if (u2_count_u == 6240) {
        direction = -1; // Switch to decrementing
    } else if (u2_count_u == 0) {
        direction = 1; // Switch to incrementing
    }
    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
}
  #define DEBUG_OUTPUT_PD00_ENABLE 1
void gpt_u_callback(timer_callback_args_t *p_args)
{
    /* TODO: add your own code here */
    if(p_args->event == TIMER_EVENT_CREST)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_LOW);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
      if(p_args->event == TIMER_EVENT_TROUGH)
    {
#if DEBUG_OUTPUT_PD00_ENABLE
        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_HIGH);
#endif
        rm_motor_driver_set_uvw_duty_test();
    }
}
  Step 9: Add below code in the beginning of hal_entry.c
enum e_gpt_three_phase_prv_gtccr
{
    GPT_THREE_PHASE_PRV_GTCCRA = 0U,
    GPT_THREE_PHASE_PRV_GTCCRB,
    GPT_THREE_PHASE_PRV_GTCCRC,
    GPT_THREE_PHASE_PRV_GTCCRE,
    GPT_THREE_PHASE_PRV_GTCCRD,
    GPT_THREE_PHASE_PRV_GTCCRF
};
static fsp_err_t gpt_complementary_pwm_mode_3_init (void);
  Step 10: In the hal_entry(), make a call to gpt_complementary_pwm_mode_3_init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTn_OVF and GPTn_UDF interrupts.
GPTn_OVF: In complementary PWM mode, these interrupts request are enabled at crests (GTCNT counter value of master channel changes from GTPR register to GTPR register value minus 1)
GPTn_UDF: In complementary PWM mode, these interrupt requests are enabled at troughs (GTCNT counter value of master channel changes from 0 to 1)
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t err = FSP_SUCCESS;
    /* Complementary PWM mode Setting */
    err = gpt_complementary_pwm_mode_3_init();
    assert(err == FSP_SUCCESS);
    while(1)
    {
    }
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}
  Step 11: Do a quick measurement to verify whether the result matches our target operation.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
PWM Frequency: 10kHz
Deadtime period: 2us (GTDVU=240, PCLKD=120MHz)
GTIOA output: 
Initial output level is Low, and active level is High
Output level is High in up count compare match, and it becomes Low in down count compare match.
GTIOB: Initial output level is Low
Initial output level is Low, and active level is High.
Output level is Low in up count compare match, and it becomes High in down count compare match.
The RA6T2 General PWM Timer (GPT) supports Complementary the PWM mode, which can generate a three-phase PWM waveform with dead time and ensure the linearity in the vicinity of duty 0% and 100%. Therefore, this article takes Complementary PWM mode 3 (transfer at both crests and troughs) as an example to illustrate how to enable this operating mode based upon the FSP General PWM Timer Driver* (r_gpt).
*As Complementary PWM operating mode is not generally supported by other RA MCU General PWM Timer (GPT) peripheral, the configuration of FSP General PWM Timer Driver (r_gpt) does not support it as default.
The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.
Step 1: Create a Renesas RA C/C++ Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective.
Step 2: In the Stacks option of FSP configuration window, first we add Three-Phase PWM module (r_gpt_three_phase) in the HAL/Common Stacks. The Three-Phase PWM module can be found under the Timer category.
Step 3: After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers.
Step 4: Configure Three-Phase PWM module (r_gpt_three_phase) with the settings below. The default value of other properties is kept.
Step 5: Configure the g_timer1, which is used for U signal output, with the setting below through FSP configuration.
Because the GPT callback channel is set to U channel, we should register a user callback function to the U channel GPT. In addition, we will use Complementary PWM mode 3 to transfer the data count at both crest and trough sections, so both Crest Interrupt and Trough Interrupt are enabled.
Step 6: Assign the required MCU Pins for running this example
Step 7: Add the below initialization function, which enables Complementary PWM mode 3 usage, in the hal_entry.c.
static fsp_err_t gpt_complementary_pwm_mode_3_init (void)
static
fsp_err_t
gpt_complementary_pwm_mode_3_init (
void
)
{
{
fsp_err_t err = FSP_SUCCESS;
fsp_err_t
err =
FSP_SUCCESS
;
/* Initializes the module. */
/* Initializes the module. */
err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);
err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);
/* Handle any errors. This function should be defined by the user. */
/* Handle any errors. This function should be defined by the user. */
if(FSP_SUCCESS != err)
if
(
FSP_SUCCESS
!= err)
{
{
return err;
return
err;
}
}
R_GPT4->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
R_GPT4->GTCR_b.MD = 0x0E;
//Complementary PWM mode 3(transfer at crest and trough)
R_GPT5->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
R_GPT5->GTCR_b.MD = 0x0E;
//Complementary PWM mode 3(transfer at crest and trough)
R_GPT6->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)
R_GPT6->GTCR_b.MD = 0x0E;
//Complementary PWM mode 3(transfer at crest and trough)
/*
/*
* GTBER: General PWM Timer Buffer Enable
* GTBER: General PWM Timer Buffer Enable
* - BD0: GTCCR Buffer Operation
* - BD0: GTCCR Buffer Operation
* - BD1: GTPR Buffer Operation
* - BD1: GTPR Buffer Operation
* - BD2: GTADTRA/GTADTRB Buffer Operation
* - BD2: GTADTRA/GTADTRB Buffer Operation
* - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)
* - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)
*/
*/
R_GPT4->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
R_GPT4->GTBER_b.BD0 = 0;
//GTCCCR Buffer operation is enabled
R_GPT4->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
R_GPT4->GTBER_b.BD1 = 0;
//GTPR Buffer operation is enabled
R_GPT4->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
R_GPT4->GTBER_b.BD2 = 1;
//GTADTRA/GTADTRB Buffer operation is disabled
R_GPT5->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
R_GPT5->GTBER_b.BD0 = 0;
//GTCCCR Buffer operation is enabled
R_GPT5->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
R_GPT5->GTBER_b.BD1 = 0;
//GTPR Buffer operation is enabled
R_GPT5->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
R_GPT5->GTBER_b.BD2 = 1;
//GTADTRA/GTADTRB Buffer operation is disabled
R_GPT6->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled
R_GPT6->GTBER_b.BD0 = 0;
//GTCCCR Buffer operation is enabled
R_GPT6->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled
R_GPT6->GTBER_b.BD1 = 0;
//GTPR Buffer operation is enabled
R_GPT6->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled
R_GPT6->GTBER_b.BD2 = 1;
//GTADTRA/GTADTRB Buffer operation is disabled
R_GPT4->GTPDBR = 6000;
R_GPT4->GTPDBR = 6000;
R_GPT5->GTPDBR = 6000;
R_GPT5->GTPDBR = 6000;
R_GPT6->GTPDBR = 6000;
R_GPT6->GTPDBR = 6000;
/*
/*
* GTIOR : General PWM Timer I/O Control Register
* GTIOR : General PWM Timer I/O Control Register
* - In complementary PWM mode,
* - In complementary PWM mode,
* the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b
* the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b
* - In complementary PWM mode,
* - In complementary PWM mode,
* the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b
* the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b
* GTIOA = 0x09
* GTIOA = 0x09
*  - Initial output is Low (Active level is High),
*  - Initial output is Low (Active level is High),
*  - High output in up count compare match
*  - High output in up count compare match
*  - Low output in down count compare match
*  - Low output in down count compare match
* GTIOB = 0x06
* GTIOB = 0x06
*  - Initial output is Low (Active level is High),
*  - Initial output is Low (Active level is High),
*  - Low output in up count compare match
*  - Low output in up count compare match
*  - High output in down count compare match
*  - High output in down count compare match
*/
*/
R_GPT4->GTIOR_b.GTIOA = 0x09;
R_GPT4->GTIOR_b.GTIOA = 0x09;
R_GPT5->GTIOR_b.GTIOA = 0x09;
R_GPT5->GTIOR_b.GTIOA = 0x09;
R_GPT6->GTIOR_b.GTIOA = 0x09;
R_GPT6->GTIOR_b.GTIOA = 0x09;
R_GPT4->GTIOR_b.GTIOB = 0x06;
R_GPT4->GTIOR_b.GTIOB = 0x06;
R_GPT5->GTIOR_b.GTIOB = 0x06;
R_GPT5->GTIOR_b.GTIOB = 0x06;
R_GPT6->GTIOR_b.GTIOB = 0x06;
R_GPT6->GTIOR_b.GTIOB = 0x06;
/*PSYE: PWM Synchronous output Enable:
/*PSYE: PWM Synchronous output Enable:
* Enable GTCPPOT4 output */
* Enable GTCPPOT4 output */
R_GPT4->GTIOR_b.PSYE = 1;
R_GPT4->GTIOR_b.PSYE = 1;
/*
/*
* GTBER2: General PWM Timer Buffer Enable 2
* GTBER2: General PWM Timer Buffer Enable 2
* - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4
* - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4
* - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select
* - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select
* - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select
* - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select
*/
*/
R_GPT4->GTBER2_b.CP3DB = 0;
R_GPT4->GTBER2_b.CP3DB = 0;
R_GPT4->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT4->GTBER2_b.OLTTA = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT4->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT4->GTBER2_b.OLTTB = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT5->GTBER2_b.CP3DB = 0;
R_GPT5->GTBER2_b.CP3DB = 0;
R_GPT5->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT5->GTBER2_b.OLTTA = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT5->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT5->GTBER2_b.OLTTB = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT6->GTBER2_b.CP3DB = 0;
R_GPT6->GTBER2_b.CP3DB = 0;
R_GPT6->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT6->GTBER2_b.OLTTA = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT6->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough
R_GPT6->GTBER2_b.OLTTB = 3;
//complementary PWM mode: Transfer at both crest and trough
R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;
/* Start the timer. */
/* Start the timer. */
err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);
err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);
if(FSP_SUCCESS != err)
if
(
FSP_SUCCESS
!= err)
{
{
return err;
return
err;
}
}
return FSP_SUCCESS;
return
FSP_SUCCESS
;
}
}
Step 8: Add the below code, which includes the implementation of gpt_u_callback, in the hal_entry.c
static volatile int direction = 1; // 1 for incrementing, -1 for decrementing
static
volatile
int
direction = 1;
// 1 for incrementing, -1 for decrementing
static volatile int u2_count_u = 0U;
static
volatile
int
u2_count_u = 0U;
static void rm_motor_driver_set_uvw_duty_test (void)
static
void
rm_motor_driver_set_uvw_duty_test (
void
)
{
{
u2_count_u += direction;
u2_count_u += direction;
// Check if the counter needs to change direction
// Check if the counter needs to change direction
if (u2_count_u == 6240) {
if
(u2_count_u == 6240) {
direction = -1; // Switch to decrementing
direction = -1;
// Switch to decrementing
} else if (u2_count_u == 0) {
}
else
if
(u2_count_u == 0) {
direction = 1; // Switch to incrementing
direction = 1;
// Switch to incrementing
}
}
R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (
uint32_t
) u2_count_u;
R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (
uint32_t
) u2_count_u;
R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;
R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (
uint32_t
) u2_count_u;
}
}
#define DEBUG_OUTPUT_PD00_ENABLE 1
#define
DEBUG_OUTPUT_PD00_ENABLE 1
void gpt_u_callback(timer_callback_args_t *p_args)
void
gpt_u_callback(timer_callback_args_t *p_args)
{
{
/* TODO: add your own code here */
/*
TODO
: add your own code here */
if(p_args->event == TIMER_EVENT_CREST)
if
(p_args->event ==
TIMER_EVENT_CREST
)
{
{
#if DEBUG_OUTPUT_PD00_ENABLE
#if
DEBUG_OUTPUT_PD00_ENABLE
R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_LOW);
R_IOPORT_PinWrite(&g_ioport_ctrl,
BSP_IO_PORT_13_PIN_00
,
BSP_IO_LEVEL_LOW
);
#endif
#endif
rm_motor_driver_set_uvw_duty_test();
rm_motor_driver_set_uvw_duty_test();
}
}
if(p_args->event == TIMER_EVENT_TROUGH)
if
(p_args->event == TIMER_EVENT_TROUGH)
{
{
#if DEBUG_OUTPUT_PD00_ENABLE
#if
DEBUG_OUTPUT_PD00_ENABLE
R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_HIGH);
R_IOPORT_PinWrite(&g_ioport_ctrl,
BSP_IO_PORT_13_PIN_00
,
BSP_IO_LEVEL_HIGH
);
#endif
#endif
rm_motor_driver_set_uvw_duty_test();
rm_motor_driver_set_uvw_duty_test();
}
}
}
}
Step 9: Add below code in the beginning of hal_entry.c
enum e_gpt_three_phase_prv_gtccr
enum
e_gpt_three_phase_prv_gtccr
{
{
GPT_THREE_PHASE_PRV_GTCCRA = 0U,
GPT_THREE_PHASE_PRV_GTCCRA
= 0U,
GPT_THREE_PHASE_PRV_GTCCRB,
GPT_THREE_PHASE_PRV_GTCCRB
,
GPT_THREE_PHASE_PRV_GTCCRC,
GPT_THREE_PHASE_PRV_GTCCRC
,
GPT_THREE_PHASE_PRV_GTCCRE,
GPT_THREE_PHASE_PRV_GTCCRE
,
GPT_THREE_PHASE_PRV_GTCCRD,
GPT_THREE_PHASE_PRV_GTCCRD
,
GPT_THREE_PHASE_PRV_GTCCRF
GPT_THREE_PHASE_PRV_GTCCRF
};
};
static fsp_err_t gpt_complementary_pwm_mode_3_init (void);
static
fsp_err_t
gpt_complementary_pwm_mode_3_init (
void
);
Step 10: In the hal_entry(), make a call to gpt_complementary_pwm_mode_3_init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTn_OVF and GPTn_UDF interrupts.
void hal_entry(void)
void
hal_entry(
void
)
{
{
/* TODO: add your own code here */
/*
TODO
: add your own code here */
fsp_err_t err = FSP_SUCCESS;
fsp_err_t
err =
FSP_SUCCESS
;
/* Complementary PWM mode Setting */
/* Complementary PWM mode Setting */
err = gpt_complementary_pwm_mode_3_init();
err = gpt_complementary_pwm_mode_3_init();
assert(err == FSP_SUCCESS);
assert(err ==
FSP_SUCCESS
);
while(1)
while
(1)
{
{
}
}
#if BSP_TZ_SECURE_BUILD
#if
BSP_TZ_SECURE_BUILD
/* Enter non-secure code */
/* Enter non-secure code */
R_BSP_NonSecureEnter();
R_BSP_NonSecureEnter();
#endif
#endif
}
}
Step 11: Do a quick measurement to verify whether the result matches our target operation.
Suitable Products
RA6T2","['data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/8d54988bfaffb52d1eddba1d0966c5da.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/91131772c15fae3c52b624c1180f8cdb.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/7142db3f1eca213dc6ec553a147d9f32.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/4701650b9a6d81bdbf2ab018ac8d3d0c.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/692c5949cc97b5bf687b61a145e6e57b.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/07128eeadeb01b85cc9f21099690e4cf.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/73daa6998081e489038f9b2a0ac2d0e3.png', 'data/categories/ra_family/ra_hardware/c4c4ce18c55c3d890ac5327a7d635d14/images/055d1d942bcb2900ddc624bea814c44c.png']",[],"['|  |\n|  |\n| The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.\nPWM Frequency: 10kHz\nDeadtime period: 2us (GTDVU=240, PCLKD=120MHz)\nGTIOA output:\nInitial output level is Low, and active level is High\nOutput level is High in up count compare match, and it becomes Low in down count compare match.\nGTIOB: Initial output level is Low\nInitial output level is Low, and active level is High.\nOutput level is Low in up count compare match, and it becomes High in down count compare match. |', '|  |\n|  |\n| In complementary PWM mode, the GTDVD register is invalid and the GTDVU register is used as the dead time value during both up-counting and down-counting. Therefore, we only need to configure Dead Time Count Up (Raw Counts). |', '|  |\n|  |\n| static fsp_err_t gpt_complementary_pwm_mode_3_init (void)\n{\n    fsp_err_t err = FSP_SUCCESS;\n    /* Initializes the module. */\n    err = R_GPT_THREE_PHASE_Open(&g_three_phase0_ctrl, &g_three_phase0_cfg);\n    /* Handle any errors. This function should be defined by the user. */\n    if(FSP_SUCCESS != err)\n    {\n        return err;\n    }\n    R_GPT4->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)\n    R_GPT5->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)\n    R_GPT6->GTCR_b.MD = 0x0E; //Complementary PWM mode 3(transfer at crest and trough)\n    /*\n     * GTBER: General PWM Timer Buffer Enable\n     * - BD0: GTCCR Buffer Operation\n     * - BD1: GTPR Buffer Operation\n     * - BD2: GTADTRA/GTADTRB Buffer Operation\n     * - BD3: GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode)\n     */\n    R_GPT4->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled\n    R_GPT4->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled\n    R_GPT4->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled\n    R_GPT5->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled\n    R_GPT5->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled\n    R_GPT5->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled\n    R_GPT6->GTBER_b.BD0 = 0; //GTCCCR Buffer operation is enabled\n    R_GPT6->GTBER_b.BD1 = 0; //GTPR Buffer operation is enabled\n    R_GPT6->GTBER_b.BD2 = 1; //GTADTRA/GTADTRB Buffer operation is disabled\n    R_GPT4->GTPDBR = 6000;\n    R_GPT5->GTPDBR = 6000;\n    R_GPT6->GTPDBR = 6000;\n    /*\n     * GTIOR : General PWM Timer I/O Control Register\n     * - In complementary PWM mode,\n     * the only values that can be set in the GTIOA[4:0] bits are 01001b, and 10110b\n     * - In complementary PWM mode,\n     * the only values that can be set in the GTIOB[4:0] bits are 00110b, and 11001b\n     * GTIOA = 0x09\n     *  - Initial output is Low (Active level is High),\n     *  - High output in up count compare match\n     *  - Low output in down count compare match\n     * GTIOB = 0x06\n     *  - Initial output is Low (Active level is High),\n     *  - Low output in up count compare match\n     *  - High output in down count compare match\n     */\n    R_GPT4->GTIOR_b.GTIOA = 0x09;\n    R_GPT5->GTIOR_b.GTIOA = 0x09;\n    R_GPT6->GTIOR_b.GTIOA = 0x09;\n    R_GPT4->GTIOR_b.GTIOB = 0x06;\n    R_GPT5->GTIOR_b.GTIOB = 0x06;\n    R_GPT6->GTIOR_b.GTIOB = 0x06;\n    /*PSYE: PWM Synchronous output Enable:\n     * Enable GTCPPOT4 output */\n    R_GPT4->GTIOR_b.PSYE = 1;\n    /*\n     * GTBER2: General PWM Timer Buffer Enable 2\n     * - CP3DB=0 : Disable double buffer function in complementary PWM mode 3, 4\n     * - OLTTA: GTIOCnA Output Level Buffer Transfer Timing Select\n     * - OLTTB: GTIOCnB Output Level Buffer Transfer Timing Select\n     */\n    R_GPT4->GTBER2_b.CP3DB = 0;\n    R_GPT4->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT4->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT5->GTBER2_b.CP3DB = 0;\n    R_GPT5->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT5->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT6->GTBER2_b.CP3DB = 0;\n    R_GPT6->GTBER2_b.OLTTA = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT6->GTBER2_b.OLTTB = 3; //complementary PWM mode: Transfer at both crest and trough\n    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;\n    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;\n    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = 3000;\n    /* Start the timer. */\n    err = R_GPT_THREE_PHASE_Start(&g_three_phase0_ctrl);\n    if(FSP_SUCCESS != err)\n    {\n        return err;\n    }\n    return FSP_SUCCESS;\n} |', '|  |\n|  |\n| static volatile int direction = 1; // 1 for incrementing, -1 for decrementing\nstatic volatile int u2_count_u = 0U;\nstatic void rm_motor_driver_set_uvw_duty_test (void)\n{\n    u2_count_u += direction;\n    // Check if the counter needs to change direction\n    if (u2_count_u == 6240) {\n        direction = -1; // Switch to decrementing\n    } else if (u2_count_u == 0) {\n        direction = 1; // Switch to incrementing\n    }\n    R_GPT4->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;\n    R_GPT5->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;\n    R_GPT6->GTCCR[GPT_THREE_PHASE_PRV_GTCCRD] = (uint32_t) u2_count_u;\n}\n  #define DEBUG_OUTPUT_PD00_ENABLE 1\nvoid gpt_u_callback(timer_callback_args_t *p_args)\n{\n    /* TODO: add your own code here */\n    if(p_args->event == TIMER_EVENT_CREST)\n    {\n#if DEBUG_OUTPUT_PD00_ENABLE\n        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_LOW);\n#endif\n        rm_motor_driver_set_uvw_duty_test();\n    }\n      if(p_args->event == TIMER_EVENT_TROUGH)\n    {\n#if DEBUG_OUTPUT_PD00_ENABLE\n        R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_13_PIN_00, BSP_IO_LEVEL_HIGH);\n#endif\n        rm_motor_driver_set_uvw_duty_test();\n    }\n} |', '|  |\n|  |\n| enum e_gpt_three_phase_prv_gtccr\n{\n    GPT_THREE_PHASE_PRV_GTCCRA = 0U,\n    GPT_THREE_PHASE_PRV_GTCCRB,\n    GPT_THREE_PHASE_PRV_GTCCRC,\n    GPT_THREE_PHASE_PRV_GTCCRE,\n    GPT_THREE_PHASE_PRV_GTCCRD,\n    GPT_THREE_PHASE_PRV_GTCCRF\n};\nstatic fsp_err_t gpt_complementary_pwm_mode_3_init (void); |', '|  |\n|  |\n| void hal_entry(void)\n{\n    /* TODO: add your own code here */\n    fsp_err_t err = FSP_SUCCESS;\n    /* Complementary PWM mode Setting */\n    err = gpt_complementary_pwm_mode_3_init();\n    assert(err == FSP_SUCCESS);\n    while(1)\n    {\n    }\n#if BSP_TZ_SECURE_BUILD\n    /* Enter non-secure code */\n    R_BSP_NonSecureEnter();\n#endif\n} |', '|  |\n|  |\n| The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions.\nPWM Frequency: 10kHz\nDeadtime period: 2us (GTDVU=240, PCLKD=120MHz)\nGTIOA output: \nInitial output level is Low, and active level is High\nOutput level is High in up count compare match, and it becomes Low in down count compare match.\nGTIOB: Initial output level is Low\nInitial output level is Low, and active level is High.\nOutput level is Low in up count compare match, and it becomes High in down count compare match. |', '|  |\n|  |\n| RA6T2 |']","{'title': 'RA6T2: How to use the GPT Complementary PWM mode', 'url': 'https://en-support.renesas.com/knowledgeBase/21745546', 'last_updated': '2024-07-01', 'extracted_at': '2025-03-08T23:13:56.988643'}","Answer The RA6T2 General PWM Timer (GPT) supports Complementary the PWM mode, which can generate a three-phase PWM waveform with dead time and ensure the linearity in the vicinity of duty 0 and 100. Therefore, this article takes Complementary PWM mode 3 (transfer at both crests and troughs) as an example to illustrate how to enable this operating mode based upon the FSP General PWM Timer Driver (rgpt). As Complementary PWM operating mode is not generally supported by other RA MCU General PWM Timer (GPT) peripheral, the configuration of FSP General PWM Timer Driver (rgpt) does not support it as default. The example below demonstrates using the complementary PWM mode with consecutive three GPT channels to generate three-phase PWM waveform with dead time based on below conditions. PWM Frequency 10kHz Deadtime period 2us (GTDVU240, PCLKD120MHz) GTIOA output Initial output level is Low, and active level is High Output level is High in up count compare match, and it becomes Low in down count compare match. GTIOB Initial output level is Low Initial output level is Low, and active level is High. Output level is Low in up count compare match, and it becomes High in down count compare match. Step 1 Create a Renesas RA C/C Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective. From the toolbar of e2studio, select File  New  RA C/C Project  Renesas RA Flat (Non-TrustZone) Project is selected RTOS selection is No RTOS. Bare Metal (Minimal) is selected. Step 2 In the Stacks option of FSP configuration window, first we add Three-Phase PWM module (rgptthreephase) in the HAL/Common Stacks. The Three-Phase PWM module can be found under the Timer category. New Stack  Timers  Three-Phase PWM (rgptthreephase) Step 3 After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers. Select one of the rgpt modules and configure Pin Output Support property to Enabled with Extra Features Step 4 Configure Three-Phase PWM module (rgptthreephase) with the settings below. The default value of other properties is kept. General  Period 10 General  Period Unit Kilohertz General  GPT U-Channel 4 General  GPT V-Channel 5 General  GPT W-Channel 6 Extra Features  Dead Time  Dead Time Count Up (Raw Counts) 240 In complementary PWM mode, the GTDVD register is invalid and the GTDVU register is used as the dead time value during both up-counting and down-counting. Therefore, we only need to configure Dead Time Count Up (Raw Counts). Step 5 Configure the gtimer1, which is used for U signal output, with the setting below through FSP configuration. Interrupts  Callback gptucallback Interrupts  Overflow/Crest Interrupt Priority Priority 1 Interrupts  Underflow/Trough Interrupt Priority Priority 1 Because the GPT callback channel is set to U channel, we should register a user callback function to the U channel GPT. In addition, we will use Complementary PWM mode 3 to transfer the data count at both crest and trough sections, so both Crest Interrupt and Trough Interrupt are enabled. Step 6 Assign the required MCU Pins for running this example FSP Configuration  Pins  Peripherals  TimersGPT  GPT GTCPPO4 PB10 (used as PWM Synchronous Output Pin) FSP Configuration  Pins  Peripherals  TimersGPT  GPT4 GTIOC4A PB04 GTIOC4B PB05 FSP Configuration  Pins  Peripherals  TimersGPT  GPT5 GTIOC5A PB06 GTIOC5B PB07 FSP Configuration  Pins  Peripherals  TimersGPT  GPT6 GTIOC6A PB08 GTIOC6B PB09 Step 7 Add the below initialization function, which enables Complementary PWM mode 3 usage, in the halentry.c. static fsperrt gptcomplementarypwmmode3init (void)  fsperrt err  FSPSUCCESS; / Initializes the module. / err  RGPTTHREEPHASEOpen(gthreephase0ctrl, gthreephase0cfg); / Handle any errors. This function should be defined by the user. / if(FSPSUCCESS ! err)  return err;  RGPT4-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT5-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT6-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) /  GTBER General PWM Timer Buffer Enable  - BD0 GTCCR Buffer Operation  - BD1 GTPR Buffer Operation  - BD2 GTADTRA/GTADTRB Buffer Operation  - BD3 GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode) / RGPT4-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT4-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT4-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT5-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT5-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT5-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT6-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT6-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT6-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT4-GTPDBR  6000; RGPT5-GTPDBR  6000; RGPT6-GTPDBR  6000;  GTIOR  General PWM Timer I/O Control Register  - In complementary PWM mode,  the only values that can be set in the GTIOA40 bits are 01001b, and 10110b  the only values that can be set in the GTIOB40 bits are 00110b, and 11001b  GTIOA  0x09  - Initial output is Low (Active level is High),  - High output in up count compare match  - Low output in down count compare match  GTIOB  0x06  - Low output in up count compare match  - High output in down count compare match RGPT4-GTIORb.GTIOA  0x09; RGPT5-GTIORb.GTIOA  0x09; RGPT6-GTIORb.GTIOA  0x09; RGPT4-GTIORb.GTIOB  0x06; RGPT5-GTIORb.GTIOB  0x06; RGPT6-GTIORb.GTIOB  0x06; /PSYE PWM Synchronous output Enable  Enable GTCPPOT4 output / RGPT4-GTIORb.PSYE  1;  GTBER2 General PWM Timer Buffer Enable 2  - CP3DB0  Disable double buffer function in complementary PWM mode 3, 4  - OLTTA GTIOCnA Output Level Buffer Transfer Timing Select  - OLTTB GTIOCnB Output Level Buffer Transfer Timing Select RGPT4-GTBER2b.CP3DB  0; RGPT4-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT4-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT5-GTBER2b.CP3DB  0; RGPT5-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT5-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT6-GTBER2b.CP3DB  0; RGPT6-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT6-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT4-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; RGPT5-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; RGPT6-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; / Start the timer. / err  RGPTTHREEPHASEStart(gthreephase0ctrl); return FSPSUCCESS;  Step 8 Add the below code, which includes the implementation of gptucallback, in the halentry.c static volatile int direction  1; // 1 for incrementing, -1 for decrementing static volatile int u2countu  0U; static void rmmotordriversetuvwdutytest (void) u2countu  direction; // Check if the counter needs to change direction if (u2countu  6240)  direction  -1; // Switch to decrementing  else if (u2countu  0)  direction  1; // Switch to incrementing RGPT4-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; RGPT5-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; RGPT6-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; define DEBUGOUTPUTPD00ENABLE 1 void gptucallback(timercallbackargst pargs) / TODO add your own code here / if(pargs-event  TIMEREVENTCREST) if DEBUGOUTPUTPD00ENABLE RIOPORTPinWrite(gioportctrl, BSPIOPORT13PIN00, BSPIOLEVELLOW); endif rmmotordriversetuvwdutytest(); if(pargs-event  TIMEREVENTTROUGH) RIOPORTPinWrite(gioportctrl, BSPIOPORT13PIN00, BSPIOLEVELHIGH); Step 9 Add below code in the beginning of halentry.c enum egptthreephaseprvgtccr GPTTHREEPHASEPRVGTCCRA  0U, GPTTHREEPHASEPRVGTCCRB, GPTTHREEPHASEPRVGTCCRC, GPTTHREEPHASEPRVGTCCRE, GPTTHREEPHASEPRVGTCCRD, GPTTHREEPHASEPRVGTCCRF ; static fsperrt gptcomplementarypwmmode3init (void); Step 10 In the halentry(), make a call to gptcomplementarypwmmode3init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTnOVF and GPTnUDF interrupts. GPTnOVF In complementary PWM mode, these interrupts request are enabled at crests (GTCNT counter value of master channel changes from GTPR register to GTPR register value minus 1) GPTnUDF In complementary PWM mode, these interrupt requests are enabled at troughs (GTCNT counter value of master channel changes from 0 to 1) void halentry(void) / Complementary PWM mode Setting / err  gptcomplementarypwmmode3init(); assert(err  FSPSUCCESS); while(1) if BSPTZSECUREBUILD / Enter non-secure code / RBSPNonSecureEnter(); Step 11 Do a quick measurement to verify whether the result matches our target operation. GTIOA output Suitable Products RA6T2 Step 1 Create a Renesas RA C/C Flat Project with the No RTOS selection based on MCK-RA6T2. Once the project is created, open the FSP Configuration perspective. Step 3 After step 2, you should receive the error indications from the configuration window like the above picture. This error can be eliminated by enabling the Pin Output Support on underneath GPT Drivers. Step 5 Configure the gtimer1, which is used for U signal output, with the setting below through FSP configuration. Step 6 Assign the required MCU Pins for running this example Step 7 Add the below initialization function, which enables Complementary PWM mode 3 usage, in the halentry.c. static fsperrt gptcomplementarypwmmode3init ( void ) fsperrt err  FSPSUCCESS; err  FSPSUCCESS ; / Initializes the module. / err  RGPTTHREEPHASEOpen(gthreephase0ctrl, gthreephase0cfg); / Handle any errors. This function should be defined by the user. / if(FSPSUCCESS ! err) if ( ! err) return err; return err; RGPT4-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT4-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT5-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT5-GTCRb.MD  0x0E; RGPT6-GTCRb.MD  0x0E; //Complementary PWM mode 3(transfer at crest and trough) RGPT6-GTCRb.MD  0x0E; /  GTBER General PWM Timer Buffer Enable  - BD0 GTCCR Buffer Operation  - BD1 GTPR Buffer Operation  - BD2 GTADTRA/GTADTRB Buffer Operation  - BD3 GTDVU/GTDVD Buffer (This bit is invalid in complementary PWM mode) / RGPT4-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT4-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT4-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT4-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT4-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT4-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT5-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT5-GTBERb.BD0  0; RGPT5-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT5-GTBERb.BD1  0; RGPT5-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT5-GTBERb.BD2  1; RGPT6-GTBERb.BD0  0; //GTCCCR Buffer operation is enabled RGPT6-GTBERb.BD0  0; RGPT6-GTBERb.BD1  0; //GTPR Buffer operation is enabled RGPT6-GTBERb.BD1  0; RGPT6-GTBERb.BD2  1; //GTADTRA/GTADTRB Buffer operation is disabled RGPT6-GTBERb.BD2  1; RGPT4-GTPDBR  6000; RGPT5-GTPDBR  6000; RGPT6-GTPDBR  6000;  GTIOR  General PWM Timer I/O Control Register  - In complementary PWM mode,  the only values that can be set in the GTIOA40 bits are 01001b, and 10110b  the only values that can be set in the GTIOB40 bits are 00110b, and 11001b  GTIOA  0x09  - Initial output is Low (Active level is High),  - High output in up count compare match  - Low output in down count compare match  GTIOB  0x06  - Low output in up count compare match  - High output in down count compare match RGPT4-GTIORb.GTIOA  0x09; RGPT5-GTIORb.GTIOA  0x09; RGPT6-GTIORb.GTIOA  0x09; RGPT4-GTIORb.GTIOB  0x06; RGPT5-GTIORb.GTIOB  0x06; RGPT6-GTIORb.GTIOB  0x06; /PSYE PWM Synchronous output Enable  Enable GTCPPOT4 output / RGPT4-GTIORb.PSYE  1;  GTBER2 General PWM Timer Buffer Enable 2  - CP3DB0  Disable double buffer function in complementary PWM mode 3, 4  - OLTTA GTIOCnA Output Level Buffer Transfer Timing Select  - OLTTB GTIOCnB Output Level Buffer Transfer Timing Select RGPT4-GTBER2b.CP3DB  0; RGPT4-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT4-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT4-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT4-GTBER2b.OLTTB  3; RGPT5-GTBER2b.CP3DB  0; RGPT5-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT5-GTBER2b.OLTTA  3; RGPT5-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT5-GTBER2b.OLTTB  3; RGPT6-GTBER2b.CP3DB  0; RGPT6-GTBER2b.OLTTA  3; //complementary PWM mode Transfer at both crest and trough RGPT6-GTBER2b.OLTTA  3; RGPT6-GTBER2b.OLTTB  3; //complementary PWM mode Transfer at both crest and trough RGPT6-GTBER2b.OLTTB  3; RGPT4-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; RGPT5-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; RGPT6-GTCCRGPTTHREEPHASEPRVGTCCRD  3000; / Start the timer. / err  RGPTTHREEPHASEStart(gthreephase0ctrl); return FSPSUCCESS; Step 8 Add the below code, which includes the implementation of gptucallback, in the halentry.c volatile int direction  1; // 1 for incrementing, -1 for decrementing u2countu  0U; rmmotordriversetuvwdutytest ( u2countu  direction; // Check if the counter needs to change direction if (u2countu  6240)  (u2countu  6240)  direction  -1; // Switch to decrementing direction  -1; // Switch to decrementing  else if (u2countu  0)  else (u2countu  0)  direction  1; // Switch to incrementing // Switch to incrementing RGPT4-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; RGPT4-GTCCRGPTTHREEPHASEPRVGTCCRD  ( uint32t ) u2countu; RGPT5-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; RGPT5-GTCCRGPTTHREEPHASEPRVGTCCRD  ( RGPT6-GTCCRGPTTHREEPHASEPRVGTCCRD  (uint32t) u2countu; RGPT6-GTCCRGPTTHREEPHASEPRVGTCCRD  ( define DEBUGOUTPUTPD00ENABLE 1 define DEBUGOUTPUTPD00ENABLE 1 gptucallback(timercallbackargst pargs) / TODO add your own code here / TODO  add your own code here / if(pargs-event  TIMEREVENTCREST) (pargs-event  TIMEREVENTCREST if DEBUGOUTPUTPD00ENABLE RIOPORTPinWrite(gioportctrl, BSPIOPORT13PIN00, BSPIOLEVELLOW); RIOPORTPinWrite(gioportctrl, BSPIOPORT13PIN00 , BSPIOLEVELLOW ); rmmotordriversetuvwdutytest(); if(pargs-event  TIMEREVENTTROUGH) (pargs-event  TIMEREVENTTROUGH) RIOPORTPinWrite(gioportctrl, BSPIOPORT13PIN00, BSPIOLEVELHIGH); BSPIOLEVELHIGH Step 9 Add below code in the beginning of halentry.c enum egptthreephaseprvgtccr GPTTHREEPHASEPRVGTCCRA  0U, GPTTHREEPHASEPRVGTCCRA  0U, GPTTHREEPHASEPRVGTCCRB, GPTTHREEPHASEPRVGTCCRB GPTTHREEPHASEPRVGTCCRC, GPTTHREEPHASEPRVGTCCRC GPTTHREEPHASEPRVGTCCRE, GPTTHREEPHASEPRVGTCCRE GPTTHREEPHASEPRVGTCCRD, GPTTHREEPHASEPRVGTCCRD GPTTHREEPHASEPRVGTCCRF Step 10 In the halentry(), make a call to gptcomplementarypwmmode3init to start the three phase PWM. Then, the GPT Compare Capture Register (GTCCRD) will be updated periodically right after the GPTnOVF and GPTnUDF interrupts. halentry( / Complementary PWM mode Setting / err  gptcomplementarypwmmode3init(); assert(err  FSPSUCCESS); assert(err  while(1) while (1) BSPTZSECUREBUILD / Enter non-secure code / RBSPNonSecureEnter(); Step 11 Do a quick measurement to verify whether the result matches our target operation. Suitable Products",
6018623afd9089cd0f48a5d1b4c5b122,"Question:
Even though a CAN/CAN-FD communication application is implemented on RA Family MCU, test signal output cannot be confirmed from the MCU pin.
Answer:
To connect the RA Family MCU to the CAN physical bus, an external CAN bus transceiver is required. If the CAN bus transceiver is not connected (e.g., the state when the receive pin is open), the MCU may not output a CAN transmit signal. Please check the setup of evaluation board used.
Some RA Family evaluation kits (e.g., the EK-RA6M5) already mounted a CAN bus transceiver on the board, so users can start evaluation without additional components consideration.
Note: Few development kits are shipped with cutting the line between MCU pins and the CAN bus transceiver by a solder jumper. Please refer to the User's Manual of evaluation kit for details on how to use it.
  Suitable Products
RA Family
Even though a CAN/CAN-FD communication application is implemented on RA Family MCU, test signal output cannot be confirmed from the MCU pin.
Even though a CAN/CAN-FD communication application is implemented on RA Family MCU, test signal output cannot be confirmed from the MCU pin.
Answer:
To connect the RA Family MCU to the CAN physical bus, an external CAN bus transceiver is required. If the CAN bus transceiver is not connected (e.g., the state when the receive pin is open), the MCU may not output a CAN transmit signal. Please check the setup of evaluation board used.
Some RA Family evaluation kits (e.g., the EK-RA6M5) already mounted a CAN bus transceiver on the board, so users can start evaluation without additional components consideration.
Note: Few development kits are shipped with cutting the line between MCU pins and the CAN bus transceiver by a solder jumper. Please refer to the User's Manual of evaluation kit for details on how to use it.
  Suitable Products
RA Family
To connect the RA Family MCU to the CAN physical bus, an external CAN bus transceiver is required. If the CAN bus transceiver is not connected (e.g., the state when the receive pin is open), the MCU may not output a CAN transmit signal. Please check the setup of evaluation board used.
Some RA Family evaluation kits (e.g., the EK-RA6M5) already mounted a CAN bus transceiver on the board, so users can start evaluation without additional components consideration.
Note: Few development kits are shipped with cutting the line between MCU pins and the CAN bus transceiver by a solder jumper. Please refer to the User's Manual of evaluation kit for details on how to use it.
To connect the RA Family MCU to the CAN physical bus, an external CAN bus transceiver is required. If the CAN bus transceiver is not connected (e.g., the state when the receive pin is open), the MCU may not output a CAN transmit signal. Please check the setup of evaluation board used.
Some RA Family evaluation kits (e.g., the EK-RA6M5) already mounted a CAN bus transceiver on the board, so users can start evaluation without additional components consideration.
Note: Few development kits are shipped with cutting the line between MCU pins and the CAN bus transceiver by a solder jumper. Please refer to the User's Manual of evaluation kit for details on how to use it.
Suitable Products
RA Family

",['data/categories/ra_family/ra_hardware/6018623afd9089cd0f48a5d1b4c5b122/images/d7f674b9591098f0ebd829b5f42f6e2f.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: CAN / CAN-FD signal output not observed', 'url': 'https://en-support.renesas.com/knowledgeBase/21727827', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:59.647580'}","Question Even though a CAN/CAN-FD communication application is implemented on RA Family MCU, test signal output cannot be confirmed from the MCU pin. Answer To connect the RA Family MCU to the CAN physical bus, an external CAN bus transceiver is required. If the CAN bus transceiver is not connected (e.g., the state when the receive pin is open), the MCU may not output a CAN transmit signal. Please check the setup of evaluation board used. Some RA Family evaluation kits (e.g., the EK-RA6M5) already mounted a CAN bus transceiver on the board, so users can start evaluation without additional components consideration. Note Few development kits are shipped with cutting the line between MCU pins and the CAN bus transceiver by a solder jumper. Please refer to the User's Manual of evaluation kit for details on how to use it. Suitable Products RA Family Suitable Products ",
f66b80baf9e191ca337d2ca1466fc28f,"For the applications such as the Internet of Things or product version management, reading the information of an MCU is a common task for developers. This topic describes how to read the Unique ID, Part Number, and Mask Version information on Renesas RA Family microcontrollers.
We can obtain information using the content stored in the following three addresses, which are located as shown below:
project RA2E1/RA2E2/RA2L1 RA2A1/RA4M1/RA4W1/RA6M1/RA6M2/RA6M3/RA6T1 RA4M2/RA4M3/RA6M4/RA6M5/RA6T2/RA4E1/ RA6E1
Unique ID (16bytes) 0x0100_1C00 FMIFRT+14h (0x407F_B1B0) 0x0100_8190
Part number (16bytes) 0x0100_1C10 FMIFRT+24h (0x407F_B1C0) 0x0100_80F0
Mask version (1byte) 0x0100_1C20 FMIFRT+44h (0x407F_B1E0) 0x0100_81B0
FMIFRT* No Yes No
Note: The address of the FMIFRT register is 0x407F_B19C.
About FMIFRT registers
FMIRT register is built into RA2A1, RA4M1, RA4W1, RA6M1, RA6M2, RA6M3, and RA6T1.
FMIFRT is a read-only register that stores the base addresses of the Unique ID register, Part Number register, and MCU Version register.
FMIFRT should be read in 32-bit units.
The address of the FMIFRT register is 0x407F_B19C.
The following steps describe how to read out the Unique ID, Part Number, and Mask Version through the program code, using the RA2L1 as an example.
(1) Unique ID register address and readout method
The 128-bit Unique ID can be read directly through the FSP API ""R_BSP_UniqueIdGet"".
Refer to the following command:
const bsp_unique_id_t* unique_id = R_BSP_UniqueIdGet();
(2) Part Number register address and readout method
There is no API in FSP to read Part Numbers, so the following code is required.
First, define the address of the Part Number register and store the struct of the Part Number array.
#define BSP_FEATURE_BSP_PART_NUMBER_POINTER (0x01001C10U)
typedef struct st_bsp_part_number
{
    union
    {
        uint32_t part_number_words[4];
        uint8_t  part_number_bytes[16];
    };
} bsp_part_number_t;
Then execute the following command in the user code to read out the Part Number.
const bsp_part_number_t* part_number = BSP_FEATURE_BSP_PART_NUMBER_POINTER;
(3) MCU Version register address and readout method
There is no API to read the MCU version in the FSP, so the following code is required.
First, define the address of the MCU Version register:
#define BSP_FEATURE_BSP_MASK_REVISION_POINTER (0x01001C20U)
Then run the following command in the user code to read out the MCU Version.
const uint8_t* mask_version = BSP_FEATURE_BSP_MASK_REVISION_POINTER;
The following results are read out in the debug state (RA2L1 is used as an example):
The product model is written in ASCII code, and the RA2L1 is used as an example to illustrate the following.
Address : 0x0100_1C0F  <->  0x0100_1C00
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
Address : 0x0100_1C1F  <->  0x0100_1C10
Part number : R7FA2L1AB2DFP case
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
P
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x50
Address : 0x0100_1C1F  <->  0x0100_1C10
Part number : R7FA2L1AB2DFM case
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
M
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x4D
Address : 0x0100_1C2F  <->  0x0100_1C20
~
~
~
~
~
~
~
~
~
~
~
~
0xFF
0xFF
0xFF
0x01

Suitable Products
RA
For the applications such as the Internet of Things or product version management, reading the information of an MCU is a common task for developers. This topic describes how to read the Unique ID, Part Number, and Mask Version information on Renesas RA Family microcontrollers.
We can obtain information using the content stored in the following three addresses, which are located as shown below:
project RA2E1/RA2E2/RA2L1 RA2A1/RA4M1/RA4W1/RA6M1/RA6M2/RA6M3/RA6T1 RA4M2/RA4M3/RA6M4/RA6M5/RA6T2/RA4E1/ RA6E1
Unique ID (16bytes) 0x0100_1C00 FMIFRT+14h (0x407F_B1B0) 0x0100_8190
Part number (16bytes) 0x0100_1C10 FMIFRT+24h (0x407F_B1C0) 0x0100_80F0
Mask version (1byte) 0x0100_1C20 FMIFRT+44h (0x407F_B1E0) 0x0100_81B0
FMIFRT* No Yes No
Note: The address of the FMIFRT register is 0x407F_B19C.
About FMIFRT registers
FMIRT register is built into RA2A1, RA4M1, RA4W1, RA6M1, RA6M2, RA6M3, and RA6T1.
FMIFRT is a read-only register that stores the base addresses of the Unique ID register, Part Number register, and MCU Version register.
FMIFRT should be read in 32-bit units.
The address of the FMIFRT register is 0x407F_B19C.
The following steps describe how to read out the Unique ID, Part Number, and Mask Version through the program code, using the RA2L1 as an example.
(1) Unique ID register address and readout method
The 128-bit Unique ID can be read directly through the FSP API ""R_BSP_UniqueIdGet"".
Refer to the following command:
const bsp_unique_id_t* unique_id = R_BSP_UniqueIdGet();
(2) Part Number register address and readout method
There is no API in FSP to read Part Numbers, so the following code is required.
First, define the address of the Part Number register and store the struct of the Part Number array.
#define BSP_FEATURE_BSP_PART_NUMBER_POINTER (0x01001C10U)
typedef struct st_bsp_part_number
{
    union
    {
        uint32_t part_number_words[4];
        uint8_t  part_number_bytes[16];
    };
} bsp_part_number_t;
Then execute the following command in the user code to read out the Part Number.
const bsp_part_number_t* part_number = BSP_FEATURE_BSP_PART_NUMBER_POINTER;
(3) MCU Version register address and readout method
There is no API to read the MCU version in the FSP, so the following code is required.
First, define the address of the MCU Version register:
#define BSP_FEATURE_BSP_MASK_REVISION_POINTER (0x01001C20U)
Then run the following command in the user code to read out the MCU Version.
const uint8_t* mask_version = BSP_FEATURE_BSP_MASK_REVISION_POINTER;
The following results are read out in the debug state (RA2L1 is used as an example):
The product model is written in ASCII code, and the RA2L1 is used as an example to illustrate the following.
Address : 0x0100_1C0F  <->  0x0100_1C00
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
Address : 0x0100_1C1F  <->  0x0100_1C10
Part number : R7FA2L1AB2DFP case
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
P
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x50
Address : 0x0100_1C1F  <->  0x0100_1C10
Part number : R7FA2L1AB2DFM case
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
M
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x4D
Address : 0x0100_1C2F  <->  0x0100_1C20
~
~
~
~
~
~
~
~
~
~
~
~
0xFF
0xFF
0xFF
0x01

Suitable Products
RA
For the applications such as the Internet of Things or product version management, reading the information of an MCU is a common task for developers. This topic describes how to read the Unique ID, Part Number, and Mask Version information on Renesas RA Family microcontrollers.
We can obtain information using the content stored in the following three addresses, which are located as shown below:
project RA2E1/RA2E2/RA2L1 RA2A1/RA4M1/RA4W1/RA6M1/RA6M2/RA6M3/RA6T1 RA4M2/RA4M3/RA6M4/RA6M5/RA6T2/RA4E1/ RA6E1
Unique ID (16bytes) 0x0100_1C00 FMIFRT+14h (0x407F_B1B0) 0x0100_8190
Part number (16bytes) 0x0100_1C10 FMIFRT+24h (0x407F_B1C0) 0x0100_80F0
Mask version (1byte) 0x0100_1C20 FMIFRT+44h (0x407F_B1E0) 0x0100_81B0
FMIFRT* No Yes No
Note: The address of the FMIFRT register is 0x407F_B19C.
About FMIFRT registers
FMIRT register is built into RA2A1, RA4M1, RA4W1, RA6M1, RA6M2, RA6M3, and RA6T1.
FMIFRT is a read-only register that stores the base addresses of the Unique ID register, Part Number register, and MCU Version register.
FMIFRT should be read in 32-bit units.
The address of the FMIFRT register is 0x407F_B19C.
The following steps describe how to read out the Unique ID, Part Number, and Mask Version through the program code, using the RA2L1 as an example.
(1) Unique ID register address and readout method
The 128-bit Unique ID can be read directly through the FSP API ""R_BSP_UniqueIdGet"".
Refer to the following command:
const bsp_unique_id_t* unique_id = R_BSP_UniqueIdGet();
(2) Part Number register address and readout method
There is no API in FSP to read Part Numbers, so the following code is required.
First, define the address of the Part Number register and store the struct of the Part Number array.
#define BSP_FEATURE_BSP_PART_NUMBER_POINTER (0x01001C10U)
typedef struct st_bsp_part_number
{
    union
    {
        uint32_t part_number_words[4];
        uint8_t  part_number_bytes[16];
    };
} bsp_part_number_t;
Then execute the following command in the user code to read out the Part Number.
const bsp_part_number_t* part_number = BSP_FEATURE_BSP_PART_NUMBER_POINTER;
(3) MCU Version register address and readout method
There is no API to read the MCU version in the FSP, so the following code is required.
First, define the address of the MCU Version register:
#define BSP_FEATURE_BSP_MASK_REVISION_POINTER (0x01001C20U)
Then run the following command in the user code to read out the MCU Version.
const uint8_t* mask_version = BSP_FEATURE_BSP_MASK_REVISION_POINTER;
The following results are read out in the debug state (RA2L1 is used as an example):
The product model is written in ASCII code, and the RA2L1 is used as an example to illustrate the following.
Address : 0x0100_1C0F  <->  0x0100_1C00
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
Address : 0x0100_1C1F  <->  0x0100_1C10
Part number : R7FA2L1AB2DFP case
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
P
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x50
Address : 0x0100_1C1F  <->  0x0100_1C10
Part number : R7FA2L1AB2DFM case
space
space
space
R
7
F
A
2
L
1
A
B
2
D
F
M
0x20
0x20
0x20
0x52
0x37
0x46
0x41
0x32
0x4C
0x31
0x41
0x42
0x32
0x44
0x46
0x4D
Address : 0x0100_1C2F  <->  0x0100_1C20
~
~
~
~
~
~
~
~
~
~
~
~
0xFF
0xFF
0xFF
0x01
For the applications such as the Internet of Things or product version management, reading the information of an MCU is a common task for developers. This topic describes how to read the Unique ID, Part Number, and Mask Version information on Renesas RA Family microcontrollers.
We can obtain information using the content stored in the following three addresses, which are located as shown below:
Note: The address of the FMIFRT register is 0x407F_B19C.
About FMIFRT registers
The following steps describe how to read out the Unique ID, Part Number, and Mask Version through the program code, using the RA2L1 as an example.
(1) Unique ID register address and readout method
The 128-bit Unique ID can be read directly through the FSP API ""R_BSP_UniqueIdGet"".
Refer to the following command:
const bsp_unique_id_t* unique_id = R_BSP_UniqueIdGet();
const bsp_unique_id_t* unique_id = R_BSP_UniqueIdGet();
(2) Part Number register address and readout method
There is no API in FSP to read Part Numbers, so the following code is required.
First, define the address of the Part Number register and store the struct of the Part Number array.
#define BSP_FEATURE_BSP_PART_NUMBER_POINTER (0x01001C10U)
typedef struct st_bsp_part_number
{
    union
    {
        uint32_t part_number_words[4];
        uint8_t  part_number_bytes[16];
    };
} bsp_part_number_t;
Then execute the following command in the user code to read out the Part Number.
const bsp_part_number_t* part_number = BSP_FEATURE_BSP_PART_NUMBER_POINTER;
const bsp_part_number_t* part_number = BSP_FEATURE_BSP_PART_NUMBER_POINTER;
(3) MCU Version register address and readout method
There is no API to read the MCU version in the FSP, so the following code is required.
First, define the address of the MCU Version register:
#define BSP_FEATURE_BSP_MASK_REVISION_POINTER (0x01001C20U)
Then run the following command in the user code to read out the MCU Version.
const uint8_t* mask_version = BSP_FEATURE_BSP_MASK_REVISION_POINTER;
const uint8_t* mask_version = BSP_FEATURE_BSP_MASK_REVISION_POINTER;
The following results are read out in the debug state (RA2L1 is used as an example):
The product model is written in ASCII code, and the RA2L1 is used as an example to illustrate the following.
Address : 0x0100_1C0F  <->  0x0100_1C00
Address : 0x0100_1C0F  <->  0x0100_1C00
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
xx
Address : 0x0100_1C1F  <->  0x0100_1C10
Part number : R7FA2L1AB2DFP case
Address : 0x0100_1C1F  <->  0x0100_1C10

Part number : R7FA2L1AB2DFP case

space
space
space
space
space
space
R
R
7
7
F
F
A
A
2
2
L
L
1
1
A
A
B
B
2
2
D
D
F
F
P
P
0x20
0x20
0x20
0x20
0x20
0x20
0x52
0x52
0x37
0x37
0x46
0x46
0x41
0x41
0x32
0x32
0x4C
0x4C
0x31
0x31
0x41
0x41
0x42
0x42
0x32
0x32
0x44
0x44
0x46
0x46
0x50
0x50
Address : 0x0100_1C1F  <->  0x0100_1C10
Part number : R7FA2L1AB2DFM case
Address : 0x0100_1C1F  <->  0x0100_1C10

Part number : R7FA2L1AB2DFM case

space
space
space
space
space
space
R
R
7
7
F
F
A
A
2
2
L
L
1
1
A
A
B
B
2
2
D
D
F
F
M
M
0x20
0x20
0x20
0x20
0x20
0x20
0x52
0x52
0x37
0x37
0x46
0x46
0x41
0x41
0x32
0x32
0x4C
0x4C
0x31
0x31
0x41
0x41
0x42
0x42
0x32
0x32
0x44
0x44
0x46
0x46
0x4D
0x4D
Address : 0x0100_1C2F  <->  0x0100_1C20
Address : 0x0100_1C2F  <->  0x0100_1C20
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
~
0xFF
0xFF
0xFF
0xFF
0xFF
0xFF
0x01
0x01
Suitable Products
RA","['data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/022ea4391fdab4bfe20bacbaab096253.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/537533407aa4c811e0635ddb92055094.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/84f145e865ab8df4d545bc49d0a26588.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/b9e58503fbcc3997ec396a27d5e84610.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/7b90d83182253db54f83b490d14dd3ed.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/d30a4927e87e9142b7a058b6912818aa.png', 'data/categories/ra_family/ra_hardware/f66b80baf9e191ca337d2ca1466fc28f/images/9d3953580a05769fbbff05450164a87c.png']",[],"['|  |\n|  |\n| project | RA2E1/RA2E2/RA2L1 | RA2A1/RA4M1/RA4W1/RA6M1/RA6M2/RA6M3/RA6T1 | RA4M2/RA4M3/RA6M4/RA6M5/RA6T2/RA4E1/ RA6E1 |\n| Unique ID (16bytes) | 0x0100_1C00 | FMIFRT+14h (0x407F_B1B0) | 0x0100_8190 |\n| Part number (16bytes) | 0x0100_1C10 | FMIFRT+24h (0x407F_B1C0) | 0x0100_80F0 |\n| Mask version (1byte) | 0x0100_1C20 | FMIFRT+44h (0x407F_B1E0) | 0x0100_81B0 |\n| FMIFRT* | No | Yes | No |', '|  |\n|  |\n| Address : 0x0100_1C0F  <->  0x0100_1C00 |\n| xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx | xx |\n| Address : 0x0100_1C1F  <->  0x0100_1C10\nPart number : R7FA2L1AB2DFP case |\n| space | space | space | R | 7 | F | A | 2 | L | 1 | A | B | 2 | D | F | P |\n| 0x20 | 0x20 | 0x20 | 0x52 | 0x37 | 0x46 | 0x41 | 0x32 | 0x4C | 0x31 | 0x41 | 0x42 | 0x32 | 0x44 | 0x46 | 0x50 |\n| Address : 0x0100_1C1F  <->  0x0100_1C10\nPart number : R7FA2L1AB2DFM case |\n| space | space | space | R | 7 | F | A | 2 | L | 1 | A | B | 2 | D | F | M |\n| 0x20 | 0x20 | 0x20 | 0x52 | 0x37 | 0x46 | 0x41 | 0x32 | 0x4C | 0x31 | 0x41 | 0x42 | 0x32 | 0x44 | 0x46 | 0x4D |\n| Address : 0x0100_1C2F  <->  0x0100_1C20 |\n| ~ | ~ | ~ | ~ | ~ | ~ | ~ | ~ | ~ | ~ | ~ | ~ | 0xFF | 0xFF | 0xFF | 0x01 |', '|  |\n|  |\n| RA |']","{'title': 'About how RA MCU reads Unique ID and Device Part Number', 'url': 'https://en-support.renesas.com/knowledgeBase/21397541', 'last_updated': None, 'extracted_at': '2025-03-08T23:14:12.060291'}","For the applications such as the Internet of Things or product version management, reading the information of an MCU is a common task for developers. This topic describes how to read the Unique ID, Part Number, and Mask Version information on Renesas RA Family microcontrollers. We can obtain information using the content stored in the following three addresses, which are located as shown below project RA2E1/RA2E2/RA2L1 RA2A1/RA4M1/RA4W1/RA6M1/RA6M2/RA6M3/RA6T1 RA4M2/RA4M3/RA6M4/RA6M5/RA6T2/RA4E1/ RA6E1 Unique ID (16bytes) 0x01001C00 FMIFRT14h (0x407FB1B0) 0x01008190 Part number (16bytes) 0x01001C10 FMIFRT24h (0x407FB1C0) 0x010080F0 Mask version (1byte) 0x01001C20 FMIFRT44h (0x407FB1E0) 0x010081B0 FMIFRT No Yes No Note The address of the FMIFRT register is 0x407FB19C. About FMIFRT registers FMIRT register is built into RA2A1, RA4M1, RA4W1, RA6M1, RA6M2, RA6M3, and RA6T1. FMIFRT is a read-only register that stores the base addresses of the Unique ID register, Part Number register, and MCU Version register. FMIFRT should be read in 32-bit units. The address of the FMIFRT register is 0x407FB19C. The following steps describe how to read out the Unique ID, Part Number, and Mask Version through the program code, using the RA2L1 as an example. (1) Unique ID register address and readout method The 128-bit Unique ID can be read directly through the FSP API ""RBSPUniqueIdGet"". Refer to the following command const bspuniqueidt uniqueid  RBSPUniqueIdGet(); (2) Part Number register address and readout method There is no API in FSP to read Part Numbers, so the following code is required. First, define the address of the Part Number register and store the struct of the Part Number array. define BSPFEATUREBSPPARTNUMBERPOINTER (0x01001C10U) typedef struct stbsppartnumber  union  uint32t partnumberwords4; uint8t partnumberbytes16; ;  bsppartnumbert; Then execute the following command in the user code to read out the Part Number. const bsppartnumbert partnumber  BSPFEATUREBSPPARTNUMBERPOINTER; (3) MCU Version register address and readout method There is no API to read the MCU version in the FSP, so the following code is required. First, define the address of the MCU Version register define BSPFEATUREBSPMASKREVISIONPOINTER (0x01001C20U) Then run the following command in the user code to read out the MCU Version. const uint8t maskversion  BSPFEATUREBSPMASKREVISIONPOINTER; The following results are read out in the debug state (RA2L1 is used as an example) The product model is written in ASCII code, and the RA2L1 is used as an example to illustrate the following. Address  0x01001C0F - 0x01001C00 xx Address  0x01001C1F - 0x01001C10 Part number  R7FA2L1AB2DFP case space R 7 F A 2 L 1 B D P 0x20 0x52 0x37 0x46 0x41 0x32 0x4C 0x31 0x42 0x44 0x50 Part number  R7FA2L1AB2DFM case M 0x4D Address  0x01001C2F - 0x01001C20  0xFF 0x01 Suitable Products RA  Part number  R7FA2L1AB2DFP case  Part number  R7FA2L1AB2DFM case",
5561a6e66e0edc7cbca9ffd52dd4046a,"Is it possible to set the TrustZone boundaries runtime?
In general for most RA MCUs, that are using a Cortex-M33 core the TrustZone boundaries cannot be changed in the firmware. And the MCUs need to be placed in either SCI or USB boot mode. However for the new E-devices like RA4E2 and RA6E2 the Trustzone boundaries can be set runtime by writing to the following registers:
Resources:
RA4E2 Group User's Manual: Hardware
RA6E2 Group User's Manual: Hardware
Suitable Products
RA4E2,RA6E2
RA4E2,RA6E2",['data/categories/ra_family/ra4__ra6_series_with_cortex-m33_core/5561a6e66e0edc7cbca9ffd52dd4046a/images/cf217399d110bbb321daa81472775099.png'],[],[],"{'title': 'RA4E2, RA6E2: Is it possible to set the TrustZone boundaries runtime?', 'url': 'https://en-support.renesas.com/knowledgeBase/21671949', 'last_updated': None, 'extracted_at': '2025-03-08T23:30:48.616301'}","Is it possible to set the TrustZone boundaries runtime? In general for most RA MCUs, that are using a Cortex-M33 core the TrustZone boundaries cannot be changed in the firmware. And the MCUs need to be placed in either SCI or USB boot mode. However for the new E-devices like RA4E2 and RA6E2 the Trustzone boundaries can be set runtime by writing to the following registers Resources RA4E2 Group User's Manual Hardware RA6E2 Group User's Manual Hardware Suitable Products RA4E2,RA6E2",
09ec298bc3147151544a700b17aace92,"The RA2 Series have available the SCI boot mode. The SCI boot mode is a state where the on-chip flash memory routine (SCI boot program), stored in the boot area within the MCU is used. In this mode the host sends some commands to do some basic operations like programming, erasing the flash memory (code and data flash) etc.
To put the MCU on this state you need to drive the MD pin (P201) to low level. For example, on EK-RA2L1 you need to close jumper J16.
The MCU will enter the boot mode only when the MD pin is held low on release from reset state.
To use the SCI boot mode SCI channel 9 must be used (SCI9).  Below you can find the pins used to communicate with the device in boot mode through 2-Wire UART interface to make basic operations.
To program the flash memory with Renesas Flash Programmer you need to use a USB to UART bridge and make the connections described below:
TXD (USB to UART bridge) ->RXD9 (P110)
RXD (USB to UART bridge) -> TXD9 (P109)
In Renesas Flash Programmer create a new project and set the Communication Settings as shown below:
And then you can select your image file to program the MCU, while being in boot mode through RFP with a USB to UART bridge only used.
You can download Renesas Flash Programmer and it's User's Manual from here:
https://www.renesas.com/en/software-tool/renesas-flash-programmer-programming-gui
Suitable Products
RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2
RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2","['data/categories/ra_family/ra2_series_with_cortex-m23_core/09ec298bc3147151544a700b17aace92/images/9804d5dcd04187b7ab818a6f3e807918.png', 'data/categories/ra_family/ra2_series_with_cortex-m23_core/09ec298bc3147151544a700b17aace92/images/53bb3b2b44b3ab27ef73c24b8648e414.png', 'data/categories/ra_family/ra2_series_with_cortex-m23_core/09ec298bc3147151544a700b17aace92/images/10b688a0258a8c93958b783457d9c8d8.png', 'data/categories/ra_family/ra2_series_with_cortex-m23_core/09ec298bc3147151544a700b17aace92/images/a916005241c85fa3432720a0d82a0fba.png', 'data/categories/ra_family/ra2_series_with_cortex-m23_core/09ec298bc3147151544a700b17aace92/images/9903db08771cb3575f6a776b316255ae.png']",[],[],"{'title': 'Using SCI Boot with RA2 and RFP.', 'url': 'https://en-support.renesas.com/knowledgeBase/21676626', 'last_updated': None, 'extracted_at': '2025-03-08T23:31:57.397554'}","The RA2 Series have available the SCI boot mode. The SCI boot mode is a state where the on-chip flash memory routine (SCI boot program), stored in the boot area within the MCU is used. In this mode the host sends some commands to do some basic operations like programming, erasing the flash memory (code and data flash) etc. To put the MCU on this state you need to drive the MD pin (P201) to low level. For example, on EK-RA2L1 you need to close jumper J16. The MCU will enter the boot mode only when the MD pin is held low on release from reset state. To use the SCI boot mode SCI channel 9 must be used (SCI9). Below you can find the pins used to communicate with the device in boot mode through 2-Wire UART interface to make basic operations. To program the flash memory with Renesas Flash Programmer you need to use a USB to UART bridge and make the connections described below TXD (USB to UART bridge) -RXD9 (P110) RXD (USB to UART bridge) - TXD9 (P109) In Renesas Flash Programmer create a new project and set the Communication Settings as shown below And then you can select your image file to program the MCU, while being in boot mode through RFP with a USB to UART bridge only used. You can download Renesas Flash Programmer and it's User's Manual from here https//www.renesas.com/en/software-tool/renesas-flash-programmer-programming-gui Suitable Products RA2E1,RA2L1,RA2E2,RA2A1,RA2E3,RA2A2",
313b8db3b3234df44b7220c593992b46,"Question:
How to generate a complementary/push-pull PWM signal
Answer:
The GPT (general purpose timer  r_gpt) module can be used to generate complementary/push-pull PWM signals.
The below reference example configuration generates two complementary PWM signals with a 10Khz frequency-
GPT mode and frequency:


Pin state configuration:


The timer output pins generate two complementary PWM signal waveforms of 10Khz as shown below:


Suitable Products
RA Family
How to generate a complementary/push-pull PWM signal
How to generate a complementary/push-pull PWM signal
Answer:
The GPT (general purpose timer  r_gpt) module can be used to generate complementary/push-pull PWM signals.
The below reference example configuration generates two complementary PWM signals with a 10Khz frequency-
GPT mode and frequency:


Pin state configuration:


The timer output pins generate two complementary PWM signal waveforms of 10Khz as shown below:


Suitable Products
RA Family
The GPT (general purpose timer  r_gpt) module can be used to generate complementary/push-pull PWM signals.
The below reference example configuration generates two complementary PWM signals with a 10Khz frequency-
GPT mode and frequency:


Pin state configuration:


The timer output pins generate two complementary PWM signal waveforms of 10Khz as shown below:
The GPT (general purpose timer  r_gpt) module can be used to generate complementary/push-pull PWM signals.
The below reference example configuration generates two complementary PWM signals with a 10Khz frequency-
GPT mode and frequency:
Pin state configuration:
The timer output pins generate two complementary PWM signal waveforms of 10Khz as shown below:
Suitable Products
RA Family","['data/categories/ra_family/timer/313b8db3b3234df44b7220c593992b46/images/7477eea50361ae67d2bcadddead125f1.png', 'data/categories/ra_family/timer/313b8db3b3234df44b7220c593992b46/images/f199977cc2d2e4201f97b19da6005402.png', 'data/categories/ra_family/timer/313b8db3b3234df44b7220c593992b46/images/de6adabfc9961d3aed9d336b477b9927.png']",[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: How to generate a complementary/push-pull PWM signal', 'url': 'https://en-support.renesas.com/knowledgeBase/21056466', 'last_updated': None, 'extracted_at': '2025-03-08T23:40:02.135823'}",Question How to generate a complementary/push-pull PWM signal Answer The GPT (general purpose timer  rgpt) module can be used to generate complementary/push-pull PWM signals. The below reference example configuration generates two complementary PWM signals with a 10Khz frequency- GPT mode and frequency Pin state configuration The timer output pins generate two complementary PWM signal waveforms of 10Khz as shown below Suitable Products RA Family,
e4fe5104cb37e3b6e337a10b84dbd4ea,"Question:
   Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU?
  Answer:
Yes, by writing 0xFF to GTCLR register the waveform outputs will start immediatetely from zero.
    For example, for channel 0 of GPT0 timer the necessary code will be R_GPT0->GTCLR = 0xFFFFFFFF.
  Also, there is a second way, using the R_GPT_Reset() API.
    Suitable Products
RA FAMILY
Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU?
Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU?
Answer:
Yes, by writing 0xFF to GTCLR register the waveform outputs will start immediatetely from zero.
    For example, for channel 0 of GPT0 timer the necessary code will be R_GPT0->GTCLR = 0xFFFFFFFF.
  Also, there is a second way, using the R_GPT_Reset() API.
    Suitable Products
RA FAMILY
Yes, by writing 0xFF to GTCLR register the waveform outputs will start immediatetely from zero.
    For example, for channel 0 of GPT0 timer the necessary code will be R_GPT0->GTCLR = 0xFFFFFFFF.
  Also, there is a second way, using the R_GPT_Reset() API.
Yes, by writing 0xFF to GTCLR register the waveform outputs will start immediatetely from zero.
For example, for channel 0 of GPT0 timer the necessary code will be R_GPT0->GTCLR = 0xFFFFFFFF.
Also, there is a second way, using the R_GPT_Reset() API.
Suitable Products
RA FAMILY
 

","['data/categories/ra_family/timer/e4fe5104cb37e3b6e337a10b84dbd4ea/images/5b49a7fc4db0fde5bfdc3a87e72e1a12.png', 'data/categories/ra_family/timer/e4fe5104cb37e3b6e337a10b84dbd4ea/images/7b448d286912028ab03ce94455162442.png', 'data/categories/ra_family/timer/e4fe5104cb37e3b6e337a10b84dbd4ea/images/50abb2634a01c2e47b401e3c8eb847ff.png']",[],['|  |\n|  |\n| RA FAMILY |'],"{'title': 'Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU?', 'url': 'https://en-support.renesas.com/knowledgeBase/21095654', 'last_updated': None, 'extracted_at': '2025-03-08T23:40:08.482425'}","Question Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU? Answer Yes, by writing 0xFF to GTCLR register the waveform outputs will start immediatetely from zero. For example, for channel 0 of GPT0 timer the necessary code will be RGPT0-GTCLR  0xFFFFFFFF. Also, there is a second way, using the RGPTReset() API. Suitable Products RA FAMILY Is there a recommended way of producing many synchronized PWM waveforms on a RA MCU? Answer For example, for channel 0 of GPT0 timer the necessary code will be RGPT0-GTCLR  0xFFFFFFFF. Also, there is a second way, using the RGPTReset() API. Suitable Products    ",
d7990364595fa35ac98b1796d83f6efe,"Issue:
After calling the FreeRTOS_IPInit API and setting  the static IP of the device and the initial MAC address. You call the FreeRTOS_UpdateMACAddress API to set the new MAC address.
Even though you can see the new MAC address being assigned to the device with the initial static IP address you have set. You are not able to ping  with the new MAC address set.
Answer:
The issue is the fact that even though the MAC address has been updated after the FreeRTOS_UpdateMACAddress API call. The hardware is still listening on the old MAC address. To solve this problem, you should also update the MAC address for the ethernet peripheral. You should set the new MAC address into the configuration structure of the ethernet instance in your code.
If you navigate the common_data.c file under the ra_gen directory, you will see that there is a configuration structure for the ethernet peripheral holding inside the MAC address set for the device:
As you can see the MAC address in this structure, is set depending on the value of g_ether0_mac_address table also declared on the same file:
This variable holds the contents of  the setting for the MAC address users set on r_ether stack properties in Stacks Tab:
To change the MAC address for the ethernet peripheral you should declare again the table g_ether0_mac_address as extern in the file you want to make the changes. Update its contents with the new physical address and then de-initialize the ethernet peripheral and re-initialize it with the new MAC adress now set:
As soon as this change is done, the device keeping the initial static IP address can ping also with the new MAC address set, other devices in the same network:
Source:  https://community.renesas.com/mcu-mpu/ra/f/forum/33669/change-mac-address-in-ra6m5-microcontroller-during-runtime-after-freertos_ipinit-api-call/119993#119993
Suitable Products
Suitable Products
Suitable Products","['data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/6dd0b9e10ee506b3e5712b384ac87248.png', 'data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/954307efcdf1a4fa24ebb52469297296.png', 'data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/0a2cc705763f0b9aae79a98e4fed7cc5.png', 'data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/6690044c1e3654fd9851452e93047ab9.png', 'data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/033336ffcd445a485d7a35357b32ba62.png', 'data/categories/ra_family/ethernet/d7990364595fa35ac98b1796d83f6efe/images/c8d2aef5311a6b13988b0123e44de9d3.png']",[],['|  |\n|  |\n| RA / FSP |'],"{'title': 'RA Family: How to change the MAC address of the device runtime using FreeRTOS+TCP', 'url': 'https://en-support.renesas.com/knowledgeBase/21297051', 'last_updated': None, 'extracted_at': '2025-03-08T23:35:16.886376'}","Issue After calling the FreeRTOSIPInit API and setting the static IP of the device and the initial MAC address. You call the FreeRTOSUpdateMACAddress API to set the new MAC address. Even though you can see the new MAC address being assigned to the device with the initial static IP address you have set. You are not able to ping with the new MAC address set. Answer The issue is the fact that even though the MAC address has been updated after the FreeRTOSUpdateMACAddress API call. The hardware is still listening on the old MAC address. To solve this problem, you should also update the MAC address for the ethernet peripheral. You should set the new MAC address into the configuration structure of the ethernet instance in your code. If you navigate the commondata.c file under the ragen directory, you will see that there is a configuration structure for the ethernet peripheral holding inside the MAC address set for the device As you can see the MAC address in this structure, is set depending on the value of gether0macaddress table also declared on the same file This variable holds the contents of the setting for the MAC address users set on rether stack properties in Stacks Tab To change the MAC address for the ethernet peripheral you should declare again the table gether0macaddress as extern in the file you want to make the changes. Update its contents with the new physical address and then de-initialize the ethernet peripheral and re-initialize it with the new MAC adress now set As soon as this change is done, the device keeping the initial static IP address can ping also with the new MAC address set, other devices in the same network Source https//community.renesas.com/mcu-mpu/ra/f/forum/33669/change-mac-address-in-ra6m5-microcontroller-during-runtime-after-freertosipinit-api-call/119993119993 Suitable Products",
5e2f6446153730f385081f39a48c4a47,"Overview:
Some RA MCUs requires special placement of Code/RAM for proper operation. One example is RAM allocation in the RA6M4 when an ethernet peripheral is used.  The EDMAC peripheral is designed for non-secure operation, so RAM buffer allocated to it needs to be placed in non-secure RAM.
This RAM assignment is accomplished by adding instructions in linker script to move the location counter for .ns_buffer (non-secure buffer) towards the end of RAM, as illustrated below.
Normally RAM is allocation from the start of RAM location.
For an MCU with CMSE (Cortex Microcomputer Security Extension, aka TrustZone), the secure and NSC regions are allocated first.  The remainder are assigned to non-secure.  For a flat project (MCU with CMSE) the ethernet buffers are allocated from the top of RAM while the rest of RAM are allocated from the start of RAM.
When RAM use exceeds the available RAM, the linker will prompt with an error message, of the form RAM region overflowed by xyz bytes.
In the case of a flat project with ethernet, a different error message is seen, of the form ../arm-none-eabi/bin/ld.exe:fsp.ld:622 cannot move location counter backwards (from 20036d70 to 2002c900)
Check your RAM assignments and reduce them where possible.  If further RAM reduction is not possible, please consider another MCU with larger RAM.
Some RA MCUs requires special placement of Code/RAM for proper operation. One example is RAM allocation in the RA6M4 when an ethernet peripheral is used.  The EDMAC peripheral is designed for non-secure operation, so RAM buffer allocated to it needs to be placed in non-secure RAM.
This RAM assignment is accomplished by adding instructions in linker script to move the location counter for .ns_buffer (non-secure buffer) towards the end of RAM, as illustrated below.
Normally RAM is allocation from the start of RAM location.
For an MCU with CMSE (Cortex Microcomputer Security Extension, aka TrustZone), the secure and NSC regions are allocated first.  The remainder are assigned to non-secure.  For a flat project (MCU with CMSE) the ethernet buffers are allocated from the top of RAM while the rest of RAM are allocated from the start of RAM.
When RAM use exceeds the available RAM, the linker will prompt with an error message, of the form RAM region overflowed by xyz bytes.
In the case of a flat project with ethernet, a different error message is seen, of the form ../arm-none-eabi/bin/ld.exe:fsp.ld:622 cannot move location counter backwards (from 20036d70 to 2002c900)
Check your RAM assignments and reduce them where possible.  If further RAM reduction is not possible, please consider another MCU with larger RAM.
Some RA MCUs requires special placement of Code/RAM for proper operation. One example is RAM allocation in the RA6M4 when an ethernet peripheral is used.  The EDMAC peripheral is designed for non-secure operation, so RAM buffer allocated to it needs to be placed in non-secure RAM.
This RAM assignment is accomplished by adding instructions in linker script to move the location counter for .ns_buffer (non-secure buffer) towards the end of RAM, as illustrated below.
Normally RAM is allocation from the start of RAM location.
For an MCU with CMSE (Cortex Microcomputer Security Extension, aka TrustZone), the secure and NSC regions are allocated first.  The remainder are assigned to non-secure.  For a flat project (MCU with CMSE) the ethernet buffers are allocated from the top of RAM while the rest of RAM are allocated from the start of RAM.
When RAM use exceeds the available RAM, the linker will prompt with an error message, of the form RAM region overflowed by xyz bytes.
In the case of a flat project with ethernet, a different error message is seen, of the form ../arm-none-eabi/bin/ld.exe:fsp.ld:622 cannot move location counter backwards (from 20036d70 to 2002c900)
Check your RAM assignments and reduce them where possible.  If further RAM reduction is not possible, please consider another MCU with larger RAM.
Suitable Products
RA6M4, RA6M5
Suitable Products
Suitable Products
RA6M4, RA6M5","['data/categories/ra_family/rafsp_knowledge_base/5e2f6446153730f385081f39a48c4a47/images/791cc8e036aa3ca0b04e3736e2721aa8.png', 'data/categories/ra_family/rafsp_knowledge_base/5e2f6446153730f385081f39a48c4a47/images/eca247e8a98c19dfef25af357547c8a2.png', 'data/categories/ra_family/rafsp_knowledge_base/5e2f6446153730f385081f39a48c4a47/images/58c1c1c42c9aaeda3959031ccf69d354.png']",[],"['|  |\n|  |\n| RA6M4, RA6M5 |']","{'title': 'RA Family: How can I resolve the linker error message cannot move location counter backwards when using the GCC toolchain', 'url': 'https://en-support.renesas.com/knowledgeBase/21618620', 'last_updated': '2024-04-10', 'extracted_at': '2025-03-08T23:23:25.772226'}","Overview Some RA MCUs requires special placement of Code/RAM for proper operation. One example is RAM allocation in the RA6M4 when an ethernet peripheral is used. The EDMAC peripheral is designed for non-secure operation, so RAM buffer allocated to it needs to be placed in non-secure RAM. This RAM assignment is accomplished by adding instructions in linker script to move the location counter for .nsbuffer (non-secure buffer) towards the end of RAM, as illustrated below. Normally RAM is allocation from the start of RAM location. For an MCU with CMSE (Cortex Microcomputer Security Extension, aka TrustZone), the secure and NSC regions are allocated first. The remainder are assigned to non-secure. For a flat project (MCU with CMSE) the ethernet buffers are allocated from the top of RAM while the rest of RAM are allocated from the start of RAM. When RAM use exceeds the available RAM, the linker will prompt with an error message, of the form RAM region overflowed by xyz bytes. In the case of a flat project with ethernet, a different error message is seen, of the form ../arm-none-eabi/bin/ld.exefsp.ld622 cannot move location counter backwards (from 20036d70 to 2002c900) Check your RAM assignments and reduce them where possible. If further RAM reduction is not possible, please consider another MCU with larger RAM. Suitable Products RA6M4, RA6M5",
5af388624ed4857aafaf1a5bb0fb4b74,"Introduction
It can be convenient to store information in a QSPI memory instead of using up valuable MCU memory. Graphics user interfaces, can often require significant amount of memory, so storing GUI data in QSPI memory can be advantageous. This article describes several important considerations and techniques useful when locating AppWizard generated data into QSPI memory.
QSPI Memory Organization in FSP
Before you begin to add data to QSPI memory. It is important to understand where the QSPI is located within an FSP project.
1. To view the memory organization, open the linker file fsp.ld included in script folder.
2. Click on Memory tab at the bottom of the editor area to populate the window:
3. The exact value of QSPI_FLASH_START and QSPI_FLASH_LENGTH can be found in memory_regions.ld , which is generated in Debug folder.
Place AppWizard resources into QSPI flash.
To locate data in QSPI memory, we need to edit the section of the QSPI Flash memory in the linker script. Follow along with the below steps to see how it is done.
1.Open with text editor the linker script fsp.ld.
2. Figure out where the AppWizard resources are located.
3. Edit the .qspi_flash section as shown below:
4. Also, it is necessary to initialize properly the QSPI memory in your project for more details check the example project provided.
5.Dont forget to perform Clean Project and then Build Project.
Placing Individual Symbols to QSPI.
To place data in the .qspi_flash section to flash it during programming, define them using the macro BSP_PLACE_IN_SECTION().
An example project for placing AppWizard resources on EK-RA6M3G is provided below.
Suitable Products
Suitable Products
Suitable Products","['data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/fb3e009774676c930ea3b4c84395c057.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/324824be9296e86d546bce0fafdfeb13.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/bcf69ff1a24a382309b605a0278017e0.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/f2fdf06faae57f90ae6d8372abaf2797.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/881916b6ed2401b59304e4784a9ea615.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/8f759893cb50c6480354847b9d7a4bdc.png', 'data/categories/ra_family/rafsp_knowledge_base/5af388624ed4857aafaf1a5bb0fb4b74/images/a260d5805dccf892842e88c5ade86a8e.png']",[],"['|  |\n|  |\n| RA,FSP,e2studio, RA6M3G |']","{'title': 'RA Family: Storing AppWizard Resources in QSPI memory.', 'url': 'https://en-support.renesas.com/knowledgeBase/21104534', 'last_updated': None, 'extracted_at': '2025-03-08T23:19:33.853589'}","Introduction It can be convenient to store information in a QSPI memory instead of using up valuable MCU memory. Graphics user interfaces, can often require significant amount of memory, so storing GUI data in QSPI memory can be advantageous. This article describes several important considerations and techniques useful when locating AppWizard generated data into QSPI memory. QSPI Memory Organization in FSP Before you begin to add data to QSPI memory. It is important to understand where the QSPI is located within an FSP project. 1. To view the memory organization, open the linker file fsp.ld included in script folder. 2. Click on Memory tab at the bottom of the editor area to populate the window 3. The exact value of QSPIFLASHSTART and QSPIFLASHLENGTH can be found in memoryregions.ld , which is generated in Debug folder. Place AppWizard resources into QSPI flash. To locate data in QSPI memory, we need to edit the section of the QSPI Flash memory in the linker script. Follow along with the below steps to see how it is done. 1.Open with text editor the linker script fsp.ld. 2. Figure out where the AppWizard resources are located. 3. Edit the .qspiflash section as shown below 4. Also, it is necessary to initialize properly the QSPI memory in your project for more details check the example project provided. 5.Dont forget to perform Clean Project and then Build Project. Placing Individual Symbols to QSPI. To place data in the .qspiflash section to flash it during programming, define them using the macro BSPPLACEINSECTION(). An example project for placing AppWizard resources on EK-RA6M3G is provided below. Suitable Products",
1048b8716f42024df89ed0789dd3d804,"Answer:
When the DRW Engine Support is Enabled, there must be enough heap memory (set by Heap size in the FSP Configurator BSP tab properties) to match the value set for MAX DRW Operations.  This is because the DRW Engine prepares a display list, which is a collection of rendering operations, and performs the drawing process, but this display list is placed in the heap area of memory.
The FSP User's Manual contains notes on MAX DRW Operations settings.
Max DRW Operations
Specifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance.
  Suitable Products
RA Family
Answer:
When the DRW Engine Support is Enabled, there must be enough heap memory (set by Heap size in the FSP Configurator BSP tab properties) to match the value set for MAX DRW Operations.  This is because the DRW Engine prepares a display list, which is a collection of rendering operations, and performs the drawing process, but this display list is placed in the heap area of memory.
The FSP User's Manual contains notes on MAX DRW Operations settings.
Max DRW Operations
Specifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance.
  Suitable Products
RA Family
When the DRW Engine Support is Enabled, there must be enough heap memory (set by Heap size in the FSP Configurator BSP tab properties) to match the value set for MAX DRW Operations.  This is because the DRW Engine prepares a display list, which is a collection of rendering operations, and performs the drawing process, but this display list is placed in the heap area of memory.
The FSP User's Manual contains notes on MAX DRW Operations settings.
Max DRW Operations
Specifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance.
When the DRW Engine Support is Enabled, there must be enough heap memory (set by Heap size in the FSP Configurator BSP tab properties) to match the value set for MAX DRW Operations.  This is because the DRW Engine prepares a display list, which is a collection of rendering operations, and performs the drawing process, but this display list is placed in the heap area of memory.
The FSP User's Manual contains notes on MAX DRW Operations settings.
Max DRW Operations
Specifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance.
Suitable Products
RA Family

","['data/categories/ra_family/rafsp_knowledge_base/1048b8716f42024df89ed0789dd3d804/images/46ca31726f2b9b5b7cf090fd7e0bc8dc.png', 'data/categories/ra_family/rafsp_knowledge_base/1048b8716f42024df89ed0789dd3d804/images/43746fbb15022b5f8c3ef73a044b91bc.png']",[],"['|  |\n|  |\n| Max DRW Operations\nSpecifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance. |', '|  |\n|  |\n| RA Family |']","{'title': 'RA Family: Graphics drawing process using GUIX does not work properly', 'url': 'https://en-support.renesas.com/knowledgeBase/21652596', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:18.835137'}","Answer When the DRW Engine Support is Enabled, there must be enough heap memory (set by Heap size in the FSP Configurator BSP tab properties) to match the value set for MAX DRW Operations. This is because the DRW Engine prepares a display list, which is a collection of rendering operations, and performs the drawing process, but this display list is placed in the heap area of memory. The FSP User's Manual contains notes on MAX DRW Operations settings. Max DRW Operations Specifies the maximum number of DRW operations before flushing the display list. Reducing this value may reduce the peak heap used by the application but may reduce performance. Suitable Products RA Family Suitable Products ",
11e79377143e719f1f29cc5244404567,"Question:
How to Debug Code from a Specified Address in Renesas RA MCUs - IAR
Answer:
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use IAR as an example.
1. Linker script file (code writing phase).
To modify the linker script, take the memory_regions.icf file as an example, FLASH_START the basic offset address is 0 by default when the code is compiled, and the target offset address of the application is changed to the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000 as seen below.
  2. Debug Configuration Settings (Code Debugging Phase)
Modify the settings in Debugger > Extra Options, as shown in the following figure.
  As shown in the following figure, when you jump to the main() function, the address is at 0x4fd0.
Suitable Products
RA
How to Debug Code from a Specified Address in Renesas RA MCUs - IAR
How to Debug Code from a Specified Address in Renesas RA MCUs - IAR
Answer:
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use IAR as an example.
1. Linker script file (code writing phase).
To modify the linker script, take the memory_regions.icf file as an example, FLASH_START the basic offset address is 0 by default when the code is compiled, and the target offset address of the application is changed to the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000 as seen below.
  2. Debug Configuration Settings (Code Debugging Phase)
Modify the settings in Debugger > Extra Options, as shown in the following figure.
  As shown in the following figure, when you jump to the main() function, the address is at 0x4fd0.
Suitable Products
RA
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use IAR as an example.
1. Linker script file (code writing phase).
To modify the linker script, take the memory_regions.icf file as an example, FLASH_START the basic offset address is 0 by default when the code is compiled, and the target offset address of the application is changed to the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000 as seen below.
2. Debug Configuration Settings (Code Debugging Phase)
Modify the settings in Debugger > Extra Options, as shown in the following figure.
As shown in the following figure, when you jump to the main() function, the address is at 0x4fd0.
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/11e79377143e719f1f29cc5244404567/images/aee31b448c849f7ddcdc961107b1dd14.png', 'data/categories/ra_family/rafsp_knowledge_base/11e79377143e719f1f29cc5244404567/images/67d9357bdfeafe8862b601fb5bf4dbb3.png', 'data/categories/ra_family/rafsp_knowledge_base/11e79377143e719f1f29cc5244404567/images/ec735d80928f030183d99de0543afc5e.png', 'data/categories/ra_family/rafsp_knowledge_base/11e79377143e719f1f29cc5244404567/images/69c1817e6079ab977ab23c6744653497.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'How to Debug Code from a Specified Address in Renesas RA MCUs - IAR', 'url': 'https://en-support.renesas.com/knowledgeBase/21172751', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:57.998604'}","Question How to Debug Code from a Specified Address in Renesas RA MCUs - IAR Answer For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged. To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use IAR as an example. 1. Linker script file (code writing phase). To modify the linker script, take the memoryregions.icf file as an example, FLASHSTART the basic offset address is 0 by default when the code is compiled, and the target offset address of the application is changed to the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000 as seen below. 2. Debug Configuration Settings (Code Debugging Phase) Modify the settings in Debugger  Extra Options, as shown in the following figure. As shown in the following figure, when you jump to the main() function, the address is at 0x4fd0. Suitable Products RA 2. Debug Configuration Settings (Code Debugging Phase) As shown in the following figure, when you jump to the main() function, the address is at 0x4fd0.",
2be83d1dbe128835e4d96b9d4c726fc1,"The GCC compiler can generate .elf, .srec or .bin files.  Typically .elf file are used for debugging whereas .srec/.bin files are sent to the flash programmer for downloading to MCUs.  The advantage of using .bin over .srec file is that .bin files are  smaller, and can be further manipulated (calculating checksum, inserting additional information) before being downloaded.  Unlike an .srec file, address information is not included in a .bin file.  Instead, the .bin image is programmed continuously from a start location (typically 0x00000000) to the last location as specified in the linker script. The last location could be an option setting area. E.g., for RA6M4, code flash 0x00000000-0x000FFFFF while the option settings occupied 0x0100A100~0x0100A2FF.
    Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x0~0x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area.  If these areas are programmed, the chip could be damaged!
If a .bin file must be used, please check the target location and the size of the file generated.  If necessary, please omit the option setting area. This can be done by adding (NOLOAD) to the linker script, fsp.ld.
  .id_code (NOLOAD):
  .option_setting_ofs (NOLOAD):
{
} > OPTION_SETTING_OFS = 0xFF
  .option_setting_sas (NOLOAD):
{
} > OPTION_SETTING_SAS = 0xFF
  .option_setting_ns (NOLOAD):
{
} > OPTION_SETTING = 0xFF
  .option_setting_s (NOLOAD):
{
} > OPTION_SETTING_S = 0xFF
  Suitable Products
RA and FSP
The GCC compiler can generate .elf, .srec or .bin files.  Typically .elf file are used for debugging whereas .srec/.bin files are sent to the flash programmer for downloading to MCUs.  The advantage of using .bin over .srec file is that .bin files are  smaller, and can be further manipulated (calculating checksum, inserting additional information) before being downloaded.  Unlike an .srec file, address information is not included in a .bin file.  Instead, the .bin image is programmed continuously from a start location (typically 0x00000000) to the last location as specified in the linker script. The last location could be an option setting area. E.g., for RA6M4, code flash 0x00000000-0x000FFFFF while the option settings occupied 0x0100A100~0x0100A2FF.
    Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x0~0x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area.  If these areas are programmed, the chip could be damaged!
If a .bin file must be used, please check the target location and the size of the file generated.  If necessary, please omit the option setting area. This can be done by adding (NOLOAD) to the linker script, fsp.ld.
  .id_code (NOLOAD):
  .option_setting_ofs (NOLOAD):
{
} > OPTION_SETTING_OFS = 0xFF
  .option_setting_sas (NOLOAD):
{
} > OPTION_SETTING_SAS = 0xFF
  .option_setting_ns (NOLOAD):
{
} > OPTION_SETTING = 0xFF
  .option_setting_s (NOLOAD):
{
} > OPTION_SETTING_S = 0xFF
  Suitable Products
RA and FSP
The GCC compiler can generate .elf, .srec or .bin files.  Typically .elf file are used for debugging whereas .srec/.bin files are sent to the flash programmer for downloading to MCUs.  The advantage of using .bin over .srec file is that .bin files are  smaller, and can be further manipulated (calculating checksum, inserting additional information) before being downloaded.  Unlike an .srec file, address information is not included in a .bin file.  Instead, the .bin image is programmed continuously from a start location (typically 0x00000000) to the last location as specified in the linker script. The last location could be an option setting area. E.g., for RA6M4, code flash 0x00000000-0x000FFFFF while the option settings occupied 0x0100A100~0x0100A2FF.
    Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x0~0x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area.  If these areas are programmed, the chip could be damaged!
If a .bin file must be used, please check the target location and the size of the file generated.  If necessary, please omit the option setting area. This can be done by adding (NOLOAD) to the linker script, fsp.ld.
  .id_code (NOLOAD):
  .option_setting_ofs (NOLOAD):
{
} > OPTION_SETTING_OFS = 0xFF
  .option_setting_sas (NOLOAD):
{
} > OPTION_SETTING_SAS = 0xFF
  .option_setting_ns (NOLOAD):
{
} > OPTION_SETTING = 0xFF
  .option_setting_s (NOLOAD):
{
} > OPTION_SETTING_S = 0xFF
  Suitable Products
The GCC compiler can generate .elf, .srec or .bin files.  Typically .elf file are used for debugging whereas .srec/.bin files are sent to the flash programmer for downloading to MCUs.  The advantage of using .bin over .srec file is that .bin files are  smaller, and can be further manipulated (calculating checksum, inserting additional information) before being downloaded.  Unlike an .srec file, address information is not included in a .bin file.  Instead, the .bin image is programmed continuously from a start location (typically 0x00000000) to the last location as specified in the linker script. The last location could be an option setting area. E.g., for RA6M4, code flash 0x00000000-0x000FFFFF while the option settings occupied 0x0100A100~0x0100A2FF.
Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x0~0x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area.  If these areas are programmed, the chip could be damaged!
If a .bin file must be used, please check the target location and the size of the file generated.  If necessary, please omit the option setting area. This can be done by adding (NOLOAD) to the linker script, fsp.ld.
.id_code (NOLOAD):
.id_code (NOLOAD):
(NOLOAD)
.option_setting_ofs (NOLOAD):
.option_setting_ofs (NOLOAD):
(NOLOAD)
{
{
} > OPTION_SETTING_OFS = 0xFF
} > OPTION_SETTING_OFS = 0xFF
.option_setting_sas (NOLOAD):
.option_setting_sas (NOLOAD):
(NOLOAD)
{
{
} > OPTION_SETTING_SAS = 0xFF
} > OPTION_SETTING_SAS = 0xFF
.option_setting_ns (NOLOAD):
.option_setting_ns (NOLOAD):
(NOLOAD)
{
{
} > OPTION_SETTING = 0xFF
} > OPTION_SETTING = 0xFF
.option_setting_s (NOLOAD):
.option_setting_s (NOLOAD):
(NOLOAD)
{
{
} > OPTION_SETTING_S = 0xFF
} > OPTION_SETTING_S = 0xFF
Suitable Products
RA and FSP
RA and FSP",['data/categories/ra_family/rafsp_knowledge_base/2be83d1dbe128835e4d96b9d4c726fc1/images/f140d228c0d295615d775f682961231e.png'],[],"['|  |\n|  |\n| .id_code (NOLOAD):\n  .option_setting_ofs (NOLOAD):\n{\n} > OPTION_SETTING_OFS = 0xFF\n  .option_setting_sas (NOLOAD):\n{\n} > OPTION_SETTING_SAS = 0xFF\n  .option_setting_ns (NOLOAD):\n{\n} > OPTION_SETTING = 0xFF\n  .option_setting_s (NOLOAD):\n{\n} > OPTION_SETTING_S = 0xFF |', '|  |\n|  |\n| RA and FSP |']","{'title': 'Caution when programming a bin file with FSP and RA Family', 'url': 'https://en-support.renesas.com/knowledgeBase/21073658', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:20.000888'}","The GCC compiler can generate .elf, .srec or .bin files. Typically .elf file are used for debugging whereas .srec/.bin files are sent to the flash programmer for downloading to MCUs. The advantage of using .bin over .srec file is that .bin files are smaller, and can be further manipulated (calculating checksum, inserting additional information) before being downloaded. Unlike an .srec file, address information is not included in a .bin file. Instead, the .bin image is programmed continuously from a start location (typically 0x00000000) to the last location as specified in the linker script. The last location could be an option setting area. E.g., for RA6M4, code flash 0x00000000-0x000FFFFF while the option settings occupied 0x0100A1000x0100A2FF. Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x00x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area. If these areas are programmed, the chip could be damaged! If a .bin file must be used, please check the target location and the size of the file generated. If necessary, please omit the option setting area. This can be done by adding (NOLOAD) to the linker script, fsp.ld. .idcode (NOLOAD) .optionsettingofs (NOLOAD)    OPTIONSETTINGOFS  0xFF .optionsettingsas (NOLOAD)   OPTIONSETTINGSAS  0xFF .optionsettingns (NOLOAD)   OPTIONSETTING  0xFF .optionsettings (NOLOAD)   OPTIONSETTINGS  0xFF Suitable Products RA and FSP Potentially a .bin file for RA6M4 could be 16,818,944 bytes (0x00x100A2FF)! Note this area includes two reserved areas where access is prohibited and the on-chip flash (factory flash) area. If these areas are programmed, the chip could be damaged! .idcode (NOLOAD) (NOLOAD) .optionsettingofs (NOLOAD) .optionsettingsas (NOLOAD) .optionsettingns (NOLOAD) .optionsettings (NOLOAD) Suitable Products",
ba4a792be062013a3461af816b82a367,"Question:
How do I configure SPI to implement the following waveform in the manual on RA6M4?
Answer:
To achieve the waveform shown in the figure, the SPI Burst Transfer needs to be used. The specific configuration method is:
Before the last transmission, update SPCMD_b[0].SSLKP from 1 to 0. One transmission represents the number of data bits specified by the bits [11:8]-SPB[3:0] (SPI Data Length Setting) of the register SPCMDm.
Please update the SPI-related API as follows (add the content between #if 1 and #endif). The r_spi_transmit function is located in the ra\fsp\src\r_spi\r_spi.c file.
static void r_spi_transmit (spi_instance_ctrl_t * p_ctrl)
{   
    uint32_t tx_count = p_ctrl->tx_count;   
    if (tx_count == p_ctrl->count)   
    {       
        return;   
    }
#if 1   // added for burst transmit
    if (tx_count == p_ctrl->count-1)   
    {       
        p_ctrl->p_regs->SPCMD_b[0].SSLKP = 0;   
    }
#endif
  Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers.
Suitable Products
RA Family
How do I configure SPI to implement the following waveform in the manual on RA6M4?
How do I configure SPI to implement the following waveform in the manual on RA6M4?
Answer:
To achieve the waveform shown in the figure, the SPI Burst Transfer needs to be used. The specific configuration method is:
Before the last transmission, update SPCMD_b[0].SSLKP from 1 to 0. One transmission represents the number of data bits specified by the bits [11:8]-SPB[3:0] (SPI Data Length Setting) of the register SPCMDm.
Please update the SPI-related API as follows (add the content between #if 1 and #endif). The r_spi_transmit function is located in the ra\fsp\src\r_spi\r_spi.c file.
static void r_spi_transmit (spi_instance_ctrl_t * p_ctrl)
{   
    uint32_t tx_count = p_ctrl->tx_count;   
    if (tx_count == p_ctrl->count)   
    {       
        return;   
    }
#if 1   // added for burst transmit
    if (tx_count == p_ctrl->count-1)   
    {       
        p_ctrl->p_regs->SPCMD_b[0].SSLKP = 0;   
    }
#endif
  Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers.
Suitable Products
RA Family
To achieve the waveform shown in the figure, the SPI Burst Transfer needs to be used. The specific configuration method is:
Before the last transmission, update SPCMD_b[0].SSLKP from 1 to 0. One transmission represents the number of data bits specified by the bits [11:8]-SPB[3:0] (SPI Data Length Setting) of the register SPCMDm.
Please update the SPI-related API as follows (add the content between #if 1 and #endif). The r_spi_transmit function is located in the ra\fsp\src\r_spi\r_spi.c file.
static void r_spi_transmit (spi_instance_ctrl_t * p_ctrl)
{   
    uint32_t tx_count = p_ctrl->tx_count;   
    if (tx_count == p_ctrl->count)   
    {       
        return;   
    }
#if 1   // added for burst transmit
    if (tx_count == p_ctrl->count-1)   
    {       
        p_ctrl->p_regs->SPCMD_b[0].SSLKP = 0;   
    }
#endif
  Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers.
To achieve the waveform shown in the figure, the SPI Burst Transfer needs to be used. The specific configuration method is:
Before the last transmission, update SPCMD_b[0].SSLKP from 1 to 0. One transmission represents the number of data bits specified by the bits [11:8]-SPB[3:0] (SPI Data Length Setting) of the register SPCMDm.
Please update the SPI-related API as follows (add the content between #if 1 and #endif). The r_spi_transmit function is located in the ra\fsp\src\r_spi\r_spi.c file.
static void r_spi_transmit (spi_instance_ctrl_t * p_ctrl)
static
void r_spi_transmit (spi_instance_ctrl_t * p_ctrl)
{
{
uint32_t tx_count = p_ctrl->tx_count;
uint32_t tx_count = p_ctrl->tx_count;
if (tx_count == p_ctrl->count)
if
(tx_count == p_ctrl->count)
{
{
return;
return
;
}
}
#if 1   // added for burst transmit
#
if
1
// added for burst transmit
if (tx_count == p_ctrl->count-1)
if
(tx_count == p_ctrl->count-1)
{
{
p_ctrl->p_regs->SPCMD_b[0].SSLKP = 0;
p_ctrl->p_regs->SPCMD_b[0].SSLKP = 0;
}
}
#endif
#endif
Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers.
Suitable Products
RA Family
Chinese
Chinese",['data/categories/ra_family/rafsp_knowledge_base/ba4a792be062013a3461af816b82a367/images/f684a0552db7123b81872006f18af8dd.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: How to use SPI Burst Mode?', 'url': 'https://en-support.renesas.com/knowledgeBase/21789661', 'last_updated': '2025-04-02', 'extracted_at': '2025-03-08T23:22:27.544396'}","Question How do I configure SPI to implement the following waveform in the manual on RA6M4? Answer To achieve the waveform shown in the figure, the SPI Burst Transfer needs to be used. The specific configuration method is Before the last transmission, update SPCMDb0.SSLKP from 1 to 0. One transmission represents the number of data bits specified by the bits 118-SPB30 (SPI Data Length Setting) of the register SPCMDm. Please update the SPI-related API as follows (add the content between if 1 and endif). The rspitransmit function is located in the rafspsrcrspirspi.c file. static void rspitransmit (spiinstancectrlt  pctrl)  uint32t txcount  pctrl-txcount; if (txcount  pctrl-count)  return;  if 1 // added for burst transmit if (txcount  pctrl-count-1) pctrl-pregs-SPCMDb0.SSLKP  0; endif Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers. Suitable Products RA Family static void rspitransmit (spiinstancectrlt  pctrl)  uint32t txcount  pctrl-txcount; if (txcount  pctrl-count) if (txcount  pctrl-count) return; return ;   1 // added for burst transmit if (txcount  pctrl-count-1) (txcount  pctrl-count-1) pctrl-pregs-SPCMDb0.SSLKP  0; Note that if you use SPI Burst Transfer, you cannot use DTC or DMA for SPI transfers. Chinese",
b0371bfed4fabbb7167d3e2634308e2c,"To use the disassembly view you must first enable the assembly listing, using the project tool settings property, as seen in the below screen shot.
Start a debug session and the assembly file is generated in the project directory src folder, as illustrated below.
Suitable Products
Suitable Products
RA/FSP","['data/categories/ra_family/rafsp_knowledge_base/b0371bfed4fabbb7167d3e2634308e2c/images/3142b1db2834630102b01914d442691d.png', 'data/categories/ra_family/rafsp_knowledge_base/b0371bfed4fabbb7167d3e2634308e2c/images/a7ca923cb8ca79da973a822b2a942f28.png']",[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'Disassembly View for RA MCUs in FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/20078475', 'last_updated': None, 'extracted_at': '2025-03-08T23:18:19.597238'}","To use the disassembly view you must first enable the assembly listing, using the project tool settings property, as seen in the below screen shot. Start a debug session and the assembly file is generated in the project directory src folder, as illustrated below. Suitable Products RA/FSP",
a99864bca4f479357225dc1a3b28125b,"Question:
How to communicate with multiple slave devices on the same I2C bus.
Answer:
When communicating with multiple I2C slave devices on the same bus, it is necessary to switch the slave address to communicate. There are two ways to do this.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)
(2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
The following steps describe each method.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)

By using the I2C Communication Device (rm_comms_i2c), the I2C master driver can communicate with multiple slave device via the I2C Shared bus. Either the r_iic_master driver or the r_sci_i2c driver can be used as the I2C master driver. Every instance of rm_comms_i2c has a 'Slave Address' setting in its properties, which can be configured independently. When an rm_comms_i2c instance communicates with a slave I2C device, the I2C Shared Bus switches to the respective slave device and communicates with it.

When using an RTOS, rm_comms_i2c provides the following features:
Blocking operation using a mutex for RM_COMMS_I2C_Write(), RM_COMMS_I2C_Read() and RM_COMMS_I2C_WriteRead().
Bus lock using a mutex.
Here is an example. In this case, the address of the g_comms_i2c_dvice0 instance is 0x44, and the address of the g_comms_i2c_device1 is 0x55.
    Pseudo code to show how to use shared i2c bus.
// Open Each device
g_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);
g_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);
  // Call I2C Communication Device Write or Read to communicate with Device(0x44)
g_comms_i2c_device0.p_api->write(...);
g_comms_i2c_device0.p_api->read(...);
  // Call I2C Communication Device Write or Read to communicate with Device(0x55)
g_comms_i2c_device1.p_api->write(...);
g_comms_i2c_device1.p_api->read(...);
  (2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
This method creates one instance of the I2C master driver. The application then uses the slaveAddressSet API to switch the slave devices for communication. Here is an example where the addresses for the slave devices are 0x44 and 0x55.
The default slave address of the I2C master driver instance is set to 0x44 in this case.
Pseudo code to show when to use the slaveAddressSet API.
// Open
g_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);
  // Switch Slave address to 0x55
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x55)
g_i2c_master.p_api->write();
g_i2c_master.p_api->read();
  // Switch Slave address to 0x44
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x44)
g_i2c_master.p_api->write();
g_i2c_master.p_api->read();
  Suitable Products
RA
How to communicate with multiple slave devices on the same I2C bus.
How to communicate with multiple slave devices on the same I2C bus.
Answer:
When communicating with multiple I2C slave devices on the same bus, it is necessary to switch the slave address to communicate. There are two ways to do this.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)
(2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
The following steps describe each method.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)

By using the I2C Communication Device (rm_comms_i2c), the I2C master driver can communicate with multiple slave device via the I2C Shared bus. Either the r_iic_master driver or the r_sci_i2c driver can be used as the I2C master driver. Every instance of rm_comms_i2c has a 'Slave Address' setting in its properties, which can be configured independently. When an rm_comms_i2c instance communicates with a slave I2C device, the I2C Shared Bus switches to the respective slave device and communicates with it.

When using an RTOS, rm_comms_i2c provides the following features:
Blocking operation using a mutex for RM_COMMS_I2C_Write(), RM_COMMS_I2C_Read() and RM_COMMS_I2C_WriteRead().
Bus lock using a mutex.
Here is an example. In this case, the address of the g_comms_i2c_dvice0 instance is 0x44, and the address of the g_comms_i2c_device1 is 0x55.
    Pseudo code to show how to use shared i2c bus.
// Open Each device
g_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);
g_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);
  // Call I2C Communication Device Write or Read to communicate with Device(0x44)
g_comms_i2c_device0.p_api->write(...);
g_comms_i2c_device0.p_api->read(...);
  // Call I2C Communication Device Write or Read to communicate with Device(0x55)
g_comms_i2c_device1.p_api->write(...);
g_comms_i2c_device1.p_api->read(...);
  (2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
This method creates one instance of the I2C master driver. The application then uses the slaveAddressSet API to switch the slave devices for communication. Here is an example where the addresses for the slave devices are 0x44 and 0x55.
The default slave address of the I2C master driver instance is set to 0x44 in this case.
Pseudo code to show when to use the slaveAddressSet API.
// Open
g_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);
  // Switch Slave address to 0x55
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x55)
g_i2c_master.p_api->write();
g_i2c_master.p_api->read();
  // Switch Slave address to 0x44
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x44)
g_i2c_master.p_api->write();
g_i2c_master.p_api->read();
  Suitable Products
RA
When communicating with multiple I2C slave devices on the same bus, it is necessary to switch the slave address to communicate. There are two ways to do this.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)
(2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
The following steps describe each method.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)

By using the I2C Communication Device (rm_comms_i2c), the I2C master driver can communicate with multiple slave device via the I2C Shared bus. Either the r_iic_master driver or the r_sci_i2c driver can be used as the I2C master driver. Every instance of rm_comms_i2c has a 'Slave Address' setting in its properties, which can be configured independently. When an rm_comms_i2c instance communicates with a slave I2C device, the I2C Shared Bus switches to the respective slave device and communicates with it.

When using an RTOS, rm_comms_i2c provides the following features:
Blocking operation using a mutex for RM_COMMS_I2C_Write(), RM_COMMS_I2C_Read() and RM_COMMS_I2C_WriteRead().
Bus lock using a mutex.
Here is an example. In this case, the address of the g_comms_i2c_dvice0 instance is 0x44, and the address of the g_comms_i2c_device1 is 0x55.
    Pseudo code to show how to use shared i2c bus.
// Open Each device
g_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);
g_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);
  // Call I2C Communication Device Write or Read to communicate with Device(0x44)
g_comms_i2c_device0.p_api->write(...);
g_comms_i2c_device0.p_api->read(...);
  // Call I2C Communication Device Write or Read to communicate with Device(0x55)
g_comms_i2c_device1.p_api->write(...);
g_comms_i2c_device1.p_api->read(...);
  (2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
This method creates one instance of the I2C master driver. The application then uses the slaveAddressSet API to switch the slave devices for communication. Here is an example where the addresses for the slave devices are 0x44 and 0x55.
The default slave address of the I2C master driver instance is set to 0x44 in this case.
Pseudo code to show when to use the slaveAddressSet API.
// Open
g_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);
  // Switch Slave address to 0x55
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x55)
g_i2c_master.p_api->write();
g_i2c_master.p_api->read();
  // Switch Slave address to 0x44
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);
  // Call I2C Write or Read to communicate with Device(0x44)
g_i2c_master.p_api->write();
g_i2c_master.p_api->read();
When communicating with multiple I2C slave devices on the same bus, it is necessary to switch the slave address to communicate. There are two ways to do this.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)
(2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
The following steps describe each method.
(1) Use the shared bus function of the I2C Communication Device (rm_comms_i2c)

By using the I2C Communication Device (rm_comms_i2c), the I2C master driver can communicate with multiple slave device via the I2C Shared bus. Either the r_iic_master driver or the r_sci_i2c driver can be used as the I2C master driver. Every instance of rm_comms_i2c has a 'Slave Address' setting in its properties, which can be configured independently. When an rm_comms_i2c instance communicates with a slave I2C device, the I2C Shared Bus switches to the respective slave device and communicates with it.
When using an RTOS, rm_comms_i2c provides the following features:
Here is an example. In this case, the address of the g_comms_i2c_dvice0 instance is 0x44, and the address of the g_comms_i2c_device1 is 0x55.
Pseudo code to show how to use shared i2c bus.
// Open Each device
// Open Each device
g_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);
g_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);
g_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);
g_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);
// Call I2C Communication Device Write or Read to communicate with Device(0x44)
// Call I2C Communication Device Write or Read to communicate with Device(0x44)
g_comms_i2c_device0.p_api->write(...);
g_comms_i2c_device0.p_api->write(...);
g_comms_i2c_device0.p_api->read(...);
g_comms_i2c_device0.p_api->read(...);
// Call I2C Communication Device Write or Read to communicate with Device(0x55)
// Call I2C Communication Device Write or Read to communicate with Device(0x55)
g_comms_i2c_device1.p_api->write(...);
g_comms_i2c_device1.p_api->write(...);
g_comms_i2c_device1.p_api->read(...);
g_comms_i2c_device1.p_api->read(...);
(2) Switch the slave address using the slaveAddressSet API of the I2C Master driver
This method creates one instance of the I2C master driver. The application then uses the slaveAddressSet API to switch the slave devices for communication. Here is an example where the addresses for the slave devices are 0x44 and 0x55.
The default slave address of the I2C master driver instance is set to 0x44 in this case.
Pseudo code to show when to use the slaveAddressSet API.
// Open
// Open
g_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);
g_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);
// Switch Slave address to 0x55
// Switch Slave address to 0x55
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);
// Call I2C Write or Read to communicate with Device(0x55)
// Call I2C Write or Read to communicate with Device(0x55)
g_i2c_master.p_api->write();
g_i2c_master.p_api->write();
g_i2c_master.p_api->read();
g_i2c_master.p_api->read();
// Switch Slave address to 0x44
// Switch Slave address to 0x44
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);
g_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);
// Call I2C Write or Read to communicate with Device(0x44)
// Call I2C Write or Read to communicate with Device(0x44)
g_i2c_master.p_api->write();
g_i2c_master.p_api->write();
g_i2c_master.p_api->read();
g_i2c_master.p_api->read();
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/a99864bca4f479357225dc1a3b28125b/images/ff0aac27a8295db8711e768439012d33.png', 'data/categories/ra_family/rafsp_knowledge_base/a99864bca4f479357225dc1a3b28125b/images/f29a51e936e6ae9513fd7a00975c96e5.png', 'data/categories/ra_family/rafsp_knowledge_base/a99864bca4f479357225dc1a3b28125b/images/d64868d36d44647fd2ee9e59f9fb9956.png', 'data/categories/ra_family/rafsp_knowledge_base/a99864bca4f479357225dc1a3b28125b/images/2e580bd593297ef469b5117b0538ee27.png', 'data/categories/ra_family/rafsp_knowledge_base/a99864bca4f479357225dc1a3b28125b/images/c6b896f74b9aca6fc83de3770c201369.png']",[],"['|  |\n|  |\n| // Open Each device\ng_comms_i2c_device0.p_api->open(g_comms_i2c_device0.p_ctrl, g_comms_i2c_device0.p_cfg);\ng_comms_i2c_device1.p_api->open(g_comms_i2c_device1.p_ctrl, g_comms_i2c_device1.p_cfg);\n  // Call I2C Communication Device Write or Read to communicate with Device(0x44)\ng_comms_i2c_device0.p_api->write(...);\ng_comms_i2c_device0.p_api->read(...);\n  // Call I2C Communication Device Write or Read to communicate with Device(0x55)\ng_comms_i2c_device1.p_api->write(...);\ng_comms_i2c_device1.p_api->read(...); |', '|  |\n|  |\n| // Open\ng_i2c_master.p_api->open(g_i2c_master.p_ctrl, g_i2c_master.p_cfg);\n  // Switch Slave address to 0x55\ng_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x55, I2C_MASTER_ADDR_MODE_7BIT);\n  // Call I2C Write or Read to communicate with Device(0x55)\ng_i2c_master.p_api->write();\ng_i2c_master.p_api->read();\n  // Switch Slave address to 0x44\ng_i2c_master.p_api->slaveAddressSet(g_i2c_master.p_ctrl, 0x44, I2C_MASTER_ADDR_MODE_7BIT);\n  // Call I2C Write or Read to communicate with Device(0x44)\ng_i2c_master.p_api->write();\ng_i2c_master.p_api->read(); |', '|  |\n|  |\n| RA |']","{'title': 'RA Family: How to communicate with multiple slave devices on the same I2C bus.', 'url': 'https://en-support.renesas.com/knowledgeBase/21132844', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:06.353475'}","Question How to communicate with multiple slave devices on the same I2C bus. Answer When communicating with multiple I2C slave devices on the same bus, it is necessary to switch the slave address to communicate. There are two ways to do this. (1) Use the shared bus function of the I2C Communication Device (rmcommsi2c) (2) Switch the slave address using the slaveAddressSet API of the I2C Master driver The following steps describe each method. By using the I2C Communication Device (rmcommsi2c), the I2C master driver can communicate with multiple slave device via the I2C Shared bus. Either the riicmaster driver or the rscii2c driver can be used as the I2C master driver. Every instance of rmcommsi2c has a 'Slave Address' setting in its properties, which can be configured independently. When an rmcommsi2c instance communicates with a slave I2C device, the I2C Shared Bus switches to the respective slave device and communicates with it. When using an RTOS, rmcommsi2c provides the following features Blocking operation using a mutex for RMCOMMSI2CWrite(), RMCOMMSI2CRead() and RMCOMMSI2CWriteRead(). Bus lock using a mutex. Here is an example. In this case, the address of the gcommsi2cdvice0 instance is 0x44, and the address of the gcommsi2cdevice1 is 0x55. Pseudo code to show how to use shared i2c bus. // Open Each device gcommsi2cdevice0.papi-open(gcommsi2cdevice0.pctrl, gcommsi2cdevice0.pcfg); gcommsi2cdevice1.papi-open(gcommsi2cdevice1.pctrl, gcommsi2cdevice1.pcfg); // Call I2C Communication Device Write or Read to communicate with Device(0x44) gcommsi2cdevice0.papi-write(...); gcommsi2cdevice0.papi-read(...); // Call I2C Communication Device Write or Read to communicate with Device(0x55) gcommsi2cdevice1.papi-write(...); gcommsi2cdevice1.papi-read(...); (2) Switch the slave address using the slaveAddressSet API of the I2C Master driver This method creates one instance of the I2C master driver. The application then uses the slaveAddressSet API to switch the slave devices for communication. Here is an example where the addresses for the slave devices are 0x44 and 0x55. The default slave address of the I2C master driver instance is set to 0x44 in this case. Pseudo code to show when to use the slaveAddressSet API. // Open gi2cmaster.papi-open(gi2cmaster.pctrl, gi2cmaster.pcfg); // Switch Slave address to 0x55 gi2cmaster.papi-slaveAddressSet(gi2cmaster.pctrl, 0x55, I2CMASTERADDRMODE7BIT); // Call I2C Write or Read to communicate with Device(0x55) gi2cmaster.papi-write(); gi2cmaster.papi-read(); // Switch Slave address to 0x44 gi2cmaster.papi-slaveAddressSet(gi2cmaster.pctrl, 0x44, I2CMASTERADDRMODE7BIT); // Call I2C Write or Read to communicate with Device(0x44) Suitable Products RA Pseudo code to show how to use shared i2c bus. // Call I2C Communication Device Write or Read to communicate with Device(0x44) // Call I2C Communication Device Write or Read to communicate with Device(0x55) // Switch Slave address to 0x55 // Call I2C Write or Read to communicate with Device(0x55) // Switch Slave address to 0x44 // Call I2C Write or Read to communicate with Device(0x44) Suitable Products",
3bd11c96d3d55f88c63f92852438247c,"Question:
How to debug code from a specified address on Renesas RA MCUs - e2 studio
Answer:
As more and more devices require OTA (Over The Air) code upgrades, there is an increasing need for parallel development of bootloaders and applications. This requires that in the development stage, the application project address can be offset to be consistent with the final address space division.
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, as shown in the following figure (take the RA2L1 manual as an example), so if the 0 address is full FFh, the code cannot be debugged.
To solve this issue, the address offset required for MCU operation can be respecified in the IDE (Initial stack pointer and Initial program counter in the figure above). In this article, we will take e2 Studio as an example.
1. Linker script file (code writing phase).
First, you need to modify the linker script file. Take the memory_regions.ld file as an example. FLASH_START is the basic offset address when the code is compiled, the default is 0, and the target offset address of the application is modified according to the requirements, such as 0x4000. Recompile the project, check the generated SREC file or MOT file, and make sure that the file starts at 0x4000, as shown below.
2. Debug Configuration Settings (Code Debugging Phase)
In the Debug Configuration, add the following three lines of code to Startup > Run Commands.
set $sp = *0x4000
set $pc = *0x4004
set {int}0xe000ed08 = 0x00020000
The meanings of these 3 lines of code are explained as follows:
set $sp = *0x20000
Since the stack pointer address is required at the start of the code, as shown in the following figure, it points to 0x20000
set $pc = *0x20004
This is the address where the reset vector is stored.
set {int}0xe000ed08 = 0x00020000
E000ED08h is the address of the Vector Table Offset Register, which is a common register for ARM core chips, which can be found in the corresponding core manual and related documents of the MCU.
For example, the Arm Cortex-M4 is detailed at the following link:
https://developer.arm.com/documentation/ddi0337/e/nested-vectored-interrupt-controller/nvic-programmer-s-model/nvic-register-descriptions
Click the debug button in the following figure to confirm the following content in the new interface: the RESET vector is located at the 0x4C45, and the code stops at the 0x4C44 after powering on.
Regarding the difference between the last bit, the explanation is as follows:
After powering up, the CPU check address is offset to the lowest bit of data at the 0x0004, if the bit is 1, it means that this is a usable thumb address. The bit is then ignored (set to 0) and the first instruction is taken as the reset handle at the modified address.
For more details, please refer to the Arm processor documentation.
Suitable Products
RA
How to debug code from a specified address on Renesas RA MCUs - e2 studio
How to debug code from a specified address on Renesas RA MCUs - e2 studio
Answer:
As more and more devices require OTA (Over The Air) code upgrades, there is an increasing need for parallel development of bootloaders and applications. This requires that in the development stage, the application project address can be offset to be consistent with the final address space division.
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, as shown in the following figure (take the RA2L1 manual as an example), so if the 0 address is full FFh, the code cannot be debugged.
To solve this issue, the address offset required for MCU operation can be respecified in the IDE (Initial stack pointer and Initial program counter in the figure above). In this article, we will take e2 Studio as an example.
1. Linker script file (code writing phase).
First, you need to modify the linker script file. Take the memory_regions.ld file as an example. FLASH_START is the basic offset address when the code is compiled, the default is 0, and the target offset address of the application is modified according to the requirements, such as 0x4000. Recompile the project, check the generated SREC file or MOT file, and make sure that the file starts at 0x4000, as shown below.
2. Debug Configuration Settings (Code Debugging Phase)
In the Debug Configuration, add the following three lines of code to Startup > Run Commands.
set $sp = *0x4000
set $pc = *0x4004
set {int}0xe000ed08 = 0x00020000
The meanings of these 3 lines of code are explained as follows:
set $sp = *0x20000
Since the stack pointer address is required at the start of the code, as shown in the following figure, it points to 0x20000
set $pc = *0x20004
This is the address where the reset vector is stored.
set {int}0xe000ed08 = 0x00020000
E000ED08h is the address of the Vector Table Offset Register, which is a common register for ARM core chips, which can be found in the corresponding core manual and related documents of the MCU.
For example, the Arm Cortex-M4 is detailed at the following link:
https://developer.arm.com/documentation/ddi0337/e/nested-vectored-interrupt-controller/nvic-programmer-s-model/nvic-register-descriptions
Click the debug button in the following figure to confirm the following content in the new interface: the RESET vector is located at the 0x4C45, and the code stops at the 0x4C44 after powering on.
Regarding the difference between the last bit, the explanation is as follows:
After powering up, the CPU check address is offset to the lowest bit of data at the 0x0004, if the bit is 1, it means that this is a usable thumb address. The bit is then ignored (set to 0) and the first instruction is taken as the reset handle at the modified address.
For more details, please refer to the Arm processor documentation.
Suitable Products
RA
As more and more devices require OTA (Over The Air) code upgrades, there is an increasing need for parallel development of bootloaders and applications. This requires that in the development stage, the application project address can be offset to be consistent with the final address space division.
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, as shown in the following figure (take the RA2L1 manual as an example), so if the 0 address is full FFh, the code cannot be debugged.
To solve this issue, the address offset required for MCU operation can be respecified in the IDE (Initial stack pointer and Initial program counter in the figure above). In this article, we will take e2 Studio as an example.
1. Linker script file (code writing phase).
First, you need to modify the linker script file. Take the memory_regions.ld file as an example. FLASH_START is the basic offset address when the code is compiled, the default is 0, and the target offset address of the application is modified according to the requirements, such as 0x4000. Recompile the project, check the generated SREC file or MOT file, and make sure that the file starts at 0x4000, as shown below.
2. Debug Configuration Settings (Code Debugging Phase)
In the Debug Configuration, add the following three lines of code to Startup > Run Commands.
set $sp = *0x4000
set $pc = *0x4004
set {int}0xe000ed08 = 0x00020000
The meanings of these 3 lines of code are explained as follows:
set $sp = *0x20000
Since the stack pointer address is required at the start of the code, as shown in the following figure, it points to 0x20000
set $pc = *0x20004
This is the address where the reset vector is stored.
set {int}0xe000ed08 = 0x00020000
E000ED08h is the address of the Vector Table Offset Register, which is a common register for ARM core chips, which can be found in the corresponding core manual and related documents of the MCU.
For example, the Arm Cortex-M4 is detailed at the following link:
https://developer.arm.com/documentation/ddi0337/e/nested-vectored-interrupt-controller/nvic-programmer-s-model/nvic-register-descriptions
Click the debug button in the following figure to confirm the following content in the new interface: the RESET vector is located at the 0x4C45, and the code stops at the 0x4C44 after powering on.
Regarding the difference between the last bit, the explanation is as follows:
After powering up, the CPU check address is offset to the lowest bit of data at the 0x0004, if the bit is 1, it means that this is a usable thumb address. The bit is then ignored (set to 0) and the first instruction is taken as the reset handle at the modified address.
For more details, please refer to the Arm processor documentation.
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/d98f6ed3e504092b8b3205f0158ca374.png', 'data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/23d194c409158fde805663e56127b821.png', 'data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/a7f760fa48cda337d6e3104e0a1f085e.png', 'data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/2beb26c8b6a12577661dada123099777.png', 'data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/55bf506502ee2f112969644f1b511f19.png', 'data/categories/ra_family/rafsp_knowledge_base/3bd11c96d3d55f88c63f92852438247c/images/acb69985710331559e0ec7affc678611.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'How to debug code from a specified address on Renesas RA MCUs - e2 studio', 'url': 'https://en-support.renesas.com/knowledgeBase/21174040', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:54.223259'}","Question How to debug code from a specified address on Renesas RA MCUs - e2 studio Answer As more and more devices require OTA (Over The Air) code upgrades, there is an increasing need for parallel development of bootloaders and applications. This requires that in the development stage, the application project address can be offset to be consistent with the final address space division. For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, as shown in the following figure (take the RA2L1 manual as an example), so if the 0 address is full FFh, the code cannot be debugged. To solve this issue, the address offset required for MCU operation can be respecified in the IDE (Initial stack pointer and Initial program counter in the figure above). In this article, we will take e2 Studio as an example. 1. Linker script file (code writing phase). First, you need to modify the linker script file. Take the memoryregions.ld file as an example. FLASHSTART is the basic offset address when the code is compiled, the default is 0, and the target offset address of the application is modified according to the requirements, such as 0x4000. Recompile the project, check the generated SREC file or MOT file, and make sure that the file starts at 0x4000, as shown below. 2. Debug Configuration Settings (Code Debugging Phase) In the Debug Configuration, add the following three lines of code to Startup  Run Commands. set sp  0x4000 set pc  0x4004 set int0xe000ed08  0x00020000 The meanings of these 3 lines of code are explained as follows set sp  0x20000 Since the stack pointer address is required at the start of the code, as shown in the following figure, it points to 0x20000 set pc  0x20004 This is the address where the reset vector is stored. E000ED08h is the address of the Vector Table Offset Register, which is a common register for ARM core chips, which can be found in the corresponding core manual and related documents of the MCU. For example, the Arm Cortex-M4 is detailed at the following link https//developer.arm.com/documentation/ddi0337/e/nested-vectored-interrupt-controller/nvic-programmer-s-model/nvic-register-descriptions Click the debug button in the following figure to confirm the following content in the new interface the RESET vector is located at the 0x4C45, and the code stops at the 0x4C44 after powering on. Regarding the difference between the last bit, the explanation is as follows After powering up, the CPU check address is offset to the lowest bit of data at the 0x0004, if the bit is 1, it means that this is a usable thumb address. The bit is then ignored (set to 0) and the first instruction is taken as the reset handle at the modified address. For more details, please refer to the Arm processor documentation. Suitable Products RA",
103fafbd04829dc8390f1a027b7c548b,"Question:
How to set the ID Code to disable ID code protection, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the ID Code Mode to Unlocked (Ignore ID) in the BSP property as shown below. In this case, ID code (32 Hex Characters) is ignored.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as  00112233445566778899AABBCCDDEEFF.
This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. You can see that the ID code is set as all FFh.
/* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */
#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0

In case of RA6M3:
S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08

In case of RA4E2:
S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38

Debugger connection in e2 studio (ID code authentication)
No ID code setting is required in the debug configuration.
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting ALeRASE ID code (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code.  It cannot be used when using J-Link. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
Connection by RFP (with ID code authentication)
There is no need to set the ID code in the connection settings.
Connection by RFP (with ALeRASE execution)
ALeRASE is not available.
Suitable Products
RA and FSP
How to set the ID Code to disable ID code protection, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the ID Code Mode to Unlocked (Ignore ID) in the BSP property as shown below. In this case, ID code (32 Hex Characters) is ignored.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as  00112233445566778899AABBCCDDEEFF.
This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. You can see that the ID code is set as all FFh.
/* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */
#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0

In case of RA6M3:
S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08

In case of RA4E2:
S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38

Debugger connection in e2 studio (ID code authentication)
No ID code setting is required in the debug configuration.
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting ALeRASE ID code (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code.  It cannot be used when using J-Link. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
Connection by RFP (with ID code authentication)
There is no need to set the ID code in the connection settings.
Connection by RFP (with ALeRASE execution)
ALeRASE is not available.
Suitable Products
RA and FSP
How to set the ID code
In the FSP configurator, set the ID Code Mode to Unlocked (Ignore ID) in the BSP property as shown below. In this case, ID code (32 Hex Characters) is ignored.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as  00112233445566778899AABBCCDDEEFF.
This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. You can see that the ID code is set as all FFh.
/* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */
#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0

In case of RA6M3:
S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08

In case of RA4E2:
S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38

Debugger connection in e2 studio (ID code authentication)
No ID code setting is required in the debug configuration.
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting ALeRASE ID code (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code.  It cannot be used when using J-Link. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
Connection by RFP (with ID code authentication)
There is no need to set the ID code in the connection settings.
Connection by RFP (with ALeRASE execution)
ALeRASE is not available.
How to set the ID code
In the FSP configurator, set the ID Code Mode to Unlocked (Ignore ID) in the BSP property as shown below. In this case, ID code (32 Hex Characters) is ignored.
ID code (32 Hex Characters)
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as  00112233445566778899AABBCCDDEEFF.
00112233
44556677
8899AABB
CCDDEEFF
This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. You can see that the ID code is set as all FFh.
/* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */
#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)
#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF)
/* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */
FFFFFFFF
FFFFFFFF
FFFFFFFF
FFFFFFFF
#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)
FFFFFFFF
#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)
FFFFFFFF
#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)
FFFFFFFF
#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF)
ffFFFFFF
The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0
S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
FFFFFFFF
FFFFFFFF
S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0
FFFFFFFF
FFFFFFFF
In case of RA6M3:
S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08
S3150100A150
FFFFFFFF
FFFFFFFF
FFFFFFFF
FFFFFFFF
08
In case of RA4E2:
S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38
S3150100A120
FFFFFFFF
FFFFFFFF
FFFFFFFF
FFFFFFFF
38
Debugger connection in e2 studio (ID code authentication)
No ID code setting is required in the debug configuration.
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting ALeRASE ID code (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code.  It cannot be used when using J-Link. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
(
FFFFFFFFFFFFFFFFFF45534152654C41
FFFFFFFF
FFFFFFFF
FF455341
52654C41
Connection by RFP (with ID code authentication)
There is no need to set the ID code in the connection settings.
Connection by RFP (with ALeRASE execution)
ALeRASE is not available.
Suitable Products
RA and FSP
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/103fafbd04829dc8390f1a027b7c548b/images/d17c6db86d4fa2c0a218d21ce110ff0e.png', 'data/categories/ra_family/rafsp_knowledge_base/103fafbd04829dc8390f1a027b7c548b/images/1f7dae96e4b4badaca4d402626b96f0c.png']",[],"['|  |\n|  |\n| /* ID CODE: FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF */\n#define BSP_CFG_ID_CODE_LONG_1 (0xFFFFFFFF)\n#define BSP_CFG_ID_CODE_LONG_2 (0xFFFFFFFF)\n#define BSP_CFG_ID_CODE_LONG_3 (0xFFFFFFFF)\n#define BSP_CFG_ID_CODE_LONG_4 (0xffFFFFFF) |', '|  |\n|  |\n| S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0\nS31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0 |', '|  |\n|  |\n| S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08 |', '|  |\n|  |\n| S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38 |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: ID code protection (in case of protection disabled)', 'url': 'https://en-support.renesas.com/knowledgeBase/20980155', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:32.770805'}","Question How to set the ID Code to disable ID code protection, and how to connect a debugger or programmer in that case? Answer How to set the ID code In the FSP configurator, set the ID Code Mode to Unlocked (Ignore ID) in the BSP property as shown below. In this case, ID code (32 Hex Characters) is ignored. The value of the ID code in the OSIS register In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to racfg/fspcfg/bsp/bspmcufamilycfg.h as shown below. You can see that the ID code is set as all FFh. / ID CODE FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF / define BSPCFGIDCODELONG1 (0xFFFFFFFF) define BSPCFGIDCODELONG2 (0xFFFFFFFF) define BSPCFGIDCODELONG3 (0xFFFFFFFF) define BSPCFGIDCODELONG4 (0xffFFFFFF) The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register In case of RA2L1 S31501010018FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0 S31101010028FFFFFFFFFFFFFFFFFFFFFFFFD0 In case of RA6M3 S3150100A150FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF08 In case of RA4E2 S3150100A120FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF38 Debugger connection in e2 studio (ID code authentication) No ID code setting is required in the debug configuration. Debugger connection in e2 studio (with ALeRASE execution) In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting ALeRASE ID code (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution. Connection by RFP (with ID code authentication) There is no need to set the ID code in the connection settings. Connection by RFP (with ALeRASE execution) ALeRASE is not available. Suitable Products RA and FSP ID code (32 Hex Characters) 00112233 44556677 8899AABB CCDDEEFF FFFFFFFF ffFFFFFF S3150100A150 08 S3150100A120 38 ( FFFFFFFFFFFFFFFFFF45534152654C41 FF455341 52654C41",
74b1913a749d3918a42ec334b062b43a,"Overview:
Some RA MCU series provide a CLKOUT pin/function to send the input or internal clock to an output pin. The CLKOUT function is sometimes overlooked as simply supplying a clock to an external IC, but it can also be used to check whether the external clock works as expected.
Some use cases include:
Probing the XCIN/XCOUT pins often attenuates the 32.768 KHz external clock (SUBCLK, SOSC) signal and stops oscillating, so CLKOUT can be used to check the frequency or continuity of the 32.768 KHz external clock.
Sometimes the MOSC (XTAL) clock introduces an external RC filter circuit to reduce the EMI noise caused by the MOSC. The CLKOUT pin can be used to verify how the sinewave-like MOSC clock input is recognized by the MCU.
Description:
The procedure to enable CLKOUT in e2 studio is described below. This is an example of using SUBCLK as a clock source on the EK-RA6M4 board, but this is generally applicable to other MCUs as well.
Clocks configuration
1. Set the clock source for CLKOUT.
2. Set the divider for CLKOUT.
  Pins configuration
1. Select the pin to use as the CLKOUT pin in CGC peripheral.
2. If necessary, change the drive capacity, pull up, output type, etc. of the CLKOUT pin.
  Test:
Simply Generate Project Content and run the code without adding/editing code. During the startup process (""SystemInit""), CLKOUT is enabled, and a square wave output can be seen from the CLKOUT pin as shown below.
  Suitable Products
RA
Some RA MCU series provide a CLKOUT pin/function to send the input or internal clock to an output pin. The CLKOUT function is sometimes overlooked as simply supplying a clock to an external IC, but it can also be used to check whether the external clock works as expected.
Some use cases include:
Probing the XCIN/XCOUT pins often attenuates the 32.768 KHz external clock (SUBCLK, SOSC) signal and stops oscillating, so CLKOUT can be used to check the frequency or continuity of the 32.768 KHz external clock.
Sometimes the MOSC (XTAL) clock introduces an external RC filter circuit to reduce the EMI noise caused by the MOSC. The CLKOUT pin can be used to verify how the sinewave-like MOSC clock input is recognized by the MCU.
Some RA MCU series provide a CLKOUT pin/function to send the input or internal clock to an output pin. The CLKOUT function is sometimes overlooked as simply supplying a clock to an external IC, but it can also be used to check whether the external clock works as expected.
Some use cases include:
Description:
The procedure to enable CLKOUT in e2 studio is described below. This is an example of using SUBCLK as a clock source on the EK-RA6M4 board, but this is generally applicable to other MCUs as well.
Clocks configuration
1. Set the clock source for CLKOUT.
2. Set the divider for CLKOUT.
  Pins configuration
1. Select the pin to use as the CLKOUT pin in CGC peripheral.
2. If necessary, change the drive capacity, pull up, output type, etc. of the CLKOUT pin.
  Test:
Simply Generate Project Content and run the code without adding/editing code. During the startup process (""SystemInit""), CLKOUT is enabled, and a square wave output can be seen from the CLKOUT pin as shown below.
  Suitable Products
RA
The procedure to enable CLKOUT in e2 studio is described below. This is an example of using SUBCLK as a clock source on the EK-RA6M4 board, but this is generally applicable to other MCUs as well.
Clocks configuration
1. Set the clock source for CLKOUT.
2. Set the divider for CLKOUT.
  Pins configuration
1. Select the pin to use as the CLKOUT pin in CGC peripheral.
2. If necessary, change the drive capacity, pull up, output type, etc. of the CLKOUT pin.
  Test:
Simply Generate Project Content and run the code without adding/editing code. During the startup process (""SystemInit""), CLKOUT is enabled, and a square wave output can be seen from the CLKOUT pin as shown below.
The procedure to enable CLKOUT in e2 studio is described below. This is an example of using SUBCLK as a clock source on the EK-RA6M4 board, but this is generally applicable to other MCUs as well.
Clocks configuration
1. Set the clock source for CLKOUT.
2. Set the divider for CLKOUT.
Pins configuration
1. Select the pin to use as the CLKOUT pin in CGC peripheral.
2. If necessary, change the drive capacity, pull up, output type, etc. of the CLKOUT pin.
Simply Generate Project Content and run the code without adding/editing code. During the startup process (""SystemInit""), CLKOUT is enabled, and a square wave output can be seen from the CLKOUT pin as shown below.
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/74b1913a749d3918a42ec334b062b43a/images/60f300b1cb538a165d18b3f268b4c019.png', 'data/categories/ra_family/rafsp_knowledge_base/74b1913a749d3918a42ec334b062b43a/images/f26958db61359f960f0cd667fca2ae1d.png', 'data/categories/ra_family/rafsp_knowledge_base/74b1913a749d3918a42ec334b062b43a/images/f1728bd1d2cd7a5c6ae4b68fd6e93384.png', 'data/categories/ra_family/rafsp_knowledge_base/74b1913a749d3918a42ec334b062b43a/images/e3bee845bdbe9416c7539f6434659cac.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'RA Family: Using CLKOUT to check if the external clock is working properly', 'url': 'https://en-support.renesas.com/knowledgeBase/21132842', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:10.036692'}","Overview Some RA MCU series provide a CLKOUT pin/function to send the input or internal clock to an output pin. The CLKOUT function is sometimes overlooked as simply supplying a clock to an external IC, but it can also be used to check whether the external clock works as expected. Some use cases include Probing the XCIN/XCOUT pins often attenuates the 32.768 KHz external clock (SUBCLK, SOSC) signal and stops oscillating, so CLKOUT can be used to check the frequency or continuity of the 32.768 KHz external clock. Sometimes the MOSC (XTAL) clock introduces an external RC filter circuit to reduce the EMI noise caused by the MOSC. The CLKOUT pin can be used to verify how the sinewave-like MOSC clock input is recognized by the MCU. Description The procedure to enable CLKOUT in e2 studio is described below. This is an example of using SUBCLK as a clock source on the EK-RA6M4 board, but this is generally applicable to other MCUs as well. Clocks configuration 1. Set the clock source for CLKOUT. 2. Set the divider for CLKOUT. Pins configuration 1. Select the pin to use as the CLKOUT pin in CGC peripheral. 2. If necessary, change the drive capacity, pull up, output type, etc. of the CLKOUT pin. Test Simply Generate Project Content and run the code without adding/editing code. During the startup process (""SystemInit""), CLKOUT is enabled, and a square wave output can be seen from the CLKOUT pin as shown below. Suitable Products RA Pins configuration Suitable Products",
eb5398e2857dbf77add8914dd9a5fb71,"Question:
How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the ID Code Mode to Locked and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. Since it should be Bit127=1 and Bit126=0, FF is changed to BF as follows.
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEBFEC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEBF40

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEBF70

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. The Bit127 and Bit126 of the ID Code should be 1 and 0 each like (00112233445566778899AABBCCDDEEBF). It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (BFEEDDCCBBAA99887766554433221100) in which Bit127=1 and Bit126=0 as shown below.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in an RFP, even if you enter the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the RFP displays an authentication failure error.

Suitable Products
RA and FSP
How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the ID Code Mode to Locked and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. Since it should be Bit127=1 and Bit126=0, FF is changed to BF as follows.
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEBFEC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEBF40

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEBF70

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. The Bit127 and Bit126 of the ID Code should be 1 and 0 each like (00112233445566778899AABBCCDDEEBF). It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (BFEEDDCCBBAA99887766554433221100) in which Bit127=1 and Bit126=0 as shown below.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in an RFP, even if you enter the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the RFP displays an authentication failure error.

Suitable Products
RA and FSP
How to set the ID code
In the FSP configurator, set the ID Code Mode to Locked and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. Since it should be Bit127=1 and Bit126=0, FF is changed to BF as follows.
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEBFEC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEBF40

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEBF70

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. The Bit127 and Bit126 of the ID Code should be 1 and 0 each like (00112233445566778899AABBCCDDEEBF). It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (BFEEDDCCBBAA99887766554433221100) in which Bit127=1 and Bit126=0 as shown below.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in an RFP, even if you enter the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the RFP displays an authentication failure error.
How to set the ID code
In the FSP configurator, set the ID Code Mode to Locked and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below.
ID Code Mode
Locked
ID Code (32 Hex Characters)
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below. Since it should be Bit127=1 and Bit126=0, FF is changed to BF as follows.
00112233
44556677
8899AABB
CCDDEEFF
.
FF
B
F
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
33221100
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
77665544
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
BBAA9988
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
b
fEEDDCC
The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEBFEC
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEBFEC
00112233
44556677
8899AABB
CCDDEE
B
F
In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEBF40
S3150100A150
00112233
44556677
8899AABB
CCDDEE
B
F
40
In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEBF70
S3150100A120
00112233
44556677
8899AABB
CCDDEE
B
F
70
Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. The Bit127 and Bit126 of the ID Code should be 1 and 0 each like (00112233445566778899AABBCCDDEEBF). It shows the case of J-Link, but the same applies to the E2 and E2 Lite.
00112233445566778899AABBCCDDEEBF)
The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog.
If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:
In case of E2/E2 Lite debugger:
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.
FFFFFFFFFFFFFFFFFF45534152654C41
Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (BFEEDDCCBBAA99887766554433221100) in which Bit127=1 and Bit126=0 as shown below.
BFEEDDCCBBAA99887766554433221100
)
After creating an RFP project, set the ID code as follows.
Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in an RFP, even if you enter the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the RFP displays an authentication failure error.
414C6552415345FFFFFFFFFFFFFFFFFF
Suitable Products
RA and FSP
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/9e1e30eb623c16ce59dc27cd8fd920e5.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/e86100f13c8fed56cba07e67a271ff46.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/875ee25ef365ecd8f08139927e4cfe2f.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/935ee6d1f77d68972fce8359d5df2325.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/a9ab9d975dec7e57d59fb7929becadf7.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/dafaf34c84728dcc0c9cd8878cc41161.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/16f04dff9a4b60ed50c5e54ec6b04314.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/93a395f271ab47b1424eadb3382985ea.png', 'data/categories/ra_family/rafsp_knowledge_base/eb5398e2857dbf77add8914dd9a5fb71/images/868004a5e25c3fcade36c269c0fbd8b6.png']",[],"['|  |\n|  |\n| /* ID CODE: 00112233445566778899AABBCCDDEEbf */\n#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)\n#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)\n#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)\n#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC) |', '|  |\n|  |\n| S3150101001800112233FFFFFFFF44556677FFFFFFFFFC\nS311010100288899AABBFFFFFFFFCCDDEEBFEC |', '|  |\n|  |\n| S3150100A15000112233445566778899AABBCCDDEEBF40 |', '|  |\n|  |\n| S3150100A12000112233445566778899AABBCCDDEEBF70 |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: ID code protection (in case of protection enabled with Bit127=1 and Bit126=0)', 'url': 'https://en-support.renesas.com/knowledgeBase/20980157', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:45.344081'}","Question How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case? Answer How to set the ID code In the FSP configurator, set the ID Code Mode to Locked and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below. The value of the ID code in the OSIS register In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to racfg/fspcfg/bsp/bspmcufamilycfg.h as shown below. Since it should be Bit1271 and Bit1260, FF is changed to BF as follows. / ID CODE 00112233445566778899AABBCCDDEEbf / define BSPCFGIDCODELONG1 (0x33221100) define BSPCFGIDCODELONG2 (0x77665544) define BSPCFGIDCODELONG3 (0xBBAA9988) define BSPCFGIDCODELONG4 (0xbfEEDDCC) The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register  In case of RA2L1 S3150101001800112233FFFFFFFF44556677FFFFFFFFFC S311010100288899AABBFFFFFFFFCCDDEEBFEC In case of RA6M3 S3150100A15000112233445566778899AABBCCDDEEBF40 In case of RA4E2 S3150100A12000112233445566778899AABBCCDDEEBF70 Debugger connection in e2 studio (ID code authentication) When connecting with e2 studio, set the ID code in Debugger - Connection Settings - Connection - ID Code (Bytes) as shown below. The Bit127 and Bit126 of the ID Code should be 1 and 0 each like (00112233445566778899AABBCCDDEEBF). It shows the case of J-Link, but the same applies to the E2 and E2 Lite. The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog. If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed. In case of J-Link debugger In case of E2/E2 Lite debugger Debugger connection in e2 studio (with ALeRASE execution) In case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed. Connection by RFP (with ID code authentication) If the authentication dialog is displayed when connecting in RFP, enter the ID code (BFEEDDCCBBAA99887766554433221100) in which Bit1271 and Bit1260 as shown below. After creating an RFP project, set the ID code as follows. Connection by RFP (with ALeRASE execution) If an authentication dialog is displayed when connecting in an RFP, even if you enter the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the RFP displays an authentication failure error. Suitable Products RA and FSP ID Code Mode Locked ID Code (32 Hex Characters) 00112233 44556677 8899AABB CCDDEEFF . FF B F 33221100 77665544 BBAA9988 b fEEDDCC CCDDEE S3150100A150 40 S3150100A120 70 00112233445566778899AABBCCDDEEBF) FFFFFFFFFFFFFFFFFF45534152654C41 BFEEDDCCBBAA99887766554433221100 ) 414C6552415345FFFFFFFFFFFFFFFFFF",
786e38d1afb6627e6d13c5245a7a42a1,"How to remap the execution address of an application?
To change the start address, of the application in Code Flash, we should edit the linker script fsp.ld and create in folder Debug a new script like memory_regions.ld.
We assume that we want our application to start from address 0x0000_4000 instead of  the default address which is 0x0000_0000.
In this example we are using RA6M4. The specific MCU has Code Flash size equal to 1MB, which corresponds to FLASH_LENGTH = 0x10_0000.
FLASH_START address and FLASH_LENGTH can be found in memory_regions.ld script generated in Debug Folder of the project:
In order to change the start address of our application we should follow these steps:
1) We should go in Debug folder and create a new script called user_regions.ld, this script will now include the new start address for Code Flash memory and
the new length. The new length can be calculated like this: new_flash_length = old_flash_length  new_flash_start_address.
2) Then we should modify the linker script fsp.ld to include the new user_regions.ld instead of memory_regions.ld.
4) Next step is to go to Debug Configurations of the project, select Startup and go to Run Commands to set the Program Counter and the Initial Stack pointer registers.
5)  Perform Clean Project and then Build Project.
6) Make sure you have previously erased the code flash and then launch a debug session to load and run your application.
Press Resume twice:
And this is it, we have our application up and running from the start address we selected.
Below you will find some readings of code flash, showing that our application is starting from address 0x0000_4000 instead of 0x0000_00000.
Suitable Products
RA , FSP, e2studio","['data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/4d0ed07b3d162a9082e3747fa1a6feef.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/96022d5e30256f44099d0f8a9bf36133.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/a12fc3526b1af203aa0c63ebc2e04329.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/82b23f25d1ff272dcd3e5106184d5b1c.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/01447c0b0028633049197b1573bf1613.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/1b1c5782246eb5255555ae899fb84abc.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/e042428b3919943dda496a2b516cac55.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/f2e5c5a78325ec5888bd9807acf499bf.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/3e698a09312b11228783afe5e12f41c8.png', 'data/categories/ra_family/rafsp_knowledge_base/786e38d1afb6627e6d13c5245a7a42a1/images/be90c517b5fb851c583e835bfd7b2e62.png']",[],"['|  |\n|  |\n| RA , FSP, e2studio |']","{'title': 'RA Family: How to remap execution address', 'url': 'https://en-support.renesas.com/knowledgeBase/21094312', 'last_updated': None, 'extracted_at': '2025-03-08T23:20:41.126991'}","How to remap the execution address of an application? To change the start address, of the application in Code Flash, we should edit the linker script fsp.ld and create in folder Debug a new script like memoryregions.ld. We assume that we want our application to start from address 0x00004000 instead of the default address which is 0x00000000. In this example we are using RA6M4. The specific MCU has Code Flash size equal to 1MB, which corresponds to FLASHLENGTH  0x100000. FLASHSTART address and FLASHLENGTH can be found in memoryregions.ld script generated in Debug Folder of the project In order to change the start address of our application we should follow these steps 1) We should go in Debug folder and create a new script called userregions.ld, this script will now include the new start address for Code Flash memory and the new length. The new length can be calculated like this newflashlength  oldflashlength  newflashstartaddress. 2) Then we should modify the linker script fsp.ld to include the new userregions.ld instead of memoryregions.ld. 4) Next step is to go to Debug Configurations of the project, select Startup and go to Run Commands to set the Program Counter and the Initial Stack pointer registers. 5) Perform Clean Project and then Build Project. 6) Make sure you have previously erased the code flash and then launch a debug session to load and run your application. Press Resume twice And this is it, we have our application up and running from the start address we selected. Below you will find some readings of code flash, showing that our application is starting from address 0x00004000 instead of 0x000000000. Suitable Products RA , FSP, e2studio",
0dd1a081bea9d7610affb979994a0449,"Some RA family MCUs have an ID Code protection function that prohibits programming via serial programming and on-chip debugging. This ID code protection function has the following four modes depending on the ID code setting. Refer to the links below for ID code authentication when connecting to the debugger and execution of the ALeRASE function in these four modes.
  ID Code ID Code Authentication
Bit127 Bit126 Bit125 - Bit0
(1)  Link  1 1 All bits are 1 Not required
(2)  Link  1 1 At least one of bit is 0 Required
(3)  Link  1 0 Dont care Required
(4)  Link  0 x Dont care Always failed

  ALeRASE function
e2 studio RFP
E2/E2 Lite J-Link
(1) Available Not available (*2) Not available
(2) Available Not available (*2) Available
(3) Not available Not available Not available
(4) Available (*1) Not available (*2) Not available
Note 1: Depends on MCU. Refer to the hardware users manual as follows.
RA2E2 (R01UH0919EJ0100):
RA4E2 (R01UH0996EJ0110):
Note 2: By using the J-Link script file in RA6M3_ALeRASE.zip uploaded on the forum, available in the article posted at the below link, users can execute ALeRASE on the J-Link commander.
RA6M1/T1: Mass-erase not performed with ID code ALeRASE

Suitable Products
RA and FSP
Some RA family MCUs have an ID Code protection function that prohibits programming via serial programming and on-chip debugging. This ID code protection function has the following four modes depending on the ID code setting. Refer to the links below for ID code authentication when connecting to the debugger and execution of the ALeRASE function in these four modes.
  ID Code ID Code Authentication
Bit127 Bit126 Bit125 - Bit0
(1)  Link  1 1 All bits are 1 Not required
(2)  Link  1 1 At least one of bit is 0 Required
(3)  Link  1 0 Dont care Required
(4)  Link  0 x Dont care Always failed

  ALeRASE function
e2 studio RFP
E2/E2 Lite J-Link
(1) Available Not available (*2) Not available
(2) Available Not available (*2) Available
(3) Not available Not available Not available
(4) Available (*1) Not available (*2) Not available
Note 1: Depends on MCU. Refer to the hardware users manual as follows.
RA2E2 (R01UH0919EJ0100):
RA4E2 (R01UH0996EJ0110):
Note 2: By using the J-Link script file in RA6M3_ALeRASE.zip uploaded on the forum, available in the article posted at the below link, users can execute ALeRASE on the J-Link commander.
RA6M1/T1: Mass-erase not performed with ID code ALeRASE

Suitable Products
RA and FSP
Some RA family MCUs have an ID Code protection function that prohibits programming via serial programming and on-chip debugging. This ID code protection function has the following four modes depending on the ID code setting. Refer to the links below for ID code authentication when connecting to the debugger and execution of the ALeRASE function in these four modes.
  ID Code ID Code Authentication
Bit127 Bit126 Bit125 - Bit0
(1)  Link  1 1 All bits are 1 Not required
(2)  Link  1 1 At least one of bit is 0 Required
(3)  Link  1 0 Dont care Required
(4)  Link  0 x Dont care Always failed

  ALeRASE function
e2 studio RFP
E2/E2 Lite J-Link
(1) Available Not available (*2) Not available
(2) Available Not available (*2) Available
(3) Not available Not available Not available
(4) Available (*1) Not available (*2) Not available
Note 1: Depends on MCU. Refer to the hardware users manual as follows.
RA2E2 (R01UH0919EJ0100):
RA4E2 (R01UH0996EJ0110):
Note 2: By using the J-Link script file in RA6M3_ALeRASE.zip uploaded on the forum, available in the article posted at the below link, users can execute ALeRASE on the J-Link commander.
RA6M1/T1: Mass-erase not performed with ID code ALeRASE
Some RA family MCUs have an ID Code protection function that prohibits programming via serial programming and on-chip debugging. This ID code protection function has the following four modes depending on the ID code setting. Refer to the links below for ID code authentication when connecting to the debugger and execution of the ALeRASE function in these four modes.
ID Code
ID Code Authentication
Bit127
Bit126
Bit125 - Bit0
ALeRASE function
e2 studio
RFP
E2/E2 Lite
J-Link
Note 1: Depends on MCU. Refer to the hardware users manual as follows.
RA2E2 (R01UH0919EJ0100):
RA4E2 (R01UH0996EJ0110):
Note 2: By using the J-Link script file in RA6M3_ALeRASE.zip uploaded on the forum, available in the article posted at the below link, users can execute ALeRASE on the J-Link commander.
Suitable Products
RA and FSP
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/0dd1a081bea9d7610affb979994a0449/images/f3fcb20ca71b749a986ad62df09e9a9c.png', 'data/categories/ra_family/rafsp_knowledge_base/0dd1a081bea9d7610affb979994a0449/images/8af16c2e63e5df68aacbd6c6b897fe8e.png']",[],"['|  |\n|  |\n|  | ID Code | ID Code Authentication |\n| Bit127 | Bit126 | Bit125 - Bit0 |\n| (1) | Link | 1 | 1 | All bits are 1 | Not required |\n| (2) | Link | 1 | 1 | At least one of bit is 0 | Required |\n| (3) | Link | 1 | 0 | Dont care | Required |\n| (4) | Link | 0 | x | Dont care | Always failed |', '|  |\n|  |\n|  | ALeRASE function |\n| e2 studio | RFP |\n| E2/E2 Lite | J-Link |\n| (1) | Available | Not available (*2) | Not available |\n| (2) | Available | Not available (*2) | Available |\n| (3) | Not available | Not available | Not available |\n| (4) | Available (*1) | Not available (*2) | Not available |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: ID Code protection with debugging and ALeRASE (Overview)', 'url': 'https://en-support.renesas.com/knowledgeBase/20980154', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:23.405639'}","Some RA family MCUs have an ID Code protection function that prohibits programming via serial programming and on-chip debugging. This ID code protection function has the following four modes depending on the ID code setting. Refer to the links below for ID code authentication when connecting to the debugger and execution of the ALeRASE function in these four modes. ID Code ID Code Authentication Bit127 Bit126 Bit125 - Bit0 (1) Link 1 1 All bits are 1 Not required (2) Link 1 1 At least one of bit is 0 Required (3) Link 1 0 Dont care Required (4) Link 0 x Dont care Always failed ALeRASE function e2 studio RFP E2/E2 Lite J-Link (1) Available Not available (2) Not available (2) Available Not available (2) Available (3) Not available Not available Not available (4) Available (1) Not available (2) Not available Note 1 Depends on MCU. Refer to the hardware users manual as follows. RA2E2 (R01UH0919EJ0100) RA4E2 (R01UH0996EJ0110) Note 2 By using the J-Link script file in RA6M3ALeRASE.zip uploaded on the forum, available in the article posted at the below link, users can execute ALeRASE on the J-Link commander. RA6M1/T1 Mass-erase not performed with ID code ALeRASE Suitable Products RA and FSP ID Code ID Code Authentication Bit127 Bit126 Bit125 - Bit0 ALeRASE function e2 studio RFP E2/E2 Lite J-Link",
1b85af70b205c9fe6c3bbe2ec5136bd0,"As we all know, an analog-to-digital converter, commonly known as ADC, refers to a device that converts an analog signal of a continuous variable into a discrete digital signal. It is mainly used for digital acquisition of analog signals for data processing. Typically, the conversion result is read when the conversion is complete. The window comparison feature in the ADC detects whether the ADC result is below or above a certain threshold, and can trigger an interrupt when the conversion result is within a certain range, with little to no software intervention. This configuration is very useful in that it monitors whether the signal is maintained within a specific range as required, or when the signal moves out of the range, as when a battery is low or overcharged.
In this article, the RA4M2 is used as an example to describe how to set up the ADC window comparison function.
RA MCUs typically include a 12-bit successive approximation A/D converter (ADC12) unit with up to 13 analog input channels, temperature sensor outputs, and internal reference voltages for conversion.
The ADC12 provides a comparison function (Window A and Window B). The comparison function specifies the upper and lower limits of the reference value for window A and window B, respectively, and the output is interrupted when the A/D conversion value of the selected channel satisfies the comparison conditions. The main differences between Window A and Window B are the difference in their interrupt output signals and the restriction that Window B can only select one channel.
This section uses window A as an example. Window A has the following 4 comparison modes.
The result is below the threshold
The result is above the threshold
The results are within the window
The results are outside the window
The registers related to the Window A comparison function are ADCMPCR, ADCMPLR0/1, and ADCMPDR0/1 registers, which can be found in the RA hardware manual for details.
The ADC data is compared to a settable high and low threshold, and a comparison break can be automatically generated for the ADC data within, outside of, high, or low within the set threshold. There are three option locations that need to be set, and we'll go through each of the property settings and user code in each case.
1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To implement the above comparison function, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example it is set to 1000.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When the AD conversion result is > ADCMPDR0 (at the time of the Lower Reference setting), a Compare interrupt is generated.
2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example 1000 is used.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
When the AD conversion result is < ADCMPDR0 (Lower Reference setting), a Compare interrupt is generated.
3. The A/D conversion result is within the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When ADCMPDR0 ( Lower Reference set) < AD conversion result < ADCMPDR1 ( Upper Reference set), a Compare interrupt is generated.
4. The A/D conversion result is outside the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
Generated when the AD conversion result < ADCMPDR0 (at the Lower Reference setting) or > ADCMPDR1 (at the Upper Reference setting). Compare is interrupted.
Also, be aware of the following limitations when using the window comparison feature:
The compare function cannot be used together with the self-diagnosis function or double-trigger mode. (The compare function is not available for ADRD, ADDBLDR, ADDBLDRA, and ADDBLDRB.)
Specify single scan mode when using match/mismatch event outputs.
When the temperature sensor output or internal reference voltage is selected for Window A, Window B operations are disabled.
When the temperature sensor output or internal reference voltage is selected for Window B, Window A operations are disabled.
Setting the same channel for Window A and Window B is prohibited.
Set the reference voltage values so that the high-potential reference voltage value is equal to or larger than the low-potential reference voltage value.
Suitable Products
RA
As we all know, an analog-to-digital converter, commonly known as ADC, refers to a device that converts an analog signal of a continuous variable into a discrete digital signal. It is mainly used for digital acquisition of analog signals for data processing. Typically, the conversion result is read when the conversion is complete. The window comparison feature in the ADC detects whether the ADC result is below or above a certain threshold, and can trigger an interrupt when the conversion result is within a certain range, with little to no software intervention. This configuration is very useful in that it monitors whether the signal is maintained within a specific range as required, or when the signal moves out of the range, as when a battery is low or overcharged.
In this article, the RA4M2 is used as an example to describe how to set up the ADC window comparison function.
RA MCUs typically include a 12-bit successive approximation A/D converter (ADC12) unit with up to 13 analog input channels, temperature sensor outputs, and internal reference voltages for conversion.
The ADC12 provides a comparison function (Window A and Window B). The comparison function specifies the upper and lower limits of the reference value for window A and window B, respectively, and the output is interrupted when the A/D conversion value of the selected channel satisfies the comparison conditions. The main differences between Window A and Window B are the difference in their interrupt output signals and the restriction that Window B can only select one channel.
This section uses window A as an example. Window A has the following 4 comparison modes.
The result is below the threshold
The result is above the threshold
The results are within the window
The results are outside the window
The registers related to the Window A comparison function are ADCMPCR, ADCMPLR0/1, and ADCMPDR0/1 registers, which can be found in the RA hardware manual for details.
The ADC data is compared to a settable high and low threshold, and a comparison break can be automatically generated for the ADC data within, outside of, high, or low within the set threshold. There are three option locations that need to be set, and we'll go through each of the property settings and user code in each case.
1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To implement the above comparison function, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example it is set to 1000.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When the AD conversion result is > ADCMPDR0 (at the time of the Lower Reference setting), a Compare interrupt is generated.
2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example 1000 is used.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
When the AD conversion result is < ADCMPDR0 (Lower Reference setting), a Compare interrupt is generated.
3. The A/D conversion result is within the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When ADCMPDR0 ( Lower Reference set) < AD conversion result < ADCMPDR1 ( Upper Reference set), a Compare interrupt is generated.
4. The A/D conversion result is outside the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
Generated when the AD conversion result < ADCMPDR0 (at the Lower Reference setting) or > ADCMPDR1 (at the Upper Reference setting). Compare is interrupted.
Also, be aware of the following limitations when using the window comparison feature:
The compare function cannot be used together with the self-diagnosis function or double-trigger mode. (The compare function is not available for ADRD, ADDBLDR, ADDBLDRA, and ADDBLDRB.)
Specify single scan mode when using match/mismatch event outputs.
When the temperature sensor output or internal reference voltage is selected for Window A, Window B operations are disabled.
When the temperature sensor output or internal reference voltage is selected for Window B, Window A operations are disabled.
Setting the same channel for Window A and Window B is prohibited.
Set the reference voltage values so that the high-potential reference voltage value is equal to or larger than the low-potential reference voltage value.
Suitable Products
RA
As we all know, an analog-to-digital converter, commonly known as ADC, refers to a device that converts an analog signal of a continuous variable into a discrete digital signal. It is mainly used for digital acquisition of analog signals for data processing. Typically, the conversion result is read when the conversion is complete. The window comparison feature in the ADC detects whether the ADC result is below or above a certain threshold, and can trigger an interrupt when the conversion result is within a certain range, with little to no software intervention. This configuration is very useful in that it monitors whether the signal is maintained within a specific range as required, or when the signal moves out of the range, as when a battery is low or overcharged.
In this article, the RA4M2 is used as an example to describe how to set up the ADC window comparison function.
RA MCUs typically include a 12-bit successive approximation A/D converter (ADC12) unit with up to 13 analog input channels, temperature sensor outputs, and internal reference voltages for conversion.
The ADC12 provides a comparison function (Window A and Window B). The comparison function specifies the upper and lower limits of the reference value for window A and window B, respectively, and the output is interrupted when the A/D conversion value of the selected channel satisfies the comparison conditions. The main differences between Window A and Window B are the difference in their interrupt output signals and the restriction that Window B can only select one channel.
This section uses window A as an example. Window A has the following 4 comparison modes.
The result is below the threshold
The result is above the threshold
The results are within the window
The results are outside the window
The registers related to the Window A comparison function are ADCMPCR, ADCMPLR0/1, and ADCMPDR0/1 registers, which can be found in the RA hardware manual for details.
The ADC data is compared to a settable high and low threshold, and a comparison break can be automatically generated for the ADC data within, outside of, high, or low within the set threshold. There are three option locations that need to be set, and we'll go through each of the property settings and user code in each case.
1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To implement the above comparison function, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example it is set to 1000.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When the AD conversion result is > ADCMPDR0 (at the time of the Lower Reference setting), a Compare interrupt is generated.
2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example 1000 is used.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
When the AD conversion result is < ADCMPDR0 (Lower Reference setting), a Compare interrupt is generated.
3. The A/D conversion result is within the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When ADCMPDR0 ( Lower Reference set) < AD conversion result < ADCMPDR1 ( Upper Reference set), a Compare interrupt is generated.
4. The A/D conversion result is outside the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
Generated when the AD conversion result < ADCMPDR0 (at the Lower Reference setting) or > ADCMPDR1 (at the Upper Reference setting). Compare is interrupted.
Also, be aware of the following limitations when using the window comparison feature:
The compare function cannot be used together with the self-diagnosis function or double-trigger mode. (The compare function is not available for ADRD, ADDBLDR, ADDBLDRA, and ADDBLDRB.)
Specify single scan mode when using match/mismatch event outputs.
When the temperature sensor output or internal reference voltage is selected for Window A, Window B operations are disabled.
When the temperature sensor output or internal reference voltage is selected for Window B, Window A operations are disabled.
Setting the same channel for Window A and Window B is prohibited.
Set the reference voltage values so that the high-potential reference voltage value is equal to or larger than the low-potential reference voltage value.
Suitable Products
As we all know, an analog-to-digital converter, commonly known as ADC, refers to a device that converts an analog signal of a continuous variable into a discrete digital signal. It is mainly used for digital acquisition of analog signals for data processing. Typically, the conversion result is read when the conversion is complete. The window comparison feature in the ADC detects whether the ADC result is below or above a certain threshold, and can trigger an interrupt when the conversion result is within a certain range, with little to no software intervention. This configuration is very useful in that it monitors whether the signal is maintained within a specific range as required, or when the signal moves out of the range, as when a battery is low or overcharged.
In this article, the RA4M2 is used as an example to describe how to set up the ADC window comparison function.
RA MCUs typically include a 12-bit successive approximation A/D converter (ADC12) unit with up to 13 analog input channels, temperature sensor outputs, and internal reference voltages for conversion.
The ADC12 provides a comparison function (Window A and Window B). The comparison function specifies the upper and lower limits of the reference value for window A and window B, respectively, and the output is interrupted when the A/D conversion value of the selected channel satisfies the comparison conditions. The main differences between Window A and Window B are the difference in their interrupt output signals and the restriction that Window B can only select one channel.
This section uses window A as an example. Window A has the following 4 comparison modes.
The registers related to the Window A comparison function are ADCMPCR, ADCMPLR0/1, and ADCMPDR0/1 registers, which can be found in the RA hardware manual for details.
The ADC data is compared to a settable high and low threshold, and a comparison break can be automatically generated for the ADC data within, outside of, high, or low within the set threshold. There are three option locations that need to be set, and we'll go through each of the property settings and user code in each case.
1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To implement the above comparison function, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example it is set to 1000.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When the AD conversion result is > ADCMPDR0 (at the time of the Lower Reference setting), a Compare interrupt is generated.
2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120_CMPAI) is generated
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference: Set the threshold here- in this example 1000 is used.
(2) Input -> Window Compare
Window Mode: Disabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
When the AD conversion result is < ADCMPDR0 (Lower Reference setting), a Compare interrupt is generated.
3. The A/D conversion result is within the threshold
3. The A/D conversion result is within the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 1;
When ADCMPDR0 ( Lower Reference set) < AD conversion result < ADCMPDR1 ( Upper Reference set), a Compare interrupt is generated.
4. The A/D conversion result is outside the threshold
4. The A/D conversion result is outside the threshold
To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below.
(1) Input -> Window Compare -> Window A
Enable: Enabled
Lower Reference, Upper Reference: Set the threshold here- in this example 1000 and 3000 are used.
(2) Input -> Window Compare
Window Mode: Enabled
(3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below.
R_ADC0->ADCMPLR_b->CMPLCHA0 = 0;
Generated when the AD conversion result < ADCMPDR0 (at the Lower Reference setting) or > ADCMPDR1 (at the Upper Reference setting). Compare is interrupted.
Also, be aware of the following limitations when using the window comparison feature:
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/d87addccaa64a37b2de1b6ce35a3fc20.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/85076eaadd05b2b85cdb03413febc1d6.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/8243f5f1f0b45b6a9aa66e32c0eff26a.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/aefd2391f61244eb09509f4a4f4c9f3e.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/b88da847a54e7310acd325b21115ce0c.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/2a172554f5487ca05f21c1b7fdd9b64b.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/d785d3abb43924fe5f041421faf1ffc2.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/136e2ee1647946c3071f78d47c4f536c.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/17ec2fd2cc4932adbbc491c130f8e81b.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/96e783e0d56bae3cc97e3e8efc927d13.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/4823cb8007478edb2932ebcab0aae23f.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/e1b2d46a0a7d7beeca2bd441a936ec05.png', 'data/categories/ra_family/rafsp_knowledge_base/1b85af70b205c9fe6c3bbe2ec5136bd0/images/a7bb5592d458bf25484228a4747be724.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'How to use the ADC window comparison feature in an RA MCU', 'url': 'https://en-support.renesas.com/knowledgeBase/21397542', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:35.642159'}","As we all know, an analog-to-digital converter, commonly known as ADC, refers to a device that converts an analog signal of a continuous variable into a discrete digital signal. It is mainly used for digital acquisition of analog signals for data processing. Typically, the conversion result is read when the conversion is complete. The window comparison feature in the ADC detects whether the ADC result is below or above a certain threshold, and can trigger an interrupt when the conversion result is within a certain range, with little to no software intervention. This configuration is very useful in that it monitors whether the signal is maintained within a specific range as required, or when the signal moves out of the range, as when a battery is low or overcharged. In this article, the RA4M2 is used as an example to describe how to set up the ADC window comparison function. RA MCUs typically include a 12-bit successive approximation A/D converter (ADC12) unit with up to 13 analog input channels, temperature sensor outputs, and internal reference voltages for conversion. The ADC12 provides a comparison function (Window A and Window B). The comparison function specifies the upper and lower limits of the reference value for window A and window B, respectively, and the output is interrupted when the A/D conversion value of the selected channel satisfies the comparison conditions. The main differences between Window A and Window B are the difference in their interrupt output signals and the restriction that Window B can only select one channel. This section uses window A as an example. Window A has the following 4 comparison modes. The result is below the threshold The result is above the threshold The results are within the window The results are outside the window The registers related to the Window A comparison function are ADCMPCR, ADCMPLR0/1, and ADCMPDR0/1 registers, which can be found in the RA hardware manual for details. The ADC data is compared to a settable high and low threshold, and a comparison break can be automatically generated for the ADC data within, outside of, high, or low within the set threshold. There are three option locations that need to be set, and we'll go through each of the property settings and user code in each case. 1. When the A/D conversion result is higher than the threshold value, a window comparison A interrupt (ADC120CMPAI) is generated To implement the above comparison function, set the ADC properties in the FSP as shown in the figure below. (1) Input - Window Compare - Window A Enable Enabled Lower Reference Set the threshold here- in this example it is set to 1000. (2) Input - Window Compare Window Mode Disabled (3) The CMPLCHA0 bit needs to be set to ""1"" in the code as shown below. RADC0-ADCMPLRb-CMPLCHA0  1; When the AD conversion result is  ADCMPDR0 (at the time of the Lower Reference setting), a Compare interrupt is generated. 2. When the A/D conversion result is lower than the threshold value, a window comparison A interrupt (ADC120CMPAI) is generated To perform the comparison function in the figure above, set the ADC properties in the FSP as shown in the figure below. Lower Reference Set the threshold here- in this example 1000 is used. (3) The CMPLCHA0 bit needs to be set to ""0"" in the code as shown below. RADC0-ADCMPLRb-CMPLCHA0  0; When the AD conversion result is  ADCMPDR0 (Lower Reference setting), a Compare interrupt is generated. 3. The A/D conversion result is within the threshold Lower Reference, Upper Reference Set the threshold here- in this example 1000 and 3000 are used. Window Mode Enabled When ADCMPDR0 ( Lower Reference set)  AD conversion result  ADCMPDR1 ( Upper Reference set), a Compare interrupt is generated. 4. The A/D conversion result is outside the threshold Generated when the AD conversion result  ADCMPDR0 (at the Lower Reference setting) or  ADCMPDR1 (at the Upper Reference setting). Compare is interrupted. Also, be aware of the following limitations when using the window comparison feature The compare function cannot be used together with the self-diagnosis function or double-trigger mode. (The compare function is not available for ADRD, ADDBLDR, ADDBLDRA, and ADDBLDRB.) Specify single scan mode when using match/mismatch event outputs. When the temperature sensor output or internal reference voltage is selected for Window A, Window B operations are disabled. When the temperature sensor output or internal reference voltage is selected for Window B, Window A operations are disabled. Setting the same channel for Window A and Window B is prohibited. Set the reference voltage values so that the high-potential reference voltage value is equal to or larger than the low-potential reference voltage value. Suitable Products RA",
13bbd2bddf0c6487f0d4b74e6915ba3d,"Question:
rand function of the C runtime library does not work 
Answer:
To use the rand() function of the C runtime library with newlib and the GCC toolchain, you need to specify some heap memory in the BSP tab of the configurator. At least 32 bytes of heap memory is required (in case of GCC v10.3.1).
  Suitable Products
RA and FSP
rand function of the C runtime library does not work
rand function of the C runtime library does not work
Answer:
To use the rand() function of the C runtime library with newlib and the GCC toolchain, you need to specify some heap memory in the BSP tab of the configurator. At least 32 bytes of heap memory is required (in case of GCC v10.3.1).
  Suitable Products
RA and FSP
To use the rand() function of the C runtime library with newlib and the GCC toolchain, you need to specify some heap memory in the BSP tab of the configurator. At least 32 bytes of heap memory is required (in case of GCC v10.3.1).
  Suitable Products
RA and FSP
To use the rand() function of the C runtime library with newlib and the GCC toolchain, you need to specify some heap memory in the BSP tab of the configurator. At least 32 bytes of heap memory is required (in case of GCC v10.3.1).
Suitable Products
RA and FSP
Go to Japanese
Go to Japanese",['data/categories/ra_family/rafsp_knowledge_base/13bbd2bddf0c6487f0d4b74e6915ba3d/images/6e2bade922c0494e97ecffd3d021648f.png'],[],['|  |\n|  |\n| RA and FSP |'],"{'title': 'RA Family: rand function of the C runtime library does not work', 'url': 'https://en-support.renesas.com/knowledgeBase/20797533', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:48.168732'}","Question rand function of the C runtime library does not work Answer To use the rand() function of the C runtime library with newlib and the GCC toolchain, you need to specify some heap memory in the BSP tab of the configurator. At least 32 bytes of heap memory is required (in case of GCC v10.3.1). Suitable Products RA and FSP rand function of the C runtime library does not work Suitable Products Go to Japanese",
d6dec3c07b526ecc237a5c7f026ce410,"Question:
How to Debug Code from a Specified Address in Renesas RA MCUs - Keil
Answer:
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use Keil as an example.
1. Linker script file (code writing phase).
Modify the linker script, taking the memory_regions.scat file as an example. Change theFLASH_START value and seen below. The basic offset address is 0 by default when the code is compiled, and it is changed to the target offset address of the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000.
2. Debug Configuration Settings (Code Debugging Phase)
In Keil settings, first change the Linker > R/O Base to 0x4000.
Save the following as a *.ini file (for example, app_0x4000.ini) and place it in the script folder in the Project directory.

FUNC void Setup (void)
{
    SP = _RDWORD(0x00004000);           // Setup Stack Pointer
    PC = _RDWORD(0x00004004);           // Setup Program Counter
    _WDWORD(0xE000ED08, 0x00004000);    // Setup Vector Table Offset Register
}

LOAD Objects\RA4M2_TE_app.axf INCREMENTAL   // Download
Setup();                                    // Setup for Running
  Point to the *.ini file in the following image.
The debugging effect is shown in the following figure, and when the code jumps to the main() function, the address is at 0x4b7c.
 Suitable Products
RA
How to Debug Code from a Specified Address in Renesas RA MCUs - Keil
How to Debug Code from a Specified Address in Renesas RA MCUs - Keil
Answer:
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use Keil as an example.
1. Linker script file (code writing phase).
Modify the linker script, taking the memory_regions.scat file as an example. Change theFLASH_START value and seen below. The basic offset address is 0 by default when the code is compiled, and it is changed to the target offset address of the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000.
2. Debug Configuration Settings (Code Debugging Phase)
In Keil settings, first change the Linker > R/O Base to 0x4000.
Save the following as a *.ini file (for example, app_0x4000.ini) and place it in the script folder in the Project directory.

FUNC void Setup (void)
{
    SP = _RDWORD(0x00004000);           // Setup Stack Pointer
    PC = _RDWORD(0x00004004);           // Setup Program Counter
    _WDWORD(0xE000ED08, 0x00004000);    // Setup Vector Table Offset Register
}

LOAD Objects\RA4M2_TE_app.axf INCREMENTAL   // Download
Setup();                                    // Setup for Running
  Point to the *.ini file in the following image.
The debugging effect is shown in the following figure, and when the code jumps to the main() function, the address is at 0x4b7c.
 Suitable Products
RA
For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged.
To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use Keil as an example.
1. Linker script file (code writing phase).
Modify the linker script, taking the memory_regions.scat file as an example. Change theFLASH_START value and seen below. The basic offset address is 0 by default when the code is compiled, and it is changed to the target offset address of the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000.
2. Debug Configuration Settings (Code Debugging Phase)
In Keil settings, first change the Linker > R/O Base to 0x4000.
Save the following as a *.ini file (for example, app_0x4000.ini) and place it in the script folder in the Project directory.
FUNC void Setup (void)
{
    SP = _RDWORD(0x00004000);           // Setup Stack Pointer
    PC = _RDWORD(0x00004004);           // Setup Program Counter
    _WDWORD(0xE000ED08, 0x00004000);    // Setup Vector Table Offset Register
}

LOAD Objects\RA4M2_TE_app.axf INCREMENTAL   // Download
Setup();                                    // Setup for Running
Point to the *.ini file in the following image.
The debugging effect is shown in the following figure, and when the code jumps to the main() function, the address is at 0x4b7c.
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/d6dec3c07b526ecc237a5c7f026ce410/images/d521c0dfda3c12a355932ae5458780b8.png', 'data/categories/ra_family/rafsp_knowledge_base/d6dec3c07b526ecc237a5c7f026ce410/images/19ef5e588bdf6c0bf87980e87232cfd1.png', 'data/categories/ra_family/rafsp_knowledge_base/d6dec3c07b526ecc237a5c7f026ce410/images/09c1ba968000ac056e1655fd056a269b.png', 'data/categories/ra_family/rafsp_knowledge_base/d6dec3c07b526ecc237a5c7f026ce410/images/8f79736b75ed2293a93c3e8e3f0121d8.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'How to Debug Code from a Specified Address in Renesas RA MCUs - Keil', 'url': 'https://en-support.renesas.com/knowledgeBase/21172752', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:01.942895'}","Question How to Debug Code from a Specified Address in Renesas RA MCUs - Keil Answer For Arm chips, the starting address 0 is required to start placing the initial stack pointer, reset vector table, and other necessary content, so if the 0 address is full FFh, the code cannot be debugged. To debug the code from the specified address, you can respecify the address offsets (Initial stack pointer and Initial program counter) required for MCU operation in the IDE. In this article, we will use Keil as an example. 1. Linker script file (code writing phase). Modify the linker script, taking the memoryregions.scat file as an example. Change theFLASHSTART value and seen below. The basic offset address is 0 by default when the code is compiled, and it is changed to the target offset address of the application as required, such as 0x4000. Recompile the project, check the generated rec file or MOT file, and make sure that the file starts at 0x4000. 2. Debug Configuration Settings (Code Debugging Phase) In Keil settings, first change the Linker  R/O Base to 0x4000. Save the following as a .ini file (for example, app0x4000.ini) and place it in the script folder in the Project directory. FUNC void Setup (void)  SP  RDWORD(0x00004000); // Setup Stack Pointer PC  RDWORD(0x00004004); // Setup Program Counter WDWORD(0xE000ED08, 0x00004000); // Setup Vector Table Offset Register  LOAD ObjectsRA4M2TEapp.axf INCREMENTAL // Download Setup(); // Setup for Running Point to the .ini file in the following image. The debugging effect is shown in the following figure, and when the code jumps to the main() function, the address is at 0x4b7c. Suitable Products RA Point to the .ini file in the following image. Suitable Products",
5f362f41de5146bdb7a53fe58dbf28c4,"Question:
Why does the actual IIC transfer rate differ from the rate defined in the configurator?
Answer:
The FSP r_iic_master driver calculates the following register values so that they are close to the transfer rate (Rate), including the Rise Time and Fall Time set in the configurator.
Bit Rate High-Level Period (ICBRH.BRH)
Bit Rate Low-Level Period (ICBRL.BRL)
Internal Reference Clock Select (ICMR1.CKS)
The calculated values can be confirmed in ra_gen/hal_data.c as follows.
const iic_master_extended_cfg_t g_i2c_master0_extend =
{
(omitted)
/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */
 .clock_settings.brl_value = 24,
 .clock_settings.brh_value = 23,
 .clock_settings.cks_value = 0,
(omitted)
};
  The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator.
Suitable Products
RA Family
Why does the actual IIC transfer rate differ from the rate defined in the configurator?
Why does the actual IIC transfer rate differ from the rate defined in the configurator?
Answer:
The FSP r_iic_master driver calculates the following register values so that they are close to the transfer rate (Rate), including the Rise Time and Fall Time set in the configurator.
Bit Rate High-Level Period (ICBRH.BRH)
Bit Rate Low-Level Period (ICBRL.BRL)
Internal Reference Clock Select (ICMR1.CKS)
The calculated values can be confirmed in ra_gen/hal_data.c as follows.
const iic_master_extended_cfg_t g_i2c_master0_extend =
{
(omitted)
/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */
 .clock_settings.brl_value = 24,
 .clock_settings.brh_value = 23,
 .clock_settings.cks_value = 0,
(omitted)
};
  The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator.
Suitable Products
RA Family
The FSP r_iic_master driver calculates the following register values so that they are close to the transfer rate (Rate), including the Rise Time and Fall Time set in the configurator.
Bit Rate High-Level Period (ICBRH.BRH)
Bit Rate Low-Level Period (ICBRL.BRL)
Internal Reference Clock Select (ICMR1.CKS)
The calculated values can be confirmed in ra_gen/hal_data.c as follows.
const iic_master_extended_cfg_t g_i2c_master0_extend =
{
(omitted)
/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */
 .clock_settings.brl_value = 24,
 .clock_settings.brh_value = 23,
 .clock_settings.cks_value = 0,
(omitted)
};
  The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator.
The FSP r_iic_master driver calculates the following register values so that they are close to the transfer rate (Rate), including the Rise Time and Fall Time set in the configurator.
The calculated values can be confirmed in ra_gen/hal_data.c as follows.
const iic_master_extended_cfg_t g_i2c_master0_extend =
{
const
iic_master_extended_cfg_t
g_i2c_master0_extend =
{
(omitted)
/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */
 .clock_settings.brl_value = 24,
 .clock_settings.brh_value = 23,
 .clock_settings.cks_value = 0,
(omitted)
(omitted)
/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */
.clock_settings.brl_value = 24
,
.clock_settings.brh_value = 23,
.clock_settings.cks_value = 0,
(omitted)
};
};
The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator.
Suitable Products
RA Family

",['data/categories/ra_family/rafsp_knowledge_base/5f362f41de5146bdb7a53fe58dbf28c4/images/3a67e70c85b65e0c7dd7a29df378e88a.png'],[],"['|  |\n|  |\n| const iic_master_extended_cfg_t g_i2c_master0_extend =\n{\n(omitted)\n/* Actual calculated bitrate: 394997. Actual calculated duty cycle: 49%. */\n .clock_settings.brl_value = 24,\n .clock_settings.brh_value = 23,\n .clock_settings.cks_value = 0,\n(omitted)\n}; |', '|  |\n|  |\n| RA Family |']","{'title': 'RA Family: Why does the actual IIC transfer rate differ from the rate defined in the configurator?', 'url': 'https://en-support.renesas.com/knowledgeBase/21652593', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:12.934662'}","Question Why does the actual IIC transfer rate differ from the rate defined in the configurator? Answer The FSP riicmaster driver calculates the following register values so that they are close to the transfer rate (Rate), including the Rise Time and Fall Time set in the configurator. Bit Rate High-Level Period (ICBRH.BRH) Bit Rate Low-Level Period (ICBRL.BRL) Internal Reference Clock Select (ICMR1.CKS) The calculated values can be confirmed in ragen/haldata.c as follows. const iicmasterextendedcfgt gi2cmaster0extend   (omitted) / Actual calculated bitrate 394997. Actual calculated duty cycle 49. / .clocksettings.brlvalue  24, .clocksettings.brhvalue  23, .clocksettings.cksvalue  0, ; The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator. Suitable Products RA Family const iicmasterextendedcfgt gi2cmaster0extend  .clocksettings.brlvalue  24 , .clocksettings.brhvalue  23, .clocksettings.cksvalue  0, The Rise Time and Fall Time vary depending on the pull-up resistance of the external connection, the wiring characteristics, and other factors. To get close to the desired IIC transfer rate, observe the Rise Time and Fall Time of the SCL clock that is actually output with an oscilloscope, etc., and set the results in the configurator. ",
22e1c8081711a1e3ff1a1860fa7ced4f,"Question:
When using USBX Host Printer Class, UX_NO_TD_AVAILABLE error occurs
Answer:
If the number of TDs (Transfer Descriptor)s is insufficient, the UX_NO_TD_AVAILABLE error occurs. If wMaxPacketSize is small (eg 8 bytes), many TDs are needed. Setting a large number of TDs will eliminate the error. The Maximum TDs (default value is 128) can be defined in the USBX Source property. See USBX Source Component Overview in the SSP Users Manual.
  Suitable Products
RA and FSP
When using USBX Host Printer Class, UX_NO_TD_AVAILABLE error occurs
When using USBX Host Printer Class, UX_NO_TD_AVAILABLE error occurs
Answer:
If the number of TDs (Transfer Descriptor)s is insufficient, the UX_NO_TD_AVAILABLE error occurs. If wMaxPacketSize is small (eg 8 bytes), many TDs are needed. Setting a large number of TDs will eliminate the error. The Maximum TDs (default value is 128) can be defined in the USBX Source property. See USBX Source Component Overview in the SSP Users Manual.
  Suitable Products
RA and FSP
If the number of TDs (Transfer Descriptor)s is insufficient, the UX_NO_TD_AVAILABLE error occurs. If wMaxPacketSize is small (eg 8 bytes), many TDs are needed. Setting a large number of TDs will eliminate the error. The Maximum TDs (default value is 128) can be defined in the USBX Source property. See USBX Source Component Overview in the SSP Users Manual.
If the number of TDs (Transfer Descriptor)s is insufficient, the UX_NO_TD_AVAILABLE error occurs. If wMaxPacketSize is small (eg 8 bytes), many TDs are needed. Setting a large number of TDs will eliminate the error. The Maximum TDs (default value is 128) can be defined in the USBX Source property. See USBX Source Component Overview in the SSP Users Manual.
Suitable Products
RA and FSP
Go to Japanese
Go to Japanese",['data/categories/ra_family/rafsp_knowledge_base/22e1c8081711a1e3ff1a1860fa7ced4f/images/6aea1a04b7917f35d212489e4b52e9cb.png'],[],['|  |\n|  |\n| RA and FSP |'],"{'title': 'When using USBX Host Printer Class, UX_NO_TD_AVAILABLE error occurs', 'url': 'https://en-support.renesas.com/knowledgeBase/20459401', 'last_updated': '2022-05-04', 'extracted_at': '2025-03-08T23:25:25.639024'}","Question When using USBX Host Printer Class, UXNOTDAVAILABLE error occurs Answer If the number of TDs (Transfer Descriptor)s is insufficient, the UXNOTDAVAILABLE error occurs. If wMaxPacketSize is small (eg 8 bytes), many TDs are needed. Setting a large number of TDs will eliminate the error. The Maximum TDs (default value is 128) can be defined in the USBX Source property. See USBX Source Component Overview in the SSP Users Manual. Suitable Products RA and FSP Suitable Products Go to Japanese",
dc6375c87e892c02b82496f5573a59eb,"Question:
The input pin level and the level indicated by the GPIO register do not match
Answer:
Some I/O pins may require initialization depending on the relationship with other functions assigned to the pins. For example, in the case of RA4M2, P402, P403, P404 can function as RTC input or AGT input function being enabled by VBTICTLR setting in addition to the I/O port configuration. As the VBTICTLR register setting is not initialized by reset, be careful that those pins will not be initialized to be input pins automatically by reset. In typical FSP-based projects, the register is initialized by R_IOPORT_Open() that is called in R_BSP_WarmStart(); therefore, you dont need to take care of the register initialization. However, if you don't use the initialization code provided in FSP, you need to handle the register initialization by yourself.
  Suitable Products
RA and FSP
The input pin level and the level indicated by the GPIO register do not match
The input pin level and the level indicated by the GPIO register do not match
Answer:
Some I/O pins may require initialization depending on the relationship with other functions assigned to the pins. For example, in the case of RA4M2, P402, P403, P404 can function as RTC input or AGT input function being enabled by VBTICTLR setting in addition to the I/O port configuration. As the VBTICTLR register setting is not initialized by reset, be careful that those pins will not be initialized to be input pins automatically by reset. In typical FSP-based projects, the register is initialized by R_IOPORT_Open() that is called in R_BSP_WarmStart(); therefore, you dont need to take care of the register initialization. However, if you don't use the initialization code provided in FSP, you need to handle the register initialization by yourself.
  Suitable Products
RA and FSP
Some I/O pins may require initialization depending on the relationship with other functions assigned to the pins. For example, in the case of RA4M2, P402, P403, P404 can function as RTC input or AGT input function being enabled by VBTICTLR setting in addition to the I/O port configuration. As the VBTICTLR register setting is not initialized by reset, be careful that those pins will not be initialized to be input pins automatically by reset. In typical FSP-based projects, the register is initialized by R_IOPORT_Open() that is called in R_BSP_WarmStart(); therefore, you dont need to take care of the register initialization. However, if you don't use the initialization code provided in FSP, you need to handle the register initialization by yourself.
  Suitable Products
RA and FSP
Some I/O pins may require initialization depending on the relationship with other functions assigned to the pins. For example, in the case of RA4M2, P402, P403, P404 can function as RTC input or AGT input function being enabled by VBTICTLR setting in addition to the I/O port configuration. As the VBTICTLR register setting is not initialized by reset, be careful that those pins will not be initialized to be input pins automatically by reset. In typical FSP-based projects, the register is initialized by R_IOPORT_Open() that is called in R_BSP_WarmStart(); therefore, you dont need to take care of the register initialization. However, if you don't use the initialization code provided in FSP, you need to handle the register initialization by yourself.
Suitable Products
RA and FSP
Go to Japanese
Go to Japanese",['data/categories/ra_family/rafsp_knowledge_base/dc6375c87e892c02b82496f5573a59eb/images/0699ccd2c9c8fc887b16383a9d5dec58.png'],[],['|  |\n|  |\n| RA and FSP |'],"{'title': 'RA Family: The input pin level and the level indicated by the GPIO register do not match', 'url': 'https://en-support.renesas.com/knowledgeBase/20797631', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:50.972493'}","Question The input pin level and the level indicated by the GPIO register do not match Answer Some I/O pins may require initialization depending on the relationship with other functions assigned to the pins. For example, in the case of RA4M2, P402, P403, P404 can function as RTC input or AGT input function being enabled by VBTICTLR setting in addition to the I/O port configuration. As the VBTICTLR register setting is not initialized by reset, be careful that those pins will not be initialized to be input pins automatically by reset. In typical FSP-based projects, the register is initialized by RIOPORTOpen() that is called in RBSPWarmStart(); therefore, you dont need to take care of the register initialization. However, if you don't use the initialization code provided in FSP, you need to handle the register initialization by yourself. Suitable Products RA and FSP Suitable Products Go to Japanese",
48180f9f6caba0ae2fa0892b01439cef,"In some cases it is possible that erasing or re-programming your target fails. Especially, if the option-setting memory area is overwritten, there is risk that the Security MPU settings have been enabled.
In some cases it is possible that erasing or re-programming your target fails. Especially, if the option-setting memory area is overwritten, there is risk that the Security MPU settings have been enabled.
To check if your MCU has been locked permanently try to run the script attached in folder RA2A1_Erase_Block_0.zip.
This script erases block 0 of code flash. You must edit  the JLink_path.bat to point to the location of JLink.exe, and then open command prompt in order to run the script.
If the script runs successfully and block 0 is erased you should see something like this:
Suitable Products
Suitable Products
RA2A1,RA2L1,RA2E1,RA2E2,RA2E3,RA2A2,RA4M1,RA4W1
RA2A1,RA2L1,RA2E1,RA2E2,RA2E3,RA2A2,RA4M1,RA4W1","['data/categories/ra_family/rafsp_knowledge_base/48180f9f6caba0ae2fa0892b01439cef/images/81ced95fcbb6498447d038057d318a86.png', 'data/categories/ra_family/rafsp_knowledge_base/48180f9f6caba0ae2fa0892b01439cef/images/94ad7f229d34cea54071080227b331d6.png']",[],[],"{'title': 'Cannot erase or program RA2A1', 'url': 'https://en-support.renesas.com/knowledgeBase/21732378', 'last_updated': None, 'extracted_at': '2025-03-08T23:22:33.779996'}","In some cases it is possible that erasing or re-programming your target fails. Especially, if the option-setting memory area is overwritten, there is risk that the Security MPU settings have been enabled. To check if your MCU has been locked permanently try to run the script attached in folder RA2A1EraseBlock0.zip. This script erases block 0 of code flash. You must edit the JLinkpath.bat to point to the location of JLink.exe, and then open command prompt in order to run the script. If the script runs successfully and block 0 is erased you should see something like this Suitable Products RA2A1,RA2L1,RA2E1,RA2E2,RA2E3,RA2A2,RA4M1,RA4W1",
d19612efac1ff72ba73b5e38e6da5a23,"Question:
Is there a way to customize the Interrupt Service Routine (ISR) settings in FSP Configurator?
For instance:
Stacks tab: Replace the ISR of the added driver with a user-defined one.
Register a new ISR corresponding to the interrupt event of each peripheral function.
Answer:
In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows.
If you add a new gpt_user_isr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gpt_user_isr will be registered as an ISR as shown below.
For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure.
References:
FSP User's Manual ""Configuring a Project""
URL: https://renesas.github.io/fsp/_s_t_a_r_t__d_e_v.html#configuring-a-project
RA and FSP Curriculum: I-002A Fundamentals of FSP (Non-Trustzone)
FSP CONFIGURATOR  INTERRUPT LINKS TAB
Suitable Products
RA Family
Is there a way to customize the Interrupt Service Routine (ISR) settings in FSP Configurator?
For instance:
Stacks tab: Replace the ISR of the added driver with a user-defined one.
Register a new ISR corresponding to the interrupt event of each peripheral function.
Is there a way to customize the Interrupt Service Routine (ISR) settings in FSP Configurator?
For instance:
Answer:
In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows.
If you add a new gpt_user_isr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gpt_user_isr will be registered as an ISR as shown below.
For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure.
References:
FSP User's Manual ""Configuring a Project""
URL: https://renesas.github.io/fsp/_s_t_a_r_t__d_e_v.html#configuring-a-project
RA and FSP Curriculum: I-002A Fundamentals of FSP (Non-Trustzone)
FSP CONFIGURATOR  INTERRUPT LINKS TAB
Suitable Products
RA Family
In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows.
If you add a new gpt_user_isr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gpt_user_isr will be registered as an ISR as shown below.
For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure.
References:
FSP User's Manual ""Configuring a Project""
URL: https://renesas.github.io/fsp/_s_t_a_r_t__d_e_v.html#configuring-a-project
RA and FSP Curriculum: I-002A Fundamentals of FSP (Non-Trustzone)
FSP CONFIGURATOR  INTERRUPT LINKS TAB
Suitable Products
In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows.
If you add a new gpt_user_isr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gpt_user_isr will be registered as an ISR as shown below.
For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure.
References:
FSP User's Manual ""Configuring a Project""
URL: https://renesas.github.io/fsp/_s_t_a_r_t__d_e_v.html#configuring-a-project
RA and FSP Curriculum: I-002A Fundamentals of FSP (Non-Trustzone)
FSP CONFIGURATOR  INTERRUPT LINKS TAB
In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows.
If you add a new gpt_user_isr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gpt_user_isr will be registered as an ISR as shown below.
For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure.
References:
Suitable Products
RA Family

","['data/categories/ra_family/rafsp_knowledge_base/d19612efac1ff72ba73b5e38e6da5a23/images/9edb7aca4a002bf48ee5a2733b1dee14.png', 'data/categories/ra_family/rafsp_knowledge_base/d19612efac1ff72ba73b5e38e6da5a23/images/c8e473e2186a3c1cb0b28651ef694ee9.png']",[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: How to customize (add or replace) interrupt service routines (ISRs)', 'url': 'https://en-support.renesas.com/knowledgeBase/21715563', 'last_updated': '2024-10-12', 'extracted_at': '2025-03-08T23:22:39.749204'}","Question Is there a way to customize the Interrupt Service Routine (ISR) settings in FSP Configurator? For instance Stacks tab Replace the ISR of the added driver with a user-defined one. Register a new ISR corresponding to the interrupt event of each peripheral function. Answer In the FSP Configurator, you can check, edit, and register additional ISR settings in the Interrupts tab. For example, if you add a driver module for GPT channel 0 to the Stacks tab, the ISR provided by the FSP driver will be registered as follows. If you add a new gptuserisr as an ISR for GPT0 COUNTER OVERFLOW from New User Event, gptuserisr will be registered as an ISR as shown below. For interrupt events that are not listed in Allocations, you can register a new user-defined function as an ISR by following the same procedure. References FSP User's Manual ""Configuring a Project"" URL https//renesas.github.io/fsp/startdev.htmlconfiguring-a-project RA and FSP Curriculum I-002A Fundamentals of FSP (Non-Trustzone) FSP CONFIGURATOR  INTERRUPT LINKS TAB Suitable Products RA Family ",
21dd805601c92b592dd87633f353b9a8,"Question:
In the Problems tab of e2 studio, you might see the message ""Pin with no drivers"" related to the RA Family Smart Configurator. What does this mean? Also, is there a way to get rid of this display?
Answer:
""Pin with no drivers"" means that there are no drivers associated with the pins to which peripheral functions are assigned in the pin configuration of the configurator. You can find out if there are any unwanted pin settings by checking the pin settings to which this indication applies.
To change the display conditions of Pin Driver Warnings, set them in Configure Pin Driver Warnings.
Suitable Products
RA Family
In the Problems tab of e2 studio, you might see the message ""Pin with no drivers"" related to the RA Family Smart Configurator. What does this mean? Also, is there a way to get rid of this display?
In the Problems tab of e2 studio, you might see the message ""Pin with no drivers"" related to the RA Family Smart Configurator. What does this mean? Also, is there a way to get rid of this display?
Answer:
""Pin with no drivers"" means that there are no drivers associated with the pins to which peripheral functions are assigned in the pin configuration of the configurator. You can find out if there are any unwanted pin settings by checking the pin settings to which this indication applies.
To change the display conditions of Pin Driver Warnings, set them in Configure Pin Driver Warnings.
Suitable Products
RA Family
""Pin with no drivers"" means that there are no drivers associated with the pins to which peripheral functions are assigned in the pin configuration of the configurator. You can find out if there are any unwanted pin settings by checking the pin settings to which this indication applies.
To change the display conditions of Pin Driver Warnings, set them in Configure Pin Driver Warnings.
Suitable Products
""Pin with no drivers"" means that there are no drivers associated with the pins to which peripheral functions are assigned in the pin configuration of the configurator. You can find out if there are any unwanted pin settings by checking the pin settings to which this indication applies.
To change the display conditions of Pin Driver Warnings, set them in Configure Pin Driver Warnings.
Suitable Products
RA Family

","['data/categories/ra_family/rafsp_knowledge_base/21dd805601c92b592dd87633f353b9a8/images/41673741faaf59dfe0f3076cf4fd51a3.png', 'data/categories/ra_family/rafsp_knowledge_base/21dd805601c92b592dd87633f353b9a8/images/6c012154347ef0129ea5503782ff0f87.png']",[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: What does it mean when I see the message ""Pin with no drivers"" related to Smart Configurator?', 'url': 'https://en-support.renesas.com/knowledgeBase/21698319', 'last_updated': None, 'extracted_at': '2025-03-08T23:22:45.585503'}","Question In the Problems tab of e2 studio, you might see the message ""Pin with no drivers"" related to the RA Family Smart Configurator. What does this mean? Also, is there a way to get rid of this display? Answer ""Pin with no drivers"" means that there are no drivers associated with the pins to which peripheral functions are assigned in the pin configuration of the configurator. You can find out if there are any unwanted pin settings by checking the pin settings to which this indication applies. To change the display conditions of Pin Driver Warnings, set them in Configure Pin Driver Warnings. Suitable Products RA Family ",
c0c620d4b540c9d439bcd389811414af,"Question:
AES encryption performance difference when C-/S-caches are on/off
Answer:
This article intends to demonstrate how the performance of RA SCE9 Encryption engine operation can be improved when C-Cache and S-Cache are both enabled. In this case study, the AES-CBC mode and key size of 256 bits are used as a base example for doing the performance comparison. A brief operation flow of SCE9 HW AES Encryption operation and the workspace environment setting are listed below. In addition, the operation time measurement uses either toggling the GPIO output level or DWT cycle counter.
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize more)
System Clock configuration: ICLK=200MHz
Peripheral Clock configuration: PCLKA=100MHz
Board: EK-RA6M4
The CPU process time for each step is measured as below based on GPIO output level change:
Message size is 2048 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23.26us
HW_SCE_Aes256EncryptDecryptUpdateSub 65.37us
HW_SCE_Aes256EncryptDecryptFinalSub 3.02us
Whole AE256 CBC Encryption process 89us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.8us
HW_SCE_Aes256EncryptDecryptUpdateSub 66.8us
HW_SCE_Aes256EncryptDecryptFinalSub 3.3us
Whole AE256 CBC Encryption process 95.6us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.76us
HW_SCE_Aes256EncryptDecryptUpdateSub 75.62us
HW_SCE_Aes256EncryptDecryptFinalSub 4.05us
Whole AE256 CBC Encryption process 114.3us
  Message size is 1024 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23us
HW_SCE_Aes256EncryptDecryptUpdateSub 34us
HW_SCE_Aes256EncryptDecryptFinalSub 2.8us
Whole AE256 CBC Encryption process 60us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 26us
HW_SCE_Aes256EncryptDecryptUpdateSub 35.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.1us
Whole AE256 CBC Encryption process 62.82us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 35us
HW_SCE_Aes256EncryptDecryptUpdateSub 39.8us
HW_SCE_Aes256EncryptDecryptFinalSub 4.3us
Whole AE256 CBC Encryption process 78.1us
  Message size is 256 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 22.85us
HW_SCE_Aes256EncryptDecryptUpdateSub 10.4us
HW_SCE_Aes256EncryptDecryptFinalSub 3us
Whole AE256 CBC Encryption process 36.05us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.9us
HW_SCE_Aes256EncryptDecryptUpdateSub 11.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.25us
Whole AE256 CBC Encryption process 39.84us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.6us
HW_SCE_Aes256EncryptDecryptUpdateSub 13us
HW_SCE_Aes256EncryptDecryptFinalSub 4.12us
Whole AE256 CBC Encryption process 51.22us
  According to the result, we can identify over 20% performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus
Reference Attachments:
Example project on EK-RA6M4 for above performance benchmarking test (below)
Suitable Products
RA Devices with SCE9
AES encryption performance difference when C-/S-caches are on/off
AES encryption performance difference when C-/S-caches are on/off
Answer:
This article intends to demonstrate how the performance of RA SCE9 Encryption engine operation can be improved when C-Cache and S-Cache are both enabled. In this case study, the AES-CBC mode and key size of 256 bits are used as a base example for doing the performance comparison. A brief operation flow of SCE9 HW AES Encryption operation and the workspace environment setting are listed below. In addition, the operation time measurement uses either toggling the GPIO output level or DWT cycle counter.
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize more)
System Clock configuration: ICLK=200MHz
Peripheral Clock configuration: PCLKA=100MHz
Board: EK-RA6M4
The CPU process time for each step is measured as below based on GPIO output level change:
Message size is 2048 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23.26us
HW_SCE_Aes256EncryptDecryptUpdateSub 65.37us
HW_SCE_Aes256EncryptDecryptFinalSub 3.02us
Whole AE256 CBC Encryption process 89us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.8us
HW_SCE_Aes256EncryptDecryptUpdateSub 66.8us
HW_SCE_Aes256EncryptDecryptFinalSub 3.3us
Whole AE256 CBC Encryption process 95.6us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.76us
HW_SCE_Aes256EncryptDecryptUpdateSub 75.62us
HW_SCE_Aes256EncryptDecryptFinalSub 4.05us
Whole AE256 CBC Encryption process 114.3us
  Message size is 1024 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23us
HW_SCE_Aes256EncryptDecryptUpdateSub 34us
HW_SCE_Aes256EncryptDecryptFinalSub 2.8us
Whole AE256 CBC Encryption process 60us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 26us
HW_SCE_Aes256EncryptDecryptUpdateSub 35.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.1us
Whole AE256 CBC Encryption process 62.82us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 35us
HW_SCE_Aes256EncryptDecryptUpdateSub 39.8us
HW_SCE_Aes256EncryptDecryptFinalSub 4.3us
Whole AE256 CBC Encryption process 78.1us
  Message size is 256 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 22.85us
HW_SCE_Aes256EncryptDecryptUpdateSub 10.4us
HW_SCE_Aes256EncryptDecryptFinalSub 3us
Whole AE256 CBC Encryption process 36.05us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.9us
HW_SCE_Aes256EncryptDecryptUpdateSub 11.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.25us
Whole AE256 CBC Encryption process 39.84us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.6us
HW_SCE_Aes256EncryptDecryptUpdateSub 13us
HW_SCE_Aes256EncryptDecryptFinalSub 4.12us
Whole AE256 CBC Encryption process 51.22us
  According to the result, we can identify over 20% performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus
Reference Attachments:
Example project on EK-RA6M4 for above performance benchmarking test (below)
Suitable Products
RA Devices with SCE9
This article intends to demonstrate how the performance of RA SCE9 Encryption engine operation can be improved when C-Cache and S-Cache are both enabled. In this case study, the AES-CBC mode and key size of 256 bits are used as a base example for doing the performance comparison. A brief operation flow of SCE9 HW AES Encryption operation and the workspace environment setting are listed below. In addition, the operation time measurement uses either toggling the GPIO output level or DWT cycle counter.
Compiler: GCC10.3.1
Compiler Optimization Level: O2 (Optimize more)
System Clock configuration: ICLK=200MHz
Peripheral Clock configuration: PCLKA=100MHz
Board: EK-RA6M4
The CPU process time for each step is measured as below based on GPIO output level change:
Message size is 2048 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23.26us
HW_SCE_Aes256EncryptDecryptUpdateSub 65.37us
HW_SCE_Aes256EncryptDecryptFinalSub 3.02us
Whole AE256 CBC Encryption process 89us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.8us
HW_SCE_Aes256EncryptDecryptUpdateSub 66.8us
HW_SCE_Aes256EncryptDecryptFinalSub 3.3us
Whole AE256 CBC Encryption process 95.6us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.76us
HW_SCE_Aes256EncryptDecryptUpdateSub 75.62us
HW_SCE_Aes256EncryptDecryptFinalSub 4.05us
Whole AE256 CBC Encryption process 114.3us
  Message size is 1024 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 23us
HW_SCE_Aes256EncryptDecryptUpdateSub 34us
HW_SCE_Aes256EncryptDecryptFinalSub 2.8us
Whole AE256 CBC Encryption process 60us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 26us
HW_SCE_Aes256EncryptDecryptUpdateSub 35.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.1us
Whole AE256 CBC Encryption process 62.82us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 35us
HW_SCE_Aes256EncryptDecryptUpdateSub 39.8us
HW_SCE_Aes256EncryptDecryptFinalSub 4.3us
Whole AE256 CBC Encryption process 78.1us
  Message size is 256 bytes:
HW SCE operation S-Cache C-Cache F-Cache Process time
HW_SCE_Aes256EncryptDecryptInitSub Enable Enable Enable 22.85us
HW_SCE_Aes256EncryptDecryptUpdateSub 10.4us
HW_SCE_Aes256EncryptDecryptFinalSub 3us
Whole AE256 CBC Encryption process 36.05us
HW_SCE_Aes256EncryptDecryptInitSub Disable Enable Enable 25.9us
HW_SCE_Aes256EncryptDecryptUpdateSub 11.3us
HW_SCE_Aes256EncryptDecryptFinalSub 3.25us
Whole AE256 CBC Encryption process 39.84us
HW_SCE_Aes256EncryptDecryptInitSub Disable Disable Enable 34.6us
HW_SCE_Aes256EncryptDecryptUpdateSub 13us
HW_SCE_Aes256EncryptDecryptFinalSub 4.12us
Whole AE256 CBC Encryption process 51.22us
  According to the result, we can identify over 20% performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus
Reference Attachments:
Example project on EK-RA6M4 for above performance benchmarking test (below)
This article intends to demonstrate how the performance of RA SCE9 Encryption engine operation can be improved when C-Cache and S-Cache are both enabled. In this case study, the AES-CBC mode and key size of 256 bits are used as a base example for doing the performance comparison. A brief operation flow of SCE9 HW AES Encryption operation and the workspace environment setting are listed below. In addition, the operation time measurement uses either toggling the GPIO output level or DWT cycle counter.
The CPU process time for each step is measured as below based on GPIO output level change:
According to the result, we can identify over 20% performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus
Reference Attachments:
Suitable Products
RA Devices with SCE9",['data/categories/ra_family/rafsp_knowledge_base/c0c620d4b540c9d439bcd389811414af/images/55d5633c8b99d64dee61199f13a6b3e1.png'],[],"['|  |\n|  |\n| HW SCE operation | S-Cache | C-Cache | F-Cache | Process time |\n| HW_SCE_Aes256EncryptDecryptInitSub | Enable | Enable | Enable | 23.26us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 65.37us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 3.02us |\n| Whole AE256 CBC Encryption process | 89us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Enable | Enable | 25.8us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 66.8us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 3.3us |\n| Whole AE256 CBC Encryption process | 95.6us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Disable | Enable | 34.76us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 75.62us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 4.05us |\n| Whole AE256 CBC Encryption process | 114.3us |', '|  |\n|  |\n| HW SCE operation | S-Cache | C-Cache | F-Cache | Process time |\n| HW_SCE_Aes256EncryptDecryptInitSub | Enable | Enable | Enable | 23us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 34us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 2.8us |\n| Whole AE256 CBC Encryption process | 60us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Enable | Enable | 26us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 35.3us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 3.1us |\n| Whole AE256 CBC Encryption process | 62.82us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Disable | Enable | 35us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 39.8us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 4.3us |\n| Whole AE256 CBC Encryption process | 78.1us |', '|  |\n|  |\n| HW SCE operation | S-Cache | C-Cache | F-Cache | Process time |\n| HW_SCE_Aes256EncryptDecryptInitSub | Enable | Enable | Enable | 22.85us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 10.4us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 3us |\n| Whole AE256 CBC Encryption process | 36.05us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Enable | Enable | 25.9us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 11.3us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 3.25us |\n| Whole AE256 CBC Encryption process | 39.84us |\n| HW_SCE_Aes256EncryptDecryptInitSub | Disable | Disable | Enable | 34.6us |\n| HW_SCE_Aes256EncryptDecryptUpdateSub | 13us |\n| HW_SCE_Aes256EncryptDecryptFinalSub | 4.12us |\n| Whole AE256 CBC Encryption process | 51.22us |', '|  |\n|  |\n| RA Devices with SCE9 |']","{'title': 'RA Devices with SCE9: AES encryption performance difference when C-/S-caches are on/off', 'url': 'https://en-support.renesas.com/knowledgeBase/21177409', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:39.352193'}","Question AES encryption performance difference when C-/S-caches are on/off Answer This article intends to demonstrate how the performance of RA SCE9 Encryption engine operation can be improved when C-Cache and S-Cache are both enabled. In this case study, the AES-CBC mode and key size of 256 bits are used as a base example for doing the performance comparison. A brief operation flow of SCE9 HW AES Encryption operation and the workspace environment setting are listed below. In addition, the operation time measurement uses either toggling the GPIO output level or DWT cycle counter. Compiler GCC10.3.1 Compiler Optimization Level O2 (Optimize more) System Clock configuration ICLK200MHz Peripheral Clock configuration PCLKA100MHz Board EK-RA6M4 The CPU process time for each step is measured as below based on GPIO output level change Message size is 2048 bytes HW SCE operation S-Cache C-Cache F-Cache Process time HWSCEAes256EncryptDecryptInitSub Enable Enable Enable 23.26us HWSCEAes256EncryptDecryptUpdateSub 65.37us HWSCEAes256EncryptDecryptFinalSub 3.02us Whole AE256 CBC Encryption process 89us HWSCEAes256EncryptDecryptInitSub Disable Enable Enable 25.8us HWSCEAes256EncryptDecryptUpdateSub 66.8us HWSCEAes256EncryptDecryptFinalSub 3.3us Whole AE256 CBC Encryption process 95.6us HWSCEAes256EncryptDecryptInitSub Disable Disable Enable 34.76us HWSCEAes256EncryptDecryptUpdateSub 75.62us HWSCEAes256EncryptDecryptFinalSub 4.05us Whole AE256 CBC Encryption process 114.3us Message size is 1024 bytes HWSCEAes256EncryptDecryptInitSub Enable Enable Enable 23us HWSCEAes256EncryptDecryptUpdateSub 34us HWSCEAes256EncryptDecryptFinalSub 2.8us Whole AE256 CBC Encryption process 60us HWSCEAes256EncryptDecryptInitSub Disable Enable Enable 26us HWSCEAes256EncryptDecryptUpdateSub 35.3us HWSCEAes256EncryptDecryptFinalSub 3.1us Whole AE256 CBC Encryption process 62.82us HWSCEAes256EncryptDecryptInitSub Disable Disable Enable 35us HWSCEAes256EncryptDecryptUpdateSub 39.8us HWSCEAes256EncryptDecryptFinalSub 4.3us Whole AE256 CBC Encryption process 78.1us Message size is 256 bytes HWSCEAes256EncryptDecryptInitSub Enable Enable Enable 22.85us HWSCEAes256EncryptDecryptUpdateSub 10.4us HWSCEAes256EncryptDecryptFinalSub 3us Whole AE256 CBC Encryption process 36.05us HWSCEAes256EncryptDecryptInitSub Disable Enable Enable 25.9us HWSCEAes256EncryptDecryptUpdateSub 11.3us HWSCEAes256EncryptDecryptFinalSub 3.25us Whole AE256 CBC Encryption process 39.84us HWSCEAes256EncryptDecryptInitSub Disable Disable Enable 34.6us HWSCEAes256EncryptDecryptUpdateSub 13us HWSCEAes256EncryptDecryptFinalSub 4.12us Whole AE256 CBC Encryption process 51.22us According to the result, we can identify over 20 performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus Reference Attachments Example project on EK-RA6M4 for above performance benchmarking test (below) Suitable Products RA Devices with SCE9 According to the result, we can identify over 20 performance improvement when both C-Cache and S-Cache are enabled, especially the C-Cache influence. In the default RA base project, the FSP generated start up and system initialization enables the flash cache (F-Cache) and system level instruction cache (C-Cache), and user can enable the system level data cache (S-Cache) based on the requirement. For the design consideration of using S-Cache in an application, please refer to the App Note - Guidelines for Using the S Cache on the System Bus",
e05a984f1d6cd781dca3f23d9adddc7d,"Question:
How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the ID Code Mode to Locked with All Erase support and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/* ID CODE: 00112233445566778899AABBCCDDEEff */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEFFAC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEFF00

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEFF30

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.


Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below.

You can also set it in the authentication code settings dialog as follows:

Suitable Products
RA and FSP
How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case?
Answer:
How to set the ID code
In the FSP configurator, set the ID Code Mode to Locked with All Erase support and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/* ID CODE: 00112233445566778899AABBCCDDEEff */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEFFAC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEFF00

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEFF30

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.


Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below.

You can also set it in the authentication code settings dialog as follows:

Suitable Products
RA and FSP
How to set the ID code
In the FSP configurator, set the ID Code Mode to Locked with All Erase support and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below.
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/* ID CODE: 00112233445566778899AABBCCDDEEff */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC)

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEFFAC

In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEFF00

In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEFF30

Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite.

The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog.

If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:

In case of E2/E2 Lite debugger:

Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.


Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows.

After creating an RFP project, set the ID code as follows.

Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below.

You can also set it in the authentication code settings dialog as follows:
How to set the ID code
In the FSP configurator, set the ID Code Mode to Locked with All Erase support and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below.
In the FSP configurator, set the ID Code Mode to Locked with All Erase support and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below.
The value of the ID code in the OSIS register
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
00112233
44556677
8899AABB
CCDDEEFF
/* ID CODE: 00112233445566778899AABBCCDDEEff */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC)
/* ID CODE: 00112233445566778899AABBCCDDEEff */
00112233
44556677
8899AABB
CCDDEEff
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
33221100
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
77665544
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
BBAA9988
#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC)
ffEEDDCC
The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register:
In case of RA2L1:
In case of RA2L1:
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEFFAC
S3150101001800112233FFFFFFFF44556677FFFFFFFFFC
S311010100288899AABBFFFFFFFFCCDDEEFFAC
00112233
44556677
8899AABB
CCDDEEFF
In case of RA6M3:
In case of RA6M3:
S3150100A15000112233445566778899AABBCCDDEEFF00
S3150100A15000112233445566778899AABBCCDDEEFF00
S3150100A150
00112233
44556677
8899AABB
CCDDEEFF
00
In case of RA4E2:
In case of RA4E2:
S3150100A12000112233445566778899AABBCCDDEEFF30
S3150100A12000112233445566778899AABBCCDDEEFF30
S3150100A120
00112233
44556677
8899AABB
CCDDEEFF
30
Debugger connection in e2 studio (ID code authentication)
Debugger connection in e2 studio (ID code authentication)
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite.
When connecting with e2 studio, set the ID code in Debugger -> Connection Settings -> Connection -> ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite.
Debugger -> Connection Settings -> Connection -> ID Code (Bytes)
The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog.
The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog.
If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed.
In case of J-Link debugger:
In case of J-Link debugger:
In case of E2/E2 Lite debugger:
In case of E2/E2 Lite debugger:
Debugger connection in e2 studio (with ALeRASE execution)
Debugger connection in e2 studio (with ALeRASE execution)
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
FFFFFFFFFFFFFFFFFF45534152654C41
Connection by RFP (with ID code authentication)
Connection by RFP (with ID code authentication)
If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows.
If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows.
FFEEDDCCBBAA99887766554433221100
After creating an RFP project, set the ID code as follows.
After creating an RFP project, set the ID code as follows.
Connection by RFP (with ALeRASE execution)
Connection by RFP (with ALeRASE execution)
If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below.
If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below.
414C6552415345FFFFFFFFFFFFFFFFFF
You can also set it in the authentication code settings dialog as follows:
You can also set it in the authentication code settings dialog as follows:
Suitable Products
RA and FSP
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/554c3a81b680af1327e431109948edca.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/2c0157a51d02c7082d8f894babfe8f5a.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/5e4235c17e0c01a9d6a2e6a06e1a67b7.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/3db10a56bfc92cef3458194713044596.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/2f1f3cdcdd90872ee62ce9b91849211f.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/d893c47bf86a17ffd26853130cedaaee.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/c6c3f4892cabdd6ed0fb5bc4567691f3.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/df748f5dfd1a525d1c0bf87d2bf69208.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/2cf0d837f17e0ca296d4653753336afb.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/f05a8f46caf53abb4b5d7a40891de95c.png', 'data/categories/ra_family/rafsp_knowledge_base/e05a984f1d6cd781dca3f23d9adddc7d/images/edfbb8594ea5c98174d951ddf325565e.png']",[],"['|  |\n|  |\n| /* ID CODE: 00112233445566778899AABBCCDDEEff */\n#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)\n#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)\n#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)\n#define BSP_CFG_ID_CODE_LONG_4 (0xffEEDDCC) |', '|  |\n|  |\n| S3150101001800112233FFFFFFFF44556677FFFFFFFFFC\nS311010100288899AABBFFFFFFFFCCDDEEFFAC |', '|  |\n|  |\n| S3150100A15000112233445566778899AABBCCDDEEFF00 |', '|  |\n|  |\n| S3150100A12000112233445566778899AABBCCDDEEFF30 |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: ID code protection (in case of protection enabled with Bit127=1 and Bit126=1)', 'url': 'https://en-support.renesas.com/knowledgeBase/20980156', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:39.424703'}","Question How to set the ID Code when protection is enabled and ALeRASE command execution is enabled, and how to connect a debugger or programmer in that case? Answer How to set the ID code In the FSP configurator, set the ID Code Mode to Locked with All Erase support and set 16bytes ID code to ID Code (32 Hex Characters) in the BSP property as shown below. The value of the ID code in the OSIS register In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. This setting is output to racfg/fspcfg/bsp/bspmcufamilycfg.h as shown below. / ID CODE 00112233445566778899AABBCCDDEEff / define BSPCFGIDCODELONG1 (0x33221100) define BSPCFGIDCODELONG2 (0x77665544) define BSPCFGIDCODELONG3 (0xBBAA9988) define BSPCFGIDCODELONG4 (0xffEEDDCC) The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register In case of RA2L1 S3150101001800112233FFFFFFFF44556677FFFFFFFFFC S311010100288899AABBFFFFFFFFCCDDEEFFAC In case of RA6M3 S3150100A15000112233445566778899AABBCCDDEEFF00 In case of RA4E2 S3150100A12000112233445566778899AABBCCDDEEFF30 Debugger connection in e2 studio (ID code authentication) When connecting with e2 studio, set the ID code in Debugger - Connection Settings - Connection - ID Code (Bytes) as shown below. It shows the case of J-Link, but the same applies to the E2 and E2 Lite. The figure below is the dialog which appears by clicking  button. You can also set the ID Code on this dialog. If you start a debug connection and the ID code authentication succeeds, the debug connection succeeds as usual. If ID code authentication fails, the following dialog will be displayed. In case of J-Link debugger In case of E2/E2 Lite debugger Debugger connection in e2 studio (with ALeRASE execution) In case of E2 or E2 Lite, you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID Code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution. Connection by RFP (with ID code authentication) If the authentication dialog is displayed when connecting in RFP, enter the ID code (FFEEDDCCBBAA99887766554433221100) as follows. After creating an RFP project, set the ID code as follows. Connection by RFP (with ALeRASE execution) If an authentication dialog is displayed when connecting in RFP, you can erase the entire internal flash ROM by entering the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF) as shown below. You can also set it in the authentication code settings dialog as follows Suitable Products RA and FSP 00112233 44556677 8899AABB CCDDEEFF CCDDEEff 33221100 77665544 BBAA9988 ffEEDDCC S3150100A150 00 S3150100A120 30 Debugger - Connection Settings - Connection - ID Code (Bytes) FFFFFFFFFFFFFFFFFF45534152654C41 FFEEDDCCBBAA99887766554433221100 414C6552415345FFFFFFFFFFFFFFFFFF",
4d17671567f62cc5962bcb0d85084af8,"Question:
Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP?
Answer:
You can find the ADPCM tool in the sample code of RX62N Group ADPCM Audio Compression Record and Playback (R01AN0698). This tool can convert WAVE data to PCM data, and can convert WAVE data to ADPCM data. See ""9. Single File Audio Format Conversion GUI"" in the application note.
  Suitable Products
RA/FSP
Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP?
Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP?
Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP?
Answer:
You can find the ADPCM tool in the sample code of RX62N Group ADPCM Audio Compression Record and Playback (R01AN0698). This tool can convert WAVE data to PCM data, and can convert WAVE data to ADPCM data. See ""9. Single File Audio Format Conversion GUI"" in the application note.
  Suitable Products
RA/FSP
You can find the ADPCM tool in the sample code of RX62N Group ADPCM Audio Compression Record and Playback (R01AN0698). This tool can convert WAVE data to PCM data, and can convert WAVE data to ADPCM data. See ""9. Single File Audio Format Conversion GUI"" in the application note.
You can find the ADPCM tool in the sample code of RX62N Group ADPCM Audio Compression Record and Playback (R01AN0698). This tool can convert WAVE data to PCM data, and can convert WAVE data to ADPCM data. See ""9. Single File Audio Format Conversion GUI"" in the application note.
Suitable Products
RA/FSP",['data/categories/ra_family/rafsp_knowledge_base/4d17671567f62cc5962bcb0d85084af8/images/cbfb37090cb812b1d09214a4e80fcb59.png'],[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'RA Family: Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP?', 'url': 'https://en-support.renesas.com/knowledgeBase/21177413', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:44.419412'}","Question Is there any tool to create ADPCM data that can be decoded with the ADPCM Decoder in FSP? Answer You can find the ADPCM tool in the sample code of RX62N Group ADPCM Audio Compression Record and Playback (R01AN0698). This tool can convert WAVE data to PCM data, and can convert WAVE data to ADPCM data. See ""9. Single File Audio Format Conversion GUI"" in the application note. Suitable Products RA/FSP Suitable Products",
d4911ae109dcb672b6288191a7fb62ce,"Question:
How to change the QSPI flash memory pin settings when using J-Link?
Answer:
After connecting the target board by using J-Link, start the J-Link Control Panel. The J-Link Web control panel will open in your browser. Change the External QSPI flash pins in the flash menu as shown below.
Suitable Products
RA/FSP
How to change the QSPI flash memory pin settings when using J-Link?
How to change the QSPI flash memory pin settings when using J-Link?
Answer:
After connecting the target board by using J-Link, start the J-Link Control Panel. The J-Link Web control panel will open in your browser. Change the External QSPI flash pins in the flash menu as shown below.
Suitable Products
RA/FSP
After connecting the target board by using J-Link, start the J-Link Control Panel. The J-Link Web control panel will open in your browser. Change the External QSPI flash pins in the flash menu as shown below.
After connecting the target board by using J-Link, start the J-Link Control Panel. The J-Link Web control panel will open in your browser. Change the External QSPI flash pins in the flash menu as shown below.
Suitable Products
RA/FSP","['data/categories/ra_family/rafsp_knowledge_base/d4911ae109dcb672b6288191a7fb62ce/images/d6816c97df5fb8d42c699c323f1e1352.png', 'data/categories/ra_family/rafsp_knowledge_base/d4911ae109dcb672b6288191a7fb62ce/images/5f548d10f7040c146bf84a1cf50e8f55.png']",[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'RA Family: How to change the QSPI flash memory pin settings when using J-Link?', 'url': 'https://en-support.renesas.com/knowledgeBase/21177416', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:49.812098'}","Question How to change the QSPI flash memory pin settings when using J-Link? Answer After connecting the target board by using J-Link, start the J-Link Control Panel. The J-Link Web control panel will open in your browser. Change the External QSPI flash pins in the flash menu as shown below. Suitable Products RA/FSP",
b81ba8ce217ee3a82fe49074afa7a178,"Some RA devices have available the USB boot mode. The USB boot mode is a state where the on-chip flash memory routine (USB boot program), stored in the boot area within the MCU is used.
In this mode the on-chip flash, including the code and data flash memory, can be modified from outside the MCU by using USB.
To put the MCU on this state you need to drive the MD pin (P201) to low level. The example on this FAQ uses the EK-RA4M2. To drive the MD pin to low on EK-RA4M2 you need to close jumper J16.
The MCU will start in USB boot mode, if the MD pin is held low on release from reset state.
To use the USB boot mode the USB Full Speed Port, must be used. On EK-RA4M2 you need to:
Press the reset button and as soon as you release the button the MCU will start in USB boot mode.
In device manager you should see a COM port recognized as RA USB Boot CDC.
In Renesas Flash Programmer create a new project and in Communication Settings select the COM port recognized as shown below:
And then you can select your image file to program the MCU, while being in boot mode through RFP using the USB Full Speed.
You can download Renesas Flash Programmer and it's User's Manual from here:
https://www.renesas.com/en/software-tool/renesas-flash-programmer-programming-gui
Suitable Products
RA Family, RFP
Suitable Products
RA Family, RFP
RA Family, RFP","['data/categories/ra_family/rafsp_knowledge_base/b81ba8ce217ee3a82fe49074afa7a178/images/ef8fed64e0402a6014add2a65043aec3.png', 'data/categories/ra_family/rafsp_knowledge_base/b81ba8ce217ee3a82fe49074afa7a178/images/634062737dc677a0544c409a10ebf216.png', 'data/categories/ra_family/rafsp_knowledge_base/b81ba8ce217ee3a82fe49074afa7a178/images/9cbf530cd478a4ebca53a63fd65a981c.png', 'data/categories/ra_family/rafsp_knowledge_base/b81ba8ce217ee3a82fe49074afa7a178/images/eb2a879b1c90cef46786436b1f5a7303.png', 'data/categories/ra_family/rafsp_knowledge_base/b81ba8ce217ee3a82fe49074afa7a178/images/e85e47e2b44524ae97b6e2bca25e84c1.png']",[],[],"{'title': 'Using USB Boot with RA and RFP', 'url': 'https://en-support.renesas.com/knowledgeBase/21678358', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:04.541448'}","Some RA devices have available the USB boot mode. The USB boot mode is a state where the on-chip flash memory routine (USB boot program), stored in the boot area within the MCU is used. In this mode the on-chip flash, including the code and data flash memory, can be modified from outside the MCU by using USB. To put the MCU on this state you need to drive the MD pin (P201) to low level. The example on this FAQ uses the EK-RA4M2. To drive the MD pin to low on EK-RA4M2 you need to close jumper J16. The MCU will start in USB boot mode, if the MD pin is held low on release from reset state. To use the USB boot mode the USB Full Speed Port, must be used. On EK-RA4M2 you need to Press the reset button and as soon as you release the button the MCU will start in USB boot mode. In device manager you should see a COM port recognized as RA USB Boot CDC. In Renesas Flash Programmer create a new project and in Communication Settings select the COM port recognized as shown below And then you can select your image file to program the MCU, while being in boot mode through RFP using the USB Full Speed. You can download Renesas Flash Programmer and it's User's Manual from here https//www.renesas.com/en/software-tool/renesas-flash-programmer-programming-gui Suitable Products RA Family, RFP",
66234f2936f314c9c9369acbfed185a1,"Question:
How to change the pin configuration at run time
Answer:
To change pin settings at run time, you need to add configuration data for the pin settings you want to change, and then set that data in the pinsCfg API of the I/O Port HAL Driver. The following is an example showing how to set pins for the IIC0 at run time.
1. Create a new pin configuration
In the Pin Configuration window, click ""Manage configurations... "" to display the Manage Pin Configurations"" dialog.  In the dialog, click Add button to display Configuration Name"" dialog. In the dialog, enter any name (e.g. New_IIC0) for the new configuration. Then click the OK button.
  2. Create the configuration forthe pin to be changed
In ""Select Pin Configuration"", select the newly created pin configuration above, and set the pin configuration of IIC0. Check the checkbox for ""Generate data:"" and input variable name for the new configuration data to the text box (e.g. g_bsp_pin_cfg_iic0). In the pin configuration, DEBUG0 is not required, so set it to Disabled. After setting up, click Generate Project Content.
Add pin setting for IIC0
  Remove pin settings for DEBUG0
  3. Confirm pin configuration data
Confirm that the data for the pin configuration added above is generated in ra_gen/pin_data.c as the specified variable.
4. Implementation of pin configuration change processing
Add the API call to set the pin configuration data created above to the application as follows.
/* Change pin configuration */
R_IOPORT_PinsCfg(&g_ioport_ctrl, &g_bsp_pin_cfg_iic0);
Suitable Products
RA and FSP
How to change the pin configuration at run time
How to change the pin configuration at run time
Answer:
To change pin settings at run time, you need to add configuration data for the pin settings you want to change, and then set that data in the pinsCfg API of the I/O Port HAL Driver. The following is an example showing how to set pins for the IIC0 at run time.
1. Create a new pin configuration
In the Pin Configuration window, click ""Manage configurations... "" to display the Manage Pin Configurations"" dialog.  In the dialog, click Add button to display Configuration Name"" dialog. In the dialog, enter any name (e.g. New_IIC0) for the new configuration. Then click the OK button.
  2. Create the configuration forthe pin to be changed
In ""Select Pin Configuration"", select the newly created pin configuration above, and set the pin configuration of IIC0. Check the checkbox for ""Generate data:"" and input variable name for the new configuration data to the text box (e.g. g_bsp_pin_cfg_iic0). In the pin configuration, DEBUG0 is not required, so set it to Disabled. After setting up, click Generate Project Content.
Add pin setting for IIC0
  Remove pin settings for DEBUG0
  3. Confirm pin configuration data
Confirm that the data for the pin configuration added above is generated in ra_gen/pin_data.c as the specified variable.
4. Implementation of pin configuration change processing
Add the API call to set the pin configuration data created above to the application as follows.
/* Change pin configuration */
R_IOPORT_PinsCfg(&g_ioport_ctrl, &g_bsp_pin_cfg_iic0);
Suitable Products
RA and FSP
To change pin settings at run time, you need to add configuration data for the pin settings you want to change, and then set that data in the pinsCfg API of the I/O Port HAL Driver. The following is an example showing how to set pins for the IIC0 at run time.
1. Create a new pin configuration
In the Pin Configuration window, click ""Manage configurations... "" to display the Manage Pin Configurations"" dialog.  In the dialog, click Add button to display Configuration Name"" dialog. In the dialog, enter any name (e.g. New_IIC0) for the new configuration. Then click the OK button.
  2. Create the configuration forthe pin to be changed
In ""Select Pin Configuration"", select the newly created pin configuration above, and set the pin configuration of IIC0. Check the checkbox for ""Generate data:"" and input variable name for the new configuration data to the text box (e.g. g_bsp_pin_cfg_iic0). In the pin configuration, DEBUG0 is not required, so set it to Disabled. After setting up, click Generate Project Content.
Add pin setting for IIC0
  Remove pin settings for DEBUG0
  3. Confirm pin configuration data
Confirm that the data for the pin configuration added above is generated in ra_gen/pin_data.c as the specified variable.
4. Implementation of pin configuration change processing
Add the API call to set the pin configuration data created above to the application as follows.
/* Change pin configuration */
R_IOPORT_PinsCfg(&g_ioport_ctrl, &g_bsp_pin_cfg_iic0);
To change pin settings at run time, you need to add configuration data for the pin settings you want to change, and then set that data in the pinsCfg API of the I/O Port HAL Driver. The following is an example showing how to set pins for the IIC0 at run time.
1. Create a new pin configuration
In the Pin Configuration window, click ""Manage configurations... "" to display the Manage Pin Configurations"" dialog.  In the dialog, click Add button to display Configuration Name"" dialog. In the dialog, enter any name (e.g. New_IIC0) for the new configuration. Then click the OK button.
2. Create the configuration forthe pin to be changed
In ""Select Pin Configuration"", select the newly created pin configuration above, and set the pin configuration of IIC0. Check the checkbox for ""Generate data:"" and input variable name for the new configuration data to the text box (e.g. g_bsp_pin_cfg_iic0). In the pin configuration, DEBUG0 is not required, so set it to Disabled. After setting up, click Generate Project Content.
Add pin setting for IIC0
Remove pin settings for DEBUG0
3. Confirm pin configuration data
Confirm that the data for the pin configuration added above is generated in ra_gen/pin_data.c as the specified variable.
4. Implementation of pin configuration change processing
Add the API call to set the pin configuration data created above to the application as follows.
Suitable Products
RA and FSP
Go to Japanese
Go to Japanese","['data/categories/ra_family/rafsp_knowledge_base/66234f2936f314c9c9369acbfed185a1/images/7e94ef95521b98bd714fea56642fef6b.png', 'data/categories/ra_family/rafsp_knowledge_base/66234f2936f314c9c9369acbfed185a1/images/360ebfa84b5b568eb5f1a4db2115f711.png', 'data/categories/ra_family/rafsp_knowledge_base/66234f2936f314c9c9369acbfed185a1/images/6d6e129fcf2ce0199dc6805c5fe6b2e7.png', 'data/categories/ra_family/rafsp_knowledge_base/66234f2936f314c9c9369acbfed185a1/images/d03be10b8be848523e16f947d8e526aa.png']",[],['|  |\n|  |\n| RA and FSP |'],"{'title': 'RA Family: How to change the pin configuration at run time', 'url': 'https://en-support.renesas.com/knowledgeBase/20481444', 'last_updated': None, 'extracted_at': '2025-03-08T23:18:39.686443'}","Question How to change the pin configuration at run time Answer To change pin settings at run time, you need to add configuration data for the pin settings you want to change, and then set that data in the pinsCfg API of the I/O Port HAL Driver. The following is an example showing how to set pins for the IIC0 at run time. 1. Create a new pin configuration In the Pin Configuration window, click ""Manage configurations... "" to display the Manage Pin Configurations"" dialog. In the dialog, click Add button to display Configuration Name"" dialog. In the dialog, enter any name (e.g. NewIIC0) for the new configuration. Then click the OK button. 2. Create the configuration forthe pin to be changed In ""Select Pin Configuration"", select the newly created pin configuration above, and set the pin configuration of IIC0. Check the checkbox for ""Generate data"" and input variable name for the new configuration data to the text box (e.g. gbsppincfgiic0). In the pin configuration, DEBUG0 is not required, so set it to Disabled. After setting up, click Generate Project Content. Add pin setting for IIC0 Remove pin settings for DEBUG0 3. Confirm pin configuration data Confirm that the data for the pin configuration added above is generated in ragen/pindata.c as the specified variable. 4. Implementation of pin configuration change processing Add the API call to set the pin configuration data created above to the application as follows. / Change pin configuration / RIOPORTPinsCfg(gioportctrl, gbsppincfgiic0); Suitable Products RA and FSP 2. Create the configuration forthe pin to be changed Remove pin settings for DEBUG0 3. Confirm pin configuration data Go to Japanese",
19ceb21a03c55ecaf0dd56dbe4f4b506,"Answer:
The attached sample reference application generates an RSA self-signed x509 certificate by leveraging FSP middleware MbedTLS stack and RSIP IP of RA on the EK-RA8M1 board.
Below are the list of operations that can be verified using the sample application -
The Sample application basically utilizes the MbedTLS stack with the underlying SCE as RSIP to generate the RSA 3K bits pair of keys and can also generate the 2K bits pair of keys by defining RSA_2048_BITS_KEY macro in the file crypto_ep.h. This application can be further explored to generate 4K keys pair as well in the RA8.
It utilizes the MbedTLS x509write_crt feature to generate a self-signed certificate in PEM or DER format by defining MBEDTLS_X509_FORMAT_PEM or MBEDTLS_X509_FORMAT_DER respectively in the function gen_certificates of the file create_cert.c.
It utilizes the MbedTLS x509_cert feature to parse the certificate in PEM or DER format and display basic parameter in the RTT Viewer as can be seen below 
Example DER certificate in RTT viewer 
Example PEM certificate in RTT viewer 
To verify the generated PEM certificate, just copy the raw PEM data to online tool (example - https://certlogik.com/decoder/) to parse the certificate.
Example of PEM certificates decode via online tool 
Details of sample project:
Board:             EK-RA8M1
FSP:                v5.5.0 or later
IDE:                 e2studio - 2024-07 (24.7.0) or later
Compiler:        GCC - 12.2.1.arm-12-mpacbti-34 or later
Suitable Products
RA8M1, RA8D1, RA8T1
Answer:
The attached sample reference application generates an RSA self-signed x509 certificate by leveraging FSP middleware MbedTLS stack and RSIP IP of RA on the EK-RA8M1 board.
Below are the list of operations that can be verified using the sample application -
The Sample application basically utilizes the MbedTLS stack with the underlying SCE as RSIP to generate the RSA 3K bits pair of keys and can also generate the 2K bits pair of keys by defining RSA_2048_BITS_KEY macro in the file crypto_ep.h. This application can be further explored to generate 4K keys pair as well in the RA8.
It utilizes the MbedTLS x509write_crt feature to generate a self-signed certificate in PEM or DER format by defining MBEDTLS_X509_FORMAT_PEM or MBEDTLS_X509_FORMAT_DER respectively in the function gen_certificates of the file create_cert.c.
It utilizes the MbedTLS x509_cert feature to parse the certificate in PEM or DER format and display basic parameter in the RTT Viewer as can be seen below 
Example DER certificate in RTT viewer 
Example PEM certificate in RTT viewer 
To verify the generated PEM certificate, just copy the raw PEM data to online tool (example - https://certlogik.com/decoder/) to parse the certificate.
Example of PEM certificates decode via online tool 
Details of sample project:
Board:             EK-RA8M1
FSP:                v5.5.0 or later
IDE:                 e2studio - 2024-07 (24.7.0) or later
Compiler:        GCC - 12.2.1.arm-12-mpacbti-34 or later
Suitable Products
RA8M1, RA8D1, RA8T1
The attached sample reference application generates an RSA self-signed x509 certificate by leveraging FSP middleware MbedTLS stack and RSIP IP of RA on the EK-RA8M1 board.
Below are the list of operations that can be verified using the sample application -
The Sample application basically utilizes the MbedTLS stack with the underlying SCE as RSIP to generate the RSA 3K bits pair of keys and can also generate the 2K bits pair of keys by defining RSA_2048_BITS_KEY macro in the file crypto_ep.h. This application can be further explored to generate 4K keys pair as well in the RA8.
It utilizes the MbedTLS x509write_crt feature to generate a self-signed certificate in PEM or DER format by defining MBEDTLS_X509_FORMAT_PEM or MBEDTLS_X509_FORMAT_DER respectively in the function gen_certificates of the file create_cert.c.
It utilizes the MbedTLS x509_cert feature to parse the certificate in PEM or DER format and display basic parameter in the RTT Viewer as can be seen below 
Example DER certificate in RTT viewer 
Example PEM certificate in RTT viewer 
To verify the generated PEM certificate, just copy the raw PEM data to online tool (example - https://certlogik.com/decoder/) to parse the certificate.
Example of PEM certificates decode via online tool 
Details of sample project:
Board:             EK-RA8M1
FSP:                v5.5.0 or later
IDE:                 e2studio - 2024-07 (24.7.0) or later
Compiler:        GCC - 12.2.1.arm-12-mpacbti-34 or later
The attached sample reference application generates an RSA self-signed x509 certificate by leveraging FSP middleware MbedTLS stack and RSIP IP of RA on the EK-RA8M1 board.
Below are the list of operations that can be verified using the sample application -
Example DER certificate in RTT viewer 
Example PEM certificate in RTT viewer 
Example of PEM certificates decode via online tool 
Details of sample project:
Suitable Products
RA8M1, RA8D1, RA8T1
Japanese
Japanese","['data/categories/ra_family/rafsp_knowledge_base/19ceb21a03c55ecaf0dd56dbe4f4b506/images/2290ce30b1d74b28d71b47a7ca70055d.png', 'data/categories/ra_family/rafsp_knowledge_base/19ceb21a03c55ecaf0dd56dbe4f4b506/images/bd789e7e1d26a94e2e1bd4e1b44909b6.png', 'data/categories/ra_family/rafsp_knowledge_base/19ceb21a03c55ecaf0dd56dbe4f4b506/images/dbd22d9341284afa7554c16209833ccd.png']",[],"['|  |\n|  |\n| RA8M1, RA8D1, RA8T1 |']","{'title': 'RA Family: How to generate self-signed x509 certificate using MbedTLS stack', 'url': 'https://en-support.renesas.com/knowledgeBase/21789660', 'last_updated': '2025-04-02', 'extracted_at': '2025-03-08T23:22:24.686098'}","Answer The attached sample reference application generates an RSA self-signed x509 certificate by leveraging FSP middleware MbedTLS stack and RSIP IP of RA on the EK-RA8M1 board. Below are the list of operations that can be verified using the sample application - The Sample application basically utilizes the MbedTLS stack with the underlying SCE as RSIP to generate the RSA 3K bits pair of keys and can also generate the 2K bits pair of keys by defining RSA2048BITSKEY macro in the file cryptoep.h. This application can be further explored to generate 4K keys pair as well in the RA8. It utilizes the MbedTLS x509writecrt feature to generate a self-signed certificate in PEM or DER format by defining MBEDTLSX509FORMATPEM or MBEDTLSX509FORMATDER respectively in the function gencertificates of the file createcert.c. It utilizes the MbedTLS x509cert feature to parse the certificate in PEM or DER format and display basic parameter in the RTT Viewer as can be seen below  Example DER certificate in RTT viewer  Example PEM certificate in RTT viewer  To verify the generated PEM certificate, just copy the raw PEM data to online tool (example - https//certlogik.com/decoder/) to parse the certificate. Example of PEM certificates decode via online tool  Details of sample project Board EK-RA8M1 FSP v5.5.0 or later IDE e2studio - 2024-07 (24.7.0) or later Compiler GCC - 12.2.1.arm-12-mpacbti-34 or later Suitable Products RA8M1, RA8D1, RA8T1 Japanese",
7b999180cd3b3a17df5f6311b8cb98ea,"Question:
How to use the MCUboot logging function on FSP
Answer:
The MCUboot provides a logging function that allows you to output the running status and error information during image booting. This feature can be used to check the execution status of the bootloader.
The MCUboot logging function has trhe following four log levels.
MCUBOOT_LOG_ERR (Error)
MCUBOOT_LOG_WRN (Warning)
MCUBOOT_LOG_INF (Info)
MCUBOOT_LOG_DBG (Debug)
The below example shows how to use the MCUboots logging function on FSP.
Use of semi-hosting

By default, FSP implements the MCUboot logging feature using the printf() function defined in the standard I/O header (stdio.h). For use of semi-hosting as the output interface, the developer can use this implementation as is. It can be enabled by changing the Log Level to a level other than Off, in the MCUboot logging block properties on the Stack tab of the FSP configurator



The log levels available by the property settings of the MCUboot logging block are shown in the table below.
  Off Error Warning Info Debug
MCUBOOT_LOG_ERR -    
MCUBOOT_LOG_WRN - -   
MCUBOOT_LOG_INF - - -  
MCUBOOT_LOG_DBG
- - - - 
: Available, -: Not available

The developer should also apply the following changes required for semi-hosting to the project:
Add the initialization code for semi-hosting at the beginning of the program.
Resize the heap size to the appropriate size in the properties of the BSP tab.
Set the linker option ""--specs=rdimon.specs"" from C/C++ Build > Settings > Tool Settings > Cross ARM C Linker > Miscellaneous in the project properties.

Use of an output interface other than semi-hosting

To use an output interface other than semi-hosting, such as SEGGER J-Link RTT Viewer, the developer can apply any user-defined execution function by redefining the macro MCUBOOT_LOG_xxx with a new header file. The link of the created header file can be applied from the Common > General > Custom mcuboot_config.h in the MCUboot block properties on the Stacks tab.



For example, to output the information for MCUBOOT_LOG_ERR and MCUBOOT_LOG_INF to SEGGER J-Link RTT View, the developer will create a header file with references to the following and apply it to the MCUboot block properties. In this case, the log level selected in the MCUboot logging block on the FSP configurator is ignored.

mcuboot_config_custom.h
#include ""SEGGER_RTT/SEGGER_RTT.h""
#define MCUBOOT_LOG_ERR(_fmt, ...)  SEGGER_RTT_printf(0, ""[ERR] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_WRN(...)  IGNORE(__VA_ARGS__)
#define MCUBOOT_LOG_INF(_fmt, ...)  SEGGER_RTT_printf(0, ""[INF] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_DBG(...)  IGNORE(__VA_ARGS__)
Note: The MCUboot's logging feature may affect the performance of the MCUboot image boot process.
Suitable Products
RA and FSP
How to use the MCUboot logging function on FSP
How to use the MCUboot logging function on FSP
Answer:
The MCUboot provides a logging function that allows you to output the running status and error information during image booting. This feature can be used to check the execution status of the bootloader.
The MCUboot logging function has trhe following four log levels.
MCUBOOT_LOG_ERR (Error)
MCUBOOT_LOG_WRN (Warning)
MCUBOOT_LOG_INF (Info)
MCUBOOT_LOG_DBG (Debug)
The below example shows how to use the MCUboots logging function on FSP.
Use of semi-hosting

By default, FSP implements the MCUboot logging feature using the printf() function defined in the standard I/O header (stdio.h). For use of semi-hosting as the output interface, the developer can use this implementation as is. It can be enabled by changing the Log Level to a level other than Off, in the MCUboot logging block properties on the Stack tab of the FSP configurator



The log levels available by the property settings of the MCUboot logging block are shown in the table below.
  Off Error Warning Info Debug
MCUBOOT_LOG_ERR -    
MCUBOOT_LOG_WRN - -   
MCUBOOT_LOG_INF - - -  
MCUBOOT_LOG_DBG
- - - - 
: Available, -: Not available

The developer should also apply the following changes required for semi-hosting to the project:
Add the initialization code for semi-hosting at the beginning of the program.
Resize the heap size to the appropriate size in the properties of the BSP tab.
Set the linker option ""--specs=rdimon.specs"" from C/C++ Build > Settings > Tool Settings > Cross ARM C Linker > Miscellaneous in the project properties.

Use of an output interface other than semi-hosting

To use an output interface other than semi-hosting, such as SEGGER J-Link RTT Viewer, the developer can apply any user-defined execution function by redefining the macro MCUBOOT_LOG_xxx with a new header file. The link of the created header file can be applied from the Common > General > Custom mcuboot_config.h in the MCUboot block properties on the Stacks tab.



For example, to output the information for MCUBOOT_LOG_ERR and MCUBOOT_LOG_INF to SEGGER J-Link RTT View, the developer will create a header file with references to the following and apply it to the MCUboot block properties. In this case, the log level selected in the MCUboot logging block on the FSP configurator is ignored.

mcuboot_config_custom.h
#include ""SEGGER_RTT/SEGGER_RTT.h""
#define MCUBOOT_LOG_ERR(_fmt, ...)  SEGGER_RTT_printf(0, ""[ERR] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_WRN(...)  IGNORE(__VA_ARGS__)
#define MCUBOOT_LOG_INF(_fmt, ...)  SEGGER_RTT_printf(0, ""[INF] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_DBG(...)  IGNORE(__VA_ARGS__)
Note: The MCUboot's logging feature may affect the performance of the MCUboot image boot process.
Suitable Products
RA and FSP
The MCUboot provides a logging function that allows you to output the running status and error information during image booting. This feature can be used to check the execution status of the bootloader.
The MCUboot logging function has trhe following four log levels.
MCUBOOT_LOG_ERR (Error)
MCUBOOT_LOG_WRN (Warning)
MCUBOOT_LOG_INF (Info)
MCUBOOT_LOG_DBG (Debug)
The below example shows how to use the MCUboots logging function on FSP.
Use of semi-hosting

By default, FSP implements the MCUboot logging feature using the printf() function defined in the standard I/O header (stdio.h). For use of semi-hosting as the output interface, the developer can use this implementation as is. It can be enabled by changing the Log Level to a level other than Off, in the MCUboot logging block properties on the Stack tab of the FSP configurator



The log levels available by the property settings of the MCUboot logging block are shown in the table below.
  Off Error Warning Info Debug
MCUBOOT_LOG_ERR -    
MCUBOOT_LOG_WRN - -   
MCUBOOT_LOG_INF - - -  
MCUBOOT_LOG_DBG
- - - - 
: Available, -: Not available

The developer should also apply the following changes required for semi-hosting to the project:
Add the initialization code for semi-hosting at the beginning of the program.
Resize the heap size to the appropriate size in the properties of the BSP tab.
Set the linker option ""--specs=rdimon.specs"" from C/C++ Build > Settings > Tool Settings > Cross ARM C Linker > Miscellaneous in the project properties.

Use of an output interface other than semi-hosting

To use an output interface other than semi-hosting, such as SEGGER J-Link RTT Viewer, the developer can apply any user-defined execution function by redefining the macro MCUBOOT_LOG_xxx with a new header file. The link of the created header file can be applied from the Common > General > Custom mcuboot_config.h in the MCUboot block properties on the Stacks tab.



For example, to output the information for MCUBOOT_LOG_ERR and MCUBOOT_LOG_INF to SEGGER J-Link RTT View, the developer will create a header file with references to the following and apply it to the MCUboot block properties. In this case, the log level selected in the MCUboot logging block on the FSP configurator is ignored.

mcuboot_config_custom.h
#include ""SEGGER_RTT/SEGGER_RTT.h""
#define MCUBOOT_LOG_ERR(_fmt, ...)  SEGGER_RTT_printf(0, ""[ERR] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_WRN(...)  IGNORE(__VA_ARGS__)
#define MCUBOOT_LOG_INF(_fmt, ...)  SEGGER_RTT_printf(0, ""[INF] "" _fmt ""\n"", ## __VA_ARGS__)
#define MCUBOOT_LOG_DBG(...)  IGNORE(__VA_ARGS__)
Note: The MCUboot's logging feature may affect the performance of the MCUboot image boot process.
The MCUboot provides a logging function that allows you to output the running status and error information during image booting. This feature can be used to check the execution status of the bootloader.
The MCUboot logging function has trhe following four log levels.
The below example shows how to use the MCUboots logging function on FSP.
MCUBOOT_LOG_DBG
: Available, -: Not available

The developer should also apply the following changes required for semi-hosting to the project:
Note: The MCUboot's logging feature may affect the performance of the MCUboot image boot process.
Suitable Products
RA and FSP
Go to Japanese
Go to Japanese","['data/categories/ra_family/rafsp_knowledge_base/7b999180cd3b3a17df5f6311b8cb98ea/images/a7bb6ffd472152fefff6a630494d8701.png', 'data/categories/ra_family/rafsp_knowledge_base/7b999180cd3b3a17df5f6311b8cb98ea/images/6fd16807f3b6ca0e8fd76db470da62c6.png', 'data/categories/ra_family/rafsp_knowledge_base/7b999180cd3b3a17df5f6311b8cb98ea/images/9ae95bc7101afe5dc0b7fa6a3ab5ba7a.png']",[],"['|  |\n|  |\n|  | Off | Error | Warning | Info | Debug |\n| MCUBOOT_LOG_ERR | - |  |  |  |  |\n| MCUBOOT_LOG_WRN | - | - |  |  |  |\n| MCUBOOT_LOG_INF | - | - | - |  |  |\n| MCUBOOT_LOG_DBG | - | - | - | - |  |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: How to use the MCUboot logging function on FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/20465583', 'last_updated': '2022-08-04', 'extracted_at': '2025-03-08T23:20:29.842257'}","Question How to use the MCUboot logging function on FSP Answer The MCUboot provides a logging function that allows you to output the running status and error information during image booting. This feature can be used to check the execution status of the bootloader. The MCUboot logging function has trhe following four log levels. MCUBOOTLOGERR (Error) MCUBOOTLOGWRN (Warning) MCUBOOTLOGINF (Info) MCUBOOTLOGDBG (Debug) The below example shows how to use the MCUboots logging function on FSP. Use of semi-hosting By default, FSP implements the MCUboot logging feature using the printf() function defined in the standard I/O header (stdio.h). For use of semi-hosting as the output interface, the developer can use this implementation as is. It can be enabled by changing the Log Level to a level other than Off, in the MCUboot logging block properties on the Stack tab of the FSP configurator The log levels available by the property settings of the MCUboot logging block are shown in the table below. Off Error Warning Info Debug MCUBOOTLOGERR -     MCUBOOTLOGWRN - -    MCUBOOTLOGINF - - -   MCUBOOTLOGDBG - - - -   Available, - Not available The developer should also apply the following changes required for semi-hosting to the project Add the initialization code for semi-hosting at the beginning of the program. Resize the heap size to the appropriate size in the properties of the BSP tab. Set the linker option ""--specsrdimon.specs"" from C/C Build  Settings  Tool Settings  Cross ARM C Linker  Miscellaneous in the project properties. Use of an output interface other than semi-hosting To use an output interface other than semi-hosting, such as SEGGER J-Link RTT Viewer, the developer can apply any user-defined execution function by redefining the macro MCUBOOTLOGxxx with a new header file. The link of the created header file can be applied from the Common  General  Custom mcubootconfig.h in the MCUboot block properties on the Stacks tab. For example, to output the information for MCUBOOTLOGERR and MCUBOOTLOGINF to SEGGER J-Link RTT View, the developer will create a header file with references to the following and apply it to the MCUboot block properties. In this case, the log level selected in the MCUboot logging block on the FSP configurator is ignored. mcubootconfigcustom.h include ""SEGGERRTT/SEGGERRTT.h"" define MCUBOOTLOGERR(fmt, ...) SEGGERRTTprintf(0, ""ERR "" fmt ""n"",  VAARGS) define MCUBOOTLOGWRN(...) IGNORE(VAARGS) define MCUBOOTLOGINF(fmt, ...) SEGGERRTTprintf(0, ""INF "" fmt ""n"",  VAARGS) define MCUBOOTLOGDBG(...) IGNORE(VAARGS) Note The MCUboot's logging feature may affect the performance of the MCUboot image boot process. Suitable Products RA and FSP Go to Japanese",
10ac896828b929a82e180fe94235abc4,"Question:
How to set the ID Code to enable protection and disable authentication, and how to connect a debugger or programmer in that case?
Answer:
Caution: If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore.
How to set the ID code
This setting is not available in the FSP configurator. It is enabled by adding the definition of BSP_ID_CODE_PERMANENTLY_LOCKED in the C Preprocessor setting as shown below.

The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. The ID code is set as all 00h in  ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/*
 ID Code
 Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.
 WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
 */
#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)
            #define BSP_CFG_ID_CODE_LONG_1 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_2 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_3 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_4 (0x00000000)
            #else
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
#endif

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800000000FFFFFFFF00000000FFFFFFFFD8
S3110101002800000000FFFFFFFF00000000C8

In case of RA6M3:
S3150100A15000000000000000000000000000000000F8

In case of RA4E2:
S3150100A1200000000000000000000000000000000028

Debugger connection in e2 studio (ID code authentication)
Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below.
In case of J-Link:

In case of E2 / E2 Lite:

Debugger connection in e2 studio (with ALeRASE execution)
In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

On the MCUs which ALeRASE is available in this mode (*1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
 
*1: ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command (TN-RA*-A0014A/E)
Connection by RFP (with ID code authentication)
Since the ID code authentication always mismatches, a connection failure error is displayed as follows.

Connection by RFP (with ALeRASE execution)
Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below.

Suitable Products
RA and FSP
How to set the ID Code to enable protection and disable authentication, and how to connect a debugger or programmer in that case?
Answer:
Caution: If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore.
How to set the ID code
This setting is not available in the FSP configurator. It is enabled by adding the definition of BSP_ID_CODE_PERMANENTLY_LOCKED in the C Preprocessor setting as shown below.

The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. The ID code is set as all 00h in  ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/*
 ID Code
 Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.
 WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
 */
#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)
            #define BSP_CFG_ID_CODE_LONG_1 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_2 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_3 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_4 (0x00000000)
            #else
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
#endif

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800000000FFFFFFFF00000000FFFFFFFFD8
S3110101002800000000FFFFFFFF00000000C8

In case of RA6M3:
S3150100A15000000000000000000000000000000000F8

In case of RA4E2:
S3150100A1200000000000000000000000000000000028

Debugger connection in e2 studio (ID code authentication)
Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below.
In case of J-Link:

In case of E2 / E2 Lite:

Debugger connection in e2 studio (with ALeRASE execution)
In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

On the MCUs which ALeRASE is available in this mode (*1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
 
*1: ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command (TN-RA*-A0014A/E)
Connection by RFP (with ID code authentication)
Since the ID code authentication always mismatches, a connection failure error is displayed as follows.

Connection by RFP (with ALeRASE execution)
Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below.

Suitable Products
RA and FSP
Caution: If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore.
How to set the ID code
This setting is not available in the FSP configurator. It is enabled by adding the definition of BSP_ID_CODE_PERMANENTLY_LOCKED in the C Preprocessor setting as shown below.

The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. The ID code is set as all 00h in  ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
/*
 ID Code
 Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.
 WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
 */
#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)
            #define BSP_CFG_ID_CODE_LONG_1 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_2 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_3 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_4 (0x00000000)
            #else
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
#endif

The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
S3150101001800000000FFFFFFFF00000000FFFFFFFFD8
S3110101002800000000FFFFFFFF00000000C8

In case of RA6M3:
S3150100A15000000000000000000000000000000000F8

In case of RA4E2:
S3150100A1200000000000000000000000000000000028

Debugger connection in e2 studio (ID code authentication)
Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below.
In case of J-Link:

In case of E2 / E2 Lite:

Debugger connection in e2 studio (with ALeRASE execution)
In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.

On the MCUs which ALeRASE is available in this mode (*1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
 
*1: ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command (TN-RA*-A0014A/E)
Connection by RFP (with ID code authentication)
Since the ID code authentication always mismatches, a connection failure error is displayed as follows.

Connection by RFP (with ALeRASE execution)
Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below.
Caution: If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore.
Caution: If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore.
How to set the ID code
How to set the ID code
This setting is not available in the FSP configurator. It is enabled by adding the definition of BSP_ID_CODE_PERMANENTLY_LOCKED in the C Preprocessor setting as shown below.
This setting is not available in the FSP configurator. It is enabled by adding the definition of BSP_ID_CODE_PERMANENTLY_LOCKED in the C Preprocessor setting as shown below.
BSP_ID_CODE_PERMANENTLY_LOCKED
The value of the ID code in the OSIS register
The value of the ID code in the OSIS register
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. The ID code is set as all 00h in  ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. The ID code is set as all 00h in  ra_cfg/fsp_cfg/bsp/bsp_mcu_family_cfg.h as shown below.
00112233
44556677
8899AABB
CCDDEEFF
/*
 ID Code
 Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.
 WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
 */
#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)
            #define BSP_CFG_ID_CODE_LONG_1 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_2 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_3 (0x00000000)
            #define BSP_CFG_ID_CODE_LONG_4 (0x00000000)
            #else
/*
ID Code
Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.
WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.
*/
#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)
#define BSP_CFG_ID_CODE_LONG_1 (0x00000000)
#define BSP_CFG_ID_CODE_LONG_1 (0x
00000000
)
#define BSP_CFG_ID_CODE_LONG_2 (0x00000000)
#define BSP_CFG_ID_CODE_LONG_2 (0x
00000000
)
#define BSP_CFG_ID_CODE_LONG_3 (0x00000000)
#define BSP_CFG_ID_CODE_LONG_3 (0x
00000000
)
#define BSP_CFG_ID_CODE_LONG_4 (0x00000000)
#define BSP_CFG_ID_CODE_LONG_4 (0x
00000000
)
#else
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
/* ID CODE: 00112233445566778899AABBCCDDEEbf */
#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)
#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)
#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)
#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)
#endif
#endif
The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register :
The ID code is generated in the program image file as shown below.
It defers as follows depending on the address of the OSIS register :
In case of RA2L1:
In case of RA2L1:
S3150101001800000000FFFFFFFF00000000FFFFFFFFD8
S3110101002800000000FFFFFFFF00000000C8
S3150101001800000000FFFFFFFF00000000FFFFFFFFD8
S31501010018
00000000
FFFFFFFF
00000000
FFFFFFFFD8
S3110101002800000000FFFFFFFF00000000C8
S31101010028
00000000
FFFFFFFF
00000000
C8
In case of RA6M3:
In case of RA6M3:
S3150100A15000000000000000000000000000000000F8
S3150100A15000000000000000000000000000000000F8
S3150100A150
00000000
00000000
00000000
00000000
F8
In case of RA4E2:
In case of RA4E2:
S3150100A1200000000000000000000000000000000028
S3150100A1200000000000000000000000000000000028
S3150100A120
00000000
00000000
00000000
00000000
28
Debugger connection in e2 studio (ID code authentication)
Debugger connection in e2 studio (ID code authentication)
Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below.
Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below.
In case of J-Link:
In case of J-Link:
In case of E2 / E2 Lite:
In case of E2 / E2 Lite:
Debugger connection in e2 studio (with ALeRASE execution)
Debugger connection in e2 studio (with ALeRASE execution)
In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.
In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed.
FFFFFFFFFFFFFFFFFF45534152654C41
On the MCUs which ALeRASE is available in this mode (*1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
On the MCUs which ALeRASE is available in this mode (*1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution.
FFFFFFFFFFFFFFFFFF45534152654C41
*1: ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command (TN-RA*-A0014A/E)
*1: ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command (TN-RA*-A0014A/E)
Connection by RFP (with ID code authentication)
Connection by RFP (with ID code authentication)
Since the ID code authentication always mismatches, a connection failure error is displayed as follows.
Since the ID code authentication always mismatches, a connection failure error is displayed as follows.
Connection by RFP (with ALeRASE execution)
Connection by RFP (with ALeRASE execution)
Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below.
Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below.
414C6552415345FFFFFFFFFFFFFFFFFF
),
Suitable Products
RA and FSP
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/917aab28b4420ae2c907ff1d61b797f5.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/92b941204089dc9a89be81f639e897b9.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/67dc4ef70e8fcf05c7e316962407377d.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/28b387332674ea54f1c83e2a5de9a2c6.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/3b53be40f9ad9b91c7fcac55e580d9ab.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/a1c6a50c20807d83810931e82a20f53e.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/1801211fb7c9ff75f297b7f3e511b6d4.png', 'data/categories/ra_family/rafsp_knowledge_base/10ac896828b929a82e180fe94235abc4/images/977ad1a02a8b575729a1cd648baaa147.png']",[],"['|  |\n|  |\n| /*\n ID Code\n Note: To permanently lock and disable the debug interface define the BSP_ID_CODE_PERMANENTLY_LOCKED in the compiler settings.\n WARNING: This will disable debug access to the part and cannot be reversed by a debug probe.\n */\n#if defined(BSP_ID_CODE_PERMANENTLY_LOCKED)\n            #define BSP_CFG_ID_CODE_LONG_1 (0x00000000)\n            #define BSP_CFG_ID_CODE_LONG_2 (0x00000000)\n            #define BSP_CFG_ID_CODE_LONG_3 (0x00000000)\n            #define BSP_CFG_ID_CODE_LONG_4 (0x00000000)\n            #else\n/* ID CODE: 00112233445566778899AABBCCDDEEbf */\n#define BSP_CFG_ID_CODE_LONG_1 (0x33221100)\n#define BSP_CFG_ID_CODE_LONG_2 (0x77665544)\n#define BSP_CFG_ID_CODE_LONG_3 (0xBBAA9988)\n#define BSP_CFG_ID_CODE_LONG_4 (0xbfEEDDCC)\n#endif |', '|  |\n|  |\n| S3150101001800000000FFFFFFFF00000000FFFFFFFFD8\nS3110101002800000000FFFFFFFF00000000C8 |', '|  |\n|  |\n| S3150100A15000000000000000000000000000000000F8 |', '|  |\n|  |\n| S3150100A1200000000000000000000000000000000028 |', '|  |\n|  |\n| RA and FSP |']","{'title': 'RA Family: ID code protection (in case of protection enabled with Bit127=0)', 'url': 'https://en-support.renesas.com/knowledgeBase/20980158', 'last_updated': None, 'extracted_at': '2025-03-08T23:24:29.252672'}","Question How to set the ID Code to enable protection and disable authentication, and how to connect a debugger or programmer in that case? Answer Caution If the MCU is protected by this manner, and cannot execute ALeRASE commands, the device will not be able to write with debugger or programmer anymore. How to set the ID code This setting is not available in the FSP configurator. It is enabled by adding the definition of BSPIDCODEPERMANENTLYLOCKED in the C Preprocessor setting as shown below. The value of the ID code in the OSIS register In the following, to make it easier to understand the relationship between the ID code value and the OSIS register, the ID code is color-coded each 4 bytes, such as 00112233445566778899AABBCCDDEEFF. The ID code is set as all 00h in racfg/fspcfg/bsp/bspmcufamilycfg.h as shown below. / ID Code Note To permanently lock and disable the debug interface define the BSPIDCODEPERMANENTLYLOCKED in the compiler settings. WARNING This will disable debug access to the part and cannot be reversed by a debug probe. / if defined(BSPIDCODEPERMANENTLYLOCKED) define BSPCFGIDCODELONG1 (0x00000000) define BSPCFGIDCODELONG2 (0x00000000) define BSPCFGIDCODELONG3 (0x00000000) define BSPCFGIDCODELONG4 (0x00000000) else / ID CODE 00112233445566778899AABBCCDDEEbf / define BSPCFGIDCODELONG1 (0x33221100) define BSPCFGIDCODELONG2 (0x77665544) define BSPCFGIDCODELONG3 (0xBBAA9988) define BSPCFGIDCODELONG4 (0xbfEEDDCC) endif The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register  In case of RA2L1 S3150101001800000000FFFFFFFF00000000FFFFFFFFD8 S3110101002800000000FFFFFFFF00000000C8 In case of RA6M3 S3150100A15000000000000000000000000000000000F8 In case of RA4E2 S3150100A1200000000000000000000000000000000028 Debugger connection in e2 studio (ID code authentication) Since ID code authentication always mismatches, an authentication error dialog is displayed as shown below. In case of J-Link In case of E2 / E2 Lite Debugger connection in e2 studio (with ALeRASE execution) In the case of E2 or E2 Lite, even if you set ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code, the erase process is not performed. As shown in the dialog below, you will see that the process of erasing all flash memory has failed. In case of J-Link, erasure is not executed. On the MCUs which ALeRASE is available in this mode (1), you can erase the entire internal flash ROM by setting the ALeRASE ID (FFFFFFFFFFFFFFFFFF45534152654C41) to the ID code. It cannot be used when using J-Link debugger. If the program image to be loaded is set, the image will be loaded after the ALeRASE execution. 1 ""RA2A1 Group, RA2L1 Group, RA2E1 Group, RA4M1 Group, RA4W1 Group, RA6M1 Group, RA6M2 Group, RA6M3 Group, RA6T1 Group, Note on ALeRASE command (TN-RA-A0014A/E) Connection by RFP (with ID code authentication) Since the ID code authentication always mismatches, a connection failure error is displayed as follows. Connection by RFP (with ALeRASE execution) Even if you set the ALeRASE code (414C6552415345FFFFFFFFFFFFFFFFFF), the execution of ALeRASE fails as shown below. Suitable Products RA and FSP BSPIDCODEPERMANENTLYLOCKED 00112233 44556677 8899AABB CCDDEEFF ID Code Note To permanently lock and disable the debug interface define the BSPIDCODEPERMANENTLYLOCKED in the compiler settings. WARNING This will disable debug access to the part and cannot be reversed by a debug probe. / define BSPCFGIDCODELONG1 (0x00000000) define BSPCFGIDCODELONG1 (0x 00000000 ) define BSPCFGIDCODELONG2 (0x00000000) define BSPCFGIDCODELONG2 (0x define BSPCFGIDCODELONG3 (0x00000000) define BSPCFGIDCODELONG3 (0x define BSPCFGIDCODELONG4 (0x00000000) define BSPCFGIDCODELONG4 (0x else The ID code is generated in the program image file as shown below. It defers as follows depending on the address of the OSIS register  S31501010018 FFFFFFFF FFFFFFFFD8 S31101010028 C8 S3150100A150 F8 S3150100A120 28 FFFFFFFFFFFFFFFFFF45534152654C41 414C6552415345FFFFFFFFFFFFFFFFFF ),",
22d51b554b6047c545f82565e4d5f950,"Often product developers find themselves in a position where application configuration parameters need to be uniquely programmed into a MCUs memory. To do so, often firmware is created which is flashed into the MCU which is responsible for the acquisition of the needed application configuration parameters. MAC addresses, IP Addresses, SSID Names, Passwords, Public/Private keys, etc. are examples of application configuration parameters. The issue with an approach where the firmware handles acquisition of the ACPs is the need to create auxiliary code which adds limited value to the main application. This in turn leads to additional test efforts, and longer development times.
A way to avoid such issues is to modularize your application and store the ACPs as a blob of structured binary data located in a fixed location in memory. So when your application starts, it is able to access the fixed location, read the data in a fixed manner, and adjust the mode of operation.
When you have achieved such modularization, you can segment your application in to two parts:
Your ACP data can then be converted into a S-Record file and programmed into the fixed memory location.
Lets look at an example where a certificate is part of the ACP and needs to be programmed into the Data Flash Address of a RA6M4 MCU.
The certificate above is stored into a file called sample.pem.
Use srec_cat to convert this into a srecord file.
srec_cat sample.pem -Binary -offset 0x08000000 -output dstfile.srec -obs=16 -data-only
srec_cat sample.pem -Binary -offset 0x08000000 -output dstfile.srec -obs=16 -data-only
The above command treats sample.pem as a binary to be programmed at address 0x08000000 using an output block size of 16 bytes. This is the main data you want to load to the RA6M4 using the Renesas Flash Programmer. But you will find that RFP fails to program the device.
This is mainly due to a malformed srec file. You need a header and a start address to pass through RFPs checklist for a S-record file. So, we adjust the options of srec_cat.
srec_cat sample.pem -Binary -offset 0x08000000 -fill 0xFF 0x08000000 0x08002000 -header=dstfile.srec -output dstfile.srec -obs=16 -start-address 0x00000000
srec_cat sample.pem -Binary -offset 0x08000000 -fill 0xFF 0x08000000 0x08002000 -header=dstfile.srec -output dstfile.srec -obs=16 -start-address 0x00000000
Lets breakdown the new command options used in the command above.
-fill value minimum maximum ensures that any missing data between the minimum and maximum address range is filled with value i.e. 0xFF. You should adjust the value of the maximum based on the block erase size of the memory region being programmed.
-header=string places the string at the start of the srec file using the S0 Record field. Typically, this is the name of the file.
-start-address 0x00000000 places an Execution Start Address towards the end.
When you pass the output file to RFP, it should be able to program the RA6M4 MCU. Note, you may have to power cycle the MCU after each RFP operation.
Finally, to confirm the values programmed, you can use RFPs Target Device > Read Memory functionality and compare it against what was written.
As you can see, data matches, but the header and some other record fields may not.
This will now allow you to create unique ACP data srec files for each MCU you intend to program. Next to program both the main application and ACP srec file combinations, you can use the rfp-cli.exe command to program multiple files.
First you need to erase the entire chip:
""c:\Program Files (x86)\Renesas Electronics\Programming Tools\Renesas Flash Programmer V3.09\rfp-cli.exe"" -d RA -port COM6 -erase-chip
""c:\Program Files (x86)\Renesas Electronics\Programming Tools\Renesas Flash Programmer V3.09\rfp-cli.exe"" -d RA -port COM6 -erase-chip
To program both files over USB/SCI Boot mode, first add the Boot Mode Jumper, and then ensure the device is enumerated as a COM port. Finally, use the command below:
""c:\Program Files (x86)\Renesas Electronics\Programming Tools\Renesas Flash Programmer V3.09\rfp-cli.exe"" -d RA -port COM6 -a ""C:\Users\a5087427\Downloads\ek_ra6m4_blinky.srec"" ""C:\Users\a5087427\Downloads\dstfile.srec""
""c:\Program Files (x86)\Renesas Electronics\Programming Tools\Renesas Flash Programmer V3.09\rfp-cli.exe"" -d RA -port COM6 -a ""C:\Users\a5087427\Downloads\ek_ra6m4_blinky.srec"" ""C:\Users\a5087427\Downloads\dstfile.srec""
A successful operation will output:
You can confirm the contents by reading memory from RFP or by removing the Boot mode jumper and allowing normal operation of the MCU.
References:
R20AN0547 - Renesas Flash Programmer - Usage from the Command Line
Suitable Products
RA and FSP
Suitable Products
RA and FSP
Suitable Products
RA and FSP
Suitable Products
RA and FSP","['data/categories/ra_family/rafsp_knowledge_base/22d51b554b6047c545f82565e4d5f950/images/02443a476d5136bbfbcff6480f708278.png', 'data/categories/ra_family/rafsp_knowledge_base/22d51b554b6047c545f82565e4d5f950/images/c84dab45df9c417f6739b2346626f5fc.png', 'data/categories/ra_family/rafsp_knowledge_base/22d51b554b6047c545f82565e4d5f950/images/c4bfaa06a0496ddc64b5510c5f4ae90f.png', 'data/categories/ra_family/rafsp_knowledge_base/22d51b554b6047c545f82565e4d5f950/images/f27c45f011f90adcf9c272d5739ffecb.png', 'data/categories/ra_family/rafsp_knowledge_base/22d51b554b6047c545f82565e4d5f950/images/ccde583e8942470ea175c24655233bd0.png']",[],['|  |\n|  |\n| RA and FSP |'],"{'title': 'Production Configuration for RA MCUs with srec_cat and Renesas Flash Programmer', 'url': 'https://en-support.renesas.com/knowledgeBase/20498707', 'last_updated': None, 'extracted_at': '2025-03-08T23:25:22.998290'}","Often product developers find themselves in a position where application configuration parameters need to be uniquely programmed into a MCUs memory. To do so, often firmware is created which is flashed into the MCU which is responsible for the acquisition of the needed application configuration parameters. MAC addresses, IP Addresses, SSID Names, Passwords, Public/Private keys, etc. are examples of application configuration parameters. The issue with an approach where the firmware handles acquisition of the ACPs is the need to create auxiliary code which adds limited value to the main application. This in turn leads to additional test efforts, and longer development times. A way to avoid such issues is to modularize your application and store the ACPs as a blob of structured binary data located in a fixed location in memory. So when your application starts, it is able to access the fixed location, read the data in a fixed manner, and adjust the mode of operation. When you have achieved such modularization, you can segment your application in to two parts Your ACP data can then be converted into a S-Record file and programmed into the fixed memory location. Lets look at an example where a certificate is part of the ACP and needs to be programmed into the Data Flash Address of a RA6M4 MCU. The certificate above is stored into a file called sample.pem. Use sreccat to convert this into a srecord file. sreccat sample.pem -Binary -offset 0x08000000 -output dstfile.srec -obs16 -data-only The above command treats sample.pem as a binary to be programmed at address 0x08000000 using an output block size of 16 bytes. This is the main data you want to load to the RA6M4 using the Renesas Flash Programmer. But you will find that RFP fails to program the device. This is mainly due to a malformed srec file. You need a header and a start address to pass through RFPs checklist for a S-record file. So, we adjust the options of sreccat. sreccat sample.pem -Binary -offset 0x08000000 -fill 0xFF 0x08000000 0x08002000 -headerdstfile.srec -output dstfile.srec -obs16 -start-address 0x00000000 Lets breakdown the new command options used in the command above. -fill value minimum maximum ensures that any missing data between the minimum and maximum address range is filled with value i.e. 0xFF. You should adjust the value of the maximum based on the block erase size of the memory region being programmed. -headerstring places the string at the start of the srec file using the S0 Record field. Typically, this is the name of the file. -start-address 0x00000000 places an Execution Start Address towards the end. When you pass the output file to RFP, it should be able to program the RA6M4 MCU. Note, you may have to power cycle the MCU after each RFP operation. Finally, to confirm the values programmed, you can use RFPs Target Device  Read Memory functionality and compare it against what was written. As you can see, data matches, but the header and some other record fields may not. This will now allow you to create unique ACP data srec files for each MCU you intend to program. Next to program both the main application and ACP srec file combinations, you can use the rfp-cli.exe command to program multiple files. First you need to erase the entire chip ""cProgram Files (x86)Renesas ElectronicsProgramming ToolsRenesas Flash Programmer V3.09rfp-cli.exe"" -d RA -port COM6 -erase-chip To program both files over USB/SCI Boot mode, first add the Boot Mode Jumper, and then ensure the device is enumerated as a COM port. Finally, use the command below ""cProgram Files (x86)Renesas ElectronicsProgramming ToolsRenesas Flash Programmer V3.09rfp-cli.exe"" -d RA -port COM6 -a ""CUsersa5087427Downloadsekra6m4blinky.srec"" ""CUsersa5087427Downloadsdstfile.srec"" A successful operation will output You can confirm the contents by reading memory from RFP or by removing the Boot mode jumper and allowing normal operation of the MCU. References R20AN0547 - Renesas Flash Programmer - Usage from the Command Line Suitable Products RA and FSP",
1ea78483764d956552ea9fac90a28ba7,"Overview:
During compilation on the e2studio/GCC toolchain, we can look at the output of the arm-none-eabi-size to see the amount of ROM/RAM used.
For an RA6M4 project using ethernet the netx ftp example project in this case), the RAM (bss) shows high usage : 260564 bytes out of total 256 kbyte available.  This is due to a special requirement to place the EDMAC buffers in non-secure RAM. Non-secure RAM is typically assigned to the end of usable RAM.
You can see below that the linker script relocates the .ns_buffer towards the end of RAM.
To find out the available RAM for this project, look at the projects .map file and see the amount that has been skipped.
  In the figure above, the *fill* amount in .ns_buffer is 0x264d0 ( 158,880 bytes). These are skipped over, to place ethernet buffers at the end of RAM.  This 158kb is the available (unused) RAM for this project.
Suitable Products
RA6M4, RA6M5
During compilation on the e2studio/GCC toolchain, we can look at the output of the arm-none-eabi-size to see the amount of ROM/RAM used.
For an RA6M4 project using ethernet the netx ftp example project in this case), the RAM (bss) shows high usage : 260564 bytes out of total 256 kbyte available.  This is due to a special requirement to place the EDMAC buffers in non-secure RAM. Non-secure RAM is typically assigned to the end of usable RAM.
You can see below that the linker script relocates the .ns_buffer towards the end of RAM.
To find out the available RAM for this project, look at the projects .map file and see the amount that has been skipped.
  In the figure above, the *fill* amount in .ns_buffer is 0x264d0 ( 158,880 bytes). These are skipped over, to place ethernet buffers at the end of RAM.  This 158kb is the available (unused) RAM for this project.
During compilation on the e2studio/GCC toolchain, we can look at the output of the arm-none-eabi-size to see the amount of ROM/RAM used.
For an RA6M4 project using ethernet the netx ftp example project in this case), the RAM (bss) shows high usage : 260564 bytes out of total 256 kbyte available.  This is due to a special requirement to place the EDMAC buffers in non-secure RAM. Non-secure RAM is typically assigned to the end of usable RAM.
You can see below that the linker script relocates the .ns_buffer towards the end of RAM.
To find out the available RAM for this project, look at the projects .map file and see the amount that has been skipped.
In the figure above, the *fill* amount in .ns_buffer is 0x264d0 ( 158,880 bytes). These are skipped over, to place ethernet buffers at the end of RAM.  This 158kb is the available (unused) RAM for this project.
Suitable Products
RA6M4, RA6M5
Suitable Products
RA6M4, RA6M5","['data/categories/ra_family/rafsp_knowledge_base/1ea78483764d956552ea9fac90a28ba7/images/6d7ee47dbcf937332cd8d72cbdad173f.png', 'data/categories/ra_family/rafsp_knowledge_base/1ea78483764d956552ea9fac90a28ba7/images/831bb49657123d6a425750c990b62915.png', 'data/categories/ra_family/rafsp_knowledge_base/1ea78483764d956552ea9fac90a28ba7/images/1e8380b690b9337b323dc07bfd1daaab.png']",[],"['|  |\n|  |\n| RA6M4, RA6M5 |']","{'title': 'RA Family: RAM remaining for an RA6M4 ethernet project', 'url': 'https://en-support.renesas.com/knowledgeBase/21618619', 'last_updated': '2024-04-10', 'extracted_at': '2025-03-08T23:23:22.319010'}","Overview During compilation on the e2studio/GCC toolchain, we can look at the output of the arm-none-eabi-size to see the amount of ROM/RAM used. For an RA6M4 project using ethernet the netx ftp example project in this case), the RAM (bss) shows high usage  260564 bytes out of total 256 kbyte available. This is due to a special requirement to place the EDMAC buffers in non-secure RAM. Non-secure RAM is typically assigned to the end of usable RAM. You can see below that the linker script relocates the .nsbuffer towards the end of RAM. To find out the available RAM for this project, look at the projects .map file and see the amount that has been skipped. In the figure above, the fill amount in .nsbuffer is 0x264d0 ( 158,880 bytes). These are skipped over, to place ethernet buffers at the end of RAM. This 158kb is the available (unused) RAM for this project. Suitable Products RA6M4, RA6M5 In the figure above, the fill amount in .nsbuffer is 0x264d0 ( 158,880 bytes). These are skipped over, to place ethernet buffers at the end of RAM. This 158kb is the available (unused) RAM for this project.",
a99bdc1c2932b067ff371ba2aeedfe12,"Question:
How to use the Debug Out function of J-Link OB on EK (Evaluation Kit)
Answer:
Renesas has equipped each EK (Evaluation Kit) for RA MCUs, such as EK-RA2E1, EK-RA2E2, EK-RA2L1, EK-RA2A1, etcEK-RA4M1EK-RA4M2EK-RA4M3EK-RA4W1EK-RA6M1EK-RA6M2, EK-RA6M3, EK-RA6M4, EK-RA6M5, etc., all EKs come with J-Link OB (On-Board Debugger), which means that the user can evaluate, debug, and test the MCU with only one USB cable, eliminating the need for a separate J-Link emulator. Most of these EKs have the J-Link OB's Debug Out function, which means that the J-Link OB (On-Board Debugger) on the board can be used to debug not only the MCU on the board, but also the customer's RA target board through the Debug OB function. However, some EKs do not support this function, such as EK-RA2A1, EK-RA4M1, EK-RA6M1, EK-RA6M2, etc.
It is important to emphasize that this on-board debugger is officially provided by Renesas, and the firmware can be updated with the update of the SEGGER tool.
In this article, EK-RA6M3 is used as an example to describe the specific implementation method.
Refer to the schematic diagram of EK-RA6M3:
J29 can be used with J8 and J9 to achieve the Debug Out function, J9 does not connect to the jumper cap[WM1] [MM2] , and J8 connects to Pin2 and Pin3.
To connect the customer target board, use the following pins of the J29:
J29 Customer Targets Board
Pin6 P108/SWDIO
Pin8 P300/SWCLK
Pin2 P110/RXD9
Pin4 P109/TXD9
J8 Customer Targets Board
Pin1 RESET
  Annotation:
These pins are all 2.0 pitch.
To control the MD pin of the RA with J-Link OB, connect Pin 8 of J29 to the MD/P201 pin of the target board chip at the same time.
Since the above pins do not have GND pins, it is also necessary to connect the GND of the user board to the GND on the EK board. The following pins can be used with double-row pins: Pin30 for J1, Pin39 for J2, Pin39 for J3, Pin39 for J4.
If the customer's target board needs power from the EK-RA6M3, please note that there are two options: 3.3V or 5V.
The following pins on J1, J2, J3, and J4 can be used to power the customer's target board:
3.3V 5V
J1: Pin 36 J1: Pin 40
J2: Pin 1  
J3: Pin 1  
J4: Pin 1  
  Suitable Products
RA
How to use the Debug Out function of J-Link OB on EK (Evaluation Kit)
How to use the Debug Out function of J-Link OB on EK (Evaluation Kit)
Answer:
Renesas has equipped each EK (Evaluation Kit) for RA MCUs, such as EK-RA2E1, EK-RA2E2, EK-RA2L1, EK-RA2A1, etcEK-RA4M1EK-RA4M2EK-RA4M3EK-RA4W1EK-RA6M1EK-RA6M2, EK-RA6M3, EK-RA6M4, EK-RA6M5, etc., all EKs come with J-Link OB (On-Board Debugger), which means that the user can evaluate, debug, and test the MCU with only one USB cable, eliminating the need for a separate J-Link emulator. Most of these EKs have the J-Link OB's Debug Out function, which means that the J-Link OB (On-Board Debugger) on the board can be used to debug not only the MCU on the board, but also the customer's RA target board through the Debug OB function. However, some EKs do not support this function, such as EK-RA2A1, EK-RA4M1, EK-RA6M1, EK-RA6M2, etc.
It is important to emphasize that this on-board debugger is officially provided by Renesas, and the firmware can be updated with the update of the SEGGER tool.
In this article, EK-RA6M3 is used as an example to describe the specific implementation method.
Refer to the schematic diagram of EK-RA6M3:
J29 can be used with J8 and J9 to achieve the Debug Out function, J9 does not connect to the jumper cap[WM1] [MM2] , and J8 connects to Pin2 and Pin3.
To connect the customer target board, use the following pins of the J29:
J29 Customer Targets Board
Pin6 P108/SWDIO
Pin8 P300/SWCLK
Pin2 P110/RXD9
Pin4 P109/TXD9
J8 Customer Targets Board
Pin1 RESET
  Annotation:
These pins are all 2.0 pitch.
To control the MD pin of the RA with J-Link OB, connect Pin 8 of J29 to the MD/P201 pin of the target board chip at the same time.
Since the above pins do not have GND pins, it is also necessary to connect the GND of the user board to the GND on the EK board. The following pins can be used with double-row pins: Pin30 for J1, Pin39 for J2, Pin39 for J3, Pin39 for J4.
If the customer's target board needs power from the EK-RA6M3, please note that there are two options: 3.3V or 5V.
The following pins on J1, J2, J3, and J4 can be used to power the customer's target board:
3.3V 5V
J1: Pin 36 J1: Pin 40
J2: Pin 1  
J3: Pin 1  
J4: Pin 1  
  Suitable Products
RA
Renesas has equipped each EK (Evaluation Kit) for RA MCUs, such as EK-RA2E1, EK-RA2E2, EK-RA2L1, EK-RA2A1, etcEK-RA4M1EK-RA4M2EK-RA4M3EK-RA4W1EK-RA6M1EK-RA6M2, EK-RA6M3, EK-RA6M4, EK-RA6M5, etc., all EKs come with J-Link OB (On-Board Debugger), which means that the user can evaluate, debug, and test the MCU with only one USB cable, eliminating the need for a separate J-Link emulator. Most of these EKs have the J-Link OB's Debug Out function, which means that the J-Link OB (On-Board Debugger) on the board can be used to debug not only the MCU on the board, but also the customer's RA target board through the Debug OB function. However, some EKs do not support this function, such as EK-RA2A1, EK-RA4M1, EK-RA6M1, EK-RA6M2, etc.
It is important to emphasize that this on-board debugger is officially provided by Renesas, and the firmware can be updated with the update of the SEGGER tool.
In this article, EK-RA6M3 is used as an example to describe the specific implementation method.
Refer to the schematic diagram of EK-RA6M3:
J29 can be used with J8 and J9 to achieve the Debug Out function, J9 does not connect to the jumper cap[WM1] [MM2] , and J8 connects to Pin2 and Pin3.
To connect the customer target board, use the following pins of the J29:
Annotation:
These pins are all 2.0 pitch.
To control the MD pin of the RA with J-Link OB, connect Pin 8 of J29 to the MD/P201 pin of the target board chip at the same time.
Since the above pins do not have GND pins, it is also necessary to connect the GND of the user board to the GND on the EK board. The following pins can be used with double-row pins: Pin30 for J1, Pin39 for J2, Pin39 for J3, Pin39 for J4.
If the customer's target board needs power from the EK-RA6M3, please note that there are two options: 3.3V or 5V.
The following pins on J1, J2, J3, and J4 can be used to power the customer's target board:
Suitable Products
RA","['data/categories/ra_family/rafsp_knowledge_base/a99bdc1c2932b067ff371ba2aeedfe12/images/d04f7b2a50278e8a71083c1281a886da.png', 'data/categories/ra_family/rafsp_knowledge_base/a99bdc1c2932b067ff371ba2aeedfe12/images/d33da1157bd9149b1155edbfb98e466d.png', 'data/categories/ra_family/rafsp_knowledge_base/a99bdc1c2932b067ff371ba2aeedfe12/images/a566c3b8770512310391ff5eade85f34.png']",[],"['|  |\n|  |\n| J29 | Customer Targets Board |\n| Pin6 | P108/SWDIO |\n| Pin8 | P300/SWCLK |\n| Pin2 | P110/RXD9 |\n| Pin4 | P109/TXD9 |\n| J8 | Customer Targets Board |\n| Pin1 | RESET |', '|  |\n|  |\n| 3.3V | 5V |\n| J1: Pin 36 | J1: Pin 40 |\n| J2: Pin 1 |  |\n| J3: Pin 1 |  |\n| J4: Pin 1 |  |', '|  |\n|  |\n| RA |']","{'title': 'RA Family: How to use the Debug Out function of J-Link OB on EK (Evaluation Kit)', 'url': 'https://en-support.renesas.com/knowledgeBase/21172753', 'last_updated': None, 'extracted_at': '2025-03-08T23:20:33.441941'}","Question How to use the Debug Out function of J-Link OB on EK (Evaluation Kit) Answer Renesas has equipped each EK (Evaluation Kit) for RA MCUs, such as EK-RA2E1, EK-RA2E2, EK-RA2L1, EK-RA2A1, etcEK-RA4M1EK-RA4M2EK-RA4M3EK-RA4W1EK-RA6M1EK-RA6M2, EK-RA6M3, EK-RA6M4, EK-RA6M5, etc., all EKs come with J-Link OB (On-Board Debugger), which means that the user can evaluate, debug, and test the MCU with only one USB cable, eliminating the need for a separate J-Link emulator. Most of these EKs have the J-Link OB's Debug Out function, which means that the J-Link OB (On-Board Debugger) on the board can be used to debug not only the MCU on the board, but also the customer's RA target board through the Debug OB function. However, some EKs do not support this function, such as EK-RA2A1, EK-RA4M1, EK-RA6M1, EK-RA6M2, etc. It is important to emphasize that this on-board debugger is officially provided by Renesas, and the firmware can be updated with the update of the SEGGER tool. In this article, EK-RA6M3 is used as an example to describe the specific implementation method. Refer to the schematic diagram of EK-RA6M3 J29 can be used with J8 and J9 to achieve the Debug Out function, J9 does not connect to the jumper capWM1 MM2 , and J8 connects to Pin2 and Pin3. To connect the customer target board, use the following pins of the J29 J29 Customer Targets Board Pin6 P108/SWDIO Pin8 P300/SWCLK Pin2 P110/RXD9 Pin4 P109/TXD9 J8 Customer Targets Board Pin1 RESET Annotation These pins are all 2.0 pitch. To control the MD pin of the RA with J-Link OB, connect Pin 8 of J29 to the MD/P201 pin of the target board chip at the same time. Since the above pins do not have GND pins, it is also necessary to connect the GND of the user board to the GND on the EK board. The following pins can be used with double-row pins Pin30 for J1, Pin39 for J2, Pin39 for J3, Pin39 for J4. If the customer's target board needs power from the EK-RA6M3, please note that there are two options 3.3V or 5V. The following pins on J1, J2, J3, and J4 can be used to power the customer's target board 3.3V 5V J1 Pin 36 J1 Pin 40 J2 Pin 1 J3 Pin 1 J4 Pin 1 Suitable Products RA Annotation Suitable Products",
1e8081c528d379f61c9dd5652c68a2d8,"Question:
When creating a RA0E1 project and changing the optimization option to None (-O0), there is an error during compilation. If the optimization option is changed to any other optimization option, there is no error during compilation.
Answer:
Currently, the RA0E1 uses ""Fill gap"" and ""Optimize aggressively for size (-Oz)"" by default to optimize code size. According to the FSP manual, there is a section of code flash between the end of the vector table (near the beginning of the flash) and the ROM register (address 0x400). When the ""Fill Flash Gap"" option is selected to ""Fill gap"", the pre-selected setup function will be filled in this area to reduce the amount of the Code Flash used by the FSP. Therefore, when the user changes the optimization option to ""None (-O0)"", the compiled content of the function will occupy a larger Flash space, which will exceed the gap area, resulting in a compilation error.
To avoid this, the user can disable gap filling by changing the ""Fill Flash Gap"" setting to ""Do not fill gap"" in the BSP properties.
Appendix: For the meaning of ""Fill Flash Gap"", please refer to the content in the FSP manual as follows:
Suitable Products
RA
When creating a RA0E1 project and changing the optimization option to None (-O0), there is an error during compilation. If the optimization option is changed to any other optimization option, there is no error during compilation.
When creating a RA0E1 project and changing the optimization option to None (-O0), there is an error during compilation. If the optimization option is changed to any other optimization option, there is no error during compilation.
Answer:
Currently, the RA0E1 uses ""Fill gap"" and ""Optimize aggressively for size (-Oz)"" by default to optimize code size. According to the FSP manual, there is a section of code flash between the end of the vector table (near the beginning of the flash) and the ROM register (address 0x400). When the ""Fill Flash Gap"" option is selected to ""Fill gap"", the pre-selected setup function will be filled in this area to reduce the amount of the Code Flash used by the FSP. Therefore, when the user changes the optimization option to ""None (-O0)"", the compiled content of the function will occupy a larger Flash space, which will exceed the gap area, resulting in a compilation error.
To avoid this, the user can disable gap filling by changing the ""Fill Flash Gap"" setting to ""Do not fill gap"" in the BSP properties.
Appendix: For the meaning of ""Fill Flash Gap"", please refer to the content in the FSP manual as follows:
Suitable Products
RA
Currently, the RA0E1 uses ""Fill gap"" and ""Optimize aggressively for size (-Oz)"" by default to optimize code size. According to the FSP manual, there is a section of code flash between the end of the vector table (near the beginning of the flash) and the ROM register (address 0x400). When the ""Fill Flash Gap"" option is selected to ""Fill gap"", the pre-selected setup function will be filled in this area to reduce the amount of the Code Flash used by the FSP. Therefore, when the user changes the optimization option to ""None (-O0)"", the compiled content of the function will occupy a larger Flash space, which will exceed the gap area, resulting in a compilation error.
To avoid this, the user can disable gap filling by changing the ""Fill Flash Gap"" setting to ""Do not fill gap"" in the BSP properties.
Appendix: For the meaning of ""Fill Flash Gap"", please refer to the content in the FSP manual as follows:
Currently, the RA0E1 uses ""Fill gap"" and ""Optimize aggressively for size (-Oz)"" by default to optimize code size. According to the FSP manual, there is a section of code flash between the end of the vector table (near the beginning of the flash) and the ROM register (address 0x400). When the ""Fill Flash Gap"" option is selected to ""Fill gap"", the pre-selected setup function will be filled in this area to reduce the amount of the Code Flash used by the FSP. Therefore, when the user changes the optimization option to ""None (-O0)"", the compiled content of the function will occupy a larger Flash space, which will exceed the gap area, resulting in a compilation error.
To avoid this, the user can disable gap filling by changing the ""Fill Flash Gap"" setting to ""Do not fill gap"" in the BSP properties.
Appendix: For the meaning of ""Fill Flash Gap"", please refer to the content in the FSP manual as follows:
Suitable Products
RA
Chinese
Chinese","['data/categories/ra_family/rafsp_knowledge_base/1e8081c528d379f61c9dd5652c68a2d8/images/f38a5a98a38add192f308b9fb6a3c235.png', 'data/categories/ra_family/rafsp_knowledge_base/1e8081c528d379f61c9dd5652c68a2d8/images/bab6ca49ea558cbfc644566873843096.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'RA0E1: When I create a RA0E1 project and change the optimization option to none (-O0), an error occurs during compilation', 'url': 'https://en-support.renesas.com/knowledgeBase/21789662', 'last_updated': '2025-04-02', 'extracted_at': '2025-03-08T23:22:30.731699'}","Question When creating a RA0E1 project and changing the optimization option to None (-O0), there is an error during compilation. If the optimization option is changed to any other optimization option, there is no error during compilation. Answer Currently, the RA0E1 uses ""Fill gap"" and ""Optimize aggressively for size (-Oz)"" by default to optimize code size. According to the FSP manual, there is a section of code flash between the end of the vector table (near the beginning of the flash) and the ROM register (address 0x400). When the ""Fill Flash Gap"" option is selected to ""Fill gap"", the pre-selected setup function will be filled in this area to reduce the amount of the Code Flash used by the FSP. Therefore, when the user changes the optimization option to ""None (-O0)"", the compiled content of the function will occupy a larger Flash space, which will exceed the gap area, resulting in a compilation error. To avoid this, the user can disable gap filling by changing the ""Fill Flash Gap"" setting to ""Do not fill gap"" in the BSP properties. Appendix For the meaning of ""Fill Flash Gap"", please refer to the content in the FSP manual as follows Suitable Products RA Chinese",
4753e664b55c0f90b45c0d867d04a93b,"Question:
In the RA8 user's manual, there is a description of ""Notes on transitioning to or canceling low power state"". What should I do if I use FSP?
Answer:
In the RA8 MCU, it is necessary to insert a certain period of NOP operation wait [MM1] [KK2] (no execution) during the transition and return to the low-power mode. The FSP contains functions corresponding to the source files ra/fsp/src/bsp/mcu/all/bsp_clocks.c of the MCU Board Support Package (BSP).
Processing when transitioning to low power consumption mode: bsp_prv_clock_prepare_pre_sleep ()
Processing when resuming from low power consumption mode: bsp_prv_clock_prepare_post_sleep ()
These functions are called internally by r_lpm driver's R_LPM_LowPowerModeEnter functions, so no additional processing is required when using them to perform low-power transitions.
However, if you do not use a r_lpm driver and perform the low-power mode transition in your application's own code, implement it in a way that meets the guidelines in the device's user's manual.  If necessary, you can use the above BSP functions.
Note: bsp_prv_clock_prepare_pre_sleep() and bsp_prv_clock_prepare_post_sleep() can be disabled in the BSP tab of the Configurator (Clocks -> Sleep Mode Entry and Exit Delays) ( Default: Enabled).
Suitable Products
RA Family
In the RA8 user's manual, there is a description of ""Notes on transitioning to or canceling low power state"". What should I do if I use FSP?
In the RA8 user's manual, there is a description of ""Notes on transitioning to or canceling low power state"". What should I do if I use FSP?
Answer:
In the RA8 MCU, it is necessary to insert a certain period of NOP operation wait [MM1] [KK2] (no execution) during the transition and return to the low-power mode. The FSP contains functions corresponding to the source files ra/fsp/src/bsp/mcu/all/bsp_clocks.c of the MCU Board Support Package (BSP).
Processing when transitioning to low power consumption mode: bsp_prv_clock_prepare_pre_sleep ()
Processing when resuming from low power consumption mode: bsp_prv_clock_prepare_post_sleep ()
These functions are called internally by r_lpm driver's R_LPM_LowPowerModeEnter functions, so no additional processing is required when using them to perform low-power transitions.
However, if you do not use a r_lpm driver and perform the low-power mode transition in your application's own code, implement it in a way that meets the guidelines in the device's user's manual.  If necessary, you can use the above BSP functions.
Note: bsp_prv_clock_prepare_pre_sleep() and bsp_prv_clock_prepare_post_sleep() can be disabled in the BSP tab of the Configurator (Clocks -> Sleep Mode Entry and Exit Delays) ( Default: Enabled).
Suitable Products
RA Family
In the RA8 MCU, it is necessary to insert a certain period of NOP operation wait [MM1] [KK2] (no execution) during the transition and return to the low-power mode. The FSP contains functions corresponding to the source files ra/fsp/src/bsp/mcu/all/bsp_clocks.c of the MCU Board Support Package (BSP).
Processing when transitioning to low power consumption mode: bsp_prv_clock_prepare_pre_sleep ()
Processing when resuming from low power consumption mode: bsp_prv_clock_prepare_post_sleep ()
These functions are called internally by r_lpm driver's R_LPM_LowPowerModeEnter functions, so no additional processing is required when using them to perform low-power transitions.
However, if you do not use a r_lpm driver and perform the low-power mode transition in your application's own code, implement it in a way that meets the guidelines in the device's user's manual.  If necessary, you can use the above BSP functions.
Note: bsp_prv_clock_prepare_pre_sleep() and bsp_prv_clock_prepare_post_sleep() can be disabled in the BSP tab of the Configurator (Clocks -> Sleep Mode Entry and Exit Delays) ( Default: Enabled).
In the RA8 MCU, it is necessary to insert a certain period of NOP operation wait [MM1] [KK2] (no execution) during the transition and return to the low-power mode. The FSP contains functions corresponding to the source files ra/fsp/src/bsp/mcu/all/bsp_clocks.c of the MCU Board Support Package (BSP).
These functions are called internally by r_lpm driver's R_LPM_LowPowerModeEnter functions, so no additional processing is required when using them to perform low-power transitions.
However, if you do not use a r_lpm driver and perform the low-power mode transition in your application's own code, implement it in a way that meets the guidelines in the device's user's manual.  If necessary, you can use the above BSP functions.
Note: bsp_prv_clock_prepare_pre_sleep() and bsp_prv_clock_prepare_post_sleep() can be disabled in the BSP tab of the Configurator (Clocks -> Sleep Mode Entry and Exit Delays) ( Default: Enabled).
Suitable Products
RA Family

",['data/categories/ra_family/rafsp_knowledge_base/4753e664b55c0f90b45c0d867d04a93b/images/5b586fe81a17d9097fea0607f9bc66a8.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: Precautions when entering and exiting the low-power state in RA8', 'url': 'https://en-support.renesas.com/knowledgeBase/21698324', 'last_updated': None, 'extracted_at': '2025-03-08T23:22:55.465369'}","Question In the RA8 user's manual, there is a description of ""Notes on transitioning to or canceling low power state"". What should I do if I use FSP? Answer In the RA8 MCU, it is necessary to insert a certain period of NOP operation wait MM1 KK2 (no execution) during the transition and return to the low-power mode. The FSP contains functions corresponding to the source files ra/fsp/src/bsp/mcu/all/bspclocks.c of the MCU Board Support Package (BSP). Processing when transitioning to low power consumption mode bspprvclockpreparepresleep () Processing when resuming from low power consumption mode bspprvclockpreparepostsleep () These functions are called internally by rlpm driver's RLPMLowPowerModeEnter functions, so no additional processing is required when using them to perform low-power transitions. However, if you do not use a rlpm driver and perform the low-power mode transition in your application's own code, implement it in a way that meets the guidelines in the device's user's manual. If necessary, you can use the above BSP functions. Note bspprvclockpreparepresleep() and bspprvclockpreparepostsleep() can be disabled in the BSP tab of the Configurator (Clocks - Sleep Mode Entry and Exit Delays) ( Default Enabled). Suitable Products RA Family ",
dace1a997b96e94b9219abf318eb3463,"Answer:
FSP's USB driver is equipped with a debug log output function to check the execution status of the driver's internal program (e.g., enumeration status and event information). You can enable the debug output of the USB driver by defining the USB_DEBUG_ON with compiler options as shown below.
The output destination is implemented in the r_usb_basic_define.h file to execute the printf function of the standard library by default. If you want to change this to a different destination, edit the USB_PRINTFn macro definition in the r_usb_basic_define.h file or redefine the _write function in the User Application code.
To output the debug log with the SEGGER J-Link RTT function, define the _write function as follows.
int _write(int file, char *ptr, int len)
{
     FSP_PARAMETER_NOT_USED(file);
     int    ret;
          ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);
          return ret;
}
  Notes:
Enabling this feature may reduce the processing, execution, and performance of the USB driver.
Suitable Products
RA Family
Answer:
FSP's USB driver is equipped with a debug log output function to check the execution status of the driver's internal program (e.g., enumeration status and event information). You can enable the debug output of the USB driver by defining the USB_DEBUG_ON with compiler options as shown below.
The output destination is implemented in the r_usb_basic_define.h file to execute the printf function of the standard library by default. If you want to change this to a different destination, edit the USB_PRINTFn macro definition in the r_usb_basic_define.h file or redefine the _write function in the User Application code.
To output the debug log with the SEGGER J-Link RTT function, define the _write function as follows.
int _write(int file, char *ptr, int len)
{
     FSP_PARAMETER_NOT_USED(file);
     int    ret;
          ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);
          return ret;
}
  Notes:
Enabling this feature may reduce the processing, execution, and performance of the USB driver.
Suitable Products
RA Family
FSP's USB driver is equipped with a debug log output function to check the execution status of the driver's internal program (e.g., enumeration status and event information). You can enable the debug output of the USB driver by defining the USB_DEBUG_ON with compiler options as shown below.
The output destination is implemented in the r_usb_basic_define.h file to execute the printf function of the standard library by default. If you want to change this to a different destination, edit the USB_PRINTFn macro definition in the r_usb_basic_define.h file or redefine the _write function in the User Application code.
To output the debug log with the SEGGER J-Link RTT function, define the _write function as follows.
int _write(int file, char *ptr, int len)
{
     FSP_PARAMETER_NOT_USED(file);
     int    ret;
          ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);
          return ret;
}
  Notes:
Enabling this feature may reduce the processing, execution, and performance of the USB driver.
FSP's USB driver is equipped with a debug log output function to check the execution status of the driver's internal program (e.g., enumeration status and event information). You can enable the debug output of the USB driver by defining the USB_DEBUG_ON with compiler options as shown below.
The output destination is implemented in the r_usb_basic_define.h file to execute the printf function of the standard library by default. If you want to change this to a different destination, edit the USB_PRINTFn macro definition in the r_usb_basic_define.h file or redefine the _write function in the User Application code.
To output the debug log with the SEGGER J-Link RTT function, define the _write function as follows.
int _write(int file, char *ptr, int len)
int _write(int file, char *ptr, int len)
{
{
FSP_PARAMETER_NOT_USED(file);
FSP_PARAMETER_NOT_USED(file);
int    ret;
int    ret;
ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);
ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);
return ret;
return ret;
}
}
Notes:
Enabling this feature may reduce the processing, execution, and performance of the USB driver.
Suitable Products
RA Family

",['data/categories/ra_family/rafsp_knowledge_base/dace1a997b96e94b9219abf318eb3463/images/f7d94c41c5a86cc8baed51846d34dba4.png'],[],"['|  |\n|  |\n| int _write(int file, char *ptr, int len)\n{\n     FSP_PARAMETER_NOT_USED(file);\n     int    ret;\n          ret = (int)SEGGER_RTT_Write(0, ptr, (unsigned int)len);\n          return ret;\n} |', '|  |\n|  |\n| RA Family |']","{'title': 'RA Family: How to enable debug logging for USB driver', 'url': 'https://en-support.renesas.com/knowledgeBase/21652595', 'last_updated': None, 'extracted_at': '2025-03-08T23:23:15.881018'}","Answer FSP's USB driver is equipped with a debug log output function to check the execution status of the driver's internal program (e.g., enumeration status and event information). You can enable the debug output of the USB driver by defining the USBDEBUGON with compiler options as shown below. The output destination is implemented in the rusbbasicdefine.h file to execute the printf function of the standard library by default. If you want to change this to a different destination, edit the USBPRINTFn macro definition in the rusbbasicdefine.h file or redefine the write function in the User Application code. To output the debug log with the SEGGER J-Link RTT function, define the write function as follows. int write(int file, char ptr, int len)  FSPPARAMETERNOTUSED(file); int ret; ret  (int)SEGGERRTTWrite(0, ptr, (unsigned int)len); return ret;  Notes Enabling this feature may reduce the processing, execution, and performance of the USB driver. Suitable Products RA Family FSPPARAMETERNOTUSED(file); int ret; ret  (int)SEGGERRTTWrite(0, ptr, (unsigned int)len); return ret; Notes ",
56b8d942e88e655c62d995783a04781a,"Answer:
RA6 MCU device supports QSPI memory controller for connecting serial ROM such as serial flash memory and has an SPI compatible interface. The QSPI controls the XIP mode for serial flash using serial data signals. Thus it is possible to run the code from external QSPI flash memory using XIP mode.
The attached reference example code builds on voice-ra6e1 kit, this board is equipped with AT25SF64 QSPI flash memory and connected to MCU QSPI interface as below 
To configure the board for QSPI flash memory, the jumper setting needs to be selected as mentioned above.
The reference sample application performs initial configuration for the AT25SF64 and enables the QSPI XIP mode, and subsequently runs the blinky_fun function which is placed in QSPI section "".qspi_flash"" of  external flash memory.
After loading the application into the MCU via e2studio, you can also confirm the QSPI external flash area through the memory view window of e2studio as below 
Environment details of sample project:
Board:       Voice-ra6e1 kit
FSP:          v5.5.0 or later
IDE:           e2studio - 2024-07 (24.7.0) or later
Compiler:  GCC - 12.2.1.arm-12-mpacbti-34 or later
Suitable Products
RA6E1
Answer:
RA6 MCU device supports QSPI memory controller for connecting serial ROM such as serial flash memory and has an SPI compatible interface. The QSPI controls the XIP mode for serial flash using serial data signals. Thus it is possible to run the code from external QSPI flash memory using XIP mode.
The attached reference example code builds on voice-ra6e1 kit, this board is equipped with AT25SF64 QSPI flash memory and connected to MCU QSPI interface as below 
To configure the board for QSPI flash memory, the jumper setting needs to be selected as mentioned above.
The reference sample application performs initial configuration for the AT25SF64 and enables the QSPI XIP mode, and subsequently runs the blinky_fun function which is placed in QSPI section "".qspi_flash"" of  external flash memory.
After loading the application into the MCU via e2studio, you can also confirm the QSPI external flash area through the memory view window of e2studio as below 
Environment details of sample project:
Board:       Voice-ra6e1 kit
FSP:          v5.5.0 or later
IDE:           e2studio - 2024-07 (24.7.0) or later
Compiler:  GCC - 12.2.1.arm-12-mpacbti-34 or later
Suitable Products
RA6E1
RA6 MCU device supports QSPI memory controller for connecting serial ROM such as serial flash memory and has an SPI compatible interface. The QSPI controls the XIP mode for serial flash using serial data signals. Thus it is possible to run the code from external QSPI flash memory using XIP mode.
The attached reference example code builds on voice-ra6e1 kit, this board is equipped with AT25SF64 QSPI flash memory and connected to MCU QSPI interface as below 
To configure the board for QSPI flash memory, the jumper setting needs to be selected as mentioned above.
The reference sample application performs initial configuration for the AT25SF64 and enables the QSPI XIP mode, and subsequently runs the blinky_fun function which is placed in QSPI section "".qspi_flash"" of  external flash memory.
After loading the application into the MCU via e2studio, you can also confirm the QSPI external flash area through the memory view window of e2studio as below 
Environment details of sample project:
Board:       Voice-ra6e1 kit
FSP:          v5.5.0 or later
IDE:           e2studio - 2024-07 (24.7.0) or later
Compiler:  GCC - 12.2.1.arm-12-mpacbti-34 or later
RA6 MCU device supports QSPI memory controller for connecting serial ROM such as serial flash memory and has an SPI compatible interface. The QSPI controls the XIP mode for serial flash using serial data signals. Thus it is possible to run the code from external QSPI flash memory using XIP mode.
The attached reference example code builds on voice-ra6e1 kit, this board is equipped with AT25SF64 QSPI flash memory and connected to MCU QSPI interface as below 
To configure the board for QSPI flash memory, the jumper setting needs to be selected as mentioned above.
The reference sample application performs initial configuration for the AT25SF64 and enables the QSPI XIP mode, and subsequently runs the blinky_fun function which is placed in QSPI section "".qspi_flash"" of  external flash memory.
After loading the application into the MCU via e2studio, you can also confirm the QSPI external flash area through the memory view window of e2studio as below 
Environment details of sample project:
Suitable Products
RA6E1
Japanese
Japanese","['data/categories/ra_family/rafsp_knowledge_base/56b8d942e88e655c62d995783a04781a/images/33546e3a71a70457d7afa0743683b8ba.png', 'data/categories/ra_family/rafsp_knowledge_base/56b8d942e88e655c62d995783a04781a/images/d498529cd3cf59e3deb93e4de610118a.png', 'data/categories/ra_family/rafsp_knowledge_base/56b8d942e88e655c62d995783a04781a/images/40e8725348c21bb7444d29076bf2830c.png']",[],['|  |\n|  |\n| RA6E1 |'],"{'title': 'RA Family: How to run code from external QSPI flash using XIP mode', 'url': 'https://en-support.renesas.com/knowledgeBase/21789659', 'last_updated': '2025-04-02', 'extracted_at': '2025-03-08T23:22:21.203943'}","Answer RA6 MCU device supports QSPI memory controller for connecting serial ROM such as serial flash memory and has an SPI compatible interface. The QSPI controls the XIP mode for serial flash using serial data signals. Thus it is possible to run the code from external QSPI flash memory using XIP mode. The attached reference example code builds on voice-ra6e1 kit, this board is equipped with AT25SF64 QSPI flash memory and connected to MCU QSPI interface as below  To configure the board for QSPI flash memory, the jumper setting needs to be selected as mentioned above. The reference sample application performs initial configuration for the AT25SF64 and enables the QSPI XIP mode, and subsequently runs the blinkyfun function which is placed in QSPI section "".qspiflash"" of external flash memory. After loading the application into the MCU via e2studio, you can also confirm the QSPI external flash area through the memory view window of e2studio as below  Environment details of sample project Board Voice-ra6e1 kit FSP v5.5.0 or later IDE e2studio - 2024-07 (24.7.0) or later Compiler GCC - 12.2.1.arm-12-mpacbti-34 or later Suitable Products RA6E1 Japanese",
f740f948e991648be77e7da74c03781d,"Question:
The user program (such as the hal_entcy function) does not execute because the R_BSP_Init_RTC function called from the FSP initialization function SystemInit does not complete.
Answer:
The RTC registers are not initialized by reset. In order to prevent unintentional counting operations, initialization processing in software is required even when the RTC is not used. If the Subclock Populated parameter is set to Populated in the BSP tab properties of the FSP Configurator, the R_BSP_Init_RTC function executes the RTC software reset process using the subclock oscillator as the clock source and waits for the process to complete. If no subclocks are populated, the process does not terminate.
If you do not want to use a subclock oscillator, set Subclock Populated to Not Populated.
For details on the initialization procedure when the RTC is not used, refer to RTC > Usage Notes > Initialization Procedure When the RTC Is Not to Be Used in the Hardware User's Manual of the MCU device.
Suitable Products
RA Family
The user program (such as the hal_entcy function) does not execute because the R_BSP_Init_RTC function called from the FSP initialization function SystemInit does not complete.
The user program (such as the hal_entcy function) does not execute because the R_BSP_Init_RTC function called from the FSP initialization function SystemInit does not complete.
Answer:
The RTC registers are not initialized by reset. In order to prevent unintentional counting operations, initialization processing in software is required even when the RTC is not used. If the Subclock Populated parameter is set to Populated in the BSP tab properties of the FSP Configurator, the R_BSP_Init_RTC function executes the RTC software reset process using the subclock oscillator as the clock source and waits for the process to complete. If no subclocks are populated, the process does not terminate.
If you do not want to use a subclock oscillator, set Subclock Populated to Not Populated.
For details on the initialization procedure when the RTC is not used, refer to RTC > Usage Notes > Initialization Procedure When the RTC Is Not to Be Used in the Hardware User's Manual of the MCU device.
Suitable Products
RA Family
The RTC registers are not initialized by reset. In order to prevent unintentional counting operations, initialization processing in software is required even when the RTC is not used. If the Subclock Populated parameter is set to Populated in the BSP tab properties of the FSP Configurator, the R_BSP_Init_RTC function executes the RTC software reset process using the subclock oscillator as the clock source and waits for the process to complete. If no subclocks are populated, the process does not terminate.
If you do not want to use a subclock oscillator, set Subclock Populated to Not Populated.
For details on the initialization procedure when the RTC is not used, refer to RTC > Usage Notes > Initialization Procedure When the RTC Is Not to Be Used in the Hardware User's Manual of the MCU device.
The RTC registers are not initialized by reset. In order to prevent unintentional counting operations, initialization processing in software is required even when the RTC is not used. If the Subclock Populated parameter is set to Populated in the BSP tab properties of the FSP Configurator, the R_BSP_Init_RTC function executes the RTC software reset process using the subclock oscillator as the clock source and waits for the process to complete. If no subclocks are populated, the process does not terminate.
If you do not want to use a subclock oscillator, set Subclock Populated to Not Populated.
For details on the initialization procedure when the RTC is not used, refer to RTC > Usage Notes > Initialization Procedure When the RTC Is Not to Be Used in the Hardware User's Manual of the MCU device.
Suitable Products
RA Family

",['data/categories/ra_family/rafsp_knowledge_base/f740f948e991648be77e7da74c03781d/images/d40e5b590b2429225ee30d42781b81eb.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: FSP initialization R_BSP_Init_RTC function does not finish and user program does not run', 'url': 'https://en-support.renesas.com/knowledgeBase/21715562', 'last_updated': '2024-10-12', 'extracted_at': '2025-03-08T23:22:36.505997'}","Question The user program (such as the halentcy function) does not execute because the RBSPInitRTC function called from the FSP initialization function SystemInit does not complete. Answer The RTC registers are not initialized by reset. In order to prevent unintentional counting operations, initialization processing in software is required even when the RTC is not used. If the Subclock Populated parameter is set to Populated in the BSP tab properties of the FSP Configurator, the RBSPInitRTC function executes the RTC software reset process using the subclock oscillator as the clock source and waits for the process to complete. If no subclocks are populated, the process does not terminate. If you do not want to use a subclock oscillator, set Subclock Populated to Not Populated. For details on the initialization procedure when the RTC is not used, refer to RTC  Usage Notes  Initialization Procedure When the RTC Is Not to Be Used in the Hardware User's Manual of the MCU device. Suitable Products RA Family ",
8b406254447d6294eb0bf458a27d70db,"Note that this article was written for FSP 1.1.0, but the process still works for FSP 3.7.0 and above.
Introduction
This article describes steps for creating a new custom Board Support Pack (BSP) for Renesas RA Flexible Software Package (FSP).
Required Resources
A PC running Microsoft Windows 10 with the following Renesas software installed:
Board Support Packs in FSP
The Board Support Pack (BSP) is a subset of the Flexible Software Package (FSP), and provides an interface for setting up FSP to work with selected MCUs and specific board HW designs. It is both MCU and board specific. The BSPs for the Renesas RA Evaluation kits are included in FSP packs, but users must create new BSPs for implementing their final products.
FSP is CMSIS-compliant and is based on the CMSIS-core. Therefore, the board pack file structure is organized into folders containing the MCU and board specific CMSIS information and is represented as an XML-based pack description (PDSC) file as defined in the CMSIS standard (Keil, 2016). All these files are packed in a ZIP format (.zip).
BSP Contents in FSP
The contents of the BSP are as follows:
For example, the Renesas.RA_board_ra6m3_ek.1.0.0.pack has files as shown below in Figure 1.
Creating a Pack Based on an Existing Pack in FSP
The steps for creating a custom board pack from an existing RA board pack are given below.
Note: All the steps are described for BSP version 1.0.0. To create a BSP of a different versions, replace 1.0.0 in all the steps to the Major.Minor.Patch version.
1. Navigate to the \internal\projectgen\ra\Packs folder in the installed e2 studio or smart configurator (sc) as shown below. e2 studio and sc are installed in the RA folder by default. Board packs are listed in the packs folder as shown in Figure 1 above.
2. Find a pack with the same or similar device as the targeted MCU, such as ra6m1_ek, Renesas.RA_board_ra6m1_ek.1.0.0.pack.
3. Pick a board name for the new custom board, such as ra6m1_custom_board. Make sure to use the same name throughout the process.
4. Copy the board pack from step 3 and rename it with the new custom board name, such as Renesas.RA_board_ra6m1_custom_board.1.0.0.pack.
5. Extract the contents of this new pack file from a file archive utility, such as 7zip.
6. Replace the RA6M1-EK.pincfg file with the new board name, ra6m1_custom_board.pincfg.
7. In the \.module_descriptions folder, rename the XML files with the custom board name.
8. Modify the contents of XML files to replace all instances of the old board name with the new custom board name. Change RA6M1-EK.pincfg in Renesas##BSP##Board##ra6m1_custom_board####1.0.0##configuration.xml file to ra6m1_custom_board.pincfg.
9. Change all instances of ra6m1ek to custom_board in Renesas##BSP##Board##ra6m1_custom_board####1.0.0.xml file. Also, change the device attribute from R7FA6M1AD3CFP to new targeted device.
10. In \ra\board folder, rename the ra6m1_ek folder to ra6m1_custom_board. Add the custom BSP files, such as board.h, board_init.c, and board_init.h to the folder.
11. Rename the *.pdsc file in the root directory to the match the name of the BSP, Renesas.RA_board_ra6m1_custom_board.1.0.0.pdsc.
Note: The name of the .pdsc file must be the same as the .pack file for the pack to be detected by the configurator.
12. Modify the contents of the PDSC file:
 Replace the board name with the new board name
 Make sure there is a <file> element in the <component> for each file to be delivered as part of this pack.
13. Modify the contents of toolingSupport.xml. Rename all instances of ra6m1_ek to ra6m1_custom_board and RA6M1-EK.pincfg to ra6m1_custom_board.pincfg.
14. Select all files and folders, right click and create a zip file Renesas.RA_board_ra6m1_custom_board.1.0.0.zip
15. Rename the .zip file to Renesas.RA_board_ra6m1_ custom_board.1.0.0.pack.
Suitable Products
FSP
RA
Suitable Products
FSP
RA
Suitable Products
Suitable Products
FSP
RA","['data/categories/ra_family/rafsp_knowledge_base/8b406254447d6294eb0bf458a27d70db/images/dcee3dfea82ff061e5ae7bb86a413eb6.png', 'data/categories/ra_family/rafsp_knowledge_base/8b406254447d6294eb0bf458a27d70db/images/64bdc742c0ccdec6ed21a86506420b5a.png', 'data/categories/ra_family/rafsp_knowledge_base/8b406254447d6294eb0bf458a27d70db/images/0f9a3479af7c9c1ab854d98fb4b35fa7.png', 'data/categories/ra_family/rafsp_knowledge_base/8b406254447d6294eb0bf458a27d70db/images/827ca2fe9e3392c7c33d892c18f1816c.png']",[],['|  |\n|  |\n| FSP |\n| RA |'],"{'title': 'RA Family: Creating a Custom Board Support Package (BSP) for FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/19427072', 'last_updated': None, 'extracted_at': '2025-03-08T23:21:09.388484'}","Note that this article was written for FSP 1.1.0, but the process still works for FSP 3.7.0 and above. Introduction This article describes steps for creating a new custom Board Support Pack (BSP) for Renesas RA Flexible Software Package (FSP). Required Resources A PC running Microsoft Windows 10 with the following Renesas software installed Board Support Packs in FSP The Board Support Pack (BSP) is a subset of the Flexible Software Package (FSP), and provides an interface for setting up FSP to work with selected MCUs and specific board HW designs. It is both MCU and board specific. The BSPs for the Renesas RA Evaluation kits are included in FSP packs, but users must create new BSPs for implementing their final products. FSP is CMSIS-compliant and is based on the CMSIS-core. Therefore, the board pack file structure is organized into folders containing the MCU and board specific CMSIS information and is represented as an XML-based pack description (PDSC) file as defined in the CMSIS standard (Keil, 2016). All these files are packed in a ZIP format (.zip). BSP Contents in FSP The contents of the BSP are as follows For example, the Renesas.RAboardra6m3ek.1.0.0.pack has files as shown below in Figure 1. Creating a Pack Based on an Existing Pack in FSP The steps for creating a custom board pack from an existing RA board pack are given below. Note All the steps are described for BSP version 1.0.0. To create a BSP of a different versions, replace 1.0.0 in all the steps to the Major.Minor.Patch version. 1. Navigate to the internalprojectgenraPacks folder in the installed e2 studio or smart configurator (sc) as shown below. e2 studio and sc are installed in the RA folder by default. Board packs are listed in the packs folder as shown in Figure 1 above. 2. Find a pack with the same or similar device as the targeted MCU, such as ra6m1ek, Renesas.RAboardra6m1ek.1.0.0.pack. 3. Pick a board name for the new custom board, such as ra6m1customboard. Make sure to use the same name throughout the process. 4. Copy the board pack from step 3 and rename it with the new custom board name, such as Renesas.RAboardra6m1customboard.1.0.0.pack. 5. Extract the contents of this new pack file from a file archive utility, such as 7zip. 6. Replace the RA6M1-EK.pincfg file with the new board name, ra6m1customboard.pincfg. 7. In the .moduledescriptions folder, rename the XML files with the custom board name. 8. Modify the contents of XML files to replace all instances of the old board name with the new custom board name. Change RA6M1-EK.pincfg in RenesasBSPBoardra6m1customboard1.0.0configuration.xml file to ra6m1customboard.pincfg. 9. Change all instances of ra6m1ek to customboard in RenesasBSPBoardra6m1customboard1.0.0.xml file. Also, change the device attribute from R7FA6M1AD3CFP to new targeted device. 10. In raboard folder, rename the ra6m1ek folder to ra6m1customboard. Add the custom BSP files, such as board.h, boardinit.c, and boardinit.h to the folder. 11. Rename the .pdsc file in the root directory to the match the name of the BSP, Renesas.RAboardra6m1customboard.1.0.0.pdsc. Note The name of the .pdsc file must be the same as the .pack file for the pack to be detected by the configurator. 12. Modify the contents of the PDSC file  Replace the board name with the new board name  Make sure there is a file element in the component for each file to be delivered as part of this pack. 13. Modify the contents of toolingSupport.xml. Rename all instances of ra6m1ek to ra6m1customboard and RA6M1-EK.pincfg to ra6m1customboard.pincfg. 14. Select all files and folders, right click and create a zip file Renesas.RAboardra6m1customboard.1.0.0.zip 15. Rename the .zip file to Renesas.RAboardra6m1 customboard.1.0.0.pack. Suitable Products FSP RA",
26e99d82d80f5b7e37a867cc08724ba0,"Question:
If the finger contacts with the touch electrode at the time of power-on, the touch judgment will not be performed as expected afterwards. Why does this happen?
Answer:
In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of R_CSTU_ScanStart() and R_CTSU_DataGet() orseveral repetitions of RM_TOUCH_ScanStart() and RM_TOUCH_DataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards. 
In initial offset tuning, the amount of offset current is adjusted so that the measured count value without contact approaches the target value. This offset current is intended to control the count value due to the parasitic capacitance. The measured count value at the time of completion of the initial offset tuning is set as a reference value, and the touch ON/OFF is determined by the amount of change from this reference value.
If you touch the electrode during initial offset tuning, the offset current is adjusted so that the increase in capacitance caused by the finger contact is removed, and the measured count value with contact is set as the reference value. Since the measured count value required to be judged to be touch ON is higher with theself-capacitance method and lower with the mutual capacitance method by a threshold value than this reference value, if the reference value is set to the measured count value with contact, the amount of change from the reference value exceeds this threshold even if the finger connected the electrodes.
Since the reference value is readjusted by the drift correction function at intervals specified at the time of touch OFF judgment, touch ON/OFF judgment may be possible after a certain period of time has elapsed.
For details on offset current and drift correction, refer to the application note ""Capacitive Sensor Microcontrollers CTSU Capacitive Touch Introduction Guide"" (R30AN0424).
https://www.renesas.com/en/document/apn/capacitive-sensor-microcontrollers-ctsu-capacitive-touch-introduction-guide
Suitable Products
RA Family
If the finger contacts with the touch electrode at the time of power-on, the touch judgment will not be performed as expected afterwards. Why does this happen?
If the finger contacts with the touch electrode at the time of power-on, the touch judgment will not be performed as expected afterwards. Why does this happen?
Answer:
In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of R_CSTU_ScanStart() and R_CTSU_DataGet() orseveral repetitions of RM_TOUCH_ScanStart() and RM_TOUCH_DataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards. 
In initial offset tuning, the amount of offset current is adjusted so that the measured count value without contact approaches the target value. This offset current is intended to control the count value due to the parasitic capacitance. The measured count value at the time of completion of the initial offset tuning is set as a reference value, and the touch ON/OFF is determined by the amount of change from this reference value.
If you touch the electrode during initial offset tuning, the offset current is adjusted so that the increase in capacitance caused by the finger contact is removed, and the measured count value with contact is set as the reference value. Since the measured count value required to be judged to be touch ON is higher with theself-capacitance method and lower with the mutual capacitance method by a threshold value than this reference value, if the reference value is set to the measured count value with contact, the amount of change from the reference value exceeds this threshold even if the finger connected the electrodes.
Since the reference value is readjusted by the drift correction function at intervals specified at the time of touch OFF judgment, touch ON/OFF judgment may be possible after a certain period of time has elapsed.
For details on offset current and drift correction, refer to the application note ""Capacitive Sensor Microcontrollers CTSU Capacitive Touch Introduction Guide"" (R30AN0424).
https://www.renesas.com/en/document/apn/capacitive-sensor-microcontrollers-ctsu-capacitive-touch-introduction-guide
Suitable Products
RA Family
In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of R_CSTU_ScanStart() and R_CTSU_DataGet() orseveral repetitions of RM_TOUCH_ScanStart() and RM_TOUCH_DataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards. 
In initial offset tuning, the amount of offset current is adjusted so that the measured count value without contact approaches the target value. This offset current is intended to control the count value due to the parasitic capacitance. The measured count value at the time of completion of the initial offset tuning is set as a reference value, and the touch ON/OFF is determined by the amount of change from this reference value.
If you touch the electrode during initial offset tuning, the offset current is adjusted so that the increase in capacitance caused by the finger contact is removed, and the measured count value with contact is set as the reference value. Since the measured count value required to be judged to be touch ON is higher with theself-capacitance method and lower with the mutual capacitance method by a threshold value than this reference value, if the reference value is set to the measured count value with contact, the amount of change from the reference value exceeds this threshold even if the finger connected the electrodes.
Since the reference value is readjusted by the drift correction function at intervals specified at the time of touch OFF judgment, touch ON/OFF judgment may be possible after a certain period of time has elapsed.
For details on offset current and drift correction, refer to the application note ""Capacitive Sensor Microcontrollers CTSU Capacitive Touch Introduction Guide"" (R30AN0424).
https://www.renesas.com/en/document/apn/capacitive-sensor-microcontrollers-ctsu-capacitive-touch-introduction-guide
In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of R_CSTU_ScanStart() and R_CTSU_DataGet() orseveral repetitions of RM_TOUCH_ScanStart() and RM_TOUCH_DataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards.
In initial offset tuning, the amount of offset current is adjusted so that the measured count value without contact approaches the target value. This offset current is intended to control the count value due to the parasitic capacitance. The measured count value at the time of completion of the initial offset tuning is set as a reference value, and the touch ON/OFF is determined by the amount of change from this reference value.
If you touch the electrode during initial offset tuning, the offset current is adjusted so that the increase in capacitance caused by the finger contact is removed, and the measured count value with contact is set as the reference value. Since the measured count value required to be judged to be touch ON is higher with theself-capacitance method and lower with the mutual capacitance method by a threshold value than this reference value, if the reference value is set to the measured count value with contact, the amount of change from the reference value exceeds this threshold even if the finger connected the electrodes.
Since the reference value is readjusted by the drift correction function at intervals specified at the time of touch OFF judgment, touch ON/OFF judgment may be possible after a certain period of time has elapsed.
For details on offset current and drift correction, refer to the application note ""Capacitive Sensor Microcontrollers CTSU Capacitive Touch Introduction Guide"" (R30AN0424).
https://www.renesas.com/en/document/apn/capacitive-sensor-microcontrollers-ctsu-capacitive-touch-introduction-guide
Suitable Products
RA Family
Japanese
Japanese",['data/categories/ra_family/capacitive_touch/26e99d82d80f5b7e37a867cc08724ba0/images/2c67f540edc8a2bebd924a5ae2ff41bc.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: If the finger contacts with the touch electrode at the time of power-on, the touch judgment will not be performed as expected afterwards.', 'url': 'https://en-support.renesas.com/knowledgeBase/21810980', 'last_updated': None, 'extracted_at': '2025-03-08T23:34:36.153583'}","Question If the finger contacts with the touch electrode at the time of power-on, the touch judgment will not be performed as expected afterwards. Why does this happen? Answer In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of RCSTUScanStart() and RCTSUDataGet() or several repetitions of RMTOUCHScanStart() and RMTOUCHDataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards. In initial offset tuning, the amount of offset current is adjusted so that the measured count value without contact approaches the target value. This offset current is intended to control the count value due to the parasitic capacitance. The measured count value at the time of completion of the initial offset tuning is set as a reference value, and the touch ON/OFF is determined by the amount of change from this reference value. If you touch the electrode during initial offset tuning, the offset current is adjusted so that the increase in capacitance caused by the finger contact is removed, and the measured count value with contact is set as the reference value. Since the measured count value required to be judged to be touch ON is higher with theself-capacitance method and lower with the mutual capacitance method by a threshold value than this reference value, if the reference value is set to the measured count value with contact, the amount of change from the reference value exceeds this threshold even if the finger connected the electrodes. Since the reference value is readjusted by the drift correction function at intervals specified at the time of touch OFF judgment, touch ON/OFF judgment may be possible after a certain period of time has elapsed. For details on offset current and drift correction, refer to the application note ""Capacitive Sensor Microcontrollers CTSU Capacitive Touch Introduction Guide"" (R30AN0424). https//www.renesas.com/en/document/apn/capacitive-sensor-microcontrollers-ctsu-capacitive-touch-introduction-guide Suitable Products RA Family In the RA Family FSP CTSU Driver, in order to suppress false detection caused by fluctuations in parasitic capacitance that depends on the product usage environment, after MCU reset and performing the open function, initial offset tuning is performed in several repetitions of RCSTUScanStart() and RCTSUDataGet() or several repetitions of RMTOUCHScanStart() and RMTOUCHDataGet(). If you touch the electrodes during this initial offset tuning period, it will affect the touch judgment behavior afterwards. Japanese",
bf7caff33b899d2bc42a5e175ce36cc9,"Question:
I am trying to perform the serial communication monitor that is provided by QE for Capacitive Touch. I wrote a capacitive touch application for the RA MCU and executed it, but the error message ""Failed to connect to the serial port."" is displayed and monitoring cannot be started. Are there any possible causes?
Answer:
1. In the program's configurator settings, the serial connection monitor is disabled.
Check if the Touch Middleware (rm_touch) properties > Common > ""Support for QE monitoring using UART"" is set to ""Enabled"".
2. In the program's configurator settings, the UART driver module for QE monitoring is not set properly.
Check if the UART driver module (r_sci_uart) is added under the Touch middleware block.
Check the Pins tab to see if any pins are assigned to the UART function pins used in the UART driver (g_uart_qe). It is possible to check the allocation status of the UART driver (g_uart_qe) properties > Pins > TXDn/RXDn.
Check if the baud rate set in the UART driver (g_uart_qe) properties > Module g_uart_qe UART (r_sci_uart) > Baud > Baud Rate and the Baud rate set in the CapTouch workflow in QE for Capacitive Touch match.
3. The program written to the MCU stopped.
This may be due to the state of the previous debug connection. After physically disconnecting the debugger, power cycle the evaluation board, then check if the serial connection is successful.
The program may not be executed as expected due to software implementation errors. Use the debugger to see where the program stops and fix the problem.
Suitable Products
RA Family
I am trying to perform the serial communication monitor that is provided by QE for Capacitive Touch. I wrote a capacitive touch application for the RA MCU and executed it, but the error message ""Failed to connect to the serial port."" is displayed and monitoring cannot be started. Are there any possible causes?
I am trying to perform the serial communication monitor that is provided by QE for Capacitive Touch. I wrote a capacitive touch application for the RA MCU and executed it, but the error message ""Failed to connect to the serial port."" is displayed and monitoring cannot be started. Are there any possible causes?
Answer:
1. In the program's configurator settings, the serial connection monitor is disabled.
Check if the Touch Middleware (rm_touch) properties > Common > ""Support for QE monitoring using UART"" is set to ""Enabled"".
2. In the program's configurator settings, the UART driver module for QE monitoring is not set properly.
Check if the UART driver module (r_sci_uart) is added under the Touch middleware block.
Check the Pins tab to see if any pins are assigned to the UART function pins used in the UART driver (g_uart_qe). It is possible to check the allocation status of the UART driver (g_uart_qe) properties > Pins > TXDn/RXDn.
Check if the baud rate set in the UART driver (g_uart_qe) properties > Module g_uart_qe UART (r_sci_uart) > Baud > Baud Rate and the Baud rate set in the CapTouch workflow in QE for Capacitive Touch match.
3. The program written to the MCU stopped.
This may be due to the state of the previous debug connection. After physically disconnecting the debugger, power cycle the evaluation board, then check if the serial connection is successful.
The program may not be executed as expected due to software implementation errors. Use the debugger to see where the program stops and fix the problem.
Suitable Products
RA Family
1. In the program's configurator settings, the serial connection monitor is disabled.
Check if the Touch Middleware (rm_touch) properties > Common > ""Support for QE monitoring using UART"" is set to ""Enabled"".
2. In the program's configurator settings, the UART driver module for QE monitoring is not set properly.
Check if the UART driver module (r_sci_uart) is added under the Touch middleware block.
Check the Pins tab to see if any pins are assigned to the UART function pins used in the UART driver (g_uart_qe). It is possible to check the allocation status of the UART driver (g_uart_qe) properties > Pins > TXDn/RXDn.
Check if the baud rate set in the UART driver (g_uart_qe) properties > Module g_uart_qe UART (r_sci_uart) > Baud > Baud Rate and the Baud rate set in the CapTouch workflow in QE for Capacitive Touch match.
3. The program written to the MCU stopped.
This may be due to the state of the previous debug connection. After physically disconnecting the debugger, power cycle the evaluation board, then check if the serial connection is successful.
The program may not be executed as expected due to software implementation errors. Use the debugger to see where the program stops and fix the problem.
1. In the program's configurator settings, the serial connection monitor is disabled.
2. In the program's configurator settings, the UART driver module for QE monitoring is not set properly.
3. The program written to the MCU stopped.
Suitable Products
RA Family
Japanese
Japanese","['data/categories/ra_family/capacitive_touch/bf7caff33b899d2bc42a5e175ce36cc9/images/726184cc9c92dcf112663f9a14ce352f.png', 'data/categories/ra_family/capacitive_touch/bf7caff33b899d2bc42a5e175ce36cc9/images/d68004df3def89855c39b641341bf6f1.png', 'data/categories/ra_family/capacitive_touch/bf7caff33b899d2bc42a5e175ce36cc9/images/1a8c7caeeb656cea0d17ee318247b685.png', 'data/categories/ra_family/capacitive_touch/bf7caff33b899d2bc42a5e175ce36cc9/images/d7abdd49f019a654bfe3ecee256cbae9.png']",[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: The serial communication monitor that is provided by QE for Capacitive Touch, Development Assistance Tool for Capacitive Touch sensors, fails to start.', 'url': 'https://en-support.renesas.com/knowledgeBase/21810981', 'last_updated': None, 'extracted_at': '2025-03-08T23:34:44.725145'}","Question I am trying to perform the serial communication monitor that is provided by QE for Capacitive Touch. I wrote a capacitive touch application for the RA MCU and executed it, but the error message ""Failed to connect to the serial port."" is displayed and monitoring cannot be started. Are there any possible causes? Answer 1. In the program's configurator settings, the serial connection monitor is disabled. Check if the Touch Middleware (rmtouch) properties  Common  ""Support for QE monitoring using UART"" is set to ""Enabled"". 2. In the program's configurator settings, the UART driver module for QE monitoring is not set properly. Check if the UART driver module (rsciuart) is added under the Touch middleware block. Check the Pins tab to see if any pins are assigned to the UART function pins used in the UART driver (guartqe). It is possible to check the allocation status of the UART driver (guartqe) properties  Pins  TXDn/RXDn. Check if the baud rate set in the UART driver (guartqe) properties  Module guartqe UART (rsciuart)  Baud  Baud Rate and the Baud rate set in the CapTouch workflow in QE for Capacitive Touch match. 3. The program written to the MCU stopped. This may be due to the state of the previous debug connection. After physically disconnecting the debugger, power cycle the evaluation board, then check if the serial connection is successful. The program may not be executed as expected due to software implementation errors. Use the debugger to see where the program stops and fix the problem. Suitable Products RA Family Japanese",
40375ca0f5a008a568e9fa5b7f1bccbd,"Last updated: 22/03/2024
Why are UART channel 1 pins P212 and P213 not working ?
The pins P212 and P213 are used as external clock oscillator pins (XTAL/EXTAL pins) so they cannot be used from SCI UART channel 1 in the same time. If you want to use them as SCI channel 1 pins, you need to have a clock source different than XTAL. Please change accordingly on Clocks tab (you can change PLL source or clock source itself):
A new blank project by default is using XTAL as clock source which is already on the EK-RA6M2.",['data/categories/ra_family/serial_communications_interface_(sci)/40375ca0f5a008a568e9fa5b7f1bccbd/images/4394c1e6fb557a06c886fa6c3937a557.png'],[],[],"{'title': 'RA Family: Why are UART channel 1 pins P212 and P213 not working ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21287506', 'last_updated': None, 'extracted_at': '2025-03-08T23:38:24.206366'}","Last updated 22/03/2024 Why are UART channel 1 pins P212 and P213 not working ? The pins P212 and P213 are used as external clock oscillator pins (XTAL/EXTAL pins) so they cannot be used from SCI UART channel 1 in the same time. If you want to use them as SCI channel 1 pins, you need to have a clock source different than XTAL. Please change accordingly on Clocks tab (you can change PLL source or clock source itself) A new blank project by default is using XTAL as clock source which is already on the EK-RA6M2.",
ec8377046d706760bccb9769c339b0b2,"Question:
In the RA MCU Users Manual: Hardware, the following explanation of capacitor connection is required. If the ADC or DAC in the RA MCU is not used, is it necessary to connect capacitors to the following pins?
(1) Analog power pins: between AVCC0 and AVSS0
(2) Analog reference voltage pins: between VREFH0 and VREFL0
(3) Analog reference voltage pins: between VREFH and VREFL
Answer:
If you dont utilize the ADCs and DACs inside the RA MCU, you dont need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
between AVCC0 and AVSS0
A 0.1F capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors shown as *1 in the above figure are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry.
between VREFH0 and VREFL0
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 0) is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU
between VREFH and VREFL
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 1) or DAC is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU.
Suitable Products
RA Family
In the RA MCU Users Manual: Hardware, the following explanation of capacitor connection is required. If the ADC or DAC in the RA MCU is not used, is it necessary to connect capacitors to the following pins?
(1) Analog power pins: between AVCC0 and AVSS0
(2) Analog reference voltage pins: between VREFH0 and VREFL0
(3) Analog reference voltage pins: between VREFH and VREFL
In the RA MCU Users Manual: Hardware, the following explanation of capacitor connection is required. If the ADC or DAC in the RA MCU is not used, is it necessary to connect capacitors to the following pins?
(1) Analog power pins: between AVCC0 and AVSS0
(1) Analog power pins: between AVCC0 and AVSS0
(1) Analog power pins: between
AVCC0
and
AVSS0
(2) Analog reference voltage pins: between VREFH0 and VREFL0
(2) Analog reference voltage pins: between VREFH0 and VREFL0
(2) Analog reference voltage pins: between
VREFH0
and
VREFL0
(3) Analog reference voltage pins: between VREFH and VREFL
(3) Analog reference voltage pins: between VREFH and VREFL
(3)
Analog reference voltage pins: between
VREFH
and
VREFL
Answer:
If you dont utilize the ADCs and DACs inside the RA MCU, you dont need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
between AVCC0 and AVSS0
A 0.1F capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors shown as *1 in the above figure are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry.
between VREFH0 and VREFL0
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 0) is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU
between VREFH and VREFL
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 1) or DAC is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU.
Suitable Products
RA Family
If you dont utilize the ADCs and DACs inside the RA MCU, you dont need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
between AVCC0 and AVSS0
A 0.1F capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors shown as *1 in the above figure are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry.
between VREFH0 and VREFL0
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 0) is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU
between VREFH and VREFL
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 1) or DAC is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU.
If you dont utilize the ADCs and DACs inside the RA MCU, you dont need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
If you dont utilize the ADCs and DACs inside the RA MCU, you dont need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
If you dont utilize the ADCs and DACs inside the RA MCU, you dont need some of the bypass capacitors specified for the analog power pins.
The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary.
between AVCC0 and AVSS0
A 0.1F capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors shown as *1 in the above figure are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry.
between
AVCC0
and
AVSS0

F capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors
*
are not required
if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry.
between VREFH0 and VREFL0
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 0) is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU
between
VREFH0
and
VREFL0
between VREFH and VREFL
The capacitor shown as *1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 1) or DAC is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU.
between
VREFH
and
VREFL
Suitable Products
RA Family

",['data/categories/ra_family/ad_converter/ec8377046d706760bccb9769c339b0b2/images/11951266f8acbc9564a59338c81a8045.png'],[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: Necessity of connecting capacitors for analog power supplies and reference voltage pins', 'url': 'https://en-support.renesas.com/knowledgeBase/21727829', 'last_updated': None, 'extracted_at': '2025-03-08T23:34:03.982410'}","Question In the RA MCU Users Manual Hardware, the following explanation of capacitor connection is required. If the ADC or DAC in the RA MCU is not used, is it necessary to connect capacitors to the following pins? (1) Analog power pins between AVCC0 and AVSS0 (2) Analog reference voltage pins between VREFH0 and VREFL0 (3) Analog reference voltage pins between VREFH and VREFL Answer If you dont utilize the ADCs and DACs inside the RA MCU, you dont need some of the bypass capacitors specified for the analog power pins. The capacitors for each analog power supply pin are used for the following purposes. Please refer to this information and judge whether or not the target capacitor is necessary. between AVCC0 and AVSS0 A 0.1F capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors shown as 1 in the above figure are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry. between VREFH0 and VREFL0 The capacitor shown as 1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 0) is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU between VREFH and VREFL The capacitor shown as 1 in the above figure and the 0.1uF capacitor are not required if the ADC (Unit 1) or DAC is not in use. Capacitors are used when it is necessary to improve the quality of the analog circuitry inside the MCU. Suitable Products RA Family (1) Analog power pins between AVCC0 and AVSS0 (2) Analog reference voltage pins between VREFH0 VREFL0 (3) Analog reference voltage pins between VREFH VREFL between  F capacitor is always required. This capacitor is used not only a bypass capacitor for ADC or DAC but also the bypass capacitor for Port0 IO power supply. The capacitors  are not required if ADC/DAC is not used. These capacitors are used when there is a need to improve the quality of the MCU's internal analog circuitry. ",
cb2f721cbff9e33e23869ed649dcce87,"This post applies to AC 6.17. Refer to the companion post for AC 6.16 and earlier here: https://en-support.renesas.com/knowledgeBase/19375553
1) Arm Compiler v6.17 will not be automatically detected when attempting to register the toolchain with e2 studio 2021-10 and earlier. Earlier Arm Compiler v6 versions are recognized.
2) When creating a new project the commands related to the compiler, assembler and linker are missing by default in the project settings.
1) Registration Issue
When attempting to register an error like the one below will be shown.
Workaround
The toolchain can be registered in the same dialog by manually entering in the information. Click Next from the dialog shown in the image above. On the next screen enter the information as shown in the image below. When done click Finish. e2 studio will request to be restarted. Once restarted, you will be able to create projects using the newly registered toolchain.
2) Compiler, Assembler and Linker Issue
When a user creates a new project with Arm compiler 6.17 and E2 studio, the commands related to the compiler, assembler are linker are missing by default in project settings.
This is resulting in failure to create binary with following error, please refer below image.
Workaround:
Add the compiler, assembler and linker commands in the project settings command window as listed below.
Example for the Compiler is shown below. Add the commands for Assembler and Linker too.
Suitable Products
e2studio and ARM Compiler for RA
  https://github.com/renesas/fsp/issues/154
Suitable Products
e2studio and ARM Compiler for RA
  https://github.com/renesas/fsp/issues/154
Suitable Products
e2studio and ARM Compiler for RA
  https://github.com/renesas/fsp/issues/154
Suitable Products
e2studio and ARM Compiler for RA
  https://github.com/renesas/fsp/issues/154
https://github.com/renesas/fsp/issues/154","['data/categories/ra_family/ra_and_fsp_technical_articles/cb2f721cbff9e33e23869ed649dcce87/images/b8599d7cb5f511020372f9bf11099e36.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/cb2f721cbff9e33e23869ed649dcce87/images/9569f85960de9aaeb39419cc51b727b2.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/cb2f721cbff9e33e23869ed649dcce87/images/cbc20504c966eb8f46f4c3d644403b37.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/cb2f721cbff9e33e23869ed649dcce87/images/87be0c4e6c38b041fc1d502b074869bc.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/cb2f721cbff9e33e23869ed649dcce87/images/bd478401771475c8f45b56e4cca4fb8f.png']",[],['|  |\n|  |\n| e2studio and ARM Compiler for RA |'],"{'title': 'Creating an RA Project with ARM Compiler 6.17 in e2 studio', 'url': 'https://en-support.renesas.com/knowledgeBase/20370421', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:23.201892'}","This post applies to AC 6.17. Refer to the companion post for AC 6.16 and earlier here https//en-support.renesas.com/knowledgeBase/19375553 1) Arm Compiler v6.17 will not be automatically detected when attempting to register the toolchain with e2 studio 2021-10 and earlier. Earlier Arm Compiler v6 versions are recognized. 2) When creating a new project the commands related to the compiler, assembler and linker are missing by default in the project settings. 1) Registration Issue When attempting to register an error like the one below will be shown. Workaround The toolchain can be registered in the same dialog by manually entering in the information. Click Next from the dialog shown in the image above. On the next screen enter the information as shown in the image below. When done click Finish. e2 studio will request to be restarted. Once restarted, you will be able to create projects using the newly registered toolchain. 2) Compiler, Assembler and Linker Issue When a user creates a new project with Arm compiler 6.17 and E2 studio, the commands related to the compiler, assembler are linker are missing by default in project settings. This is resulting in failure to create binary with following error, please refer below image. Workaround Add the compiler, assembler and linker commands in the project settings command window as listed below. Example for the Compiler is shown below. Add the commands for Assembler and Linker too. Suitable Products e2studio and ARM Compiler for RA https//github.com/renesas/fsp/issues/154 https//github.com/renesas/fsp/issues/154",
c565d516b95fcb0d4d8e89daf02b17b3,"Question:
How do I find the right crystals for RA MCUs?
Question:
How do I find the right crystals for RA MCUs?
How do I find the right crystals for RA MCUs?
Answer:
You can find the crystals you need for the sub-clock resonators on RA MCUs from the crystal manufacturers web site here:
https://global.kyocera.com/prdct/electro/product/crystal-device/xtal/  
Simply click on the search tool:
  And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page.
See below for RA2 series other than RA2A1.
https://www.sii.co.jp/en/quartz/news/topics/2021/12/06/1678/
Suitable Products
Answer:
You can find the crystals you need for the sub-clock resonators on RA MCUs from the crystal manufacturers web site here:
https://global.kyocera.com/prdct/electro/product/crystal-device/xtal/  
Simply click on the search tool:
  And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page.
See below for RA2 series other than RA2A1.
https://www.sii.co.jp/en/quartz/news/topics/2021/12/06/1678/
Suitable Products
You can find the crystals you need for the sub-clock resonators on RA MCUs from the crystal manufacturers web site here:
https://global.kyocera.com/prdct/electro/product/crystal-device/xtal/
You can find the crystals you need for the sub-clock resonators on RA MCUs from the crystal manufacturers web site here:
https://global.kyocera.com/prdct/electro/product/crystal-device/xtal/
Simply click on the search tool:
Simply click on the search tool:
And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page.
And then
using a search with
Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page.
See below for RA2 series other than RA2A1.
https://www.sii.co.jp/en/quartz/news/topics/2021/12/06/1678/
Suitable Products
RA2 Series
RA4 Series
RA6 Series",['data/categories/ra_family/ra_and_fsp_technical_articles/c565d516b95fcb0d4d8e89daf02b17b3/images/95b01bd0387d8a076515fa62281af95f.png'],[],['|  |\n|  |\n| RA2 Series\nRA4 Series\nRA6 Series |'],"{'title': 'Finding the right crystals for RA MCUs', 'url': 'https://en-support.renesas.com/knowledgeBase/19558422', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:37.432764'}",Question How do I find the right crystals for RA MCUs? Answer You can find the crystals you need for the sub-clock resonators on RA MCUs from the crystal manufacturers web site here https//global.kyocera.com/prdct/electro/product/crystal-device/xtal/ Simply click on the search tool And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page. See below for RA2 series other than RA2A1. https//www.sii.co.jp/en/quartz/news/topics/2021/12/06/1678/ Suitable Products https//global.kyocera.com/prdct/electro/product/crystal-device/xtal/ And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page. And then using a search with Renesas as the IC Manufacturer and the desired RA Series as the IC Family. The recommended Crystals will show up at the bottom of the page. RA2 Series RA4 Series RA6 Series,
a4d0626f190549bfa06956a8362711c3,"Issue
Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run. 
Example of copy command failing:
Solution:
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
    e2studio
FSP
Source: RAP-1819
Issue
Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run. 
Example of copy command failing:
Solution:
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
    e2studio
FSP
Source: RAP-1819
Issue
Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run.
Issue
Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run.
Example of copy command failing:
Example of copy command failing:
Solution:
Solution:
Solution:
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
Use Linux commands instead. For example, Changing del => rm, and copy => cp should allow the build to complete without these error messages from the pre-build step.
e2studio
FSP
Source: RAP-1819
Source: RAP-1819",['data/categories/ra_family/ra_and_fsp_technical_articles/a4d0626f190549bfa06956a8362711c3/images/62d3c1926a2e9d408c6c6bf3ffe992a9.png'],[],['|  |\n|  |\n| e2studio |\n| FSP |'],"{'title': 'RA Family: Windows System Commands Fail to Run from e2studio from the Build Steps Option in FSP 3.7.0 and Later', 'url': 'https://en-support.renesas.com/knowledgeBase/20554960', 'last_updated': '2022-10-06', 'extracted_at': '2025-03-08T23:11:55.741946'}","Issue Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run. Example of copy command failing Solution Use Linux commands instead. For example, Changing del  rm, and copy  cp should allow the build to complete without these error messages from the pre-build step. e2studio FSP Source RAP-1819 Windows Systems Commands don't run in FSP 3.7.0 and later (will fail), but Linux System Commands will run. e2studio",
552055185b9e9f12bcf6895e2ab92511,"Issues
1) Even though the Ethernet Link is up successfully, the RA6E1/M4/M5 device may not respond to the ICMP echo request (PING). 
2) Even though the Ethernet Link is up successfully, no signal is output through MII/RMII TXDs pins of MCU.
  Description:
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the Users Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error. 
  Solution:
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customers board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the users external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
      Figure 1 - Snippet code from the fsp.ld file 
    Figure 2 - Snippet code from the ra_gen/common_data.c 
 
   Figure 3  Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
 
  Figure 4  Setup TrustZone Partition via RFP- Boundary Settings
  EDMAC
FSP
Issues
1) Even though the Ethernet Link is up successfully, the RA6E1/M4/M5 device may not respond to the ICMP echo request (PING). 
2) Even though the Ethernet Link is up successfully, no signal is output through MII/RMII TXDs pins of MCU.
  Description:
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the Users Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error. 
  Solution:
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customers board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the users external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
      Figure 1 - Snippet code from the fsp.ld file 
    Figure 2 - Snippet code from the ra_gen/common_data.c 
 
   Figure 3  Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
 
  Figure 4  Setup TrustZone Partition via RFP- Boundary Settings
  EDMAC
FSP
Issues
1) Even though the Ethernet Link is up successfully, the RA6E1/M4/M5 device may not respond to the ICMP echo request (PING). 
2) Even though the Ethernet Link is up successfully, no signal is output through MII/RMII TXDs pins of MCU.
Issues
1) Even though the Ethernet Link is up successfully, the RA6E1/M4/M5 device may not respond to the ICMP echo request (PING). 
2) Even though the Ethernet Link is up successfully, no signal is output through MII/RMII TXDs pins of MCU.
Description:
Description:
Description:
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the Users Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error.
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the Users Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error.
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the Users Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error.
The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the Users Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area.  Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF = 1) error of will be received. For Ethernet frame transmission, the operation FSP R_ETHER_Write() will return the transmit buffer full error.
receive frame counter overflow (EESR.RFCOF = 1)
receive frame counter overflow (EESR.RFCOF = 1)
receive frame counter overflow (EESR.RFCOF = 1)
transmit buffer full
transmit buffer full
transmit buffer full
Solution:
Solution:
Solution:
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customers board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customers board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customers board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a ns_buffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customers board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the users external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the users external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the users external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the users external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example).
Figure 1 - Snippet code from the fsp.ld file
Figure 1 - Snippet code from the fsp.ld file
Figure 1 - Snippet code from the fsp.ld file
Figure 1 - Snippet code from the
fsp.ld
file
Figure 2 - Snippet code from the ra_gen/common_data.c
Figure 2 - Snippet code from the ra_gen/common_data.c
Figure 2 - Snippet code from the ra_gen/common_data.c
Figure 2 - Snippet code from the
ra_gen
/
common_data.c
Figure 3  Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
Figure 3  Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
Figure 3  Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
Figure 3  Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes
Figure 4  Setup TrustZone Partition via RFP- Boundary Settings
Figure 4  Setup TrustZone Partition via RFP- Boundary Settings
Figure 4  Setup TrustZone Partition via RFP- Boundary Settings
Figure 4 
Setup
TrustZone Partition
via RFP- Boundary Settings
EDMAC
FSP","['data/categories/ra_family/ra_and_fsp_technical_articles/552055185b9e9f12bcf6895e2ab92511/images/cc80e2638fda428468acd962f5837319.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/552055185b9e9f12bcf6895e2ab92511/images/cf1a104003a42ffa58d4fd192578ab52.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/552055185b9e9f12bcf6895e2ab92511/images/ec75bac187c5db1c36be76ae6a27618d.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/552055185b9e9f12bcf6895e2ab92511/images/3fb8645eaba201fccd554a58753fd051.png']",[],['|  |\n|  |\n| EDMAC |\n| FSP |'],"{'title': 'EDMAC operation issue possible on custom RA6E1/M4/M5 board', 'url': 'https://en-support.renesas.com/knowledgeBase/20540134', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:11.022517'}","Issues 1) Even though the Ethernet Link is up successfully, the RA6E1/M4/M5 device may not respond to the ICMP echo request (PING). 2) Even though the Ethernet Link is up successfully, no signal is output through MII/RMII TXDs pins of MCU. Description The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the Users Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area. Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF  1) error of will be received. For Ethernet frame transmission, the operation FSP RETHERWrite() will return the transmit buffer full error. Solution In the RA Flat (secure) project, the default linker file for Renesas FSP (fsp.ld, as shown in Figure 1 below) reserves a nsbuffer section (as shown in Figure 2 below) in non-secure region of RAM for placing the Ethernet buffer. Therefore, the RA serial boot interface (SCI/USB Boot Mode) needs to be available on the customers board in order to program the IDAU register to setup the Renesas RA TrustZone boundaries, which allocate the proper size of non-secure memory partition to RAM. For debugging the flat project, the user needs to confirm that the external debug probe supports the serial boot connection and interaction on the RA6E1/M4/M5, and the TrustZone secure/non-secure boundaries of the debugger connection settings must be set (as seen below in Figure 3). For the hardware connection design of the external debug probe, the P110/RXD9, P109/TXD9, MD, RES pins from MCU are required except on the SWD interface. If the users external debug probe hardware does not support the serial boot connection, the user can utilize the RFP (Renesas Flash Programmer) to program the IDAU register through the RA serial boot interface as well (below Figure 4 as an example). Figure 1 - Snippet code from the fsp.ld file Figure 2 - Snippet code from the ragen/commondata.c Figure 3  Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes Figure 4  Setup TrustZone Partition via RFP- Boundary Settings EDMAC FSP Description The ETHERC (Ethernet MAC Controller) is connected to the EDMAC (Ethernet DMA Controller) so data can be transferred without using the CPU. However, for the MCU with EDMAC and TrustZone support, the EDMAC peripheral can only be configured with the non-secure attribute, which is described by the Peripheral Security Attribution section in the Users Manual. Therefore, the EDMAC on these target devices always requires the non-secure buffers in non-secure attributed RAM area. Without satisfying this condition, the Ethernet operation will encounter a memory address error, since the address that the EDMAC tried to use for the transfer is invalid. This issue can be indicated by the Address Error (ADE) flag in EDMAC Status Register and the TrustZone Filter Error Status (TZFST) Flag in NMISR. Followed by this error, for Ethernet frame reception, the receive frame counter overflow (EESR.RFCOF  1) error of will be received. For Ethernet frame transmission, the operation FSP RETHERWrite() will return the transmit buffer full error. receive frame counter overflow (EESR.RFCOF  1) transmit buffer full Solution Figure 1 - Snippet code from the fsp.ld file Figure 1 - Snippet code from the fsp.ld file Figure 2 - Snippet code from the ragen/commondata.c Figure 2 - Snippet code from the ragen / commondata.c Figure 3  Debugger Connection Settings- TrustZone secure/non-secure boundaries, Yes Figure 4  Setup TrustZone Partition via RFP- Boundary Settings Figure 4  Setup TrustZone Partition via RFP- Boundary Settings EDMAC",
d5835ab1490b2c4dd0539f7090b90aff,"Issue:
AppWizard is the Segger emWin provided PC software that makes GUI building and embedded software programming easier for developers. Sometimes, what you want to achieve cannot be all done by AppWizard, so changes need to be made at the source code level with emWin API.
Description:
There are two types of emWin APIs, one is AppWizard APIs and the other is conventional emWin APIs. AppWizard APIs and conventional emWin APIs generally work the same but AppWizard APIs are a more general form that can be used all across the objects. Since some AppWizard APIs are still undocumented, we will use conventional emWin API in this document.
AppWizard APIs are listed in AppWizard.h
Core emWin APIs are listed in GUI.h and WM.h
Widgets emWin APIs are listed in each widget header files like TEXT.h, BUTTON.h, ROTARY.h, and so on.
Answers:
Change TEXT when button is pressed (TEXT moves along when screen swipe)
If you have a TEXT widget that does not know what to print out at build time but make up a word or sentence at runtime when BUTTON is pressed, then the text in TEXT widget can be changed dynamically with the following code. The figures below show that the text of TEXT changes when the button is pressed, and the position of TEXT also changes when the screen is swiped.
           If you have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, ID_TEXT_00);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
default:
      //WM_DefaultProc(); --> Screen callback MUST not have default function handler
      break;  }
}
  If you dont have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
        hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->hWin, WM_CF_SHOW, 0, GUI_ID_TEXT0, ""HI"");
      break;
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
    default:
      //WM_DefaultProc(); --> Screen callback MUST not have default function handler
      break;
  }
}
  GUI user interface
There is no direct user interface APIs, for example, for a BUTTON widget to change from unpressed to pressed state. The only way to change the BUTTON to the pressed state is to deliver a keyboard or PID message to the BUTTON, and the message to be processed in a callback function. Keyboard input is delivered in GUI_StoreKeyMsg(), and PID input is delivered in GUI_PID_StoreState(). The example below shows how to make a push button IRQ interrupt act like the Enter key was pressed on BUTTON. Please note that BUTTON widget reacts to keyboard input differently than PID input. For example, keyboard Enter press on BUTTON widget generates both press and release messages in turn at once.
void external_irq_callback (void)
{
WM_HWIN hWin;
WM_HWIN hItem;
    hWin = WM_GetActiveWindow();
  hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);
  WIDGET_SetFocusable(hItem,1);
  WM_SetFocus(hItem);
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 1); /* Pressed */
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 0); /* Release */
}
      It would be also possible to make a button press act like touch/mouse swipe.
GUI_PID_STATE swipe_state;
void external_irq_callback (void)
{
swipe_state.x = x_position;
swipe_state.y = y_position;
swipe_state.Pressed = 1;
  GUI_PID_StoreState(&swipe_state);
  x_position += x_position_increment;
  if(x_position >= x_position_max){
    swipe_state.Pressed = 0;
    GUI_PID_StoreState(&swipe_state);
}
}
  Custom drawing on top
If you need to do some custom drawing on top and stay on top, you can make a child window of WM_HBKWIN and set the StayOnTop flag. A window is created with the given x, y coordinate and size, and a custom user callback function pointer. In the callback function, WM_PAINT is where the user is allowed to do some custom drawing. MEMDEV is a temporary drawing place used for anti-flicker, image decompression, scaling & rotating, animation, and so on. For more details on MEMDEV, please refer to the emWin manual. The example below draws one line from (0,0) to (100,100) and stays on top during/after screen swiping.
static void _cbTopWin(WM_MESSAGE * pMsg) {
GUI_MEMDEV_Handle hMem;
    switch (pMsg->MsgId) {
    case WM_PAINT:
      hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);
      GUI_MEMDEV_Select(hMem);
      GUI_SetColor(GUI_BLACK);
      for(uint32_t i=0; i<100; i++){
        GUI_DrawPixel(i, i);
      }
      GUI_MEMDEV_CopyToLCD(hMem);
      GUI_MEMDEV_Delete(hMem);
      GUI_MEMDEV_Select(0);
      break;
    default:
      WM_DefaultProc(pMsg);
      break;
  }
}
  void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
      hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);
      WM_SetStayOnTop(hWin, 1);
      break;
}
}
  To learn more about emWin and AppWizard, please find the links below.
https://www.youtube.com/@SeggerMicro/videos
https://www.segger.com/downloads/emwin/UM03001
Suitable Products
RA Family
AppWizard is the Segger emWin provided PC software that makes GUI building and embedded software programming easier for developers. Sometimes, what you want to achieve cannot be all done by AppWizard, so changes need to be made at the source code level with emWin API.
AppWizard is the Segger emWin provided PC software that makes GUI building and embedded software programming easier for developers. Sometimes, what you want to achieve cannot be all done by AppWizard, so changes need to be made at the source code level with emWin API.
There are two types of emWin APIs, one is AppWizard APIs and the other is conventional emWin APIs. AppWizard APIs and conventional emWin APIs generally work the same but AppWizard APIs are a more general form that can be used all across the objects. Since some AppWizard APIs are still undocumented, we will use conventional emWin API in this document.
AppWizard APIs are listed in AppWizard.h
Core emWin APIs are listed in GUI.h and WM.h
Widgets emWin APIs are listed in each widget header files like TEXT.h, BUTTON.h, ROTARY.h, and so on.
There are two types of emWin APIs, one is AppWizard APIs and the other is conventional emWin APIs. AppWizard APIs and conventional emWin APIs generally work the same but AppWizard APIs are a more general form that can be used all across the objects. Since some AppWizard APIs are still undocumented, we will use conventional emWin API in this document.
Answers:
Change TEXT when button is pressed (TEXT moves along when screen swipe)
If you have a TEXT widget that does not know what to print out at build time but make up a word or sentence at runtime when BUTTON is pressed, then the text in TEXT widget can be changed dynamically with the following code. The figures below show that the text of TEXT changes when the button is pressed, and the position of TEXT also changes when the screen is swiped.
           If you have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, ID_TEXT_00);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
default:
      //WM_DefaultProc(); --> Screen callback MUST not have default function handler
      break;  }
}
  If you dont have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
        hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->hWin, WM_CF_SHOW, 0, GUI_ID_TEXT0, ""HI"");
      break;
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
    default:
      //WM_DefaultProc(); --> Screen callback MUST not have default function handler
      break;
  }
}
  GUI user interface
There is no direct user interface APIs, for example, for a BUTTON widget to change from unpressed to pressed state. The only way to change the BUTTON to the pressed state is to deliver a keyboard or PID message to the BUTTON, and the message to be processed in a callback function. Keyboard input is delivered in GUI_StoreKeyMsg(), and PID input is delivered in GUI_PID_StoreState(). The example below shows how to make a push button IRQ interrupt act like the Enter key was pressed on BUTTON. Please note that BUTTON widget reacts to keyboard input differently than PID input. For example, keyboard Enter press on BUTTON widget generates both press and release messages in turn at once.
void external_irq_callback (void)
{
WM_HWIN hWin;
WM_HWIN hItem;
    hWin = WM_GetActiveWindow();
  hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);
  WIDGET_SetFocusable(hItem,1);
  WM_SetFocus(hItem);
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 1); /* Pressed */
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 0); /* Release */
}
      It would be also possible to make a button press act like touch/mouse swipe.
GUI_PID_STATE swipe_state;
void external_irq_callback (void)
{
swipe_state.x = x_position;
swipe_state.y = y_position;
swipe_state.Pressed = 1;
  GUI_PID_StoreState(&swipe_state);
  x_position += x_position_increment;
  if(x_position >= x_position_max){
    swipe_state.Pressed = 0;
    GUI_PID_StoreState(&swipe_state);
}
}
  Custom drawing on top
If you need to do some custom drawing on top and stay on top, you can make a child window of WM_HBKWIN and set the StayOnTop flag. A window is created with the given x, y coordinate and size, and a custom user callback function pointer. In the callback function, WM_PAINT is where the user is allowed to do some custom drawing. MEMDEV is a temporary drawing place used for anti-flicker, image decompression, scaling & rotating, animation, and so on. For more details on MEMDEV, please refer to the emWin manual. The example below draws one line from (0,0) to (100,100) and stays on top during/after screen swiping.
static void _cbTopWin(WM_MESSAGE * pMsg) {
GUI_MEMDEV_Handle hMem;
    switch (pMsg->MsgId) {
    case WM_PAINT:
      hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);
      GUI_MEMDEV_Select(hMem);
      GUI_SetColor(GUI_BLACK);
      for(uint32_t i=0; i<100; i++){
        GUI_DrawPixel(i, i);
      }
      GUI_MEMDEV_CopyToLCD(hMem);
      GUI_MEMDEV_Delete(hMem);
      GUI_MEMDEV_Select(0);
      break;
    default:
      WM_DefaultProc(pMsg);
      break;
  }
}
  void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
      hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);
      WM_SetStayOnTop(hWin, 1);
      break;
}
}
  To learn more about emWin and AppWizard, please find the links below.
https://www.youtube.com/@SeggerMicro/videos
https://www.segger.com/downloads/emwin/UM03001
Suitable Products
RA Family
Change TEXT when button is pressed (TEXT moves along when screen swipe)
If you have a TEXT widget that does not know what to print out at build time but make up a word or sentence at runtime when BUTTON is pressed, then the text in TEXT widget can be changed dynamically with the following code. The figures below show that the text of TEXT changes when the button is pressed, and the position of TEXT also changes when the screen is swiped.
           If you have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, ID_TEXT_00);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
default:
      //WM_DefaultProc(); --> Screen callback MUST not have default function handler
      break;  }
}
  If you dont have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
  int      Id, NCode;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
        hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->hWin, WM_CF_SHOW, 0, GUI_ID_TEXT0, ""HI"");
      break;
      case WM_NOTIFY_PARENT:
      Id = WM_GetId(pMsg->hWinSrc);
      NCode = pMsg->Data.v;
        switch(Id) {
        case ID_BUTTON_00:
            switch(NCode){
              case WM_NOTIFICATION_CLICKED:
                hWin = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
                TEXT_SetText(hWin, ""Success"");
              break;
            }
            break;
      }
      break;
    default:
      //WM_DefaultProc(); --> Screen callback MUST not have default function handler
      break;
  }
}
  GUI user interface
There is no direct user interface APIs, for example, for a BUTTON widget to change from unpressed to pressed state. The only way to change the BUTTON to the pressed state is to deliver a keyboard or PID message to the BUTTON, and the message to be processed in a callback function. Keyboard input is delivered in GUI_StoreKeyMsg(), and PID input is delivered in GUI_PID_StoreState(). The example below shows how to make a push button IRQ interrupt act like the Enter key was pressed on BUTTON. Please note that BUTTON widget reacts to keyboard input differently than PID input. For example, keyboard Enter press on BUTTON widget generates both press and release messages in turn at once.
void external_irq_callback (void)
{
WM_HWIN hWin;
WM_HWIN hItem;
    hWin = WM_GetActiveWindow();
  hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);
  WIDGET_SetFocusable(hItem,1);
  WM_SetFocus(hItem);
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 1); /* Pressed */
  GUI_StoreKeyMsg(GUI_KEY_ENTER, 0); /* Release */
}
      It would be also possible to make a button press act like touch/mouse swipe.
GUI_PID_STATE swipe_state;
void external_irq_callback (void)
{
swipe_state.x = x_position;
swipe_state.y = y_position;
swipe_state.Pressed = 1;
  GUI_PID_StoreState(&swipe_state);
  x_position += x_position_increment;
  if(x_position >= x_position_max){
    swipe_state.Pressed = 0;
    GUI_PID_StoreState(&swipe_state);
}
}
  Custom drawing on top
If you need to do some custom drawing on top and stay on top, you can make a child window of WM_HBKWIN and set the StayOnTop flag. A window is created with the given x, y coordinate and size, and a custom user callback function pointer. In the callback function, WM_PAINT is where the user is allowed to do some custom drawing. MEMDEV is a temporary drawing place used for anti-flicker, image decompression, scaling & rotating, animation, and so on. For more details on MEMDEV, please refer to the emWin manual. The example below draws one line from (0,0) to (100,100) and stays on top during/after screen swiping.
static void _cbTopWin(WM_MESSAGE * pMsg) {
GUI_MEMDEV_Handle hMem;
    switch (pMsg->MsgId) {
    case WM_PAINT:
      hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);
      GUI_MEMDEV_Select(hMem);
      GUI_SetColor(GUI_BLACK);
      for(uint32_t i=0; i<100; i++){
        GUI_DrawPixel(i, i);
      }
      GUI_MEMDEV_CopyToLCD(hMem);
      GUI_MEMDEV_Delete(hMem);
      GUI_MEMDEV_Select(0);
      break;
    default:
      WM_DefaultProc(pMsg);
      break;
  }
}
  void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
  WM_HWIN  hWin;
    switch (pMsg->MsgId) {
    case WM_INIT_DIALOG:
      hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);
      WM_SetStayOnTop(hWin, 1);
      break;
}
}
  To learn more about emWin and AppWizard, please find the links below.
https://www.youtube.com/@SeggerMicro/videos
https://www.segger.com/downloads/emwin/UM03001
Change TEXT when button is pressed (TEXT moves along when screen swipe)
If you have a TEXT widget that does not know what to print out at build time but make up a word or sentence at runtime when BUTTON is pressed, then the text in TEXT widget can be changed dynamically with the following code. The figures below show that the text of TEXT changes when the button is pressed, and the position of TEXT also changes when the screen is swiped.
If you have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
void
cbID_SCREEN_00(
WM_MESSAGE
* pMsg) {
WM_HWIN  hWin;
WM_HWIN  hWin;
int      Id, NCode;
int
Id, NCode;
switch (pMsg->MsgId) {
switch
(pMsg->
MsgId
) {
case WM_NOTIFY_PARENT:
case
WM_NOTIFY_PARENT:
Id = WM_GetId(pMsg->hWinSrc);
Id = WM_GetId(pMsg->
hWinSrc
);
NCode = pMsg->Data.v;
NCode = pMsg->
Data
.
v
;
switch(Id) {
switch
(Id) {
case ID_BUTTON_00:
case
ID_BUTTON_00:
switch(NCode){
switch
(NCode){
case WM_NOTIFICATION_CLICKED:
case
WM_NOTIFICATION_CLICKED:
hWin = WM_GetDialogItem(pMsg->hWin, ID_TEXT_00);
hWin = WM_GetDialogItem(pMsg->
hWin
, ID_TEXT_00);
TEXT_SetText(hWin, ""Success"");
TEXT_SetText(hWin,
""Success""
);
break;
break
;
}
}
break;
break
;
}
}
break;
break
;
default:
default
:
//WM_DefaultProc(); --> Screen callback MUST not have default function handler
//WM_DefaultProc(); -->
Screen callback MUST not have default function handler
break;  }
break
;  }
}
}
If you dont have TEXT widget made by AppWizard.
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
void
cbID_SCREEN_00(
WM_MESSAGE
* pMsg) {
WM_HWIN  hWin;
WM_HWIN  hWin;
int      Id, NCode;
int
Id, NCode;
switch (pMsg->MsgId) {
switch
(pMsg->
MsgId
) {
case WM_INIT_DIALOG:
case
WM_INIT_DIALOG:
hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->hWin, WM_CF_SHOW, 0, GUI_ID_TEXT0, ""HI"");
hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->
hWin
, WM_CF_SHOW, 0, GUI_ID_TEXT0,
""HI""
);
break;
break
;
case WM_NOTIFY_PARENT:
case
WM_NOTIFY_PARENT:
Id = WM_GetId(pMsg->hWinSrc);
Id = WM_GetId(pMsg->
hWinSrc
);
NCode = pMsg->Data.v;
NCode = pMsg->
Data
.
v
;
switch(Id) {
switch
(Id) {
case ID_BUTTON_00:
case
ID_BUTTON_00:
switch(NCode){
switch
(NCode){
case WM_NOTIFICATION_CLICKED:
case
WM_NOTIFICATION_CLICKED:
hWin = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
hWin = WM_GetDialogItem(pMsg->
hWin
, GUI_ID_TEXT0);
TEXT_SetText(hWin, ""Success"");
TEXT_SetText(hWin,
""Success""
);
break;
break
;
}
}
break;
break
;
}
}
break;
break
;
default:
default
:
//WM_DefaultProc(); --> Screen callback MUST not have default function handler
//WM_DefaultProc(); -->
Screen callback MUST not have default function handler
break;
break
;
}
}
}
}
GUI user interface
There is no direct user interface APIs, for example, for a BUTTON widget to change from unpressed to pressed state. The only way to change the BUTTON to the pressed state is to deliver a keyboard or PID message to the BUTTON, and the message to be processed in a callback function. Keyboard input is delivered in GUI_StoreKeyMsg(), and PID input is delivered in GUI_PID_StoreState(). The example below shows how to make a push button IRQ interrupt act like the Enter key was pressed on BUTTON. Please note that BUTTON widget reacts to keyboard input differently than PID input. For example, keyboard Enter press on BUTTON widget generates both press and release messages in turn at once.
void external_irq_callback (void)
void
external_irq_callback (
void
)
{
{
WM_HWIN hWin;
WM_HWIN hWin;
WM_HWIN hItem;
WM_HWIN hItem;
hWin = WM_GetActiveWindow();
hWin = WM_GetActiveWindow();
hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);
hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);
WIDGET_SetFocusable(hItem,1);
WIDGET_SetFocusable(hItem,1);
WM_SetFocus(hItem);
WM_SetFocus(hItem);
GUI_StoreKeyMsg(GUI_KEY_ENTER, 1); /* Pressed */
GUI_StoreKeyMsg(GUI_KEY_ENTER, 1);
/* Pressed */
GUI_StoreKeyMsg(GUI_KEY_ENTER, 0); /* Release */
GUI_StoreKeyMsg(GUI_KEY_ENTER, 0);
/* Release */
}
}
It would be also possible to make a button press act like touch/mouse swipe.
GUI_PID_STATE swipe_state;
GUI_PID_STATE
swipe_state;
void external_irq_callback (void)
void
external_irq_callback (
void
)
{
{
swipe_state.x = x_position;
swipe_state.
x
= x_position;
swipe_state.y = y_position;
swipe_state.
y
= y_position;
swipe_state.Pressed = 1;
swipe_state.
Pressed
= 1;
GUI_PID_StoreState(&swipe_state);
GUI_PID_StoreState(&swipe_state);
x_position += x_position_increment;
x_position += x_position_increment;
if(x_position >= x_position_max){
if
(x_position >= x_position_max){
swipe_state.Pressed = 0;
swipe_state.
Pressed
= 0;
GUI_PID_StoreState(&swipe_state);
GUI_PID_StoreState(&swipe_state);
}
}
}
}
Custom drawing on top
If you need to do some custom drawing on top and stay on top, you can make a child window of WM_HBKWIN and set the StayOnTop flag. A window is created with the given x, y coordinate and size, and a custom user callback function pointer. In the callback function, WM_PAINT is where the user is allowed to do some custom drawing. MEMDEV is a temporary drawing place used for anti-flicker, image decompression, scaling & rotating, animation, and so on. For more details on MEMDEV, please refer to the emWin manual. The example below draws one line from (0,0) to (100,100) and stays on top during/after screen swiping.
static void _cbTopWin(WM_MESSAGE * pMsg) {
static
void
_cbTopWin(
WM_MESSAGE
* pMsg) {
GUI_MEMDEV_Handle hMem;
GUI_MEMDEV_Handle
hMem;
switch (pMsg->MsgId) {
switch
(pMsg->
MsgId
) {
case WM_PAINT:
case
WM_PAINT:
hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);
hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);
GUI_MEMDEV_Select(hMem);
GUI_MEMDEV_Select(hMem);
GUI_SetColor(GUI_BLACK);
GUI_SetColor(GUI_BLACK);
for(uint32_t i=0; i<100; i++){
for
(
uint32_t
i=0; i<100; i++){
GUI_DrawPixel(i, i);
GUI_DrawPixel(i, i);
}
}
GUI_MEMDEV_CopyToLCD(hMem);
GUI_MEMDEV_CopyToLCD(hMem);
GUI_MEMDEV_Delete(hMem);
GUI_MEMDEV_Delete(hMem);
GUI_MEMDEV_Select(0);
GUI_MEMDEV_Select(0);
break;
break
;
default:
default
:
WM_DefaultProc(pMsg);
WM_DefaultProc(pMsg);
break;
break
;
}
}
}
}
void cbID_SCREEN_00(WM_MESSAGE * pMsg) {
void
cbID_SCREEN_00(
WM_MESSAGE
* pMsg) {
WM_HWIN  hWin;
WM_HWIN  hWin;
switch (pMsg->MsgId) {
switch
(pMsg->
MsgId
) {
case WM_INIT_DIALOG:
case
WM_INIT_DIALOG:
hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);
hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);
WM_SetStayOnTop(hWin, 1);
WM_SetStayOnTop(hWin, 1);
break;
break
;
}
}
}
}
To learn more about emWin and AppWizard, please find the links below.
https://www.youtube.com/@SeggerMicro/videos
https://www.segger.com/downloads/emwin/UM03001
Suitable Products
RA Family
Go to Japanese
Go to Japanese","['data/categories/ra_family/ra_and_fsp_technical_articles/d5835ab1490b2c4dd0539f7090b90aff/images/6c24640ee16991f913ed6e286d29d184.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d5835ab1490b2c4dd0539f7090b90aff/images/81cda652f39c36b27687d99fc0800879.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d5835ab1490b2c4dd0539f7090b90aff/images/a5f61e62dd68924d032f0d24306e41e6.jpg']",[],"['|  |\n|  |\n| void cbID_SCREEN_00(WM_MESSAGE * pMsg) {\n  WM_HWIN  hWin;\n  int      Id, NCode;\n    switch (pMsg->MsgId) {\n      case WM_NOTIFY_PARENT:\n      Id = WM_GetId(pMsg->hWinSrc);\n      NCode = pMsg->Data.v;\n        switch(Id) {\n        case ID_BUTTON_00:\n            switch(NCode){\n              case WM_NOTIFICATION_CLICKED:\n                hWin = WM_GetDialogItem(pMsg->hWin, ID_TEXT_00);\n                TEXT_SetText(hWin, ""Success"");\n              break;\n            }\n            break;\n      }\n      break;\ndefault:\n      //WM_DefaultProc(); --> Screen callback MUST not have default function handler\n      break;  }\n} |', '|  |\n|  |\n| void cbID_SCREEN_00(WM_MESSAGE * pMsg) {\n  WM_HWIN  hWin;\n  int      Id, NCode;\n    switch (pMsg->MsgId) {\n    case WM_INIT_DIALOG:\n        hWin = TEXT_CreateEx(5, 5, 100, 100, pMsg->hWin, WM_CF_SHOW, 0, GUI_ID_TEXT0, ""HI"");\n      break;\n      case WM_NOTIFY_PARENT:\n      Id = WM_GetId(pMsg->hWinSrc);\n      NCode = pMsg->Data.v;\n        switch(Id) {\n        case ID_BUTTON_00:\n            switch(NCode){\n              case WM_NOTIFICATION_CLICKED:\n                hWin = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);\n                TEXT_SetText(hWin, ""Success"");\n              break;\n            }\n            break;\n      }\n      break;\n    default:\n      //WM_DefaultProc(); --> Screen callback MUST not have default function handler\n      break;\n  }\n} |', '|  |\n|  |\n| void external_irq_callback (void)\n{\nWM_HWIN hWin;\nWM_HWIN hItem;\n    hWin = WM_GetActiveWindow();\n  hItem = WM_GetDialogItem(hWin, ID_BUTTON_00);\n  WIDGET_SetFocusable(hItem,1);\n  WM_SetFocus(hItem);\n  GUI_StoreKeyMsg(GUI_KEY_ENTER, 1); /* Pressed */\n  GUI_StoreKeyMsg(GUI_KEY_ENTER, 0); /* Release */\n} |', '|  |\n|  |\n| GUI_PID_STATE swipe_state;\nvoid external_irq_callback (void)\n{\nswipe_state.x = x_position;\nswipe_state.y = y_position;\nswipe_state.Pressed = 1;\n  GUI_PID_StoreState(&swipe_state);\n  x_position += x_position_increment;\n  if(x_position >= x_position_max){\n    swipe_state.Pressed = 0;\n    GUI_PID_StoreState(&swipe_state);\n}\n} |', '|  |\n|  |\n| static void _cbTopWin(WM_MESSAGE * pMsg) {\nGUI_MEMDEV_Handle hMem;\n    switch (pMsg->MsgId) {\n    case WM_PAINT:\n      hMem  = GUI_MEMDEV_CreateFixed(0, 0, 100, 100, GUI_MEMDEV_HASTRANS, GUI_MEMDEV_APILIST_32, GUI_COLOR_CONV_888);\n      GUI_MEMDEV_Select(hMem);\n      GUI_SetColor(GUI_BLACK);\n      for(uint32_t i=0; i<100; i++){\n        GUI_DrawPixel(i, i);\n      }\n      GUI_MEMDEV_CopyToLCD(hMem);\n      GUI_MEMDEV_Delete(hMem);\n      GUI_MEMDEV_Select(0);\n      break;\n    default:\n      WM_DefaultProc(pMsg);\n      break;\n  }\n}\n  void cbID_SCREEN_00(WM_MESSAGE * pMsg) {\n  WM_HWIN  hWin;\n    switch (pMsg->MsgId) {\n    case WM_INIT_DIALOG:\n      hWin = WM_CreateWindowAsChild(0, 0, 100, 100, WM_HBKWIN, (WM_CF_HASTRANS|WM_CF_SHOW), _cbTopWin, 0);\n      WM_SetStayOnTop(hWin, 1);\n      break;\n}\n} |', '|  |\n|  |\n| RA Family |']","{'title': 'RA Family : Custom user code integration in AppWizard emWin project', 'url': 'https://en-support.renesas.com/knowledgeBase/20775903', 'last_updated': '2022-06-12', 'extracted_at': '2025-03-08T23:12:56.643610'}","Issue AppWizard is the Segger emWin provided PC software that makes GUI building and embedded software programming easier for developers. Sometimes, what you want to achieve cannot be all done by AppWizard, so changes need to be made at the source code level with emWin API. Description There are two types of emWin APIs, one is AppWizard APIs and the other is conventional emWin APIs. AppWizard APIs and conventional emWin APIs generally work the same but AppWizard APIs are a more general form that can be used all across the objects. Since some AppWizard APIs are still undocumented, we will use conventional emWin API in this document. AppWizard APIs are listed in AppWizard.h Core emWin APIs are listed in GUI.h and WM.h Widgets emWin APIs are listed in each widget header files like TEXT.h, BUTTON.h, ROTARY.h, and so on. Answers Change TEXT when button is pressed (TEXT moves along when screen swipe) If you have a TEXT widget that does not know what to print out at build time but make up a word or sentence at runtime when BUTTON is pressed, then the text in TEXT widget can be changed dynamically with the following code. The figures below show that the text of TEXT changes when the button is pressed, and the position of TEXT also changes when the screen is swiped. If you have TEXT widget made by AppWizard. void cbIDSCREEN00(WMMESSAGE  pMsg)  WMHWIN hWin; int Id, NCode; switch (pMsg-MsgId)  case WMNOTIFYPARENT Id  WMGetId(pMsg-hWinSrc); NCode  pMsg-Data.v; switch(Id)  case IDBUTTON00 switch(NCode) case WMNOTIFICATIONCLICKED hWin  WMGetDialogItem(pMsg-hWin, IDTEXT00); TEXTSetText(hWin, ""Success""); break;  break;  break; default //WMDefaultProc(); -- Screen callback MUST not have default function handler break;   If you dont have TEXT widget made by AppWizard. case WMINITDIALOG hWin  TEXTCreateEx(5, 5, 100, 100, pMsg-hWin, WMCFSHOW, 0, GUIIDTEXT0, ""HI""); hWin  WMGetDialogItem(pMsg-hWin, GUIIDTEXT0); default  GUI user interface There is no direct user interface APIs, for example, for a BUTTON widget to change from unpressed to pressed state. The only way to change the BUTTON to the pressed state is to deliver a keyboard or PID message to the BUTTON, and the message to be processed in a callback function. Keyboard input is delivered in GUIStoreKeyMsg(), and PID input is delivered in GUIPIDStoreState(). The example below shows how to make a push button IRQ interrupt act like the Enter key was pressed on BUTTON. Please note that BUTTON widget reacts to keyboard input differently than PID input. For example, keyboard Enter press on BUTTON widget generates both press and release messages in turn at once. void externalirqcallback (void)  WMHWIN hWin; WMHWIN hItem; hWin  WMGetActiveWindow(); hItem  WMGetDialogItem(hWin, IDBUTTON00); WIDGETSetFocusable(hItem,1); WMSetFocus(hItem); GUIStoreKeyMsg(GUIKEYENTER, 1); / Pressed / GUIStoreKeyMsg(GUIKEYENTER, 0); / Release / It would be also possible to make a button press act like touch/mouse swipe. GUIPIDSTATE swipestate; swipestate.x  xposition; swipestate.y  yposition; swipestate.Pressed  1; GUIPIDStoreState(swipestate); xposition  xpositionincrement; if(xposition  xpositionmax) swipestate.Pressed  0; GUIPIDStoreState(swipestate); Custom drawing on top If you need to do some custom drawing on top and stay on top, you can make a child window of WMHBKWIN and set the StayOnTop flag. A window is created with the given x, y coordinate and size, and a custom user callback function pointer. In the callback function, WMPAINT is where the user is allowed to do some custom drawing. MEMDEV is a temporary drawing place used for anti-flicker, image decompression, scaling  rotating, animation, and so on. For more details on MEMDEV, please refer to the emWin manual. The example below draws one line from (0,0) to (100,100) and stays on top during/after screen swiping. static void cbTopWin(WMMESSAGE  pMsg)  GUIMEMDEVHandle hMem; case WMPAINT hMem  GUIMEMDEVCreateFixed(0, 0, 100, 100, GUIMEMDEVHASTRANS, GUIMEMDEVAPILIST32, GUICOLORCONV888); GUIMEMDEVSelect(hMem); GUISetColor(GUIBLACK); for(uint32t i0; i100; i) GUIDrawPixel(i, i); GUIMEMDEVCopyToLCD(hMem); GUIMEMDEVDelete(hMem); GUIMEMDEVSelect(0); WMDefaultProc(pMsg); void cbIDSCREEN00(WMMESSAGE  pMsg)  hWin  WMCreateWindowAsChild(0, 0, 100, 100, WMHBKWIN, (WMCFHASTRANSWMCFSHOW), cbTopWin, 0); WMSetStayOnTop(hWin, 1); To learn more about emWin and AppWizard, please find the links below. https//www.youtube.com/SeggerMicro/videos https//www.segger.com/downloads/emwin/UM03001 Suitable Products RA Family If you have TEXT widget made by AppWizard. void cbIDSCREEN00( WMMESSAGE  pMsg)  WMHWIN hWin; int Id, NCode; int Id, NCode; switch (pMsg-MsgId)  switch (pMsg- MsgId )  case WMNOTIFYPARENT case WMNOTIFYPARENT Id  WMGetId(pMsg-hWinSrc); Id  WMGetId(pMsg- hWinSrc ); NCode  pMsg-Data.v; NCode  pMsg- Data . v ; switch(Id)  (Id)  case IDBUTTON00 IDBUTTON00 switch(NCode) (NCode) case WMNOTIFICATIONCLICKED WMNOTIFICATIONCLICKED hWin  WMGetDialogItem(pMsg-hWin, IDTEXT00); hWin  WMGetDialogItem(pMsg- hWin , IDTEXT00); TEXTSetText(hWin, ""Success""); TEXTSetText(hWin, ""Success"" break; break default  //WMDefaultProc(); -- Screen callback MUST not have default function handler //WMDefaultProc(); -- Screen callback MUST not have default function handler break;  ;  If you dont have TEXT widget made by AppWizard. case WMINITDIALOG WMINITDIALOG hWin  TEXTCreateEx(5, 5, 100, 100, pMsg-hWin, WMCFSHOW, 0, GUIIDTEXT0, ""HI""); hWin  TEXTCreateEx(5, 5, 100, 100, pMsg- , WMCFSHOW, 0, GUIIDTEXT0, ""HI"" hWin  WMGetDialogItem(pMsg-hWin, GUIIDTEXT0); , GUIIDTEXT0); GUI user interface externalirqcallback ( ) hWin  WMGetActiveWindow(); hItem  WMGetDialogItem(hWin, IDBUTTON00); WIDGETSetFocusable(hItem,1); WMSetFocus(hItem); GUIStoreKeyMsg(GUIKEYENTER, 1); / Pressed / GUIStoreKeyMsg(GUIKEYENTER, 1); / Pressed / GUIStoreKeyMsg(GUIKEYENTER, 0); / Release / GUIStoreKeyMsg(GUIKEYENTER, 0); / Release / It would be also possible to make a button press act like touch/mouse swipe. GUIPIDSTATE swipestate; swipestate. x  xposition; y  yposition; Pressed  1; GUIPIDStoreState(swipestate); xposition  xpositionincrement; if(xposition  xpositionmax) if (xposition  xpositionmax) swipestate.Pressed  0;  0; Custom drawing on top static cbTopWin( GUIMEMDEVHandle hMem; case WMPAINT WMPAINT hMem  GUIMEMDEVCreateFixed(0, 0, 100, 100, GUIMEMDEVHASTRANS, GUIMEMDEVAPILIST32, GUICOLORCONV888); GUIMEMDEVSelect(hMem); GUISetColor(GUIBLACK); for(uint32t i0; i100; i) for ( uint32t i0; i100; i) GUIDrawPixel(i, i); GUIMEMDEVCopyToLCD(hMem); GUIMEMDEVDelete(hMem); GUIMEMDEVSelect(0); WMDefaultProc(pMsg); hWin  WMCreateWindowAsChild(0, 0, 100, 100, WMHBKWIN, (WMCFHASTRANSWMCFSHOW), cbTopWin, 0); WMSetStayOnTop(hWin, 1); To learn more about emWin and AppWizard, please find the links below. Go to Japanese",
d28631ef91309bdcdab1f7dd0b4a008c,"The below description applies to AC 6.16 and earlier. Refer to the companion post for AC 6.17 here: https://en-support.renesas.com/knowledgeBase/20370421
e2 studio does not include the ARM Compiler 6 (AC6) toolchain by default.
Below are the steps for integrating AC6 into e2 studio and creating an RA project with the toolchain.
Note:
Steps 1 through 8 describe the process for integrating ARM Compiler 6 into e2 studio.
9. When creating a new RA C/C++ project, select ARM Compiler 6 included in the Toolchains section.","['data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/232ddb68ddc5fe243d3439f6e84bed45.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/0f2b051816dad05fe9785a26b8d466f7.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/9df5102781467045e2a2847ba4b6a0ea.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/bf7123f9a9bd52008ba75969136ddbb4.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/bdbe3da6ef764cad9bc33441f64c3fe9.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/d28631ef91309bdcdab1f7dd0b4a008c/images/5b34313a8ed1a3089b78a13673ac61cd.png']",[],[],"{'title': 'Creating an RA Project with ARM Compiler 6.16 and earlier in e2 studio', 'url': 'https://en-support.renesas.com/knowledgeBase/19375553', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:19.126301'}","The below description applies to AC 6.16 and earlier. Refer to the companion post for AC 6.17 here https//en-support.renesas.com/knowledgeBase/20370421 e2 studio does not include the ARM Compiler 6 (AC6) toolchain by default. Below are the steps for integrating AC6 into e2 studio and creating an RA project with the toolchain. Note Steps 1 through 8 describe the process for integrating ARM Compiler 6 into e2 studio. 9. When creating a new RA C/C project, select ARM Compiler 6 included in the Toolchains section.",
4d6dbe65e1eb7337da226e43afacc605,"The schematics for the EK-RA2L1 is missing some connections, inserted below in red and green. The connections are on the board, juts not included in the schematic. These will be updated in the next revision of the schematic.
The schematics for the EK-RA2L1 is missing some connections, inserted below in red and green. The connections are on the board, juts not included in the schematic. These will be updated in the next revision of the schematic.
The schematics for the EK-RA2L1 is missing some connections, inserted below in red and green. The connections are on the board, juts not included in the schematic. These will be updated in the next revision of the schematic.
Suitable Products
Suitable Products
RA/FSP
Source:   Ticket 349162",['data/categories/ra_family/ra_and_fsp_technical_articles/4d6dbe65e1eb7337da226e43afacc605/images/083c4e170953cc97124aa6a22dbfa4fa.png'],[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'EK-RA2L1 Schematic Missing Connections', 'url': 'https://en-support.renesas.com/knowledgeBase/20474167', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:34.765892'}","The schematics for the EK-RA2L1 is missing some connections, inserted below in red and green. The connections are on the board, juts not included in the schematic. These will be updated in the next revision of the schematic. Suitable Products RA/FSP Source Ticket 349162",
936810f8e8d29da37300067c752b12ac,"It is probably best to disable the JLink from caching the dataflash when trying to work with flash debugging. With the debug session terminated, in the .jlink file in the top level directory of the e2studio project change:
CacheExcludeSize = 0
CacheExcludeAddr = 0
to
CacheExcludeSize = 0x2000
CacheExcludeAddr = 0x40100000
then save the file, and then start the debug session.
As an example, for the RA2L1 the data flash on the RA2L1 is not enabled at power on of the device, and isn't enabled until this line of code:
Before it is enabled, a read to the dataflash region will return 0 (as can be seen in the image above), after the dataflash is enabled, the actual contents will be visible:
Suitable Products
FSP
Suitable Products
FSP
Suitable Products
FSP
Source:   (19) Trouble reading values from data flash, reads all 0s - Forum - RA MCU - Renesas Community","['data/categories/ra_family/ra_and_fsp_technical_articles/936810f8e8d29da37300067c752b12ac/images/b28435b1d599d3a90c6d61a7e3a2ff01.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/936810f8e8d29da37300067c752b12ac/images/a4c210d2d1eda2a5d6505df5593cf115.png']",[],['|  |\n|  |\n| FSP |'],"{'title': 'RA Family: Disable J-Link Caching When Debugging Flash Issues in FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/20197204', 'last_updated': None, 'extracted_at': '2025-03-08T23:12:28.211890'}","It is probably best to disable the JLink from caching the dataflash when trying to work with flash debugging. With the debug session terminated, in the .jlink file in the top level directory of the e2studio project change CacheExcludeSize  0 CacheExcludeAddr  0 to CacheExcludeSize  0x2000 CacheExcludeAddr  0x40100000 then save the file, and then start the debug session. As an example, for the RA2L1 the data flash on the RA2L1 is not enabled at power on of the device, and isn't enabled until this line of code Before it is enabled, a read to the dataflash region will return 0 (as can be seen in the image above), after the dataflash is enabled, the actual contents will be visible Suitable Products FSP Source (19) Trouble reading values from data flash, reads all 0s - Forum - RA MCU - Renesas Community",
1f395323acb85fc02d0067c02e2ffdcd,"You can use FreeRTOS+FAT without FreeRTOS by following the below setup steps, which are also well described in RA FSP Documentation.
1.    Copy ra/fsp/src/rm_freertos_plus_fat/FreeRTOSConfigMinimal.h to one of your project include paths and rename it FreeRTOSConfig.h.
2.    Update the Malloc function to malloc and the Free function to free in the Common configuration of FreeRTOS+FAT as seen below.
 
3.    Implement the detection of media insertion because the media must be inserted before calling the RM_FREERTOS_PLUS_FAT_MediaInit(). 
a.    If the Block Media USB is used in the Bare Metal, the low-level USB driver does not pass the USB event to the block media framework through the internal rm_block_media_usb_callback. Therefore, user application needs to poll the R_USB_EventGet() function to obtain the status of USB media insertion.
b.    If the Block Media SDMMC is used, the media insertion event will be notified through the preassigned callback function of FreeRTOS+FAT Port. Therefore, user application can just wait for the event of RM_FREERTOS_PLUS_FAT_EVENT_MEDIA_INSERTED notified by the callback before starting the media initialization.
Sample Project  using FreeRTOS+FAT with Block Media on USB in a Bare Metal project
FSP version: 3.8.0
Used Kit: EK-RA6M3
Setup: Connect USB pendrive to J11, Connect J12 Pin1-Pin2, Remove jumper from J15.
   Suitable Products
You can use FreeRTOS+FAT without FreeRTOS by following the below setup steps, which are also well described in RA FSP Documentation.
1.    Copy ra/fsp/src/rm_freertos_plus_fat/FreeRTOSConfigMinimal.h to one of your project include paths and rename it FreeRTOSConfig.h.
2.    Update the Malloc function to malloc and the Free function to free in the Common configuration of FreeRTOS+FAT as seen below.
 
3.    Implement the detection of media insertion because the media must be inserted before calling the RM_FREERTOS_PLUS_FAT_MediaInit(). 
a.    If the Block Media USB is used in the Bare Metal, the low-level USB driver does not pass the USB event to the block media framework through the internal rm_block_media_usb_callback. Therefore, user application needs to poll the R_USB_EventGet() function to obtain the status of USB media insertion.
b.    If the Block Media SDMMC is used, the media insertion event will be notified through the preassigned callback function of FreeRTOS+FAT Port. Therefore, user application can just wait for the event of RM_FREERTOS_PLUS_FAT_EVENT_MEDIA_INSERTED notified by the callback before starting the media initialization.
RA FSP Documentation.
Sample Project  using FreeRTOS+FAT with Block Media on USB in a Bare Metal project
FSP version: 3.8.0
Used Kit: EK-RA6M3
Setup: Connect USB pendrive to J11, Connect J12 Pin1-Pin2, Remove jumper from J15.
Suitable Products
RA/FSP
Go to Japanese
Go to Japanese
Source:",['data/categories/ra_family/ra_and_fsp_technical_articles/1f395323acb85fc02d0067c02e2ffdcd/images/bd5f82dccf6a2eb827c53ee34f68d8a3.png'],[],['|  |\n|  |\n| RA/FSP |'],"{'title': 'RA Family: Using FreeRTOS+FAT on a Bare Metal Project', 'url': 'https://en-support.renesas.com/knowledgeBase/20641575', 'last_updated': '2022-10-08', 'extracted_at': '2025-03-08T23:12:01.547413'}","You can use FreeRTOSFAT without FreeRTOS by following the below setup steps, which are also well described in RA FSP Documentation. 1. Copy ra/fsp/src/rmfreertosplusfat/FreeRTOSConfigMinimal.h to one of your project include paths and rename it FreeRTOSConfig.h. 2. Update the Malloc function to malloc and the Free function to free in the Common configuration of FreeRTOSFAT as seen below. 3. Implement the detection of media insertion because the media must be inserted before calling the RMFREERTOSPLUSFATMediaInit(). a. If the Block Media USB is used in the Bare Metal, the low-level USB driver does not pass the USB event to the block media framework through the internal rmblockmediausbcallback. Therefore, user application needs to poll the RUSBEventGet() function to obtain the status of USB media insertion. b. If the Block Media SDMMC is used, the media insertion event will be notified through the preassigned callback function of FreeRTOSFAT Port. Therefore, user application can just wait for the event of RMFREERTOSPLUSFATEVENTMEDIAINSERTED notified by the callback before starting the media initialization. Sample Project  using FreeRTOSFAT with Block Media on USB in a Bare Metal project FSP version 3.8.0 Used Kit EK-RA6M3 Setup Connect USB pendrive to J11, Connect J12 Pin1-Pin2, Remove jumper from J15. Suitable Products RA FSP Documentation. Suitable Products RA/FSP Go to Japanese Source",
4060b1f194bbcfc0aabe1abddc00c1ec,"Overview:
Some RA MCUs support both a Linear Mode and a Dual Bank mode. This feature is switchable by an option memory setting. The Dual Bank flash mode is the preferred choice when user firmware A in Bank0 and user firmware B in Bank1 must be built identically to run from the same flash memory address, or when a user firmware update (including a user bootloader) must be safely completed even in the event of a power failure, while a firmware update is underway. In addition, the Dual Bank mode supports BGO (Background operation, or so called RWW), allowing flash memory to be read/executed from the current bank even when a firmware update on the other bank is in progress.
The example provided below is a simple way to implement a firmware update in Dual Bank mode using Xmodem. Once all the firmware updates are complete, the ""Bank Swap"" function is used to swap the current running bank with the newly downloaded bank.
Hardware configuration
- EK-RA6M4 board (1MB flash MCU)
- Your own USB-UART adapter (TX: P411, RX: P410)
Flash memory configuration
- Dual bank mode (512 KB x 2 banks) is used.
- Each bank (Bank0, 1) is divided into user bootloader area and user application area as below.
- The user bootloader is always built at address 0 regardless of the bank number to download.
- The user application is always built at address 0x8000 (bootloader size = e.g., 32 Kbytes) regardless of the bank number to download.
- The size and location of user bootloader and application can be changed as user needs.
- Whether or not to have a user bootloader is user's choice.
Bank 0 (Block 0 to 21) memory in 1MB product
Bank 1 (Block 70 to 91) memory in 1MB product
Linker script configuration (both bootloader and application)
- In the linker script, two user-defined sections (.verinfo, .sizeinfo) are added immediately after the application interrupt vector (.application_vectors), so they are always placed at a fixed address locations regardless of user code modification.
- The size of the application interrupt vector (g_Vector_table[BSP_ICU_VECTOR_MAX_ENTRIES]) depends on the MCU series used, so please ensure that both the bootloader project and application project are built on the same MCU series.
- During the user application firmware post-build process, CRC32 is padded to the end of the user application firmware binary, and its (CRC32) location is pointed by .sizeinfo.
Caution with bin firmware and option memory
User firmware can be converted to .hex, .srec, or .bin file type format in e2 studio. However, when creating a bin file, care must be taken to ensure that the option memory is not unintentionally filled with garbage values or zero values. This is because some settings in option memory cannot be permanently changed once set. e2 studio's default linker script has many memory sections (e.g. .text, .data, option_setting_x, .data_flash, qspi_flash, etc.) spread over a wide address range. Therefore, the user binary output file will be over 1 Mbyte in size, but only user code/data sections are required unless you download it new to a virgin MCU. This can be easily achieved by checking only those two check boxes in e2 studio.
Please don't forget to program the MCU with .srec or .hex at least once with the option memory settings to change Linear Mode to Dual Bank mode.
Append CRC32 to end of bin file
As an example of the firmware integrity verification process, the application_postbuild.bat and srec_cat.exe files are added in the application project folder. The ""srec_cat.exe"" is free software available on the Internet that allows you to rearrange, reformat, and relocate input files into output file as well as CRC32 calculation. Current version of e2 studio Post-build steps runs before the GNU Arm Cross Create Flash Image which creates a .bin file, so the Append CRC32 builder was added as an alternative. If all the build processes are completed successfully, another .bin file will be created that ends with <original bin file>_crc.bin, which is 4 bytes (CRC32) larger than the original .bin file.
Operation flow of the example projects
User bootloader
1. Program the board with the bootloader project. Use .srec (.hex) for option memory update.
2. The bootloader toggles the LED1 (Blue) on the board a number of times equal to the user bootloaders own version.
3. When the S2 button is pressed, the bootloader checks the CRC32 of the user application firmware, and if the CRC32 is correct, it jumps to the user application as shown below.
4. If CRC32 is incorrect or an error occurs, the bootloader starts Xmodem task as shown below.
4-1. Press 1 and download the user bootloader .bin file to the opposite bank.
4-2. Press 2 and download the user application _crc.bin file to the opposite bank.
4-3. Press 0 to swap the banks.
4-4. Press 3 to reset the board.
User application
1. The application toggles the LED3 (Red) on the board a number of times equal to the user applications own version.
2. When the S1 button is pressed, the application starts Xmodem task to download a new bootloader and application to the opposite bank.
3. After the Xmodem download is complete, the user can determine the bank swap and reset the MCU.
Tera Term setting
115200, 8bit, parity none, 1 stop bit, no hardware flow control.
To view the text properly, New-line setting for reception should be CR+LF as follows:
Suitable Products
RA
Some RA MCUs support both a Linear Mode and a Dual Bank mode. This feature is switchable by an option memory setting. The Dual Bank flash mode is the preferred choice when user firmware A in Bank0 and user firmware B in Bank1 must be built identically to run from the same flash memory address, or when a user firmware update (including a user bootloader) must be safely completed even in the event of a power failure, while a firmware update is underway. In addition, the Dual Bank mode supports BGO (Background operation, or so called RWW), allowing flash memory to be read/executed from the current bank even when a firmware update on the other bank is in progress.
The example provided below is a simple way to implement a firmware update in Dual Bank mode using Xmodem. Once all the firmware updates are complete, the ""Bank Swap"" function is used to swap the current running bank with the newly downloaded bank.
Hardware configuration
- EK-RA6M4 board (1MB flash MCU)
- Your own USB-UART adapter (TX: P411, RX: P410)
Flash memory configuration
- Dual bank mode (512 KB x 2 banks) is used.
- Each bank (Bank0, 1) is divided into user bootloader area and user application area as below.
- The user bootloader is always built at address 0 regardless of the bank number to download.
- The user application is always built at address 0x8000 (bootloader size = e.g., 32 Kbytes) regardless of the bank number to download.
- The size and location of user bootloader and application can be changed as user needs.
- Whether or not to have a user bootloader is user's choice.
Bank 0 (Block 0 to 21) memory in 1MB product
Bank 1 (Block 70 to 91) memory in 1MB product
Linker script configuration (both bootloader and application)
- In the linker script, two user-defined sections (.verinfo, .sizeinfo) are added immediately after the application interrupt vector (.application_vectors), so they are always placed at a fixed address locations regardless of user code modification.
- The size of the application interrupt vector (g_Vector_table[BSP_ICU_VECTOR_MAX_ENTRIES]) depends on the MCU series used, so please ensure that both the bootloader project and application project are built on the same MCU series.
- During the user application firmware post-build process, CRC32 is padded to the end of the user application firmware binary, and its (CRC32) location is pointed by .sizeinfo.
Caution with bin firmware and option memory
User firmware can be converted to .hex, .srec, or .bin file type format in e2 studio. However, when creating a bin file, care must be taken to ensure that the option memory is not unintentionally filled with garbage values or zero values. This is because some settings in option memory cannot be permanently changed once set. e2 studio's default linker script has many memory sections (e.g. .text, .data, option_setting_x, .data_flash, qspi_flash, etc.) spread over a wide address range. Therefore, the user binary output file will be over 1 Mbyte in size, but only user code/data sections are required unless you download it new to a virgin MCU. This can be easily achieved by checking only those two check boxes in e2 studio.
Please don't forget to program the MCU with .srec or .hex at least once with the option memory settings to change Linear Mode to Dual Bank mode.
Append CRC32 to end of bin file
As an example of the firmware integrity verification process, the application_postbuild.bat and srec_cat.exe files are added in the application project folder. The ""srec_cat.exe"" is free software available on the Internet that allows you to rearrange, reformat, and relocate input files into output file as well as CRC32 calculation. Current version of e2 studio Post-build steps runs before the GNU Arm Cross Create Flash Image which creates a .bin file, so the Append CRC32 builder was added as an alternative. If all the build processes are completed successfully, another .bin file will be created that ends with <original bin file>_crc.bin, which is 4 bytes (CRC32) larger than the original .bin file.
Operation flow of the example projects
User bootloader
1. Program the board with the bootloader project. Use .srec (.hex) for option memory update.
2. The bootloader toggles the LED1 (Blue) on the board a number of times equal to the user bootloaders own version.
3. When the S2 button is pressed, the bootloader checks the CRC32 of the user application firmware, and if the CRC32 is correct, it jumps to the user application as shown below.
4. If CRC32 is incorrect or an error occurs, the bootloader starts Xmodem task as shown below.
4-1. Press 1 and download the user bootloader .bin file to the opposite bank.
4-2. Press 2 and download the user application _crc.bin file to the opposite bank.
4-3. Press 0 to swap the banks.
4-4. Press 3 to reset the board.
User application
1. The application toggles the LED3 (Red) on the board a number of times equal to the user applications own version.
2. When the S1 button is pressed, the application starts Xmodem task to download a new bootloader and application to the opposite bank.
3. After the Xmodem download is complete, the user can determine the bank swap and reset the MCU.
Tera Term setting
115200, 8bit, parity none, 1 stop bit, no hardware flow control.
To view the text properly, New-line setting for reception should be CR+LF as follows:
Some RA MCUs support both a Linear Mode and a Dual Bank mode. This feature is switchable by an option memory setting. The Dual Bank flash mode is the preferred choice when user firmware A in Bank0 and user firmware B in Bank1 must be built identically to run from the same flash memory address, or when a user firmware update (including a user bootloader) must be safely completed even in the event of a power failure, while a firmware update is underway. In addition, the Dual Bank mode supports BGO (Background operation, or so called RWW), allowing flash memory to be read/executed from the current bank even when a firmware update on the other bank is in progress.
The example provided below is a simple way to implement a firmware update in Dual Bank mode using Xmodem. Once all the firmware updates are complete, the ""Bank Swap"" function is used to swap the current running bank with the newly downloaded bank.
Hardware configuration
- EK-RA6M4 board (1MB flash MCU)
- Your own USB-UART adapter (TX: P411, RX: P410)
Flash memory configuration
- Dual bank mode (512 KB x 2 banks) is used.
- Each bank (Bank0, 1) is divided into user bootloader area and user application area as below.
- The user bootloader is always built at address 0 regardless of the bank number to download.
- The user application is always built at address 0x8000 (bootloader size = e.g., 32 Kbytes) regardless of the bank number to download.
- The size and location of user bootloader and application can be changed as user needs.
- Whether or not to have a user bootloader is user's choice.
Bank 0 (Block 0 to 21) memory in 1MB product
Bank 1 (Block 70 to 91) memory in 1MB product
Linker script configuration (both bootloader and application)
- In the linker script, two user-defined sections (.verinfo, .sizeinfo) are added immediately after the application interrupt vector (.application_vectors), so they are always placed at a fixed address locations regardless of user code modification.
- The size of the application interrupt vector (g_Vector_table[BSP_ICU_VECTOR_MAX_ENTRIES]) depends on the MCU series used, so please ensure that both the bootloader project and application project are built on the same MCU series.
- During the user application firmware post-build process, CRC32 is padded to the end of the user application firmware binary, and its (CRC32) location is pointed by .sizeinfo.
Caution with bin firmware and option memory
Caution with bin firmware and option memory
User firmware can be converted to .hex, .srec, or .bin file type format in e2 studio. However, when creating a bin file, care must be taken to ensure that the option memory is not unintentionally filled with garbage values or zero values. This is because some settings in option memory cannot be permanently changed once set. e2 studio's default linker script has many memory sections (e.g. .text, .data, option_setting_x, .data_flash, qspi_flash, etc.) spread over a wide address range. Therefore, the user binary output file will be over 1 Mbyte in size, but only user code/data sections are required unless you download it new to a virgin MCU. This can be easily achieved by checking only those two check boxes in e2 studio.
Please don't forget to program the MCU with .srec or .hex at least once with the option memory settings to change Linear Mode to Dual Bank mode.
Append CRC32 to end of bin file
Append CRC32 to end of bin file
As an example of the firmware integrity verification process, the application_postbuild.bat and srec_cat.exe files are added in the application project folder. The ""srec_cat.exe"" is free software available on the Internet that allows you to rearrange, reformat, and relocate input files into output file as well as CRC32 calculation. Current version of e2 studio Post-build steps runs before the GNU Arm Cross Create Flash Image which creates a .bin file, so the Append CRC32 builder was added as an alternative. If all the build processes are completed successfully, another .bin file will be created that ends with <original bin file>_crc.bin, which is 4 bytes (CRC32) larger than the original .bin file.
Operation flow of the example projects
Operation flow of the example projects
User bootloader
1. Program the board with the bootloader project. Use .srec (.hex) for option memory update.
2. The bootloader toggles the LED1 (Blue) on the board a number of times equal to the user bootloaders own version.
3. When the S2 button is pressed, the bootloader checks the CRC32 of the user application firmware, and if the CRC32 is correct, it jumps to the user application as shown below.
4. If CRC32 is incorrect or an error occurs, the bootloader starts Xmodem task as shown below.
4-1. Press 1 and download the user bootloader .bin file to the opposite bank.
4-2. Press 2 and download the user application _crc.bin file to the opposite bank.
opposite
opposite
4-3. Press 0 to swap the banks.
4-4. Press 3 to reset the board.
swap the banks
User application
1. The application toggles the LED3 (Red) on the board a number of times equal to the user applications own version.
2. When the S1 button is pressed, the application starts Xmodem task to download a new bootloader and application to the opposite bank.
3. After the Xmodem download is complete, the user can determine the bank swap and reset the MCU.
opposite
Tera Term setting
115200, 8bit, parity none, 1 stop bit, no hardware flow control.
To view the text properly, New-line setting for reception should be CR+LF as follows:
Suitable Products
RA
Suitable Products
RA","['data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/87e9e983cec7aef987cedc8838701d7f.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/81386aa1d109719bd5edd30b1d853787.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/852d51c16952b0363b3ffe3105428c28.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/1f46c535d3a62bcbb67e1873232808ac.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/6d155f5077b60f3f573ebc741a58cab5.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/34856018334af7bf447121dcc1d31579.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/ab432ee5ccf993eb4c260cab60135cd0.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/5aff6b191903590f29299de89211e103.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/4060b1f194bbcfc0aabe1abddc00c1ec/images/aa3cfb0d7c447951b809025a1983d51c.png']",[],['|  |\n|  |\n| RA |'],"{'title': 'RA Family: Simple dual bank flash swap example for firmware A/B update', 'url': 'https://en-support.renesas.com/knowledgeBase/21546612', 'last_updated': '2024-03-09', 'extracted_at': '2025-03-08T23:12:33.227699'}","Overview Some RA MCUs support both a Linear Mode and a Dual Bank mode. This feature is switchable by an option memory setting. The Dual Bank flash mode is the preferred choice when user firmware A in Bank0 and user firmware B in Bank1 must be built identically to run from the same flash memory address, or when a user firmware update (including a user bootloader) must be safely completed even in the event of a power failure, while a firmware update is underway. In addition, the Dual Bank mode supports BGO (Background operation, or so called RWW), allowing flash memory to be read/executed from the current bank even when a firmware update on the other bank is in progress. The example provided below is a simple way to implement a firmware update in Dual Bank mode using Xmodem. Once all the firmware updates are complete, the ""Bank Swap"" function is used to swap the current running bank with the newly downloaded bank. Hardware configuration - EK-RA6M4 board (1MB flash MCU) - Your own USB-UART adapter (TX P411, RX P410) Flash memory configuration - Dual bank mode (512 KB x 2 banks) is used. - Each bank (Bank0, 1) is divided into user bootloader area and user application area as below. - The user bootloader is always built at address 0 regardless of the bank number to download. - The user application is always built at address 0x8000 (bootloader size  e.g., 32 Kbytes) regardless of the bank number to download. - The size and location of user bootloader and application can be changed as user needs. - Whether or not to have a user bootloader is user's choice. Bank 0 (Block 0 to 21) memory in 1MB product Bank 1 (Block 70 to 91) memory in 1MB product Linker script configuration (both bootloader and application) - In the linker script, two user-defined sections (.verinfo, .sizeinfo) are added immediately after the application interrupt vector (.applicationvectors), so they are always placed at a fixed address locations regardless of user code modification. - The size of the application interrupt vector (gVectortableBSPICUVECTORMAXENTRIES) depends on the MCU series used, so please ensure that both the bootloader project and application project are built on the same MCU series. - During the user application firmware post-build process, CRC32 is padded to the end of the user application firmware binary, and its (CRC32) location is pointed by .sizeinfo. Caution with bin firmware and option memory User firmware can be converted to .hex, .srec, or .bin file type format in e2 studio. However, when creating a bin file, care must be taken to ensure that the option memory is not unintentionally filled with garbage values or zero values. This is because some settings in option memory cannot be permanently changed once set. e2 studio's default linker script has many memory sections (e.g. .text, .data, optionsettingx, .dataflash, qspiflash, etc.) spread over a wide address range. Therefore, the user binary output file will be over 1 Mbyte in size, but only user code/data sections are required unless you download it new to a virgin MCU. This can be easily achieved by checking only those two check boxes in e2 studio. Please don't forget to program the MCU with .srec or .hex at least once with the option memory settings to change Linear Mode to Dual Bank mode. Append CRC32 to end of bin file As an example of the firmware integrity verification process, the applicationpostbuild.bat and sreccat.exe files are added in the application project folder. The ""sreccat.exe"" is free software available on the Internet that allows you to rearrange, reformat, and relocate input files into output file as well as CRC32 calculation. Current version of e2 studio Post-build steps runs before the GNU Arm Cross Create Flash Image which creates a .bin file, so the Append CRC32 builder was added as an alternative. If all the build processes are completed successfully, another .bin file will be created that ends with original bin filecrc.bin, which is 4 bytes (CRC32) larger than the original .bin file. Operation flow of the example projects User bootloader 1. Program the board with the bootloader project. Use .srec (.hex) for option memory update. 2. The bootloader toggles the LED1 (Blue) on the board a number of times equal to the user bootloaders own version. 3. When the S2 button is pressed, the bootloader checks the CRC32 of the user application firmware, and if the CRC32 is correct, it jumps to the user application as shown below. 4. If CRC32 is incorrect or an error occurs, the bootloader starts Xmodem task as shown below. 4-1. Press 1 and download the user bootloader .bin file to the opposite bank. 4-2. Press 2 and download the user application crc.bin file to the opposite bank. 4-3. Press 0 to swap the banks. 4-4. Press 3 to reset the board. User application 1. The application toggles the LED3 (Red) on the board a number of times equal to the user applications own version. 2. When the S1 button is pressed, the application starts Xmodem task to download a new bootloader and application to the opposite bank. 3. After the Xmodem download is complete, the user can determine the bank swap and reset the MCU. Tera Term setting 115200, 8bit, parity none, 1 stop bit, no hardware flow control. To view the text properly, New-line setting for reception should be CRLF as follows Suitable Products RA opposite swap the banks",
53dfb41c0a87368066a2be97a9245fe6,"Question:
How to I connect the VCL pin on RA4M2 MCUs?
Question:
How to I connect the VCL pin on RA4M2 MCUs?
How to I connect the VCL pin on RA4M2 MCUs?
Answer:
You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says: 
""Connect this pin to the VSS pin by the smoothing capacitor used to stabilize the internal power supply"", you might think that you connect VCL to Vss right next to the main decoupling capacitor. This would be incorrect.
The Hardware User Manual, section 45 shows more clearly what to do- connect VCL to a capacitor that then connects to VSS- as seen in the right side of the below diagram.
Answer:
You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says: 
""Connect this pin to the VSS pin by the smoothing capacitor used to stabilize the internal power supply"", you might think that you connect VCL to Vss right next to the main decoupling capacitor. This would be incorrect.
The Hardware User Manual, section 45 shows more clearly what to do- connect VCL to a capacitor that then connects to VSS- as seen in the right side of the below diagram.
You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says:
You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says:
""Connect this pin to the VSS pin by the smoothing capacitor used to stabilize the internal power supply"", you might think that you connect VCL to Vss right next to the main decoupling capacitor. This would be incorrect.
The Hardware User Manual, section 45 shows more clearly what to do- connect VCL to a capacitor that then connects to VSS- as seen in the right side of the below diagram.
Suitable Products
RA4 Series",['data/categories/ra_family/ra_and_fsp_technical_articles/53dfb41c0a87368066a2be97a9245fe6/images/1a84e7b92f46b6b0888fd7ca9ed9b7df.png'],[],['|  |\n|  |\n| RA4 Series |'],"{'title': 'Correct Connections for VCL pin on RA4M2 MCUs', 'url': 'https://en-support.renesas.com/knowledgeBase/20344994', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:13.657895'}","Question How to I connect the VCL pin on RA4M2 MCUs? Answer You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says ""Connect this pin to the VSS pin by the smoothing capacitor used to stabilize the internal power supply"", you might think that you connect VCL to Vss right next to the main decoupling capacitor. This would be incorrect. The Hardware User Manual, section 45 shows more clearly what to do- connect VCL to a capacitor that then connects to VSS- as seen in the right side of the below diagram. You might be confused on what to do with the VCL pin when reading the datasheet. Section 1.5 says Suitable Products RA4 Series",
715bc382a76f4e386a2c65056d73e6d4,"This article details how to use the RA6T2 16-bit ADC to apply the sample-and-hold function for AD sampling in hybrid mode, as well as the specific application of the background function. In this article, we use FSP to build an application project, explain in detail how to set the operation time of each part of the ADC module according to the data sheet, and show the measured results. The application uses FSP4.0.0 to generate the main code framework, which is easily portable.
1. Introduction to Hybrid mode
1.1 The RA6T2 16-bit ADC can operate in both Oversampling and Hybrid modes, but the ADC conversion process is slower when the oversampling single sweep function is used. Therefore, when the ADC conversion time is required to be fast, it is recommended that the Scan Mode be set to Continuous Scan and the Conversion Method be set to Hybrid Mode as shown below.
1.2 In this example, AN003, AN005, AN007, and AN008 are selected as the signal acquisition ports.
See the RA6T2 data sheet, ADC Channel Affiliation and Functional Design:
AN003 and AN005 of the ADC0 unit and AN007 and AN008 of the ADC1 unit can be set to sample-and-hold
For specific FSP settings, please refer to the picture and pay attention to the settings of virtual2 and virtual5.
For the specific group mode FSP, please see the below properties windows.
    According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below.
  According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below.
1) Start by setting the tAD_SPL time
  2) Set the tSH_D time
  3) Set the tAD_CNV time
  4) Set the sample-and-hold function time
  After the above settings are completed, the project is established.
1.3 The following is the actual measurement of the AD sampling process, confirmed as per Figure 36.56 on page 1559 of the data sheet.
  In this mode, the processing time of each AD conversion is as follows:
tSH_D +tSH_SPL+ tSH_HLD+tAD_SPL+ tAD_CNV* 2+ tADDP
=2 +25+4+7+11* 2 + 9 + 5=81 (ADCLK),
When we selected a 60MHz clock, the time was around 1.35us.
In the actual test, we measured the ADC conversion time by flipping the I/O port in the ADC End Transition Interrupt adc_b_adi0_isr. As shown in the figure below, the port rollover time is 1.44us.
The additional test is 0.084us for the individual rollover port time, that is, the actual ADC conversion time is (1.44us-0.084us =) 1.356us. This result shows that the data sheet is consistent with the FSP actual engineering test results.

2. Explanation of the specific application of the background mode function in hybrid mode
The background mode can be set to trigger at a specific moment to output the current AD sampling result.
2.1 Set the ADC Conversion Method to Hybrid Mode and Scan Mode to Background Continuous Scan (Hybrid Conversion Method Only)
This test was conducted using the official Renesas model MCK-RA6T2, please refer to the MCK-RA6T2 User's Manual (renesas.com) for details. The experiment was designed based on 4 ADC channels and divided into two groups. And enable the end interrupt of ADC0 and output an I/O signal to test the end time of the ADC.
  Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4.
When a comparison match occurs, set the GTIOC4A output signal to assist in confirming the ADC time.
  In the GPT4 Comparison Match interrupt program, we make the PE11 output high,
  void gpt_capture_a_isr (void)
{
  .....
  g_ioport.p_api->pinWrite(g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_HIGH);
  .....
}
  In the ADC0 end interrupt, we make the PE11 output low
  void adc_b_adi0_isr (void)
{
.....
g_ioport.p_api->pinWrite (g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_LOW);
.....
}
  Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output.
The working principle of Hybrid background mode is shown in the following figure:
  As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below.
Total elapsed time = (trigger duration) + (data output time) = tD_ADST + tADD= tD_TRG + tD_ITRG + tD_SYOP = (1+3+1+3+0+9) * ADCLK+5* PCLKA= 0.283+0.042=0.322us.
Thus the theoretical calculations are basically consistent with the actual test results.
  Suitable Products
RA6T2
This article details how to use the RA6T2 16-bit ADC to apply the sample-and-hold function for AD sampling in hybrid mode, as well as the specific application of the background function. In this article, we use FSP to build an application project, explain in detail how to set the operation time of each part of the ADC module according to the data sheet, and show the measured results. The application uses FSP4.0.0 to generate the main code framework, which is easily portable.
1. Introduction to Hybrid mode
1.1 The RA6T2 16-bit ADC can operate in both Oversampling and Hybrid modes, but the ADC conversion process is slower when the oversampling single sweep function is used. Therefore, when the ADC conversion time is required to be fast, it is recommended that the Scan Mode be set to Continuous Scan and the Conversion Method be set to Hybrid Mode as shown below.
1.2 In this example, AN003, AN005, AN007, and AN008 are selected as the signal acquisition ports.
See the RA6T2 data sheet, ADC Channel Affiliation and Functional Design:
AN003 and AN005 of the ADC0 unit and AN007 and AN008 of the ADC1 unit can be set to sample-and-hold
For specific FSP settings, please refer to the picture and pay attention to the settings of virtual2 and virtual5.
For the specific group mode FSP, please see the below properties windows.
    According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below.
  According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below.
1) Start by setting the tAD_SPL time
  2) Set the tSH_D time
  3) Set the tAD_CNV time
  4) Set the sample-and-hold function time
  After the above settings are completed, the project is established.
1.3 The following is the actual measurement of the AD sampling process, confirmed as per Figure 36.56 on page 1559 of the data sheet.
  In this mode, the processing time of each AD conversion is as follows:
tSH_D +tSH_SPL+ tSH_HLD+tAD_SPL+ tAD_CNV* 2+ tADDP
=2 +25+4+7+11* 2 + 9 + 5=81 (ADCLK),
When we selected a 60MHz clock, the time was around 1.35us.
In the actual test, we measured the ADC conversion time by flipping the I/O port in the ADC End Transition Interrupt adc_b_adi0_isr. As shown in the figure below, the port rollover time is 1.44us.
The additional test is 0.084us for the individual rollover port time, that is, the actual ADC conversion time is (1.44us-0.084us =) 1.356us. This result shows that the data sheet is consistent with the FSP actual engineering test results.

2. Explanation of the specific application of the background mode function in hybrid mode
The background mode can be set to trigger at a specific moment to output the current AD sampling result.
2.1 Set the ADC Conversion Method to Hybrid Mode and Scan Mode to Background Continuous Scan (Hybrid Conversion Method Only)
This test was conducted using the official Renesas model MCK-RA6T2, please refer to the MCK-RA6T2 User's Manual (renesas.com) for details. The experiment was designed based on 4 ADC channels and divided into two groups. And enable the end interrupt of ADC0 and output an I/O signal to test the end time of the ADC.
  Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4.
When a comparison match occurs, set the GTIOC4A output signal to assist in confirming the ADC time.
  In the GPT4 Comparison Match interrupt program, we make the PE11 output high,
  void gpt_capture_a_isr (void)
{
  .....
  g_ioport.p_api->pinWrite(g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_HIGH);
  .....
}
  In the ADC0 end interrupt, we make the PE11 output low
  void adc_b_adi0_isr (void)
{
.....
g_ioport.p_api->pinWrite (g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_LOW);
.....
}
  Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output.
The working principle of Hybrid background mode is shown in the following figure:
  As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below.
Total elapsed time = (trigger duration) + (data output time) = tD_ADST + tADD= tD_TRG + tD_ITRG + tD_SYOP = (1+3+1+3+0+9) * ADCLK+5* PCLKA= 0.283+0.042=0.322us.
Thus the theoretical calculations are basically consistent with the actual test results.
  Suitable Products
RA6T2
This article details how to use the RA6T2 16-bit ADC to apply the sample-and-hold function for AD sampling in hybrid mode, as well as the specific application of the background function. In this article, we use FSP to build an application project, explain in detail how to set the operation time of each part of the ADC module according to the data sheet, and show the measured results. The application uses FSP4.0.0 to generate the main code framework, which is easily portable.
1. Introduction to Hybrid mode
1.1 The RA6T2 16-bit ADC can operate in both Oversampling and Hybrid modes, but the ADC conversion process is slower when the oversampling single sweep function is used. Therefore, when the ADC conversion time is required to be fast, it is recommended that the Scan Mode be set to Continuous Scan and the Conversion Method be set to Hybrid Mode as shown below.
1.2 In this example, AN003, AN005, AN007, and AN008 are selected as the signal acquisition ports.
See the RA6T2 data sheet, ADC Channel Affiliation and Functional Design:
AN003 and AN005 of the ADC0 unit and AN007 and AN008 of the ADC1 unit can be set to sample-and-hold
For specific FSP settings, please refer to the picture and pay attention to the settings of virtual2 and virtual5.
For the specific group mode FSP, please see the below properties windows.
    According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below.
  According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below.
1) Start by setting the tAD_SPL time
  2) Set the tSH_D time
  3) Set the tAD_CNV time
  4) Set the sample-and-hold function time
  After the above settings are completed, the project is established.
1.3 The following is the actual measurement of the AD sampling process, confirmed as per Figure 36.56 on page 1559 of the data sheet.
  In this mode, the processing time of each AD conversion is as follows:
tSH_D +tSH_SPL+ tSH_HLD+tAD_SPL+ tAD_CNV* 2+ tADDP
=2 +25+4+7+11* 2 + 9 + 5=81 (ADCLK),
When we selected a 60MHz clock, the time was around 1.35us.
In the actual test, we measured the ADC conversion time by flipping the I/O port in the ADC End Transition Interrupt adc_b_adi0_isr. As shown in the figure below, the port rollover time is 1.44us.
The additional test is 0.084us for the individual rollover port time, that is, the actual ADC conversion time is (1.44us-0.084us =) 1.356us. This result shows that the data sheet is consistent with the FSP actual engineering test results.

2. Explanation of the specific application of the background mode function in hybrid mode
The background mode can be set to trigger at a specific moment to output the current AD sampling result.
2.1 Set the ADC Conversion Method to Hybrid Mode and Scan Mode to Background Continuous Scan (Hybrid Conversion Method Only)
This test was conducted using the official Renesas model MCK-RA6T2, please refer to the MCK-RA6T2 User's Manual (renesas.com) for details. The experiment was designed based on 4 ADC channels and divided into two groups. And enable the end interrupt of ADC0 and output an I/O signal to test the end time of the ADC.
  Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4.
When a comparison match occurs, set the GTIOC4A output signal to assist in confirming the ADC time.
  In the GPT4 Comparison Match interrupt program, we make the PE11 output high,
  void gpt_capture_a_isr (void)
{
  .....
  g_ioport.p_api->pinWrite(g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_HIGH);
  .....
}
  In the ADC0 end interrupt, we make the PE11 output low
  void adc_b_adi0_isr (void)
{
.....
g_ioport.p_api->pinWrite (g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_LOW);
.....
}
  Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output.
The working principle of Hybrid background mode is shown in the following figure:
  As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below.
Total elapsed time = (trigger duration) + (data output time) = tD_ADST + tADD= tD_TRG + tD_ITRG + tD_SYOP = (1+3+1+3+0+9) * ADCLK+5* PCLKA= 0.283+0.042=0.322us.
Thus the theoretical calculations are basically consistent with the actual test results.
This article details how to use the RA6T2 16-bit ADC to apply the sample-and-hold function for AD sampling in hybrid mode, as well as the specific application of the background function. In this article, we use FSP to build an application project, explain in detail how to set the operation time of each part of the ADC module according to the data sheet, and show the measured results. The application uses FSP4.0.0 to generate the main code framework, which is easily portable.
1. Introduction to Hybrid mode
1.1 The RA6T2 16-bit ADC can operate in both Oversampling and Hybrid modes, but the ADC conversion process is slower when the oversampling single sweep function is used. Therefore, when the ADC conversion time is required to be fast, it is recommended that the Scan Mode be set to Continuous Scan and the Conversion Method be set to Hybrid Mode as shown below.
1.2 In this example, AN003, AN005, AN007, and AN008 are selected as the signal acquisition ports.
See the RA6T2 data sheet, ADC Channel Affiliation and Functional Design:
AN003 and AN005 of the ADC0 unit and AN007 and AN008 of the ADC1 unit can be set to sample-and-hold
For specific FSP settings, please refer to the picture and pay attention to the settings of virtual2 and virtual5.
For the specific group mode FSP, please see the below properties windows.
According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below.
According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below.
1) Start by setting the tAD_SPL time
2) Set the tSH_D time
3) Set the tAD_CNV time
4) Set the sample-and-hold function time
After the above settings are completed, the project is established.
1.3 The following is the actual measurement of the AD sampling process, confirmed as per Figure 36.56 on page 1559 of the data sheet.
In this mode, the processing time of each AD conversion is as follows:
tSH_D +tSH_SPL+ tSH_HLD+tAD_SPL+ tAD_CNV* 2+ tADDP
=2 +25+4+7+11* 2 + 9 + 5=81 (ADCLK),
When we selected a 60MHz clock, the time was around 1.35us.
In the actual test, we measured the ADC conversion time by flipping the I/O port in the ADC End Transition Interrupt adc_b_adi0_isr. As shown in the figure below, the port rollover time is 1.44us.
The additional test is 0.084us for the individual rollover port time, that is, the actual ADC conversion time is (1.44us-0.084us =) 1.356us. This result shows that the data sheet is consistent with the FSP actual engineering test results.
2. Explanation of the specific application of the background mode function in hybrid mode
The background mode can be set to trigger at a specific moment to output the current AD sampling result.
2.1 Set the ADC Conversion Method to Hybrid Mode and Scan Mode to Background Continuous Scan (Hybrid Conversion Method Only)
This test was conducted using the official Renesas model MCK-RA6T2, please refer to the MCK-RA6T2 User's Manual (renesas.com) for details. The experiment was designed based on 4 ADC channels and divided into two groups. And enable the end interrupt of ADC0 and output an I/O signal to test the end time of the ADC.
Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4.
When a comparison match occurs, set the GTIOC4A output signal to assist in confirming the ADC time.
In the GPT4 Comparison Match interrupt program, we make the PE11 output high,
void gpt_capture_a_isr (void)
{
  .....
  g_ioport.p_api->pinWrite(g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_HIGH);
  .....
}
In the ADC0 end interrupt, we make the PE11 output low
void adc_b_adi0_isr (void)
{
.....
g_ioport.p_api->pinWrite (g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_LOW);
.....
}
Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output.
The working principle of Hybrid background mode is shown in the following figure:
As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below.
Total elapsed time = (trigger duration) + (data output time) = tD_ADST + tADD= tD_TRG + tD_ITRG + tD_SYOP = (1+3+1+3+0+9) * ADCLK+5* PCLKA= 0.283+0.042=0.322us.
Thus the theoretical calculations are basically consistent with the actual test results.
Suitable Products
RA6T2

","['data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/3a0957dd56a5f4dc4affb67f432e4a87.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/3165e2cd0e4182abe24cd8c7ae647814.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/82ef6aef27dbcc20a92fcd2d2390ba7d.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/bd4eddd03b2c9e050b276ab93d6f4824.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/9fbf744eb425c124a74a6959fec81c2e.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/679fbca67a3ecb13fcf07da80bffb057.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/47418356fe8422c99be03a03f4e0719b.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/b10c35dc45bbc07bd796b22cbebaf25a.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/c69d29b39791acc278dd502c16dbff24.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/21e6552802c7c66f368ac74e8cae646a.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/52b2e1200bb78bb57a5665a0d595d97d.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/8e6afa1e2d8534d1a946bd53e4336bee.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/75b401d624183a94fcbaade4f4f53128.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/4453e16fe59b8d21f42b48378c37c5a7.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/ea710b319ae163c8a423fc272022b5cf.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/9f87324aa9c332bba068b36de422a6e5.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/609aad12438d56dfe72118510d8564ac.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/43b9e9242d92f26bf334f52ff7e3c67a.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/c3b50e708f05622eb841a5ef3a872369.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/61398bb02ec2ed3ab223381996c79f13.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/d25daaef161876f30cde09a115929e13.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/cb01fa7ac9ba0544f30b2a813585606c.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/ebd19128a51e02f4fb3ca4fb2366528b.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/b9182bccfd7a4e088e77fac8070e909c.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/c85bbb3987d6504f57c0ea141686cd50.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/a8edf34e1f6a98a46bf06ea22e7c88f5.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/d752eeb5eb3e86ddaaad51725c0258ad.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/73f64e14e80b9c156461508582d8aa77.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/e5b7edbe75dec852083d62c135102459.jpg', 'data/categories/ra_family/ra_and_fsp_technical_articles/715bc382a76f4e386a2c65056d73e6d4/images/0f3f650492498ad8d2b313c9127361ac.png']",[],"['|  |\n|  |\n| void gpt_capture_a_isr (void)\n{\n  .....\n  g_ioport.p_api->pinWrite(g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_HIGH);\n  .....\n} |', '|  |\n|  |\n| void adc_b_adi0_isr (void)\n{\n.....\ng_ioport.p_api->pinWrite (g_ioport.p_ctrl,BSP_IO_PORT_14_PIN_11,BSP_IO_LEVEL_LOW);\n.....\n} |', '|  |\n|  |\n| RA6T2 |']","{'title': 'A detailed explanation of the RA6T2 16-bit ADC mixed sampling mode application', 'url': 'https://en-support.renesas.com/knowledgeBase/21246525', 'last_updated': None, 'extracted_at': '2025-03-08T23:12:45.052299'}","This article details how to use the RA6T2 16-bit ADC to apply the sample-and-hold function for AD sampling in hybrid mode, as well as the specific application of the background function. In this article, we use FSP to build an application project, explain in detail how to set the operation time of each part of the ADC module according to the data sheet, and show the measured results. The application uses FSP4.0.0 to generate the main code framework, which is easily portable. 1. Introduction to Hybrid mode 1.1 The RA6T2 16-bit ADC can operate in both Oversampling and Hybrid modes, but the ADC conversion process is slower when the oversampling single sweep function is used. Therefore, when the ADC conversion time is required to be fast, it is recommended that the Scan Mode be set to Continuous Scan and the Conversion Method be set to Hybrid Mode as shown below. 1.2 In this example, AN003, AN005, AN007, and AN008 are selected as the signal acquisition ports. See the RA6T2 data sheet, ADC Channel Affiliation and Functional Design AN003 and AN005 of the ADC0 unit and AN007 and AN008 of the ADC1 unit can be set to sample-and-hold For specific FSP settings, please refer to the picture and pay attention to the settings of virtual2 and virtual5. For the specific group mode FSP, please see the below properties windows. According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below. According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below. 1) Start by setting the tADSPL time 2) Set the tSHD time 3) Set the tADCNV time 4) Set the sample-and-hold function time After the above settings are completed, the project is established. 1.3 The following is the actual measurement of the AD sampling process, confirmed as per Figure 36.56 on page 1559 of the data sheet. In this mode, the processing time of each AD conversion is as follows tSHD tSHSPL tSHHLDtADSPL tADCNV 2 tADDP 2 254711 2  9  581 (ADCLK), When we selected a 60MHz clock, the time was around 1.35us. In the actual test, we measured the ADC conversion time by flipping the I/O port in the ADC End Transition Interrupt adcbadi0isr. As shown in the figure below, the port rollover time is 1.44us. The additional test is 0.084us for the individual rollover port time, that is, the actual ADC conversion time is (1.44us-0.084us ) 1.356us. This result shows that the data sheet is consistent with the FSP actual engineering test results. 2. Explanation of the specific application of the background mode function in hybrid mode The background mode can be set to trigger at a specific moment to output the current AD sampling result. 2.1 Set the ADC Conversion Method to Hybrid Mode and Scan Mode to Background Continuous Scan (Hybrid Conversion Method Only) This test was conducted using the official Renesas model MCK-RA6T2, please refer to the MCK-RA6T2 User's Manual (renesas.com) for details. The experiment was designed based on 4 ADC channels and divided into two groups. And enable the end interrupt of ADC0 and output an I/O signal to test the end time of the ADC. Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4. When a comparison match occurs, set the GTIOC4A output signal to assist in confirming the ADC time. In the GPT4 Comparison Match interrupt program, we make the PE11 output high, void gptcaptureaisr (void)  ..... gioport.papi-pinWrite(gioport.pctrl,BSPIOPORT14PIN11,BSPIOLEVELHIGH);  In the ADC0 end interrupt, we make the PE11 output low void adcbadi0isr (void) ..... gioport.papi-pinWrite (gioport.pctrl,BSPIOPORT14PIN11,BSPIOLEVELLOW); Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output. The working principle of Hybrid background mode is shown in the following figure As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below. Total elapsed time  (trigger duration)  (data output time)  tDADST  tADD tDTRG  tDITRG  tDSYOP  (131309)  ADCLK5 PCLKA 0.2830.0420.322us. Thus the theoretical calculations are basically consistent with the actual test results. Suitable Products RA6T2 According to data sheet Section 36.9 Scan Conversion Time, the AD conversion time in this mode should be added as seen in the yellow highlight below. According to data sheet Section 46.4 A/D Converter Characteristics, set the highlighted characteristics above as shown in the steps below. 2) Set the tSHD time 3) Set the tADCNV time 4) Set the sample-and-hold function time After the above settings are completed, the project is established. In this mode, the processing time of each AD conversion is as follows Using the ELC function, the comparison match between the ADC12A0 and GPT4 is linked, and the ADC is triggered when the comparison match occurs on GPT4. In the GPT4 Comparison Match interrupt program, we make the PE11 output high, void gptcaptureaisr (void) In the ADC0 end interrupt, we make the PE11 output low void adcbadi0isr (void) Tested with an oscilloscope, the AD conversion time was 0.39us. As shown in the figure below, green is the GPT4 comparison matching output, and purple is the PE11 output. As detailed in Table 36.55, Table 36.56, and Figure 36.55 in the data sheet, when the ADCLK is set to 60MHz, the theoretical calculation time of this action process is computed as shown below. Suitable Products ",
0b441b2f3da18a0e27fe2a3d466172f7,"Issue:
Some Renesas Cortex-M33 MCUs are equipped with two caches to improve performance. The c-cache is on the instruction bus and the s-cache is on the data bus, between the Cortex-M33 and AHB bus matrix. When the s-cache is enabled, users may experience communication failures with such as:
External QSPI memory
External OSPI memory
Shared memory with CPU in SRAM (Ethernet, Segger RTT viewer)
Answers:
There are two ways to solve this issue:
Use the s-cache flush (invalidate/clean) command.
Use the MPU (Memory protection unit).
For more information about s-cache flush usage, cache coherency issues with DMA/DTC, and MPU, please refer to the links below.
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the Description at the bottom of this article for details on each MPU setting. 
The following defines are to be commonly used in all 3 cases to be explained.
#define CTRL_PV 1
#define CTRL_HN 1
#define ARM_MPU_CTRL(PV, HN) \
  (((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \
  ((HN) << MPU_CTRL_HFNMIENA_Pos))
  #define MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04
#define MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0
#define MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA
#define MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1
#define MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF
#define MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3

(1) External QSPI memory
Use the code below to disable the s-cache on QSPI memory locations. If your MCU has a different address map for QSPI, please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
0x6000 0000 - 0x63FF FFFF : External SPI device
0x6400 0000 - 0x67FF FFFF : QSPI I/O registers
const ARM_MPU_Region_t mpuTable[2] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                        LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
      //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }
};
  void mpu_config_quadspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_quadspi();
enable_s_cache();
  qspi_init();
    while(1)
  {
  (2) External OSPI memory
Use the code below to disable the s-cache on OSPI area. If your MCU has a different address map for OSPI, please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
0x6800 0000 - 0x6FFF FFFF : CS0
0x7000 0000 - 0x7FFF FFFF : CS1
void mpu_config_octaspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_octaspi();
enable_s_cache();
  ospi_init();
    while(1)
  {
  (3) Shared memory with CPU in SRAM
Ethernet (EDMAC)
Use the code below to disable the s-cache on the EDMAC descriptors and buffers area. The default linker script of the e2 studio project places the EDMAC descriptors and buffers in the "".ns_buffer.eth"" section, and these addresses are likely to change with code changes. Therefore, change the addresses of ARM_MPU_RBAR and ARM_MPU_RLAR accordingly, or place the EDMAC descriptors and buffers in a section with fixed address.
Figure.1 Memory map file snippet (EDMAC)
With the given memory map file snippet example above, the memory area covering EDMAC descriptors and buffers will be:
Start address: 0x2003 CF80
End address: 0x2003 FFFF (0x2003CF80 + 0x3080  1)
Please note that MPU addresses should be aligned in multiples of 32-byte.
const ARM_MPU_Region_t mpuTable[1] = {
    //                       BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                       LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_eth(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_eth();
enable_s_cache();
    while(1)
  {
  Segger RTT Viewer
Use the code below to disable the s-cache on the Segger RTT area. The Segger RTT uses some of user SRAM to output debug information, and receive input from the user. The start and end addresses for the 3 regions below can be found in the memory map file after compilation of your project, so please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
.bss._SEGGER_RTT
.bss._acUpBuffer
.bss._acDownBuffer
Figure.2 Memory map file snippet (Segger RTT Viewer)
With the given memory map file snippet example above, the memory area covering all 3 regions will be:
Start address: 0x2000 01D4
End address: 0x2000 128B
MPU addresses should be aligned in multiples of 32-byte, so
Start address: 0x2000 01C0
End address: 0x2000 129F
const ARM_MPU_Region_t mpuTable[1] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_rtt(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_rtt();
enable_s_cache();
  SEGGER_RTT_printf(HELLO);
    while(1)
  {
  Arm Cortex-M33 Processor Technical Reference Manual
https://documentation-service.arm.com/static/5f15c42420b7cf4bc5247f3a
Armv8-M Architecture Reference Manual
https://documentation-service.arm.com/static/5f8efe85f86e16515cdbe596
Guidelines for Using the S Cache on the System Bus
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
Suitable Products
RA Family
Some Renesas Cortex-M33 MCUs are equipped with two caches to improve performance. The c-cache is on the instruction bus and the s-cache is on the data bus, between the Cortex-M33 and AHB bus matrix. When the s-cache is enabled, users may experience communication failures with such as:
Answers:
There are two ways to solve this issue:
Use the s-cache flush (invalidate/clean) command.
Use the MPU (Memory protection unit).
For more information about s-cache flush usage, cache coherency issues with DMA/DTC, and MPU, please refer to the links below.
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the Description at the bottom of this article for details on each MPU setting. 
The following defines are to be commonly used in all 3 cases to be explained.
#define CTRL_PV 1
#define CTRL_HN 1
#define ARM_MPU_CTRL(PV, HN) \
  (((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \
  ((HN) << MPU_CTRL_HFNMIENA_Pos))
  #define MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04
#define MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0
#define MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA
#define MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1
#define MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF
#define MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3

(1) External QSPI memory
Use the code below to disable the s-cache on QSPI memory locations. If your MCU has a different address map for QSPI, please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
0x6000 0000 - 0x63FF FFFF : External SPI device
0x6400 0000 - 0x67FF FFFF : QSPI I/O registers
const ARM_MPU_Region_t mpuTable[2] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                        LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
      //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }
};
  void mpu_config_quadspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_quadspi();
enable_s_cache();
  qspi_init();
    while(1)
  {
  (2) External OSPI memory
Use the code below to disable the s-cache on OSPI area. If your MCU has a different address map for OSPI, please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
0x6800 0000 - 0x6FFF FFFF : CS0
0x7000 0000 - 0x7FFF FFFF : CS1
void mpu_config_octaspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_octaspi();
enable_s_cache();
  ospi_init();
    while(1)
  {
  (3) Shared memory with CPU in SRAM
Ethernet (EDMAC)
Use the code below to disable the s-cache on the EDMAC descriptors and buffers area. The default linker script of the e2 studio project places the EDMAC descriptors and buffers in the "".ns_buffer.eth"" section, and these addresses are likely to change with code changes. Therefore, change the addresses of ARM_MPU_RBAR and ARM_MPU_RLAR accordingly, or place the EDMAC descriptors and buffers in a section with fixed address.
Figure.1 Memory map file snippet (EDMAC)
With the given memory map file snippet example above, the memory area covering EDMAC descriptors and buffers will be:
Start address: 0x2003 CF80
End address: 0x2003 FFFF (0x2003CF80 + 0x3080  1)
Please note that MPU addresses should be aligned in multiples of 32-byte.
const ARM_MPU_Region_t mpuTable[1] = {
    //                       BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                       LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_eth(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_eth();
enable_s_cache();
    while(1)
  {
  Segger RTT Viewer
Use the code below to disable the s-cache on the Segger RTT area. The Segger RTT uses some of user SRAM to output debug information, and receive input from the user. The start and end addresses for the 3 regions below can be found in the memory map file after compilation of your project, so please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
.bss._SEGGER_RTT
.bss._acUpBuffer
.bss._acDownBuffer
Figure.2 Memory map file snippet (Segger RTT Viewer)
With the given memory map file snippet example above, the memory area covering all 3 regions will be:
Start address: 0x2000 01D4
End address: 0x2000 128B
MPU addresses should be aligned in multiples of 32-byte, so
Start address: 0x2000 01C0
End address: 0x2000 129F
const ARM_MPU_Region_t mpuTable[1] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_rtt(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_rtt();
enable_s_cache();
  SEGGER_RTT_printf(HELLO);
    while(1)
  {
  Arm Cortex-M33 Processor Technical Reference Manual
https://documentation-service.arm.com/static/5f15c42420b7cf4bc5247f3a
Armv8-M Architecture Reference Manual
https://documentation-service.arm.com/static/5f8efe85f86e16515cdbe596
Guidelines for Using the S Cache on the System Bus
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
Suitable Products
RA Family
There are two ways to solve this issue:
Use the s-cache flush (invalidate/clean) command.
Use the MPU (Memory protection unit).
For more information about s-cache flush usage, cache coherency issues with DMA/DTC, and MPU, please refer to the links below.
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the Description at the bottom of this article for details on each MPU setting. 
The following defines are to be commonly used in all 3 cases to be explained.
#define CTRL_PV 1
#define CTRL_HN 1
#define ARM_MPU_CTRL(PV, HN) \
  (((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \
  ((HN) << MPU_CTRL_HFNMIENA_Pos))
  #define MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04
#define MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0
#define MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA
#define MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1
#define MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF
#define MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3

(1) External QSPI memory
Use the code below to disable the s-cache on QSPI memory locations. If your MCU has a different address map for QSPI, please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
0x6000 0000 - 0x63FF FFFF : External SPI device
0x6400 0000 - 0x67FF FFFF : QSPI I/O registers
const ARM_MPU_Region_t mpuTable[2] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                        LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
      //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }
};
  void mpu_config_quadspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_quadspi();
enable_s_cache();
  qspi_init();
    while(1)
  {
  (2) External OSPI memory
Use the code below to disable the s-cache on OSPI area. If your MCU has a different address map for OSPI, please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
0x6800 0000 - 0x6FFF FFFF : CS0
0x7000 0000 - 0x7FFF FFFF : CS1
void mpu_config_octaspi(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 2);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_octaspi();
enable_s_cache();
  ospi_init();
    while(1)
  {
  (3) Shared memory with CPU in SRAM
Ethernet (EDMAC)
Use the code below to disable the s-cache on the EDMAC descriptors and buffers area. The default linker script of the e2 studio project places the EDMAC descriptors and buffers in the "".ns_buffer.eth"" section, and these addresses are likely to change with code changes. Therefore, change the addresses of ARM_MPU_RBAR and ARM_MPU_RLAR accordingly, or place the EDMAC descriptors and buffers in a section with fixed address.
Figure.1 Memory map file snippet (EDMAC)
With the given memory map file snippet example above, the memory area covering EDMAC descriptors and buffers will be:
Start address: 0x2003 CF80
End address: 0x2003 FFFF (0x2003CF80 + 0x3080  1)
Please note that MPU addresses should be aligned in multiples of 32-byte.
const ARM_MPU_Region_t mpuTable[1] = {
    //                       BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                       LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_eth(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_eth();
enable_s_cache();
    while(1)
  {
  Segger RTT Viewer
Use the code below to disable the s-cache on the Segger RTT area. The Segger RTT uses some of user SRAM to output debug information, and receive input from the user. The start and end addresses for the 3 regions below can be found in the memory map file after compilation of your project, so please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
.bss._SEGGER_RTT
.bss._acUpBuffer
.bss._acDownBuffer
Figure.2 Memory map file snippet (Segger RTT Viewer)
With the given memory map file snippet example above, the memory area covering all 3 regions will be:
Start address: 0x2000 01D4
End address: 0x2000 128B
MPU addresses should be aligned in multiples of 32-byte, so
Start address: 0x2000 01C0
End address: 0x2000 129F
const ARM_MPU_Region_t mpuTable[1] = {
    //                         BASE          SH              RO   NP   XN
    { .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
    //                         LIMIT         ATTR
      .RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
  void mpu_config_rtt(void)
{
ARM_MPU_Disable();
    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
    ARM_MPU_Load(0, mpuTable, 1);
    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
  void hal_entry(void)
{
  mpu_config_rtt();
enable_s_cache();
  SEGGER_RTT_printf(HELLO);
    while(1)
  {
  Arm Cortex-M33 Processor Technical Reference Manual
https://documentation-service.arm.com/static/5f15c42420b7cf4bc5247f3a
Armv8-M Architecture Reference Manual
https://documentation-service.arm.com/static/5f8efe85f86e16515cdbe596
Guidelines for Using the S Cache on the System Bus
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
There are two ways to solve this issue:
For more information about s-cache flush usage, cache coherency issues with DMA/DTC, and MPU, please refer to the links below.
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the Description at the bottom of this article for details on each MPU setting.
The following defines are to be commonly used in all 3 cases to be explained.
#define CTRL_PV 1
#define
CTRL_PV 1
#define CTRL_HN 1
#define
CTRL_HN 1
#define ARM_MPU_CTRL(PV, HN) \
#define
ARM_MPU_CTRL(PV, HN) \
(((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \
(((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \
((HN) << MPU_CTRL_HFNMIENA_Pos))
((HN) << MPU_CTRL_HFNMIENA_Pos))
#define MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04
#define
MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04
#define MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0
#define
MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0
#define MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA
#define
MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA
#define MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1
#define
MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1
#define MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF
#define
MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF
#define MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2
#define
MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44
#define
MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44
#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3
#define
MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3
(1) External QSPI memory
Use the code below to disable the s-cache on QSPI memory locations. If your MCU has a different address map for QSPI, please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
0x6000 0000 - 0x63FF FFFF : External SPI device
0x6400 0000 - 0x67FF FFFF : QSPI I/O registers
const ARM_MPU_Region_t mpuTable[2] = {
const
ARM_MPU_Region_t
mpuTable[2] = {
//                         BASE          SH              RO   NP   XN
//                         BASE          SH              RO   NP   XN
{ .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
{ .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
//                        LIMIT         ATTR
//                        LIMIT         ATTR
.RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
.RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
//                         BASE          SH              RO   NP   XN
//                         BASE          SH              RO   NP   XN
{ .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
{ .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
//                         LIMIT         ATTR
//                         LIMIT         ATTR
.RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }
.RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }
};
};
void mpu_config_quadspi(void)
void
mpu_config_quadspi(
void
)
{
{
ARM_MPU_Disable();
ARM_MPU_Disable();
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_Load(0, mpuTable, 2);
ARM_MPU_Load(0, mpuTable, 2);
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
}
void hal_entry(void)
void
hal_entry(
void
)
{
{
mpu_config_quadspi();
mpu_config_quadspi();
enable_s_cache();
enable_s_cache();
qspi_init();
qspi_init();
while(1)
while
(1)
{
(2) External OSPI memory
Use the code below to disable the s-cache on OSPI area. If your MCU has a different address map for OSPI, please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
0x6800 0000 - 0x6FFF FFFF : CS0
0x7000 0000 - 0x7FFF FFFF : CS1
void mpu_config_octaspi(void)
void
mpu_config_octaspi(
void
)
{
{
ARM_MPU_Disable();
ARM_MPU_Disable();
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_Load(0, mpuTable, 2);
ARM_MPU_Load(0, mpuTable, 2);
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
}
void hal_entry(void)
void
hal_entry(
void
)
{
{
mpu_config_octaspi();
mpu_config_octaspi();
enable_s_cache();
enable_s_cache();
ospi_init();
ospi_init();
while(1)
while
(1)
{
(3) Shared memory with CPU in SRAM
Ethernet (EDMAC)
Use the code below to disable the s-cache on the EDMAC descriptors and buffers area. The default linker script of the e2 studio project places the EDMAC descriptors and buffers in the "".ns_buffer.eth"" section, and these addresses are likely to change with code changes. Therefore, change the addresses of ARM_MPU_RBAR and ARM_MPU_RLAR accordingly, or place the EDMAC descriptors and buffers in a section with fixed address.
Figure.1 Memory map file snippet (EDMAC)
With the given memory map file snippet example above, the memory area covering EDMAC descriptors and buffers will be:
Start address: 0x2003 CF80
End address: 0x2003 FFFF (0x2003CF80 + 0x3080  1)
Please note that MPU addresses should be aligned in multiples of 32-byte.
const ARM_MPU_Region_t mpuTable[1] = {
const
ARM_MPU_Region_t
mpuTable[1] = {
//                       BASE          SH              RO   NP   XN
//                       BASE          SH              RO   NP   XN
{ .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
{ .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
//                       LIMIT         ATTR
//                       LIMIT         ATTR
.RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
.RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
};
void mpu_config_eth(void)
void
mpu_config_eth(
void
)
{
{
ARM_MPU_Disable();
ARM_MPU_Disable();
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_Load(0, mpuTable, 1);
ARM_MPU_Load(0, mpuTable, 1);
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
}
void hal_entry(void)
void
hal_entry(
void
)
{
{
mpu_config_eth();
mpu_config_eth();
enable_s_cache();
enable_s_cache();
while(1)
while
(1)
{
Segger RTT Viewer
Use the code below to disable the s-cache on the Segger RTT area. The Segger RTT uses some of user SRAM to output debug information, and receive input from the user. The start and end addresses for the 3 regions below can be found in the memory map file after compilation of your project, so please change addresses in ARM_MPU_RBAR and ARM_MPU_RLAR accordingly.
.bss._SEGGER_RTT
.bss._acUpBuffer
.bss._acDownBuffer
Figure.2 Memory map file snippet (Segger RTT Viewer)
With the given memory map file snippet example above, the memory area covering all 3 regions will be:
Start address: 0x2000 01D4
End address: 0x2000 128B
MPU addresses should be aligned in multiples of 32-byte, so
Start address: 0x2000 01C0
End address: 0x2000 129F
const ARM_MPU_Region_t mpuTable[1] = {
const
ARM_MPU_Region_t
mpuTable[1] = {
//                         BASE          SH              RO   NP   XN
//                         BASE          SH              RO   NP   XN
{ .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
{ .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),
//                         LIMIT         ATTR
//                         LIMIT         ATTR
.RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
.RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },
};
};
void mpu_config_rtt(void)
void
mpu_config_rtt(
void
)
{
{
ARM_MPU_Disable();
ARM_MPU_Disable();
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);
ARM_MPU_Load(0, mpuTable, 1);
ARM_MPU_Load(0, mpuTable, 1);
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));
}
}
void hal_entry(void)
void
hal_entry(
void
)
{
{
mpu_config_rtt();
mpu_config_rtt();
enable_s_cache();
enable_s_cache();
SEGGER_RTT_printf(HELLO);
SEGGER_RTT_printf(
HELLO
);
while(1)
while
(1)
{
Arm Cortex-M33 Processor Technical Reference Manual
https://documentation-service.arm.com/static/5f15c42420b7cf4bc5247f3a
Armv8-M Architecture Reference Manual
https://documentation-service.arm.com/static/5f8efe85f86e16515cdbe596
Guidelines for Using the S Cache on the System Bus
https://www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus
Suitable Products
RA Family","['data/categories/ra_family/ra_and_fsp_technical_articles/0b441b2f3da18a0e27fe2a3d466172f7/images/79980aa685ea1d6d72e111c70c00cf46.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/0b441b2f3da18a0e27fe2a3d466172f7/images/7c3091d22fb397d570ab025366582248.png']",[],"['|  |\n|  |\n| #define CTRL_PV 1\n#define CTRL_HN 1\n#define ARM_MPU_CTRL(PV, HN) \\\n  (((PV) << MPU_CTRL_PRIVDEFENA_Pos) | \\\n  ((HN) << MPU_CTRL_HFNMIENA_Pos))\n  #define MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL             0x04\n#define MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX             0\n#define MPU_ARMV8M_MAIR_ATTR_CODE_VAL               0xAA\n#define MPU_ARMV8M_MAIR_ATTR_CODE_IDX               1\n#define MPU_ARMV8M_MAIR_ATTR_DATA_VAL               0xFF\n#define MPU_ARMV8M_MAIR_ATTR_DATA_IDX               2\n#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL        0x44\n#define MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX        3 |', '|  |\n|  |\n| const ARM_MPU_Region_t mpuTable[2] = {\n    //                         BASE          SH              RO   NP   XN\n    { .RBAR = ARM_MPU_RBAR(0x60000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),\n    //                        LIMIT         ATTR\n      .RLAR = ARM_MPU_RLAR(0x63FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },\n      //                         BASE          SH              RO   NP   XN\n    { .RBAR = ARM_MPU_RBAR(0x64000000UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),\n    //                         LIMIT         ATTR\n      .RLAR = ARM_MPU_RLAR(0x67FFFFFFUL, MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX) }\n};\n  void mpu_config_quadspi(void)\n{\nARM_MPU_Disable();\n    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);\n    ARM_MPU_Load(0, mpuTable, 2);\n    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));\n}\n  void hal_entry(void)\n{\n  mpu_config_quadspi();\nenable_s_cache();\n  qspi_init();\n    while(1)\n  { |', '|  |\n|  |\n| void mpu_config_octaspi(void)\n{\nARM_MPU_Disable();\n    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);\n    ARM_MPU_Load(0, mpuTable, 2);\n    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));\n}\n  void hal_entry(void)\n{\n  mpu_config_octaspi();\nenable_s_cache();\n  ospi_init();\n    while(1)\n  { |', '|  |\n|  |\n| const ARM_MPU_Region_t mpuTable[1] = {\n    //                       BASE          SH              RO   NP   XN\n    { .RBAR = ARM_MPU_RBAR(0x2003CF80, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),\n    //                       LIMIT         ATTR\n      .RLAR = ARM_MPU_RLAR(0x2003FFFF, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },\n};\n  void mpu_config_eth(void)\n{\nARM_MPU_Disable();\n    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);\n    ARM_MPU_Load(0, mpuTable, 1);\n    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));\n}\n  void hal_entry(void)\n{\n  mpu_config_eth();\nenable_s_cache();\n    while(1)\n  { |', '|  |\n|  |\n| const ARM_MPU_Region_t mpuTable[1] = {\n    //                         BASE          SH              RO   NP   XN\n    { .RBAR = ARM_MPU_RBAR(0x200001C0UL, ARM_MPU_SH_NON, 0UL, 1UL, 1UL),\n    //                         LIMIT         ATTR\n      .RLAR = ARM_MPU_RLAR(0x2000129FUL, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX) },\n};\n  void mpu_config_rtt(void)\n{\nARM_MPU_Disable();\n    ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX, MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_CODE_IDX, MPU_ARMV8M_MAIR_ATTR_CODE_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATA_IDX, MPU_ARMV8M_MAIR_ATTR_DATA_VAL);\n  ARM_MPU_SetMemAttr(MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX, MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL);\n    ARM_MPU_Load(0, mpuTable, 1);\n    ARM_MPU_Enable(ARM_MPU_CTRL(CTRL_PV, CTRL_HN));\n}\n  void hal_entry(void)\n{\n  mpu_config_rtt();\nenable_s_cache();\n  SEGGER_RTT_printf(HELLO);\n    while(1)\n  { |', '|  |\n|  |\n| RA Family |']","{'title': 'RA Family: Potential Issues when s-cache is enabled without MPU configuration in Cortex-M33 MCU', 'url': 'https://en-support.renesas.com/knowledgeBase/20892495', 'last_updated': None, 'extracted_at': '2025-03-08T23:12:51.120380'}","Issue Some Renesas Cortex-M33 MCUs are equipped with two caches to improve performance. The c-cache is on the instruction bus and the s-cache is on the data bus, between the Cortex-M33 and AHB bus matrix. When the s-cache is enabled, users may experience communication failures with such as External QSPI memory External OSPI memory Shared memory with CPU in SRAM (Ethernet, Segger RTT viewer) Answers There are two ways to solve this issue Use the s-cache flush (invalidate/clean) command. Use the MPU (Memory protection unit). For more information about s-cache flush usage, cache coherency issues with DMA/DTC, and MPU, please refer to the links below. https//www.renesas.com/us/en/document/apn/ra-family-guidelines-using-s-cache-system-bus The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the Description at the bottom of this article for details on each MPU setting. The following defines are to be commonly used in all 3 cases to be explained. define CTRLPV 1 define CTRLHN 1 define ARMMPUCTRL(PV, HN)  (((PV)  MPUCTRLPRIVDEFENAPos)   ((HN)  MPUCTRLHFNMIENAPos)) define MPUARMV8MMAIRATTRDEVICEVAL 0x04 define MPUARMV8MMAIRATTRDEVICEIDX 0 define MPUARMV8MMAIRATTRCODEVAL 0xAA define MPUARMV8MMAIRATTRCODEIDX 1 define MPUARMV8MMAIRATTRDATAVAL 0xFF define MPUARMV8MMAIRATTRDATAIDX 2 define MPUARMV8MMAIRATTRDATANOCACHEVAL 0x44 define MPUARMV8MMAIRATTRDATANOCACHEIDX 3 (1) External QSPI memory Use the code below to disable the s-cache on QSPI memory locations. If your MCU has a different address map for QSPI, please change addresses in ARMMPURBAR and ARMMPURLAR accordingly. 0x6000 0000 - 0x63FF FFFF  External SPI device 0x6400 0000 - 0x67FF FFFF  QSPI I/O registers const ARMMPURegiont mpuTable2   // BASE SH RO NP XN  .RBAR  ARMMPURBAR(0x60000000UL, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x63FFFFFFUL, MPUARMV8MMAIRATTRDATANOCACHEIDX) , // BASE SH RO NP XN  .RBAR  ARMMPURBAR(0x64000000UL, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x67FFFFFFUL, MPUARMV8MMAIRATTRDEVICEIDX)  ; void mpuconfigquadspi(void)  ARMMPUDisable(); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDEVICEIDX, MPUARMV8MMAIRATTRDEVICEVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRCODEIDX, MPUARMV8MMAIRATTRCODEVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDATAIDX, MPUARMV8MMAIRATTRDATAVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDATANOCACHEIDX, MPUARMV8MMAIRATTRDATANOCACHEVAL); ARMMPULoad(0, mpuTable, 2); ARMMPUEnable(ARMMPUCTRL(CTRLPV, CTRLHN));  void halentry(void) mpuconfigquadspi(); enablescache(); qspiinit(); while(1)  (2) External OSPI memory Use the code below to disable the s-cache on OSPI area. If your MCU has a different address map for OSPI, please change addresses in ARMMPURBAR and ARMMPURLAR accordingly. 0x6800 0000 - 0x6FFF FFFF  CS0 0x7000 0000 - 0x7FFF FFFF  CS1 void mpuconfigoctaspi(void) mpuconfigoctaspi(); ospiinit(); (3) Shared memory with CPU in SRAM Ethernet (EDMAC) Use the code below to disable the s-cache on the EDMAC descriptors and buffers area. The default linker script of the e2 studio project places the EDMAC descriptors and buffers in the "".nsbuffer.eth"" section, and these addresses are likely to change with code changes. Therefore, change the addresses of ARMMPURBAR and ARMMPURLAR accordingly, or place the EDMAC descriptors and buffers in a section with fixed address. Figure.1 Memory map file snippet (EDMAC) With the given memory map file snippet example above, the memory area covering EDMAC descriptors and buffers will be Start address 0x2003 CF80 End address 0x2003 FFFF (0x2003CF80  0x3080  1) Please note that MPU addresses should be aligned in multiples of 32-byte. const ARMMPURegiont mpuTable1   // BASE SH RO NP XN  .RBAR  ARMMPURBAR(0x2003CF80, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x2003FFFF, MPUARMV8MMAIRATTRDATANOCACHEIDX) , void mpuconfigeth(void) ARMMPULoad(0, mpuTable, 1); mpuconfigeth(); Segger RTT Viewer Use the code below to disable the s-cache on the Segger RTT area. The Segger RTT uses some of user SRAM to output debug information, and receive input from the user. The start and end addresses for the 3 regions below can be found in the memory map file after compilation of your project, so please change addresses in ARMMPURBAR and ARMMPURLAR accordingly. .bss.SEGGERRTT .bss.acUpBuffer .bss.acDownBuffer Figure.2 Memory map file snippet (Segger RTT Viewer) With the given memory map file snippet example above, the memory area covering all 3 regions will be Start address 0x2000 01D4 End address 0x2000 128B MPU addresses should be aligned in multiples of 32-byte, so Start address 0x2000 01C0 End address 0x2000 129F  .RBAR  ARMMPURBAR(0x200001C0UL, ARMMPUSHNON, 0UL, 1UL, 1UL), .RLAR  ARMMPURLAR(0x2000129FUL, MPUARMV8MMAIRATTRDATANOCACHEIDX) , void mpuconfigrtt(void) mpuconfigrtt(); SEGGERRTTprintf(HELLO); Arm Cortex-M33 Processor Technical Reference Manual https//documentation-service.arm.com/static/5f15c42420b7cf4bc5247f3a Armv8-M Architecture Reference Manual https//documentation-service.arm.com/static/5f8efe85f86e16515cdbe596 Guidelines for Using the S Cache on the System Bus Suitable Products RA Family The second approach, using the MPU, involves disabling the s-cache only in the specific user configurable memory area that causes the problem. Below we will explain how to fix the issue by configuring the MPU. See the Description at the bottom of this article for details on each MPU setting. define CTRLPV 1 CTRLHN 1 ARMMPUCTRL(PV, HN)  (((PV)  MPUCTRLPRIVDEFENAPos)   ((HN)  MPUCTRLHFNMIENAPos)) define MPUARMV8MMAIRATTRDEVICEVAL 0x04 MPUARMV8MMAIRATTRDEVICEVAL 0x04 MPUARMV8MMAIRATTRDEVICEIDX 0 MPUARMV8MMAIRATTRCODEVAL 0xAA MPUARMV8MMAIRATTRCODEIDX 1 MPUARMV8MMAIRATTRDATAVAL 0xFF MPUARMV8MMAIRATTRDATAIDX 2 MPUARMV8MMAIRATTRDATANOCACHEVAL 0x44 MPUARMV8MMAIRATTRDATANOCACHEIDX 3 const ARMMPURegiont mpuTable2   // BASE SH RO NP XN  .RBAR  ARMMPURBAR(0x60000000UL, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x63FFFFFFUL, MPUARMV8MMAIRATTRDATANOCACHEIDX) ,  .RBAR  ARMMPURBAR(0x64000000UL, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x67FFFFFFUL, MPUARMV8MMAIRATTRDEVICEIDX)  void mpuconfigquadspi(void) void mpuconfigquadspi( ) ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDEVICEIDX, MPUARMV8MMAIRATTRDEVICEVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRCODEIDX, MPUARMV8MMAIRATTRCODEVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDATAIDX, MPUARMV8MMAIRATTRDATAVAL); ARMMPUSetMemAttr(MPUARMV8MMAIRATTRDATANOCACHEIDX, MPUARMV8MMAIRATTRDATANOCACHEVAL); ARMMPULoad(0, mpuTable, 2); ARMMPUEnable(ARMMPUCTRL(CTRLPV, CTRLHN)); void halentry(void) halentry( mpuconfigquadspi(); qspiinit(); while(1) while (1) (2) External OSPI memory mpuconfigoctaspi( mpuconfigoctaspi(); ospiinit(); (3) Shared memory with CPU in SRAM mpuTable1   // BASE SH RO NP XN  .RBAR  ARMMPURBAR(0x2003CF80, ARMMPUSHNON, 0UL, 1UL, 1UL), // LIMIT ATTR .RLAR  ARMMPURLAR(0x2003FFFF, MPUARMV8MMAIRATTRDATANOCACHEIDX) , void mpuconfigeth(void) mpuconfigeth( ARMMPULoad(0, mpuTable, 1); mpuconfigeth(); Segger RTT Viewer  .RBAR  ARMMPURBAR(0x200001C0UL, ARMMPUSHNON, 0UL, 1UL, 1UL), .RLAR  ARMMPURLAR(0x2000129FUL, MPUARMV8MMAIRATTRDATANOCACHEIDX) , void mpuconfigrtt(void) mpuconfigrtt( mpuconfigrtt(); SEGGERRTTprintf(HELLO); SEGGERRTTprintf( HELLO ); Arm Cortex-M33 Processor Technical Reference Manual",
1d9a13eb4bdb064b0985c6fd7c73b1da,"Description
For MCUs with ARM CoreSight  MTB (Micro Trace buffer) such as RA2E1, the MTB buffer may be mapped to the beginning of the SRAM area. When a user application uses the same SRAM area, it doesnt work. To avoid this issue, the memory allocation of the MTB buffer can be changed as follows.
int ConfigTargetSettings(void)
int ConfigTargetSettings(void)
{
{
JLINK_ExecCommand(""CORESIGHT_SetMTBBufUseAddr=0x20007C00"");
JLINK_ExecCommand(""CORESIGHT_SetMTBBufUseAddr=0x20007C00"");
JLINK_ExecCommand(""CORESIGHT_SetMTBBufUsageSize=0x400"");
JLINK_ExecCommand(""CORESIGHT_SetMTBBufUsageSize=0x400"");
return 0;
return 0;
}
}
T4F68 003:353.246   MTB: Starting trace using 0x400 bytes buffer @ 0x20007C00
T4F68 003:353.246   MTB: Starting trace using 0x400 bytes buffer @ 0x20007C00
The file location of JLinkLogOverride.log can be confirmed on the J-Link Control Panel. For Windows machines, select the J-Link Control Panel from the Start Menu, and find the Log file: in the Settings menu.
Suitable Products
FSP, J-Link
RA
FSP, J-Link
RA
FSP, J-Link
RA
Source:","['data/categories/ra_family/ra_and_fsp_technical_articles/1d9a13eb4bdb064b0985c6fd7c73b1da/images/68b7b4380ddffb498fdc789aa5884c11.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/1d9a13eb4bdb064b0985c6fd7c73b1da/images/f10168b0924a154d3c1818010a711358.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/1d9a13eb4bdb064b0985c6fd7c73b1da/images/9aa5189bcd34a429292a73669fc6bdf6.png']",[],"['|  |\n|  |\n| int ConfigTargetSettings(void)\n{\nJLINK_ExecCommand(""CORESIGHT_SetMTBBufUseAddr=0x20007C00"");\nJLINK_ExecCommand(""CORESIGHT_SetMTBBufUsageSize=0x400"");\nreturn 0;\n} |', '|  |\n|  |\n| T4F68 003:353.246   MTB: Starting trace using 0x400 bytes buffer @ 0x20007C00 |', '|  |\n|  |\n| FSP, J-Link |\n| RA |']","{'title': 'RA Family: How to Change the MTB (Micro Trace Buffer) settings with J-Link', 'url': 'https://en-support.renesas.com/knowledgeBase/20628005', 'last_updated': None, 'extracted_at': '2025-03-08T23:12:23.205697'}","Description For MCUs with ARM CoreSight  MTB (Micro Trace buffer) such as RA2E1, the MTB buffer may be mapped to the beginning of the SRAM area. When a user application uses the same SRAM area, it doesnt work. To avoid this issue, the memory allocation of the MTB buffer can be changed as follows. int ConfigTargetSettings(void)  JLINKExecCommand(""CORESIGHTSetMTBBufUseAddr0x20007C00""); JLINKExecCommand(""CORESIGHTSetMTBBufUsageSize0x400""); return 0;  T4F68 003353.246 MTB Starting trace using 0x400 bytes buffer  0x20007C00 The file location of JLinkLogOverride.log can be confirmed on the J-Link Control Panel. For Windows machines, select the J-Link Control Panel from the Start Menu, and find the Log file in the Settings menu. Suitable Products FSP, J-Link RA Source",
7aceec3deee8e79eff81311622276878,"Overview:
This article describes how to improve the LOCO (Low-speed On-Chip Oscillator) clock accuracy (15%) using the HOCO (High-speed On-Chip Oscillator) with 1% accuracy as a reference clock along with the CAC (Clock Frequency Accuracy Measurement Circuit) peripheral module and the LOCO user trimming control register.
Description:
This solution uses the following hardware peripherals modules and is able to compensate the LOCO accuracy within around 4% (Note: this does not mean absolute 4% is guaranteed. Please evaluate it with your actual board).
LOCO User Trimming Register (LOCOUTCR)
LOCOUTCR allows the user to change the LOCO frequency. In the case of RA2 MCUs, by adding 1 to this register, the clock will be changed around 4% (Note: 4% is not a guaranteed value. Please evaluate it with your actual board).
Clock Frequency Accuracy Measurement Circuit (CAC)
The CAC can count a clock source against a reference clock. This can be used to determine if the frequency deviation of the clock source is in an allowable range. The measurement target and reference clocks are selectable, and the division ratio can be set. In this solution, the LOCO is the clock source and the HOCO is the reference clock to determine the LOCO frequency deviation, but since the clock difference between HOCO and LOCO is large, so the following clock source selection will be used.
Target clock to be measured: LOCO divided by 32
Reference clock: HOCO divided by 32
CLKOUT (just for debugging purpose)
The CLKOUT of the CGC (Clock Generation Circuit) can be used for debugging purpose to check if this solution is effective in improving the LOCO accuracy.
Figure.1 Solution block diagram
Solution flowchart:
Figure.2 Flow of clock correction using CAC module
Key points:
The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by +1 or -1 depending on number comparison between the CAC counter value and predefined threshold values.
Demo Project:
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
The correction target clock can be set in loco_clock_correction.c.
LEDs indicate the application running state.
LED1: Blinks when the clock correction is completed.
LED3: Turns on when an API error occur.
Figure.4 The example of RTT viewer logs
  Suitable Products
RA2 MCUs
This article describes how to improve the LOCO (Low-speed On-Chip Oscillator) clock accuracy (15%) using the HOCO (High-speed On-Chip Oscillator) with 1% accuracy as a reference clock along with the CAC (Clock Frequency Accuracy Measurement Circuit) peripheral module and the LOCO user trimming control register.
Description:
This solution uses the following hardware peripherals modules and is able to compensate the LOCO accuracy within around 4% (Note: this does not mean absolute 4% is guaranteed. Please evaluate it with your actual board).
LOCO User Trimming Register (LOCOUTCR)
LOCOUTCR allows the user to change the LOCO frequency. In the case of RA2 MCUs, by adding 1 to this register, the clock will be changed around 4% (Note: 4% is not a guaranteed value. Please evaluate it with your actual board).
Clock Frequency Accuracy Measurement Circuit (CAC)
The CAC can count a clock source against a reference clock. This can be used to determine if the frequency deviation of the clock source is in an allowable range. The measurement target and reference clocks are selectable, and the division ratio can be set. In this solution, the LOCO is the clock source and the HOCO is the reference clock to determine the LOCO frequency deviation, but since the clock difference between HOCO and LOCO is large, so the following clock source selection will be used.
Target clock to be measured: LOCO divided by 32
Reference clock: HOCO divided by 32
CLKOUT (just for debugging purpose)
The CLKOUT of the CGC (Clock Generation Circuit) can be used for debugging purpose to check if this solution is effective in improving the LOCO accuracy.
Figure.1 Solution block diagram
Solution flowchart:
Figure.2 Flow of clock correction using CAC module
Key points:
The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by +1 or -1 depending on number comparison between the CAC counter value and predefined threshold values.
Demo Project:
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
The correction target clock can be set in loco_clock_correction.c.
LEDs indicate the application running state.
LED1: Blinks when the clock correction is completed.
LED3: Turns on when an API error occur.
Figure.4 The example of RTT viewer logs
This article describes how to improve the LOCO (Low-speed On-Chip Oscillator) clock accuracy (15%) using the HOCO (High-speed On-Chip Oscillator) with 1% accuracy as a reference clock along with the CAC (Clock Frequency Accuracy Measurement Circuit) peripheral module and the LOCO user trimming control register.
This solution uses the following hardware peripherals modules and is able to compensate the LOCO accuracy within around 4% (Note: this does not mean absolute 4% is guaranteed. Please evaluate it with your actual board).
LOCO User Trimming Register (LOCOUTCR)
LOCOUTCR allows the user to change the LOCO frequency. In the case of RA2 MCUs, by adding 1 to this register, the clock will be changed around 4% (Note: 4% is not a guaranteed value. Please evaluate it with your actual board).
Clock Frequency Accuracy Measurement Circuit (CAC)
The CAC can count a clock source against a reference clock. This can be used to determine if the frequency deviation of the clock source is in an allowable range. The measurement target and reference clocks are selectable, and the division ratio can be set. In this solution, the LOCO is the clock source and the HOCO is the reference clock to determine the LOCO frequency deviation, but since the clock difference between HOCO and LOCO is large, so the following clock source selection will be used.
Target clock to be measured: LOCO divided by 32
Reference clock: HOCO divided by 32
CLKOUT (just for debugging purpose)
The CLKOUT of the CGC (Clock Generation Circuit) can be used for debugging purpose to check if this solution is effective in improving the LOCO accuracy.
Figure.1 Solution block diagram
Solution flowchart:
Figure.2 Flow of clock correction using CAC module
Key points:
The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by +1 or -1 depending on number comparison between the CAC counter value and predefined threshold values.
Demo Project:
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
The correction target clock can be set in loco_clock_correction.c.
LEDs indicate the application running state.
LED1: Blinks when the clock correction is completed.
LED3: Turns on when an API error occur.
Figure.4 The example of RTT viewer logs
This solution uses the following hardware peripherals modules and is able to compensate the LOCO accuracy within around 4% (Note: this does not mean absolute 4% is guaranteed. Please evaluate it with your actual board).
Figure.1 Solution block diagram
Figure.2 Flow of clock correction using CAC module
Key points:
The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by +1 or -1 depending on number comparison between the CAC counter value and predefined threshold values.
Demo Project:
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
The correction target clock can be set in loco_clock_correction.c.
LEDs indicate the application running state.
LED1: Blinks when the clock correction is completed.
LED3: Turns on when an API error occur.
Figure.4 The example of RTT viewer logs
Figure.2 Flow of clock correction using CAC module
Key points:
The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by +1 or -1 depending on number comparison between the CAC counter value and predefined threshold values.
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
The correction target clock can be set in loco_clock_correction.c.
LEDs indicate the application running state.
LED1: Blinks when the clock correction is completed.
LED3: Turns on when an API error occur.
Figure.4 The example of RTT viewer logs
The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO.
Figure.3 Demo application flowchart
Note:
Figure.4 The example of RTT viewer logs
Suitable Products
RA2 MCUs
Suitable Products
RA2 MCUs
Suitable Products
RA2 MCUs
Go to Japanese
Go to Japanese","['data/categories/ra_family/ra_and_fsp_technical_articles/7aceec3deee8e79eff81311622276878/images/d0e9633087841b3090316e79fe7ffd50.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/7aceec3deee8e79eff81311622276878/images/ed2b24bb9d41792ac5d3323855d696e8.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/7aceec3deee8e79eff81311622276878/images/3eb6c856b1a7aad30a11382338061c7e.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/7aceec3deee8e79eff81311622276878/images/7f9f15227d30668f9c051b22f623f8d7.png']",[],['|  |\n|  |\n| RA2 MCUs |'],"{'title': 'RA2 MCUs: How to improve the accuracy of LOCO frequency', 'url': 'https://en-support.renesas.com/knowledgeBase/20797532', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:00.159194'}","Overview This article describes how to improve the LOCO (Low-speed On-Chip Oscillator) clock accuracy (15) using the HOCO (High-speed On-Chip Oscillator) with 1 accuracy as a reference clock along with the CAC (Clock Frequency Accuracy Measurement Circuit) peripheral module and the LOCO user trimming control register. Description This solution uses the following hardware peripherals modules and is able to compensate the LOCO accuracy within around 4 (Note this does not mean absolute 4 is guaranteed. Please evaluate it with your actual board). LOCO User Trimming Register (LOCOUTCR) LOCOUTCR allows the user to change the LOCO frequency. In the case of RA2 MCUs, by adding 1 to this register, the clock will be changed around 4 (Note 4 is not a guaranteed value. Please evaluate it with your actual board). Clock Frequency Accuracy Measurement Circuit (CAC) The CAC can count a clock source against a reference clock. This can be used to determine if the frequency deviation of the clock source is in an allowable range. The measurement target and reference clocks are selectable, and the division ratio can be set. In this solution, the LOCO is the clock source and the HOCO is the reference clock to determine the LOCO frequency deviation, but since the clock difference between HOCO and LOCO is large, so the following clock source selection will be used. Target clock to be measured LOCO divided by 32 Reference clock HOCO divided by 32 CLKOUT (just for debugging purpose) The CLKOUT of the CGC (Clock Generation Circuit) can be used for debugging purpose to check if this solution is effective in improving the LOCO accuracy. Figure.1 Solution block diagram Solution flowchart Figure.2 Flow of clock correction using CAC module Key points The LOCO frequency is adjusted by changing the user trimming register is to be adjusted by 1 or -1 depending on number comparison between the CAC counter value and predefined threshold values. Demo Project The attached project is for RA2E1 and it demonstrates the LOCO clock frequency accuracy correction explained above. All processes will be executed sequentially as shown in Figure.3, but the on-board user switch SW1 is to be used to trigger to next step. The running logs can be seen in the SEGGER RTT viewer (Figure.4). Note that, the LOCO frequency should be close to the typical value at room temperature (25C); hence, the demo project is unlikely to trigger the clock correction. In order to test this demo project, you will need to put the MCU in an enough high (or cold) temperature to cause the frequency deviation on LOCO. Figure.3 Demo application flowchart Note The correction target clock can be set in lococlockcorrection.c. LEDs indicate the application running state. LED1 Blinks when the clock correction is completed. LED3 Turns on when an API error occur. Figure.4 The example of RTT viewer logs Suitable Products RA2 MCUs Suitable Products Go to Japanese",
70027263d80c62bc902152d4d6bfe74c,"The below description assumes you are using GCC complier and e2studio and is demonstrated with the RA6M5.
  In the linker settings for the project, change the Other linker flags so the semihosted version of newlib is not used:
    In the BSP tab of the configurator, add some heap memory (printf() requires some heap):
    Override the low level write function of the C runtime library, with a version that will write the data to the ITM:
  
int _write(int file, char *ptr, int len)
{
  FSP_PARAMETER_NOT_USED(file);

  int32_t todo;

  /* If the debugger is connected */
  if (CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk)
  {
      /* Send the character */
        for (todo = 0; todo < len; todo++)
        {
            ITM_SendChar((uint32_t)*ptr);/* CMSIS call */
            ptr++;
        }
  }

  return len;
}
In your code, call printf().
 uint32_t count = 0;
    
    while(1)
    {
        printf(""FSP ITM printf %ld\r\n"", count++);
        R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
    }
 Build the project.
  In the debug configuration for the project, set the SWV Core clock:
    The frequency set in the SWV Core clock in the debug configuration is not actually the speed the CPU core is operating at, it is the speed of the trace clock (TRCLK). In the case of the RA6M5 the JLink will configure the TRCKCR register to 0x81, which will divide the system clock by 2 (PLL is the system clock by default in an FSP project), giving a trace clock speed of 100MHz. This results in the value of 100MHz for the core clock speed in the debug configuration.
  Open the Live Trace Console window (Window->Show View->Other ). In the setting for the Live Trace Console, enable ITM stimulus port 0:
    Then enable the Live Trace Console, and run the program, and you should see the output of the printf:
      Printf
FSP and RA
Sourced from: 346439
The below description assumes you are using GCC complier and e2studio and is demonstrated with the RA6M5.
  In the linker settings for the project, change the Other linker flags so the semihosted version of newlib is not used:
    In the BSP tab of the configurator, add some heap memory (printf() requires some heap):
    Override the low level write function of the C runtime library, with a version that will write the data to the ITM:
  
int _write(int file, char *ptr, int len)
{
  FSP_PARAMETER_NOT_USED(file);

  int32_t todo;

  /* If the debugger is connected */
  if (CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk)
  {
      /* Send the character */
        for (todo = 0; todo < len; todo++)
        {
            ITM_SendChar((uint32_t)*ptr);/* CMSIS call */
            ptr++;
        }
  }

  return len;
}
In your code, call printf().
 uint32_t count = 0;
    
    while(1)
    {
        printf(""FSP ITM printf %ld\r\n"", count++);
        R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
    }
 Build the project.
  In the debug configuration for the project, set the SWV Core clock:
    The frequency set in the SWV Core clock in the debug configuration is not actually the speed the CPU core is operating at, it is the speed of the trace clock (TRCLK). In the case of the RA6M5 the JLink will configure the TRCKCR register to 0x81, which will divide the system clock by 2 (PLL is the system clock by default in an FSP project), giving a trace clock speed of 100MHz. This results in the value of 100MHz for the core clock speed in the debug configuration.
  Open the Live Trace Console window (Window->Show View->Other ). In the setting for the Live Trace Console, enable ITM stimulus port 0:
    Then enable the Live Trace Console, and run the program, and you should see the output of the printf:
      Printf
FSP and RA
Sourced from: 346439
The below description assumes you are using GCC complier and e2studio and is demonstrated with the RA6M5.
RA6M5.
In the linker settings for the project, change the Other linker flags so the semihosted version of newlib is not used:
In the BSP tab of the configurator, add some heap memory (printf() requires some heap):
Override the low level write function of the C runtime library, with a version that will write the data to the ITM:
In your code, call printf().
Build the project.
In the debug configuration for the project, set the SWV Core clock:
The frequency set in the SWV Core clock in the debug configuration is not actually the speed the CPU core is operating at, it is the speed of the trace clock (TRCLK). In the case of the RA6M5 the JLink will configure the TRCKCR register to 0x81, which will divide the system clock by 2 (PLL is the system clock by default in an FSP project), giving a trace clock speed of 100MHz. This results in the value of 100MHz for the core clock speed in the debug configuration.
Open the Live Trace Console window (Window->Show View->Other ). In the setting for the Live Trace Console, enable ITM stimulus port 0:
Then enable the Live Trace Console, and run the program, and you should see the output of the printf:
Printf
FSP and RA
Sourced from: 346439
Sourced from: 346439","['data/categories/ra_family/ra_and_fsp_technical_articles/70027263d80c62bc902152d4d6bfe74c/images/8725ea5bd5841443b1813a7f69320889.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/70027263d80c62bc902152d4d6bfe74c/images/41ed6235aa6f5282c05791f598127ad3.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/70027263d80c62bc902152d4d6bfe74c/images/9974cbc88e1911a9edd00c6b6029151f.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/70027263d80c62bc902152d4d6bfe74c/images/b1f5e2367ec53ab5d8295d034d7de548.png', 'data/categories/ra_family/ra_and_fsp_technical_articles/70027263d80c62bc902152d4d6bfe74c/images/f2be995af3d8bbe52df2ddc38cac0c53.png']",[],['|  |\n|  |\n| Printf |\n| FSP and RA |'],"{'title': 'Using Arm Cortex SWO with printf with RA and FSP', 'url': 'https://en-support.renesas.com/knowledgeBase/20540919', 'last_updated': None, 'extracted_at': '2025-03-08T23:13:27.514771'}","The below description assumes you are using GCC complier and e2studio and is demonstrated with the RA6M5. In the linker settings for the project, change the Other linker flags so the semihosted version of newlib is not used In the BSP tab of the configurator, add some heap memory (printf() requires some heap) Override the low level write function of the C runtime library, with a version that will write the data to the ITM int write(int file, char ptr, int len)  FSPPARAMETERNOTUSED(file); int32t todo; / If the debugger is connected / if (CoreDebug-DHCSR  CoreDebugDHCSRCDEBUGENMsk)  / Send the character / for (todo  0; todo  len; todo)  ITMSendChar((uint32t)ptr);/ CMSIS call / ptr;   return len;  In your code, call printf(). uint32t count  0; while(1)  printf(""FSP ITM printf ldrn"", count); RBSPSoftwareDelay(1000, BSPDELAYUNITSMILLISECONDS);  Build the project. In the debug configuration for the project, set the SWV Core clock The frequency set in the SWV Core clock in the debug configuration is not actually the speed the CPU core is operating at, it is the speed of the trace clock (TRCLK). In the case of the RA6M5 the JLink will configure the TRCKCR register to 0x81, which will divide the system clock by 2 (PLL is the system clock by default in an FSP project), giving a trace clock speed of 100MHz. This results in the value of 100MHz for the core clock speed in the debug configuration. Open the Live Trace Console window (Window-Show View-Other ). In the setting for the Live Trace Console, enable ITM stimulus port 0 Then enable the Live Trace Console, and run the program, and you should see the output of the printf Printf FSP and RA Sourced from 346439 RA6M5. In the linker settings for the project, change the Other linker flags so the semihosted version of newlib is not used In the BSP tab of the configurator, add some heap memory (printf() requires some heap) Override the low level write function of the C runtime library, with a version that will write the data to the ITM Build the project. In the debug configuration for the project, set the SWV Core clock The frequency set in the SWV Core clock in the debug configuration is not actually the speed the CPU core is operating at, it is the speed of the trace clock (TRCLK). In the case of the RA6M5 the JLink will configure the TRCKCR register to 0x81, which will divide the system clock by 2 (PLL is the system clock by default in an FSP project), giving a trace clock speed of 100MHz. This results in the value of 100MHz for the core clock speed in the debug configuration. Open the Live Trace Console window (Window-Show View-Other ). In the setting for the Live Trace Console, enable ITM stimulus port 0 Then enable the Live Trace Console, and run the program, and you should see the output of the printf Printf",
b5c043ca694caf48ad22adcac1ba8f3b,"Question:
I plan to connect external SRAM by using CS area controller (CSC) of the RA6 MCU.
What should I do with the following items when selecting Renesas' RMLV1616A (16Mbit) as the target memory,
a) How to connect the address lines between RA MCU and SRAM.
b) How to select write access mode (single-write strobe mode / byte strobe mode)  about CSCnMOD register in RA MCU.
Figure 1: Pin Assignment of RMLV1616A (48pin TSOP)
Answer:
The target SRAM is available in two bus widths: 1M words  16 bits / 2M words  8 bits.
(1) Data width is 16bits (Word mode):
BYTE# pin of the SRAM is pulled-up to H level to set it to word mode.
The address of RMLV1616 is a word (1 word = 16 bits) address which is 20 lines from A0 to A19.
On the other hand, RA MCU uses byte address. For this reason, the address lines of the two devices are connected with an offset.

RA MCU A20  SRAM A19
RA MCU A19  SRAM A18
        ...
RA MCU A2  SRAM A1
RA MCU A1  SRAM A0

In this configuration, the A-1 pin on the SRAM is not connected to the address signal of RA MCU. The A-1 pin is used as DQ15 on the 16-bit data bus.

The write access mode of RA MCU is selected as ""single-write strobe mode"".
Connect the BC0/BC1 pins of RA MCU to the byte selection pins LB#/UB# on the SRAM, respectively.
Figure 2: Word mode connection
(2) Data width is 8bits (Byte mode):
BYTE# pin of the SRAM is pulled-down to L level to set it to byte mode.
The address of RMLV1616 is a word (1 word = 16 bits) address which is 21 lines from A-1 to A19.
On the other hand, RA MCU uses byte address. For this reason, the address lines of the two devices are connected with an offset.

RA MCU A20  SRAM A19
RA MCU A19  SRAM A18
       ...
RA MCU A2  SRAM A1
RA MCU A1  SRAM A0
RA MCU A0  SRAM A-1

In this configuration, the A-1 pin on the SRAM is connected to A0 pin of RA MCU.

The write access mode of RA MCU is selected as ""byte strobe mode"".
The BC0 pin of RA MCU is used as the address A0 pin.
BC1 pin and D[15-8] pins of the RA MCU are not used for this connection. These can be used as a pin for functions other than CSC.
LB#/UB# pins and DQ[14-8] pins of SRAM are not used for this connection. It is recommended to pull it up on the substrate.

Figure 3: Byte mode connection
Suitable Products
RA Family
I plan to connect external SRAM by using CS area controller (CSC) of the RA6 MCU.
What should I do with the following items when selecting Renesas' RMLV1616A (16Mbit) as the target memory,
a) How to connect the address lines between RA MCU and SRAM.
b) How to select write access mode (single-write strobe mode / byte strobe mode)  about CSCnMOD register in RA MCU.
Figure 1: Pin Assignment of RMLV1616A (48pin TSOP)
I plan to connect external SRAM by using CS area controller (CSC) of the RA6 MCU.
What should I do with the following items when selecting Renesas' RMLV1616A (16Mbit) as the target memory,
a) How to connect the address lines between RA MCU and SRAM.
b) How to select write access mode (single-write strobe mode / byte strobe mode)  about CSCnMOD register in RA MCU.
Figure 1: Pin Assignment of RMLV1616A (48pin TSOP)
Answer:
The target SRAM is available in two bus widths: 1M words  16 bits / 2M words  8 bits.
(1) Data width is 16bits (Word mode):
BYTE# pin of the SRAM is pulled-up to H level to set it to word mode.
The address of RMLV1616 is a word (1 word = 16 bits) address which is 20 lines from A0 to A19.
On the other hand, RA MCU uses byte address. For this reason, the address lines of the two devices are connected with an offset.

RA MCU A20  SRAM A19
RA MCU A19  SRAM A18
        ...
RA MCU A2  SRAM A1
RA MCU A1  SRAM A0

In this configuration, the A-1 pin on the SRAM is not connected to the address signal of RA MCU. The A-1 pin is used as DQ15 on the 16-bit data bus.

The write access mode of RA MCU is selected as ""single-write strobe mode"".
Connect the BC0/BC1 pins of RA MCU to the byte selection pins LB#/UB# on the SRAM, respectively.
Figure 2: Word mode connection
(2) Data width is 8bits (Byte mode):
BYTE# pin of the SRAM is pulled-down to L level to set it to byte mode.
The address of RMLV1616 is a word (1 word = 16 bits) address which is 21 lines from A-1 to A19.
On the other hand, RA MCU uses byte address. For this reason, the address lines of the two devices are connected with an offset.

RA MCU A20  SRAM A19
RA MCU A19  SRAM A18
       ...
RA MCU A2  SRAM A1
RA MCU A1  SRAM A0
RA MCU A0  SRAM A-1

In this configuration, the A-1 pin on the SRAM is connected to A0 pin of RA MCU.

The write access mode of RA MCU is selected as ""byte strobe mode"".
The BC0 pin of RA MCU is used as the address A0 pin.
BC1 pin and D[15-8] pins of the RA MCU are not used for this connection. These can be used as a pin for functions other than CSC.
LB#/UB# pins and DQ[14-8] pins of SRAM are not used for this connection. It is recommended to pull it up on the substrate.

Figure 3: Byte mode connection
Suitable Products
RA Family
The target SRAM is available in two bus widths: 1M words  16 bits / 2M words  8 bits.
(1) Data width is 16bits (Word mode):
Figure 2: Word mode connection
(2) Data width is 8bits (Byte mode):
Figure 3: Byte mode connection
Suitable Products
RA Family

","['data/categories/ra_family/external_bus/b5c043ca694caf48ad22adcac1ba8f3b/images/75594f616ee0e23434fa2e553830bae5.png', 'data/categories/ra_family/external_bus/b5c043ca694caf48ad22adcac1ba8f3b/images/c372b7c25b771bc307ac27decd6be46f.png', 'data/categories/ra_family/external_bus/b5c043ca694caf48ad22adcac1ba8f3b/images/1928f52af349ef0851525ebde8dd594f.png']",[],['|  |\n|  |\n| RA Family |'],"{'title': 'RA Family: How to connect external SRAM?', 'url': 'https://en-support.renesas.com/knowledgeBase/21727828', 'last_updated': None, 'extracted_at': '2025-03-08T23:35:47.570411'}","Question I plan to connect external SRAM by using CS area controller (CSC) of the RA6 MCU. What should I do with the following items when selecting Renesas' RMLV1616A (16Mbit) as the target memory, a) How to connect the address lines between RA MCU and SRAM. b) How to select write access mode (single-write strobe mode / byte strobe mode) about CSCnMOD register in RA MCU. Figure 1 Pin Assignment of RMLV1616A (48pin TSOP) Answer The target SRAM is available in two bus widths 1M words  16 bits / 2M words  8 bits. (1) Data width is 16bits (Word mode) BYTE pin of the SRAM is pulled-up to H level to set it to word mode. The address of RMLV1616 is a word (1 word  16 bits) address which is 20 lines from A0 to A19. On the other hand, RA MCU uses byte address. For this reason, the address lines of the two devices are connected with an offset. RA MCU A20  SRAM A19 RA MCU A19  SRAM A18 ... RA MCU A2  SRAM A1 RA MCU A1  SRAM A0 In this configuration, the A-1 pin on the SRAM is not connected to the address signal of RA MCU. The A-1 pin is used as DQ15 on the 16-bit data bus. The write access mode of RA MCU is selected as ""single-write strobe mode"". Connect the BC0/BC1 pins of RA MCU to the byte selection pins LB/UB on the SRAM, respectively. Figure 2 Word mode connection (2) Data width is 8bits (Byte mode) BYTE pin of the SRAM is pulled-down to L level to set it to byte mode. The address of RMLV1616 is a word (1 word  16 bits) address which is 21 lines from A-1 to A19. ... RA MCU A0  SRAM A-1 In this configuration, the A-1 pin on the SRAM is connected to A0 pin of RA MCU. The write access mode of RA MCU is selected as ""byte strobe mode"". The BC0 pin of RA MCU is used as the address A0 pin. BC1 pin and D15-8 pins of the RA MCU are not used for this connection. These can be used as a pin for functions other than CSC. LB/UB pins and DQ14-8 pins of SRAM are not used for this connection. It is recommended to pull it up on the substrate. Figure 3 Byte mode connection Suitable Products RA Family ",
c6a4d7a380e20427c73bafb0a02760ef,"Question:
I plan to connect a 16-bit wide SDRAM by using the SDRAM area controller (SDRAMC) of the RA MCU.
I am considering the following four types of Micron memory as target memory. Is it possible to use any one of these SDRAMs?
MT48LC4M16A2     64Mb ( 8MB)
MT48LC8M16A2    128Mb (16MB)
MT48LC16M16A2  256Mb (32MB)
MT48LC32M16A2  512Mb (64MB)
Answer:
Yes, it is possible to connect these SDRAM types.
If the user wants to connect the largest memory MT48LC32M16A2, Figure 1 shows the general connection method. On the other hand, as shown in Figure 2, all four types of memory can be used on the same PCB which is designed by replacing some of the wiring of the address line and bank address line.
In addition, the address pins of the RA MCU use byte addressing, and the address pins of the SDRAM use word addressing. For this reason, the address lines of the two devices are connected using an offset.
Figure 1.  General Connection
  Figure 2. Proposed Connection
  Explanation
Comparing the addressing specifications of the four types of SDRAM, they can be classified as shown in Table 1.
Table 1. The address specifications of each SDRAM
Part Numbers Density Bank address Row address Column address
MT48LC4M16A2 64Mb (8MB) BA[1:0] (2bit)
A[11:0] (12bits)
A[7:0] (8bits)
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits)
MT48LC16M16A2 256Mb (32MB) A[12:0] (13bits)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits)
The difference in column address can be managed by setting the register of the RA MCU. By changing the address multiplexing selection bits of the SDRAM address register (SDADR. MXC[1:0]) , the amount of shift in the row address is set and it does not directly affect the routing on the board.

Table 2. The setting of address multiplexing for each SDRAM
Part Numbers Density Column address SDADR.MXC[1:0]
MT48LC4M16A2 64Mb (8MB) A[7:0] (8bits) 0 0 : 8-bit shift
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits) 0 1 : 9-bit shift
MT48LC16M16A2 256Mb (32MB)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits) 1 0 : 10-bit shift
  On the other hand, the difference in Row address needs to be managed by H/W.
First, check the address specifications of the RA MCU. Table 3. shows the relationship between the RA MCU internal address and the RA MCU external pins for SDRAM address. As shown in this table, MT48LC16M16A2 (32 MB) and MT48LC32M16A2 (64 MB) require one more external pin A15.

Table 3. Relationship between RA MCU internal address and External address pins
a[31:0] : RA MCU Internal address
A[15:0] : RA MCU External pins for SDRAMC address signals
  Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC.
By connecting that pin36 (A12) to the A15 pin of the RA MCU and shifting the bank address, it is possible to realize a board which has the required specifications.
Figure 3. Pin assignment (MT48LC4M16A2 and MT48LC8M16A2)
    Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2)
    Reference
The relationship between each connection and their memory allocation when the MT48LC32M16A2 is selected as follows.
In the case of the proposed connection, the access in SDRAM is interleaved. As a result, data is stored in a different location in SDRAM compared to general connection, but there is no particular effect on the operation of the RA MCU.
Figure 5. Memory allocation (general connection)
  Figure 6. Memory allocation (proposed connection)
  Suitable Products
RA8M1, RA8D1, RA8T1, RA8E2, RA6M3, RA6M2
I plan to connect a 16-bit wide SDRAM by using the SDRAM area controller (SDRAMC) of the RA MCU.
I am considering the following four types of Micron memory as target memory. Is it possible to use any one of these SDRAMs?
MT48LC4M16A2     64Mb ( 8MB)
MT48LC8M16A2    128Mb (16MB)
MT48LC16M16A2  256Mb (32MB)
MT48LC32M16A2  512Mb (64MB)
I plan to connect a 16-bit wide SDRAM by using the SDRAM area controller (SDRAMC) of the RA MCU.
I am considering the following four types of Micron memory as target memory. Is it possible to use any one of these SDRAMs?
Answer:
Yes, it is possible to connect these SDRAM types.
If the user wants to connect the largest memory MT48LC32M16A2, Figure 1 shows the general connection method. On the other hand, as shown in Figure 2, all four types of memory can be used on the same PCB which is designed by replacing some of the wiring of the address line and bank address line.
In addition, the address pins of the RA MCU use byte addressing, and the address pins of the SDRAM use word addressing. For this reason, the address lines of the two devices are connected using an offset.
Figure 1.  General Connection
  Figure 2. Proposed Connection
  Explanation
Comparing the addressing specifications of the four types of SDRAM, they can be classified as shown in Table 1.
Table 1. The address specifications of each SDRAM
Part Numbers Density Bank address Row address Column address
MT48LC4M16A2 64Mb (8MB) BA[1:0] (2bit)
A[11:0] (12bits)
A[7:0] (8bits)
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits)
MT48LC16M16A2 256Mb (32MB) A[12:0] (13bits)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits)
The difference in column address can be managed by setting the register of the RA MCU. By changing the address multiplexing selection bits of the SDRAM address register (SDADR. MXC[1:0]) , the amount of shift in the row address is set and it does not directly affect the routing on the board.

Table 2. The setting of address multiplexing for each SDRAM
Part Numbers Density Column address SDADR.MXC[1:0]
MT48LC4M16A2 64Mb (8MB) A[7:0] (8bits) 0 0 : 8-bit shift
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits) 0 1 : 9-bit shift
MT48LC16M16A2 256Mb (32MB)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits) 1 0 : 10-bit shift
  On the other hand, the difference in Row address needs to be managed by H/W.
First, check the address specifications of the RA MCU. Table 3. shows the relationship between the RA MCU internal address and the RA MCU external pins for SDRAM address. As shown in this table, MT48LC16M16A2 (32 MB) and MT48LC32M16A2 (64 MB) require one more external pin A15.

Table 3. Relationship between RA MCU internal address and External address pins
a[31:0] : RA MCU Internal address
A[15:0] : RA MCU External pins for SDRAMC address signals
  Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC.
By connecting that pin36 (A12) to the A15 pin of the RA MCU and shifting the bank address, it is possible to realize a board which has the required specifications.
Figure 3. Pin assignment (MT48LC4M16A2 and MT48LC8M16A2)
    Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2)
    Reference
The relationship between each connection and their memory allocation when the MT48LC32M16A2 is selected as follows.
In the case of the proposed connection, the access in SDRAM is interleaved. As a result, data is stored in a different location in SDRAM compared to general connection, but there is no particular effect on the operation of the RA MCU.
Figure 5. Memory allocation (general connection)
  Figure 6. Memory allocation (proposed connection)
  Suitable Products
RA8M1, RA8D1, RA8T1, RA8E2, RA6M3, RA6M2
Yes, it is possible to connect these SDRAM types.
If the user wants to connect the largest memory MT48LC32M16A2, Figure 1 shows the general connection method. On the other hand, as shown in Figure 2, all four types of memory can be used on the same PCB which is designed by replacing some of the wiring of the address line and bank address line.
In addition, the address pins of the RA MCU use byte addressing, and the address pins of the SDRAM use word addressing. For this reason, the address lines of the two devices are connected using an offset.
Figure 1.  General Connection
  Figure 2. Proposed Connection
  Explanation
Comparing the addressing specifications of the four types of SDRAM, they can be classified as shown in Table 1.
Table 1. The address specifications of each SDRAM
Part Numbers Density Bank address Row address Column address
MT48LC4M16A2 64Mb (8MB) BA[1:0] (2bit)
A[11:0] (12bits)
A[7:0] (8bits)
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits)
MT48LC16M16A2 256Mb (32MB) A[12:0] (13bits)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits)
The difference in column address can be managed by setting the register of the RA MCU. By changing the address multiplexing selection bits of the SDRAM address register (SDADR. MXC[1:0]) , the amount of shift in the row address is set and it does not directly affect the routing on the board.

Table 2. The setting of address multiplexing for each SDRAM
Part Numbers Density Column address SDADR.MXC[1:0]
MT48LC4M16A2 64Mb (8MB) A[7:0] (8bits) 0 0 : 8-bit shift
MT48LC8M16A2 128Mb (16MB) A[8:0] (9bits) 0 1 : 9-bit shift
MT48LC16M16A2 256Mb (32MB)
MT48LC32M16A2 512Mb (64MB) A[9:0] (10bits) 1 0 : 10-bit shift
  On the other hand, the difference in Row address needs to be managed by H/W.
First, check the address specifications of the RA MCU. Table 3. shows the relationship between the RA MCU internal address and the RA MCU external pins for SDRAM address. As shown in this table, MT48LC16M16A2 (32 MB) and MT48LC32M16A2 (64 MB) require one more external pin A15.

Table 3. Relationship between RA MCU internal address and External address pins
a[31:0] : RA MCU Internal address
A[15:0] : RA MCU External pins for SDRAMC address signals
  Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC.
By connecting that pin36 (A12) to the A15 pin of the RA MCU and shifting the bank address, it is possible to realize a board which has the required specifications.
Figure 3. Pin assignment (MT48LC4M16A2 and MT48LC8M16A2)
    Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2)
    Reference
The relationship between each connection and their memory allocation when the MT48LC32M16A2 is selected as follows.
In the case of the proposed connection, the access in SDRAM is interleaved. As a result, data is stored in a different location in SDRAM compared to general connection, but there is no particular effect on the operation of the RA MCU.
Figure 5. Memory allocation (general connection)
  Figure 6. Memory allocation (proposed connection)
  Suitable Products
Yes, it is possible to connect these SDRAM types.
If the user wants to connect the largest memory MT48LC32M16A2, Figure 1 shows the general connection method. On the other hand, as shown in Figure 2, all four types of memory can be used on the same PCB which is designed by replacing some of the wiring of the address line and bank address line.
In addition, the address pins of the RA MCU use byte addressing, and the address pins of the SDRAM use word addressing. For this reason, the address lines of the two devices are connected using an offset.
Figure 1.  General Connection
Figure 2. Proposed Connection
Explanation
Comparing the addressing specifications of the four types of SDRAM, they can be classified as shown in Table 1.
Table 1. The address specifications of each SDRAM
A[11:0] (12bits)
The difference in column address can be managed by setting the register of the RA MCU. By changing the address multiplexing selection bits of the SDRAM address register (SDADR. MXC[1:0]) , the amount of shift in the row address is set and it does not directly affect the routing on the board.
Table 2. The setting of address multiplexing for each SDRAM
On the other hand, the difference in Row address needs to be managed by H/W.
First, check the address specifications of the RA MCU. Table 3. shows the relationship between the RA MCU internal address and the RA MCU external pins for SDRAM address. As shown in this table, MT48LC16M16A2 (32 MB) and MT48LC32M16A2 (64 MB) require one more external pin A15.
Table 3. Relationship between RA MCU internal address and External address pins
a[31:0] : RA MCU Internal address
A[15:0] : RA MCU External pins for SDRAMC address signals
Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC.
By connecting that pin36 (A12) to the A15 pin of the RA MCU and shifting the bank address, it is possible to realize a board which has the required specifications.
Figure 3. Pin assignment (MT48LC4M16A2 and MT48LC8M16A2)
Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2)
Reference
The relationship between each connection and their memory allocation when the MT48LC32M16A2 is selected as follows.
In the case of the proposed connection, the access in SDRAM is interleaved. As a result, data is stored in a different location in SDRAM compared to general connection, but there is no particular effect on the operation of the RA MCU.
Figure 5. Memory allocation (general connection)
Figure 6. Memory allocation (proposed connection)
Suitable Products
RA8M1, RA8D1, RA8T1, RA8E2, RA6M3, RA6M2
Japanese
Japanese","['data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/4c303e20af5c11ada331a29cc1d9e024.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/80af3029d7bc0032a1bf868e2c832ee3.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/78abf77ad0677d25f5cfeecc0f956bcb.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/1d6ce4771fc1258e2b76554974a614ce.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/073bbfafdf13ff0625cd5775759cb475.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/72da270b198e18f9fdda958a980cd1bb.png', 'data/categories/ra_family/external_bus/c6a4d7a380e20427c73bafb0a02760ef/images/992a3ae603af962032c66bed8d6df848.png']",[],"['|  |\n|  |\n| Part Numbers | Density | Bank address | Row address | Column address |\n| MT48LC4M16A2 | 64Mb (8MB) | BA[1:0] (2bit) | A[11:0] (12bits) | A[7:0] (8bits) |\n| MT48LC8M16A2 | 128Mb (16MB) | A[8:0] (9bits) |\n| MT48LC16M16A2 | 256Mb (32MB) | A[12:0] (13bits) |\n| MT48LC32M16A2 | 512Mb (64MB) | A[9:0] (10bits) |', '|  |\n|  |\n| Part Numbers | Density | Column address | SDADR.MXC[1:0] |\n| MT48LC4M16A2 | 64Mb (8MB) | A[7:0] (8bits) | 0 0 : 8-bit shift |\n| MT48LC8M16A2 | 128Mb (16MB) | A[8:0] (9bits) | 0 1 : 9-bit shift |\n| MT48LC16M16A2 | 256Mb (32MB) |\n| MT48LC32M16A2 | 512Mb (64MB) | A[9:0] (10bits) | 1 0 : 10-bit shift |', '|  |\n|  |\n| RA8M1, RA8D1, RA8T1, RA8E2, RA6M3, RA6M2 |']","{'title': 'RA Family: How to connect external SDRAM', 'url': 'https://en-support.renesas.com/knowledgeBase/21810949', 'last_updated': None, 'extracted_at': '2025-03-08T23:35:32.172218'}","Question I plan to connect a 16-bit wide SDRAM by using the SDRAM area controller (SDRAMC) of the RA MCU. I am considering the following four types of Micron memory as target memory. Is it possible to use any one of these SDRAMs? MT48LC4M16A2  64Mb ( 8MB) MT48LC8M16A2  128Mb (16MB) MT48LC16M16A2  256Mb (32MB) MT48LC32M16A2  512Mb (64MB) Answer Yes, it is possible to connect these SDRAM types. If the user wants to connect the largest memory MT48LC32M16A2, Figure 1 shows the general connection method. On the other hand, as shown in Figure 2, all four types of memory can be used on the same PCB which is designed by replacing some of the wiring of the address line and bank address line. In addition, the address pins of the RA MCU use byte addressing, and the address pins of the SDRAM use word addressing. For this reason, the address lines of the two devices are connected using an offset. Figure 1. General Connection Figure 2. Proposed Connection Explanation Comparing the addressing specifications of the four types of SDRAM, they can be classified as shown in Table 1. Table 1. The address specifications of each SDRAM Part Numbers Density Bank address Row address Column address MT48LC4M16A2 64Mb (8MB) BA10 (2bit) A110 (12bits) A70 (8bits) MT48LC8M16A2 128Mb (16MB) A80 (9bits) MT48LC16M16A2 256Mb (32MB) A120 (13bits) MT48LC32M16A2 512Mb (64MB) A90 (10bits) The difference in column address can be managed by setting the register of the RA MCU. By changing the address multiplexing selection bits of the SDRAM address register (SDADR. MXC10) , the amount of shift in the row address is set and it does not directly affect the routing on the board. Table 2. The setting of address multiplexing for each SDRAM Part Numbers Density Column address SDADR.MXC10 MT48LC4M16A2 64Mb (8MB) A70 (8bits) 0 0  8-bit shift MT48LC8M16A2 128Mb (16MB) A80 (9bits) 0 1  9-bit shift MT48LC16M16A2 256Mb (32MB) MT48LC32M16A2 512Mb (64MB) A90 (10bits) 1 0  10-bit shift On the other hand, the difference in Row address needs to be managed by H/W. First, check the address specifications of the RA MCU. Table 3. shows the relationship between the RA MCU internal address and the RA MCU external pins for SDRAM address. As shown in this table, MT48LC16M16A2 (32 MB) and MT48LC32M16A2 (64 MB) require one more external pin A15. Table 3. Relationship between RA MCU internal address and External address pins a310  RA MCU Internal address A150  RA MCU External pins for SDRAMC address signals Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC. By connecting that pin36 (A12) to the A15 pin of the RA MCU and shifting the bank address, it is possible to realize a board which has the required specifications. Figure 3. Pin assignment (MT48LC4M16A2 and MT48LC8M16A2) Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2) Reference The relationship between each connection and their memory allocation when the MT48LC32M16A2 is selected as follows. In the case of the proposed connection, the access in SDRAM is interleaved. As a result, data is stored in a different location in SDRAM compared to general connection, but there is no particular effect on the operation of the RA MCU. Figure 5. Memory allocation (general connection) Figure 6. Memory allocation (proposed connection) Suitable Products RA8M1, RA8D1, RA8T1, RA8E2, RA6M3, RA6M2 Figure 2. Proposed Connection Explanation On the other hand, the difference in Row address needs to be managed by H/W. Similarly, the specifications on the SDRAM are also compared. Figure 3 and Figure 4 are pinout diagrams corresponding to each memory model number. In the case of MT48LC16M16A2 and MT48LC32M16A2, one more address pin (A12) is enabled at pin36. In the case of MT48LC4M16A2 and MT48LC8M16A2, pin36 is NC. Figure 4. Pin assignment (MT48LC16M16A2 and MT48LC32M16A2) Reference Figure 6. Memory allocation (proposed connection) Suitable Products Japanese",
811bb5e293d798ab9432732a5358105f,"Question:
When an I2C slave executes a clock stretching action (holding the clock line SCL low to  wait for the master), RA family MCU (master) detects an unexpected start condition on the I2C bus.
Answer:
When a I2C slave executes a clock stretching and releases it, it outputs the data line signal for the next first clock, and then sets up a data input setup time specified by the electrical characteristics of the MCU (please refer to the MCU user's manual) and a data setup time specified by I2C bus specification (Standard mode: Min 250 ns, High-speed mode: Min 100 ns) before releasing the clock line low.
If the data setup time is not met, the master may detect an unexpected start condition (the data line SDA is falling during the clock line SCL is high).
Figure. Example of timing of I2C clock stretching
Suitable Products
RA MCU
When an I2C slave executes a clock stretching action (holding the clock line SCL low to  wait for the master), RA family MCU (master) detects an unexpected start condition on the I2C bus.
When an I2C slave executes a clock stretching action (holding the clock line SCL low to  wait for the master), RA family MCU (master) detects an unexpected start condition on the I2C bus.
Answer:
When a I2C slave executes a clock stretching and releases it, it outputs the data line signal for the next first clock, and then sets up a data input setup time specified by the electrical characteristics of the MCU (please refer to the MCU user's manual) and a data setup time specified by I2C bus specification (Standard mode: Min 250 ns, High-speed mode: Min 100 ns) before releasing the clock line low.
If the data setup time is not met, the master may detect an unexpected start condition (the data line SDA is falling during the clock line SCL is high).
Figure. Example of timing of I2C clock stretching
Suitable Products
RA MCU
When a I2C slave executes a clock stretching and releases it, it outputs the data line signal for the next first clock, and then sets up a data input setup time specified by the electrical characteristics of the MCU (please refer to the MCU user's manual) and a data setup time specified by I2C bus specification (Standard mode: Min 250 ns, High-speed mode: Min 100 ns) before releasing the clock line low.
If the data setup time is not met, the master may detect an unexpected start condition (the data line SDA is falling during the clock line SCL is high).
Figure. Example of timing of I2C clock stretching
When a I2C slave executes a clock stretching and releases it, it outputs the data line signal for the next first clock, and then sets up a data input setup time specified by the electrical characteristics of the MCU (please refer to the MCU user's manual) and a data setup time specified by I2C bus specification (Standard mode: Min 250 ns, High-speed mode: Min 100 ns) before releasing the clock line low.
If the data setup time is not met, the master may detect an unexpected start condition (the data line SDA is falling during the clock line SCL is high).
Figure. Example of timing of I2C clock stretching
Suitable Products
RA MCU",['data/categories/ra_family/i2c-bus_interface_(iic)/811bb5e293d798ab9432732a5358105f/images/837e223a822c744d3c7abe227137e351.png'],[],['|  |\n|  |\n| RA MCU |'],"{'title': 'RA Family: I2C-BUS could detect unexpected Start Condition and malfunction when a slave device executes clock stretching', 'url': 'https://en-support.renesas.com/knowledgeBase/21180394', 'last_updated': None, 'extracted_at': '2025-03-08T23:36:45.558284'}","Question When an I2C slave executes a clock stretching action (holding the clock line SCL low to wait for the master), RA family MCU (master) detects an unexpected start condition on the I2C bus. Answer When a I2C slave executes a clock stretching and releases it, it outputs the data line signal for the next first clock, and then sets up a data input setup time specified by the electrical characteristics of the MCU (please refer to the MCU user's manual) and a data setup time specified by I2C bus specification (Standard mode Min 250 ns, High-speed mode Min 100 ns) before releasing the clock line low. If the data setup time is not met, the master may detect an unexpected start condition (the data line SDA is falling during the clock line SCL is high). Figure. Example of timing of I2C clock stretching Suitable Products RA MCU",
ccacdef63f51d672e7af05bc2720fbc5,"Overview
This article explains how and when the CPU interrupt handler call is generated on each RSPI and DMAC interrupt when using an RSPI as slave and enabling full-duplex and DMAC transfer.
This article only covers three types of interrupts.
RSPI - SPRIx : Receive buffer full interrupt
RSPI - SPTIx : Transmit buffer empty interrupt
DMAC - DMACxI : Transfer end interrupt (1 channel for RSPI RX linked to SPRIx interrupt and 1 channel for RSPI TX linked to SPTIx interrupt)
At the end of this article, some related driver software settings are introduced for your reference.
Operation Result
The following capture image shows a signal waveform when the RSPI receives 10 bytes of data. At this time, the DMAC transfer is enabled and configured to do 10 bytes (1 byte x 10 times) transfer triggered by each RSIP interrupts. In the image, SSL, CLK and MOSI are actual SPI communication signals, following RSPI RX, RSPI TX, DMA RX and DMA TX show the timing of the CPU interrupt handler call occurrence. The test program was implemented so that the GPIO pin will go to low when the CPU interrupt handler is called.
As you can see in the picture below, the interrupt handlers are called in the following order. We will review how and why the interrupt occurred at this timing:
DMAC transfer end interrupt for RSPI Transmit
RSPI Transmit buffer empty interrupt
DMAC transfer end interrupt for RSPI Receive
RSPI Receive buffer full interrupt (Does not occur)


1. DMAC transfer end interrupt for RSPI Transmit
First you will get the DMA TX transfer end interrupt around two bytes earlier. The reason why it occurs two bytes earlier is due to the RSPI shift register and the SPTI interrupt timing. As soon as RSPI is enabled, if the shit register is empty, the RSPI issues TX buffer empty interrupt, that triggers DMACs first transfer (first byte) to the RSIP data register (SPDR). The data will move to the shift register soon, and then another TX buffer empty interrupt occurrs and the second DMAC transfer (second byte) will be transferred. These are done before receiving the clock signal from the connected device. After that, the remaining 8 bytes will be transferred by synchronizing with the SPI clock. Therefore, the DMAC Transfer end interrupt occurs 2 bytes earlier.
Please note that this is not a good place to put some user code like restarting the RSPI slave operation, since the RSPI clock is still coming in.
Refer to section Serial Peripheral Interface > Operation > Communications Operating Mode > Full-Duplex Communications in the hardware user manual of MCU device.
2. RSPI Transmit buffer empty interrupt
After the DMAC has completed its TX task with the provided transfer information (e.g. number of transfers), the interrupt request of the RSPI Transmit buffer empty is passed to the CPU when the RSPI TX buffer is empty, so the CPU interrupt handler for the RSPI Transmit buffer empty will be executed. There is no special operation to do here.
3. DMAC transfer end interrupt for RSPI Receive
The DMAC transfer occurs every RSIP Receive buffer full interrupt, and the CPU interrupt handler call for DMAC transfer end interrupt is executed when the 10 bytes (10 times) transfer complete.
4. RSPI RX buffer full interrupt (Does not occur)
You may be wondering why the CPU interrupt handler call of the RSPI Transmit empty interrupt is called. but for the RSPI RX interrupt is not. As explained in #3, the DMAC transfer happens every RSPI Receive buffer full interrupt, so if it received 10 bytes (1 byte x 10 times), 10 interrupt requests are generated. However, all the interrupt requests are passed to the DMAC, and the DMAC executes 10 data transfers. Therefore, in the case of the RSPI RX buffer full interrupt, the CPU interrupt handler call does not happen.
Please note that the RSPI RX buffer full interrupt handler is not a good place to put user code like restarting the RSPI slave operation, and instead it would be better to put it in the DMAC transfer end interrupt for the RSPI Receive handler.
Setting - RSPI slave interrupt generation and user callback code generation
To trigger the DMAC transfer by the RSPI, the RSPI should enable either the TX or TX/RX interrupts. The RSPI can enable the TX interrupt by setting RSPIx.SPCR.SPTIE=1 and the RX interrupt by setting RSPIx.SPCR.SPRIE=1. This allows the RSPI interrupt to arrive at the ICU.
In the CG driver setting on the smart configurator, you can find the Callback function setting field below. However, this field setting enables the generation of user callback function code to allow the user to put any code into the CPU interrupt handling. Even if you uncheck the boxes below, TX, RX, Error interrupt handlers will still be created by the smart configurator (code generator).
Please dont confuse enabling RSPI interrupts and generating the user callback function code for RSPI interrupts.
Setting - ICU
The ICU is responsible for deciding whether to forward the RSPI generated interrupts to the CPU or to the DMA (DTC or DMAC). First, the ICU should be configured to receive the RSPI TX or the TX/RX interrupts by setting ICU.IERm.IENn. Then, the ICU needs to be configured to relay the RSPI TX or the RX interrupts to the respective DMAC channel (ICU.DMARSRm), not to the CPU in our example.
Setting - DMAC interrupt handling (generation)
Unlike the DTC, the DMAC can generate an interrupt (DMACxI) with its own interrupt generation sources, such as the DMAC transfer end event. Additionally, the DMAC can be configured (DMACm.DMCSL.DISEL) to pass every single interrupt to the CPU after it has processed them. However, this will increase unnecessary CPU/bus load, so keep the setting as follows. (Clear interrupt flag of the activation source)


Suitable Products
RX Family
Overview
Overview
This article explains how and when the CPU interrupt handler call is generated on each RSPI and DMAC interrupt when using an RSPI as slave and enabling full-duplex and DMAC transfer.
This article only covers three types of interrupts.
RSPI - SPRIx : Receive buffer full interrupt
RSPI - SPTIx : Transmit buffer empty interrupt
DMAC - DMACxI : Transfer end interrupt (1 channel for RSPI RX linked to SPRIx interrupt and 1 channel for RSPI TX linked to SPTIx interrupt)
At the end of this article, some related driver software settings are introduced for your reference.
This article explains how and when the CPU interrupt handler call is generated on each RSPI and DMAC interrupt when using an RSPI as slave and enabling full-duplex and DMAC transfer.
This article only covers three types of interrupts.
At the end of this article, some related driver software settings are introduced for your reference.
Operation Result
The following capture image shows a signal waveform when the RSPI receives 10 bytes of data. At this time, the DMAC transfer is enabled and configured to do 10 bytes (1 byte x 10 times) transfer triggered by each RSIP interrupts. In the image, SSL, CLK and MOSI are actual SPI communication signals, following RSPI RX, RSPI TX, DMA RX and DMA TX show the timing of the CPU interrupt handler call occurrence. The test program was implemented so that the GPIO pin will go to low when the CPU interrupt handler is called.
As you can see in the picture below, the interrupt handlers are called in the following order. We will review how and why the interrupt occurred at this timing:
DMAC transfer end interrupt for RSPI Transmit
RSPI Transmit buffer empty interrupt
DMAC transfer end interrupt for RSPI Receive
RSPI Receive buffer full interrupt (Does not occur)


1. DMAC transfer end interrupt for RSPI Transmit
First you will get the DMA TX transfer end interrupt around two bytes earlier. The reason why it occurs two bytes earlier is due to the RSPI shift register and the SPTI interrupt timing. As soon as RSPI is enabled, if the shit register is empty, the RSPI issues TX buffer empty interrupt, that triggers DMACs first transfer (first byte) to the RSIP data register (SPDR). The data will move to the shift register soon, and then another TX buffer empty interrupt occurrs and the second DMAC transfer (second byte) will be transferred. These are done before receiving the clock signal from the connected device. After that, the remaining 8 bytes will be transferred by synchronizing with the SPI clock. Therefore, the DMAC Transfer end interrupt occurs 2 bytes earlier.
Please note that this is not a good place to put some user code like restarting the RSPI slave operation, since the RSPI clock is still coming in.
Refer to section Serial Peripheral Interface > Operation > Communications Operating Mode > Full-Duplex Communications in the hardware user manual of MCU device.
2. RSPI Transmit buffer empty interrupt
After the DMAC has completed its TX task with the provided transfer information (e.g. number of transfers), the interrupt request of the RSPI Transmit buffer empty is passed to the CPU when the RSPI TX buffer is empty, so the CPU interrupt handler for the RSPI Transmit buffer empty will be executed. There is no special operation to do here.
3. DMAC transfer end interrupt for RSPI Receive
The DMAC transfer occurs every RSIP Receive buffer full interrupt, and the CPU interrupt handler call for DMAC transfer end interrupt is executed when the 10 bytes (10 times) transfer complete.
4. RSPI RX buffer full interrupt (Does not occur)
You may be wondering why the CPU interrupt handler call of the RSPI Transmit empty interrupt is called. but for the RSPI RX interrupt is not. As explained in #3, the DMAC transfer happens every RSPI Receive buffer full interrupt, so if it received 10 bytes (1 byte x 10 times), 10 interrupt requests are generated. However, all the interrupt requests are passed to the DMAC, and the DMAC executes 10 data transfers. Therefore, in the case of the RSPI RX buffer full interrupt, the CPU interrupt handler call does not happen.
Please note that the RSPI RX buffer full interrupt handler is not a good place to put user code like restarting the RSPI slave operation, and instead it would be better to put it in the DMAC transfer end interrupt for the RSPI Receive handler.
Setting - RSPI slave interrupt generation and user callback code generation
To trigger the DMAC transfer by the RSPI, the RSPI should enable either the TX or TX/RX interrupts. The RSPI can enable the TX interrupt by setting RSPIx.SPCR.SPTIE=1 and the RX interrupt by setting RSPIx.SPCR.SPRIE=1. This allows the RSPI interrupt to arrive at the ICU.
In the CG driver setting on the smart configurator, you can find the Callback function setting field below. However, this field setting enables the generation of user callback function code to allow the user to put any code into the CPU interrupt handling. Even if you uncheck the boxes below, TX, RX, Error interrupt handlers will still be created by the smart configurator (code generator).
Please dont confuse enabling RSPI interrupts and generating the user callback function code for RSPI interrupts.
Setting - ICU
The ICU is responsible for deciding whether to forward the RSPI generated interrupts to the CPU or to the DMA (DTC or DMAC). First, the ICU should be configured to receive the RSPI TX or the TX/RX interrupts by setting ICU.IERm.IENn. Then, the ICU needs to be configured to relay the RSPI TX or the RX interrupts to the respective DMAC channel (ICU.DMARSRm), not to the CPU in our example.
Setting - DMAC interrupt handling (generation)
Unlike the DTC, the DMAC can generate an interrupt (DMACxI) with its own interrupt generation sources, such as the DMAC transfer end event. Additionally, the DMAC can be configured (DMACm.DMCSL.DISEL) to pass every single interrupt to the CPU after it has processed them. However, this will increase unnecessary CPU/bus load, so keep the setting as follows. (Clear interrupt flag of the activation source)


Suitable Products
RX Family
Operation Result
Operation Result
The following capture image shows a signal waveform when the RSPI receives 10 bytes of data. At this time, the DMAC transfer is enabled and configured to do 10 bytes (1 byte x 10 times) transfer triggered by each RSIP interrupts. In the image, SSL, CLK and MOSI are actual SPI communication signals, following RSPI RX, RSPI TX, DMA RX and DMA TX show the timing of the CPU interrupt handler call occurrence. The test program was implemented so that the GPIO pin will go to low when the CPU interrupt handler is called.
As you can see in the picture below, the interrupt handlers are called in the following order. We will review how and why the interrupt occurred at this timing:
DMAC transfer end interrupt for RSPI Transmit
RSPI Transmit buffer empty interrupt
DMAC transfer end interrupt for RSPI Receive
RSPI Receive buffer full interrupt (Does not occur)


1. DMAC transfer end interrupt for RSPI Transmit
First you will get the DMA TX transfer end interrupt around two bytes earlier. The reason why it occurs two bytes earlier is due to the RSPI shift register and the SPTI interrupt timing. As soon as RSPI is enabled, if the shit register is empty, the RSPI issues TX buffer empty interrupt, that triggers DMACs first transfer (first byte) to the RSIP data register (SPDR). The data will move to the shift register soon, and then another TX buffer empty interrupt occurrs and the second DMAC transfer (second byte) will be transferred. These are done before receiving the clock signal from the connected device. After that, the remaining 8 bytes will be transferred by synchronizing with the SPI clock. Therefore, the DMAC Transfer end interrupt occurs 2 bytes earlier.
Please note that this is not a good place to put some user code like restarting the RSPI slave operation, since the RSPI clock is still coming in.
Refer to section Serial Peripheral Interface > Operation > Communications Operating Mode > Full-Duplex Communications in the hardware user manual of MCU device.
2. RSPI Transmit buffer empty interrupt
After the DMAC has completed its TX task with the provided transfer information (e.g. number of transfers), the interrupt request of the RSPI Transmit buffer empty is passed to the CPU when the RSPI TX buffer is empty, so the CPU interrupt handler for the RSPI Transmit buffer empty will be executed. There is no special operation to do here.
3. DMAC transfer end interrupt for RSPI Receive
The DMAC transfer occurs every RSIP Receive buffer full interrupt, and the CPU interrupt handler call for DMAC transfer end interrupt is executed when the 10 bytes (10 times) transfer complete.
4. RSPI RX buffer full interrupt (Does not occur)
You may be wondering why the CPU interrupt handler call of the RSPI Transmit empty interrupt is called. but for the RSPI RX interrupt is not. As explained in #3, the DMAC transfer happens every RSPI Receive buffer full interrupt, so if it received 10 bytes (1 byte x 10 times), 10 interrupt requests are generated. However, all the interrupt requests are passed to the DMAC, and the DMAC executes 10 data transfers. Therefore, in the case of the RSPI RX buffer full interrupt, the CPU interrupt handler call does not happen.
Please note that the RSPI RX buffer full interrupt handler is not a good place to put user code like restarting the RSPI slave operation, and instead it would be better to put it in the DMAC transfer end interrupt for the RSPI Receive handler.
Setting - RSPI slave interrupt generation and user callback code generation
To trigger the DMAC transfer by the RSPI, the RSPI should enable either the TX or TX/RX interrupts. The RSPI can enable the TX interrupt by setting RSPIx.SPCR.SPTIE=1 and the RX interrupt by setting RSPIx.SPCR.SPRIE=1. This allows the RSPI interrupt to arrive at the ICU.
In the CG driver setting on the smart configurator, you can find the Callback function setting field below. However, this field setting enables the generation of user callback function code to allow the user to put any code into the CPU interrupt handling. Even if you uncheck the boxes below, TX, RX, Error interrupt handlers will still be created by the smart configurator (code generator).
Please dont confuse enabling RSPI interrupts and generating the user callback function code for RSPI interrupts.
Setting - ICU
The ICU is responsible for deciding whether to forward the RSPI generated interrupts to the CPU or to the DMA (DTC or DMAC). First, the ICU should be configured to receive the RSPI TX or the TX/RX interrupts by setting ICU.IERm.IENn. Then, the ICU needs to be configured to relay the RSPI TX or the RX interrupts to the respective DMAC channel (ICU.DMARSRm), not to the CPU in our example.
Setting - DMAC interrupt handling (generation)
Unlike the DTC, the DMAC can generate an interrupt (DMACxI) with its own interrupt generation sources, such as the DMAC transfer end event. Additionally, the DMAC can be configured (DMACm.DMCSL.DISEL) to pass every single interrupt to the CPU after it has processed them. However, this will increase unnecessary CPU/bus load, so keep the setting as follows. (Clear interrupt flag of the activation source)
The following capture image shows a signal waveform when the RSPI receives 10 bytes of data. At this time, the DMAC transfer is enabled and configured to do 10 bytes (1 byte x 10 times) transfer triggered by each RSIP interrupts. In the image, SSL, CLK and MOSI are actual SPI communication signals, following RSPI RX, RSPI TX, DMA RX and DMA TX show the timing of the CPU interrupt handler call occurrence. The test program was implemented so that the GPIO pin will go to low when the CPU interrupt handler is called.
As you can see in the picture below, the interrupt handlers are called in the following order. We will review how and why the interrupt occurred at this timing:
1. DMAC transfer end interrupt for RSPI Transmit
First you will get the DMA TX transfer end interrupt around two bytes earlier. The reason why it occurs two bytes earlier is due to the RSPI shift register and the SPTI interrupt timing. As soon as RSPI is enabled, if the shit register is empty, the RSPI issues TX buffer empty interrupt, that triggers DMACs first transfer (first byte) to the RSIP data register (SPDR). The data will move to the shift register soon, and then another TX buffer empty interrupt occurrs and the second DMAC transfer (second byte) will be transferred. These are done before receiving the clock signal from the connected device. After that, the remaining 8 bytes will be transferred by synchronizing with the SPI clock. Therefore, the DMAC Transfer end interrupt occurs 2 bytes earlier.
Please note that this is not a good place to put some user code like restarting the RSPI slave operation, since the RSPI clock is still coming in.
Refer to section Serial Peripheral Interface > Operation > Communications Operating Mode > Full-Duplex Communications in the hardware user manual of MCU device.
2. RSPI Transmit buffer empty interrupt
After the DMAC has completed its TX task with the provided transfer information (e.g. number of transfers), the interrupt request of the RSPI Transmit buffer empty is passed to the CPU when the RSPI TX buffer is empty, so the CPU interrupt handler for the RSPI Transmit buffer empty will be executed. There is no special operation to do here.
3. DMAC transfer end interrupt for RSPI Receive
The DMAC transfer occurs every RSIP Receive buffer full interrupt, and the CPU interrupt handler call for DMAC transfer end interrupt is executed when the 10 bytes (10 times) transfer complete.
4. RSPI RX buffer full interrupt (Does not occur)
You may be wondering why the CPU interrupt handler call of the RSPI Transmit empty interrupt is called. but for the RSPI RX interrupt is not. As explained in #3, the DMAC transfer happens every RSPI Receive buffer full interrupt, so if it received 10 bytes (1 byte x 10 times), 10 interrupt requests are generated. However, all the interrupt requests are passed to the DMAC, and the DMAC executes 10 data transfers. Therefore, in the case of the RSPI RX buffer full interrupt, the CPU interrupt handler call does not happen.
Please note that the RSPI RX buffer full interrupt handler is not a good place to put user code like restarting the RSPI slave operation, and instead it would be better to put it in the DMAC transfer end interrupt for the RSPI Receive handler.
Setting - RSPI slave interrupt generation and user callback code generation
Setting - RSPI slave interrupt generation and user callback code generation
To trigger the DMAC transfer by the RSPI, the RSPI should enable either the TX or TX/RX interrupts. The RSPI can enable the TX interrupt by setting RSPIx.SPCR.SPTIE=1 and the RX interrupt by setting RSPIx.SPCR.SPRIE=1. This allows the RSPI interrupt to arrive at the ICU.
In the CG driver setting on the smart configurator, you can find the Callback function setting field below. However, this field setting enables the generation of user callback function code to allow the user to put any code into the CPU interrupt handling. Even if you uncheck the boxes below, TX, RX, Error interrupt handlers will still be created by the smart configurator (code generator).
Please dont confuse enabling RSPI interrupts and generating the user callback function code for RSPI interrupts.
Setting - ICU
Setting - ICU
The ICU is responsible for deciding whether to forward the RSPI generated interrupts to the CPU or to the DMA (DTC or DMAC). First, the ICU should be configured to receive the RSPI TX or the TX/RX interrupts by setting ICU.IERm.IENn. Then, the ICU needs to be configured to relay the RSPI TX or the RX interrupts to the respective DMAC channel (ICU.DMARSRm), not to the CPU in our example.
Setting - DMAC interrupt handling (generation)
Setting - DMAC interrupt handling (generation)
Unlike the DTC, the DMAC can generate an interrupt (DMACxI) with its own interrupt generation sources, such as the DMAC transfer end event. Additionally, the DMAC can be configured (DMACm.DMCSL.DISEL) to pass every single interrupt to the CPU after it has processed them. However, this will increase unnecessary CPU/bus load, so keep the setting as follows. (Clear interrupt flag of the activation source)
Suitable Products
RX Family","['data/categories/rx_family/data_transfer_(dmac_dtc_others)/ccacdef63f51d672e7af05bc2720fbc5/images/cb1b5d9fc2c2cbd6d91e78ec24a3657b.png', 'data/categories/rx_family/data_transfer_(dmac_dtc_others)/ccacdef63f51d672e7af05bc2720fbc5/images/d2be9c6298b71f61194f009af54be269.png', 'data/categories/rx_family/data_transfer_(dmac_dtc_others)/ccacdef63f51d672e7af05bc2720fbc5/images/0c7713722f7189029a62a9b43e37a8d7.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'RX Family: Timing of CPU interrupt handler call during RSPI full-duplex slave operation with DMAC transfer enabled', 'url': 'https://en-support.renesas.com/knowledgeBase/21715565', 'last_updated': '2024-10-12', 'extracted_at': '2025-03-09T00:12:16.399083'}","Overview This article explains how and when the CPU interrupt handler call is generated on each RSPI and DMAC interrupt when using an RSPI as slave and enabling full-duplex and DMAC transfer. This article only covers three types of interrupts. RSPI - SPRIx  Receive buffer full interrupt RSPI - SPTIx  Transmit buffer empty interrupt DMAC - DMACxI  Transfer end interrupt (1 channel for RSPI RX linked to SPRIx interrupt and 1 channel for RSPI TX linked to SPTIx interrupt) At the end of this article, some related driver software settings are introduced for your reference. Operation Result The following capture image shows a signal waveform when the RSPI receives 10 bytes of data. At this time, the DMAC transfer is enabled and configured to do 10 bytes (1 byte x 10 times) transfer triggered by each RSIP interrupts. In the image, SSL, CLK and MOSI are actual SPI communication signals, following RSPI RX, RSPI TX, DMA RX and DMA TX show the timing of the CPU interrupt handler call occurrence. The test program was implemented so that the GPIO pin will go to low when the CPU interrupt handler is called. As you can see in the picture below, the interrupt handlers are called in the following order. We will review how and why the interrupt occurred at this timing DMAC transfer end interrupt for RSPI Transmit RSPI Transmit buffer empty interrupt DMAC transfer end interrupt for RSPI Receive RSPI Receive buffer full interrupt (Does not occur) 1. DMAC transfer end interrupt for RSPI Transmit First you will get the DMA TX transfer end interrupt around two bytes earlier. The reason why it occurs two bytes earlier is due to the RSPI shift register and the SPTI interrupt timing. As soon as RSPI is enabled, if the shit register is empty, the RSPI issues TX buffer empty interrupt, that triggers DMACs first transfer (first byte) to the RSIP data register (SPDR). The data will move to the shift register soon, and then another TX buffer empty interrupt occurrs and the second DMAC transfer (second byte) will be transferred. These are done before receiving the clock signal from the connected device. After that, the remaining 8 bytes will be transferred by synchronizing with the SPI clock. Therefore, the DMAC Transfer end interrupt occurs 2 bytes earlier. Please note that this is not a good place to put some user code like restarting the RSPI slave operation, since the RSPI clock is still coming in. Refer to section Serial Peripheral Interface  Operation  Communications Operating Mode  Full-Duplex Communications in the hardware user manual of MCU device. 2. RSPI Transmit buffer empty interrupt After the DMAC has completed its TX task with the provided transfer information (e.g. number of transfers), the interrupt request of the RSPI Transmit buffer empty is passed to the CPU when the RSPI TX buffer is empty, so the CPU interrupt handler for the RSPI Transmit buffer empty will be executed. There is no special operation to do here. 3. DMAC transfer end interrupt for RSPI Receive The DMAC transfer occurs every RSIP Receive buffer full interrupt, and the CPU interrupt handler call for DMAC transfer end interrupt is executed when the 10 bytes (10 times) transfer complete. 4. RSPI RX buffer full interrupt (Does not occur) You may be wondering why the CPU interrupt handler call of the RSPI Transmit empty interrupt is called. but for the RSPI RX interrupt is not. As explained in 3, the DMAC transfer happens every RSPI Receive buffer full interrupt, so if it received 10 bytes (1 byte x 10 times), 10 interrupt requests are generated. However, all the interrupt requests are passed to the DMAC, and the DMAC executes 10 data transfers. Therefore, in the case of the RSPI RX buffer full interrupt, the CPU interrupt handler call does not happen. Please note that the RSPI RX buffer full interrupt handler is not a good place to put user code like restarting the RSPI slave operation, and instead it would be better to put it in the DMAC transfer end interrupt for the RSPI Receive handler. Setting - RSPI slave interrupt generation and user callback code generation To trigger the DMAC transfer by the RSPI, the RSPI should enable either the TX or TX/RX interrupts. The RSPI can enable the TX interrupt by setting RSPIx.SPCR.SPTIE1 and the RX interrupt by setting RSPIx.SPCR.SPRIE1. This allows the RSPI interrupt to arrive at the ICU. In the CG driver setting on the smart configurator, you can find the Callback function setting field below. However, this field setting enables the generation of user callback function code to allow the user to put any code into the CPU interrupt handling. Even if you uncheck the boxes below, TX, RX, Error interrupt handlers will still be created by the smart configurator (code generator). Please dont confuse enabling RSPI interrupts and generating the user callback function code for RSPI interrupts. Setting - ICU The ICU is responsible for deciding whether to forward the RSPI generated interrupts to the CPU or to the DMA (DTC or DMAC). First, the ICU should be configured to receive the RSPI TX or the TX/RX interrupts by setting ICU.IERm.IENn. Then, the ICU needs to be configured to relay the RSPI TX or the RX interrupts to the respective DMAC channel (ICU.DMARSRm), not to the CPU in our example. Setting - DMAC interrupt handling (generation) Unlike the DTC, the DMAC can generate an interrupt (DMACxI) with its own interrupt generation sources, such as the DMAC transfer end event. Additionally, the DMAC can be configured (DMACm.DMCSL.DISEL) to pass every single interrupt to the CPU after it has processed them. However, this will increase unnecessary CPU/bus load, so keep the setting as follows. (Clear interrupt flag of the activation source) Suitable Products RX Family",
392527ad99a936bafbcd9ecf8daf19f2,"Question:
How do I set up the Data Transfer Controller (DTC) for the several trigger sources by using code generator driver?
Answer:
To use DTC with multiple trigger sources, set up the DTC Code Generator driver as follows:
(1) Add as many DTC drivers to the Component tab of the Smart Configurator as the number of trigger sources.
Example: Select the two trigger sources

Note:
At this time, the default trigger source is selected.
Then each driver shows an error icon on the bottom left of the driver.
Please remove this error applying step 2 and 3.
(2) Select a different ""Activation source"" trigger source for each DTC driver and make other settings as needed.
(3) All the settings in Base setting tab must remain the same for all DTC driver instances.
If you change some settings on this ""Base setting"" tab, you will need to apply the same settings to the ""Base setting"" tabs of other DTC drivers as well.
Please refer to more information including use case from the following application note and sample code:
RX Family How to Change Transfer Data Length During RSPI Communication Using a DTC Rev.1.00
https://www.renesas.com/search?keywords=R01AN7238
Suitable Products
RX
How do I set up the Data Transfer Controller (DTC) for the several trigger sources by using code generator driver?
How do I set up the Data Transfer Controller (DTC) for the several trigger sources by using code generator driver?
Answer:
To use DTC with multiple trigger sources, set up the DTC Code Generator driver as follows:
(1) Add as many DTC drivers to the Component tab of the Smart Configurator as the number of trigger sources.
Example: Select the two trigger sources

Note:
At this time, the default trigger source is selected.
Then each driver shows an error icon on the bottom left of the driver.
Please remove this error applying step 2 and 3.
(2) Select a different ""Activation source"" trigger source for each DTC driver and make other settings as needed.
(3) All the settings in Base setting tab must remain the same for all DTC driver instances.
If you change some settings on this ""Base setting"" tab, you will need to apply the same settings to the ""Base setting"" tabs of other DTC drivers as well.
Please refer to more information including use case from the following application note and sample code:
RX Family How to Change Transfer Data Length During RSPI Communication Using a DTC Rev.1.00
https://www.renesas.com/search?keywords=R01AN7238
Suitable Products
RX
To use DTC with multiple trigger sources, set up the DTC Code Generator driver as follows:
(1) Add as many DTC drivers to the Component tab of the Smart Configurator as the number of trigger sources.
Example: Select the two trigger sources

Note:
At this time, the default trigger source is selected.
Then each driver shows an error icon on the bottom left of the driver.
Please remove this error applying step 2 and 3.
(2) Select a different ""Activation source"" trigger source for each DTC driver and make other settings as needed.
(3) All the settings in Base setting tab must remain the same for all DTC driver instances.
If you change some settings on this ""Base setting"" tab, you will need to apply the same settings to the ""Base setting"" tabs of other DTC drivers as well.
Please refer to more information including use case from the following application note and sample code:
RX Family How to Change Transfer Data Length During RSPI Communication Using a DTC Rev.1.00
https://www.renesas.com/search?keywords=R01AN7238
To use DTC with multiple trigger sources, set up the DTC Code Generator driver as follows:
(1) Add as many DTC drivers to the Component tab of the Smart Configurator as the number of trigger sources.
Example: Select the two trigger sources
Note:
At this time, the default trigger source is selected.
Then each driver shows an error icon on the bottom left of the driver.
Please remove this error applying step 2 and 3.
(2) Select a different ""Activation source"" trigger source for each DTC driver and make other settings as needed.
(3) All the settings in Base setting tab must remain the same for all DTC driver instances.
If you change some settings on this ""Base setting"" tab, you will need to apply the same settings to the ""Base setting"" tabs of other DTC drivers as well.
Please refer to more information including use case from the following application note and sample code:
RX Family How to Change Transfer Data Length During RSPI Communication Using a DTC Rev.1.00
https://www.renesas.com/search?keywords=R01AN7238
Suitable Products
RX

","['data/categories/rx_family/data_transfer_(dmac_dtc_others)/392527ad99a936bafbcd9ecf8daf19f2/images/70ec38a11eacde77f39d4a2e9ab4a685.png', 'data/categories/rx_family/data_transfer_(dmac_dtc_others)/392527ad99a936bafbcd9ecf8daf19f2/images/8d9db0816448d6aef52e25a5a6440363.png', 'data/categories/rx_family/data_transfer_(dmac_dtc_others)/392527ad99a936bafbcd9ecf8daf19f2/images/38a51ae57dc7c588e03594f35c88dd01.png', 'data/categories/rx_family/data_transfer_(dmac_dtc_others)/392527ad99a936bafbcd9ecf8daf19f2/images/db82a79e1a94ed77cf22d776e0135a4f.png']",[],['|  |\n|  |\n| RX |'],"{'title': 'RX Family: How to set up multiple trigger sources on DTC using Code Generator driver', 'url': 'https://en-support.renesas.com/knowledgeBase/21419422', 'last_updated': '2024-04-06', 'extracted_at': '2025-03-09T00:12:20.007831'}","Question How do I set up the Data Transfer Controller (DTC) for the several trigger sources by using code generator driver? Answer To use DTC with multiple trigger sources, set up the DTC Code Generator driver as follows (1) Add as many DTC drivers to the Component tab of the Smart Configurator as the number of trigger sources. Example Select the two trigger sources Note At this time, the default trigger source is selected. Then each driver shows an error icon on the bottom left of the driver. Please remove this error applying step 2 and 3. (2) Select a different ""Activation source"" trigger source for each DTC driver and make other settings as needed. (3) All the settings in Base setting tab must remain the same for all DTC driver instances. If you change some settings on this ""Base setting"" tab, you will need to apply the same settings to the ""Base setting"" tabs of other DTC drivers as well. Please refer to more information including use case from the following application note and sample code RX Family How to Change Transfer Data Length During RSPI Communication Using a DTC Rev.1.00 https//www.renesas.com/search?keywordsR01AN7238 Suitable Products RX ",
bcc73008f3a1cb3e9fe098e551ea3b76,"Question:
Where should the RTCICn pins be pulled up when using battery backup mode where power is supplied from the VBATT pin when the voltage from the VCC pin drops?
Answer:
First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8  VBATT.
Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation.
When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation.
(Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics.
Suitable Products
RX
Where should the RTCICn pins be pulled up when using battery backup mode where power is supplied from the VBATT pin when the voltage from the VCC pin drops?
Where should the RTCICn pins be pulled up when using battery backup mode where power is supplied from the VBATT pin when the voltage from the VCC pin drops?
Answer:
First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8  VBATT.
Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation.
When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation.
(Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics.
Suitable Products
RX
First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8  VBATT.
Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation.
When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation.
(Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics.
First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8  VBATT.
Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation.
When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation.
(Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics.
First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8  VBATT.
Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation.
When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation.
(Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics.
Suitable Products
RX

",['data/categories/rx_family/battery_backup_function/bcc73008f3a1cb3e9fe098e551ea3b76/images/58462d2cb45ad055cc284d541842ea7f.png'],[],['|  |\n|  |\n| RX |'],"{'title': 'RX Family: When using battery backup mode, where should the RTCICn pins be pulled up?', 'url': 'https://en-support.renesas.com/knowledgeBase/21588894', 'last_updated': None, 'extracted_at': '2025-03-09T00:06:58.169554'}","Question Where should the RTCICn pins be pulled up when using battery backup mode where power is supplied from the VBATT pin when the voltage from the VCC pin drops? Answer First, if the RTCICn pins are pulled up to VCC and VCC becomes a voltage of VBATT/2, the state of RTCICn pins become an intermediate potential and a through-current may flow. Also, if the RTCICn pins are pulled up to VCC when using the RTCICn function, the RTCICn function cannot be used if VCC is not greater than 0.8  VBATT. Meanwhile, the following is an example of a typical battery backup switching circuit. The connection circuit should be determined by the customer after thorough enough evaluation. When the RTCICn pins are pulled up as shown in the circuit example above, they are pulled up to the VCC reference (Note) during VCC operation, and they are pulled up to the VBATT reference (Note) during the battery backup mode operation. (Note) Please consider the voltage drop due to the diode. Also, make sure that the input voltage on the RTCICn pins meets the VIH and VIL electrical characteristics. Suitable Products RX ",
e91bb1809fd784a3ae3f68c8e6d4f02d,"Question:
Is there any limitation when using Double-Precision Floating-Point Coprocessor on some RXv3 devices (RX66N, RX72N, RX72M)?
  Answer:
  n some RXv3 devices, when the Double-Precision Floating Point Coprocessor is enabled, the byte-alignement for the floating point variables should be 4 bytes or 8bytes respectively. Any other byte-alignement smaller than 4 bytes will cause an undefined exeption.
  If the double precision floating handling isn't enabled, there isn't any byte-alignement limitation on the RXv3 core.
  For more information, Chapter 2.8 of RX66N user's manual describes this feature:
  https://www.renesas.com/en/document/mah/rx66n-group-users-manual-hardware?r=1170201
  The double- Precision Floating Coprocessor can be enabled/disabled on the e2studio from the setting below:
        f IAR is using for the RX project developement, the double FPU functionality can be enabled/disabled from the setting below:
      Suitable Products
RX66N, RX72N, RX72M
Is there any limitation when using Double-Precision Floating-Point Coprocessor on some RXv3 devices (RX66N, RX72N, RX72M)?
Answer:
  n some RXv3 devices, when the Double-Precision Floating Point Coprocessor is enabled, the byte-alignement for the floating point variables should be 4 bytes or 8bytes respectively. Any other byte-alignement smaller than 4 bytes will cause an undefined exeption.
  If the double precision floating handling isn't enabled, there isn't any byte-alignement limitation on the RXv3 core.
  For more information, Chapter 2.8 of RX66N user's manual describes this feature:
  https://www.renesas.com/en/document/mah/rx66n-group-users-manual-hardware?r=1170201
  The double- Precision Floating Coprocessor can be enabled/disabled on the e2studio from the setting below:
        f IAR is using for the RX project developement, the double FPU functionality can be enabled/disabled from the setting below:
      Suitable Products
RX66N, RX72N, RX72M
n some RXv3 devices, when the Double-Precision Floating Point Coprocessor is enabled, the byte-alignement for the floating point variables should be 4 bytes or 8bytes respectively. Any other byte-alignement smaller than 4 bytes will cause an undefined exeption.
If the double precision floating handling isn't enabled, there isn't any byte-alignement limitation on the RXv3 core.
For more information, Chapter 2.8 of RX66N user's manual describes this feature:
https://www.renesas.com/en/document/mah/rx66n-group-users-manual-hardware?r=1170201
The double- Precision Floating Coprocessor can be enabled/disabled on the e2studio from the setting below:
f IAR is using for the RX project developement, the double FPU functionality can be enabled/disabled from the setting below:
Suitable Products
RX66N, RX72N, RX72M
??? ??
???
??","['data/categories/rx_family/rx72m_rx72n_rx66n/e91bb1809fd784a3ae3f68c8e6d4f02d/images/21e9b37a6a9e7a6fdf3c40eb2897e807.png', 'data/categories/rx_family/rx72m_rx72n_rx66n/e91bb1809fd784a3ae3f68c8e6d4f02d/images/b186c0cd427793732d9768d591175945.png']",[],"['|  |\n|  |\n| RX66N, RX72N, RX72M |']","{'title': 'Is there any limitation when using Double-Precision Floating-Point Coprocessor on some RXv3 devices (RX66N, RX72N, RX72M)?', 'url': 'https://en-support.renesas.com/knowledgeBase/21716024', 'last_updated': '2024-10-12', 'extracted_at': '2025-03-09T00:02:24.563425'}","Question Is there any limitation when using Double-Precision Floating-Point Coprocessor on some RXv3 devices (RX66N, RX72N, RX72M)? Answer n some RXv3 devices, when the Double-Precision Floating Point Coprocessor is enabled, the byte-alignement for the floating point variables should be 4 bytes or 8bytes respectively. Any other byte-alignement smaller than 4 bytes will cause an undefined exeption. If the double precision floating handling isn't enabled, there isn't any byte-alignement limitation on the RXv3 core. For more information, Chapter 2.8 of RX66N user's manual describes this feature https//www.renesas.com/en/document/mah/rx66n-group-users-manual-hardware?r1170201 The double- Precision Floating Coprocessor can be enabled/disabled on the e2studio from the setting below f IAR is using for the RX project developement, the double FPU functionality can be enabled/disabled from the setting below Suitable Products RX66N, RX72N, RX72M Answer n some RXv3 devices, when the Double-Precision Floating Point Coprocessor is enabled, the byte-alignement for the floating point variables should be 4 bytes or 8bytes respectively. Any other byte-alignement smaller than 4 bytes will cause an undefined exeption. If the double precision floating handling isn't enabled, there isn't any byte-alignement limitation on the RXv3 core. For more information, Chapter 2.8 of RX66N user's manual describes this feature https//www.renesas.com/en/document/mah/rx66n-group-users-manual-hardware?r1170201 The double- Precision Floating Coprocessor can be enabled/disabled on the e2studio from the setting below f IAR is using for the RX project developement, the double FPU functionality can be enabled/disabled from the setting below Suitable Products ??? ?? ??? ??",
9a52300879ee0df7febd7d1b2f7b3784,"Question:
Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment.
Answer:
Make sure that bitmap data is positioned at 4-byte aligned addresses.
In a GCC environment:
In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables.
If you are using e2 studio, select [Project] > [C/C++ Project Settings] to display the properties window. Then, in the tree view of the window, under the [C/C++ General] node, select [Paths and Symbols], open the [Symbols] tab, click the [Add] button, and then add the following definition:
Name: GUI_CONST_STORAGE
Value: __attribute__ ((aligned(4))) const
  In an IAR environment:
In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. Therefore, add the #pragma data_alignment=4 specification to each variable by, for example, a search-and-replace operation.
Suitable Products
RX Family
  
Question:
Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment.
Answer:
Make sure that bitmap data is positioned at 4-byte aligned addresses.
In a GCC environment:
In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables.
If you are using e2 studio, select [Project] > [C/C++ Project Settings] to display the properties window. Then, in the tree view of the window, under the [C/C++ General] node, select [Paths and Symbols], open the [Symbols] tab, click the [Add] button, and then add the following definition:
Name: GUI_CONST_STORAGE
Value: __attribute__ ((aligned(4))) const
  In an IAR environment:
In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. Therefore, add the #pragma data_alignment=4 specification to each variable by, for example, a search-and-replace operation.
Suitable Products
RX Family
Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment.
Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment.
Answer:
Make sure that bitmap data is positioned at 4-byte aligned addresses.
In a GCC environment:
In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables.
If you are using e2 studio, select [Project] > [C/C++ Project Settings] to display the properties window. Then, in the tree view of the window, under the [C/C++ General] node, select [Paths and Symbols], open the [Symbols] tab, click the [Add] button, and then add the following definition:
Name: GUI_CONST_STORAGE
Value: __attribute__ ((aligned(4))) const
  In an IAR environment:
In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. Therefore, add the #pragma data_alignment=4 specification to each variable by, for example, a search-and-replace operation.
Suitable Products
RX Family
Make sure that bitmap data is positioned at 4-byte aligned addresses.
In a GCC environment:
In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables.
If you are using e2 studio, select [Project] > [C/C++ Project Settings] to display the properties window. Then, in the tree view of the window, under the [C/C++ General] node, select [Paths and Symbols], open the [Symbols] tab, click the [Add] button, and then add the following definition:
Name: GUI_CONST_STORAGE
Value: __attribute__ ((aligned(4))) const
  In an IAR environment:
In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. Therefore, add the #pragma data_alignment=4 specification to each variable by, for example, a search-and-replace operation.
Make sure that bitmap data is positioned at 4-byte aligned addresses.
In a GCC environment:
In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables.
If you are using e2 studio, select [Project] > [C/C++ Project Settings] to display the properties window. Then, in the tree view of the window, under the [C/C++ General] node, select [Paths and Symbols], open the [Symbols] tab, click the [Add] button, and then add the following definition:
In an IAR environment:
In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUI_CONST_STORAGE macro. Therefore, add the #pragma data_alignment=4 specification to each variable by, for example, a search-and-replace operation.
Suitable Products
RX Family

",['data/categories/rx_family/others/9a52300879ee0df7febd7d1b2f7b3784/images/5637767e76701d01bb3fc173ea2b08e8.png'],[],['|  |\n|  |\n| RX Family |'],"{'title': 'Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment.', 'url': 'https://en-support.renesas.com/knowledgeBase/20940283', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:29.040606'}","Question Bitmap images are not correctly displayed if DRW2D is enabled by using emWin. This phenomenon occurs in a GCC or IAR environment. Answer Make sure that bitmap data is positioned at 4-byte aligned addresses. In a GCC environment In a GCC environment, the alignment type must be specified for each variable of image data. Each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUICONSTSTORAGE macro. By redefining this macro including alignment specification attribute, you can apply the same alignment specification to all target variables. If you are using e2 studio, select Project  C/C Project Settings to display the properties window. Then, in the tree view of the window, under the C/C General node, select Paths and Symbols, open the Symbols tab, click the Add button, and then add the following definition Name GUICONSTSTORAGE Value attribute ((aligned(4))) const In an IAR environment In an IAR environment, the alignment type must be specified for each variable of image data. Unlike CC-RX or GCC, there is no way to specify the alignment type for all variables at one time. Note, however, that each variable of image data in the source code output by AppWizard or Bitmap Converter bundled with the emWin FIT module is provided with the GUICONSTSTORAGE macro. Therefore, add the pragma dataalignment4 specification to each variable by, for example, a search-and-replace operation. Suitable Products RX Family  In an IAR environment ",
5e5bc918d6d283f85868037d4d180167,"Question:
How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured?
Answer:
In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area.
Therefore, the size of frame buffers is not included in the buffer size set with [Work area size for GUI] (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio.
If you use QE for Display, you can set frame buffers in the following location.
emWin FIT Module Settings:
Note: The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings.
GLCDC FIT Module Settings:
  Note: The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer.
Suitable Products
RX Family
  
Question:
How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured?
Answer:
In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area.
Therefore, the size of frame buffers is not included in the buffer size set with [Work area size for GUI] (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio.
If you use QE for Display, you can set frame buffers in the following location.
emWin FIT Module Settings:
Note: The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings.
GLCDC FIT Module Settings:
  Note: The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer.
Suitable Products
RX Family
How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured?
How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured?
Answer:
In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area.
Therefore, the size of frame buffers is not included in the buffer size set with [Work area size for GUI] (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio.
If you use QE for Display, you can set frame buffers in the following location.
emWin FIT Module Settings:
Note: The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings.
GLCDC FIT Module Settings:
  Note: The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer.
Suitable Products
RX Family
In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area.
Therefore, the size of frame buffers is not included in the buffer size set with [Work area size for GUI] (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio.
If you use QE for Display, you can set frame buffers in the following location.
emWin FIT Module Settings:
Note: The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings.
GLCDC FIT Module Settings:
  Note: The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer.
In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area.
Therefore, the size of frame buffers is not included in the buffer size set with [Work area size for GUI] (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio.
If you use QE for Display, you can set frame buffers in the following location.
emWin FIT Module Settings:
Note: The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings.
GLCDC FIT Module Settings:
Note: The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer.
Suitable Products
RX Family

","['data/categories/rx_family/others/5e5bc918d6d283f85868037d4d180167/images/b27433509fd2a4ca01dd585107531e80.png', 'data/categories/rx_family/others/5e5bc918d6d283f85868037d4d180167/images/ebe6d8707bb5afc67f836cb783939e3b.png', 'data/categories/rx_family/others/5e5bc918d6d283f85868037d4d180167/images/691876c97c7bd58f8bd2e7fc3ad38aa2.png', 'data/categories/rx_family/others/5e5bc918d6d283f85868037d4d180167/images/03a54a7159f31e4505be0df3634ffcba.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940278', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:18.538511'}","Question How should I configure frame buffers when using emWin with RX family? Where are frame buffers secured? Answer In the emWin FIT module, frame buffers are not secured as areas. The user must specify the first address of free space in the Internal RAM or Extended Internal RAM area. Therefore, the size of frame buffers is not included in the buffer size set with Work area size for GUI (size of the buffer used by emWin). Also, frame buffers are not included in section B, section R, and heap area. Note that frame buffers are just free space from the viewpoint of compiler, and therefore their sizes are not applied to the Memory Usage view and other components of e2 studio. If you use QE for Display, you can set frame buffers in the following location. emWin FIT Module Settings Note The address of frame buffer 1 is linked to the setting of the start address of the frame buffer in the GLCDC FIT module. To change the address, go to the GLCDC FIT module settings. GLCDC FIT Module Settings Note The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer. Suitable Products RX Family  Note The starting address setting of the frame buffer is linked to the address of frame buffer 1 in the emWin FIT module. If you want to change the address of frame buffer 1 in the emWin FIT module, change this starting address setting of frame buffer. ",
15b8c3770d2ad86ca65ea35992eef21e,"Question:
Enabling an interrupt (software configurable) on a peripheral results in an error in the smart configurator. How can I fix this issue?
Answer:
Some RX MCU peripherals use only fixed interrupt vectors, while some others also use software configurable interrupt vectors. If you use a software configurable interrupt and only configure the ""Component tab"", you will get the following error:
Example for GTCIU2 setting:
To resolve this error, you must configure additional interrupt settings in the Interrupt tab.
As shown in the figure below, you need to select the interrupt from the corresponding interrupt vector group, INTA or INTB.
Please also refer to the ""User Manual: Hardware"" of each product to determine whether the interrupt belongs to INTA or INTB.
Suitable Products
RX Family
Enabling an interrupt (software configurable) on a peripheral results in an error in the smart configurator. How can I fix this issue?
Enabling an interrupt (software configurable) on a peripheral results in an error in the smart configurator. How can I fix this issue?
Answer:
Some RX MCU peripherals use only fixed interrupt vectors, while some others also use software configurable interrupt vectors. If you use a software configurable interrupt and only configure the ""Component tab"", you will get the following error:
Example for GTCIU2 setting:
To resolve this error, you must configure additional interrupt settings in the Interrupt tab.
As shown in the figure below, you need to select the interrupt from the corresponding interrupt vector group, INTA or INTB.
Please also refer to the ""User Manual: Hardware"" of each product to determine whether the interrupt belongs to INTA or INTB.
Suitable Products
RX Family
Some RX MCU peripherals use only fixed interrupt vectors, while some others also use software configurable interrupt vectors. If you use a software configurable interrupt and only configure the ""Component tab"", you will get the following error:
Example for GTCIU2 setting:
To resolve this error, you must configure additional interrupt settings in the Interrupt tab.
As shown in the figure below, you need to select the interrupt from the corresponding interrupt vector group, INTA or INTB.
Please also refer to the ""User Manual: Hardware"" of each product to determine whether the interrupt belongs to INTA or INTB.
Some RX MCU peripherals use only fixed interrupt vectors, while some others also use software configurable interrupt vectors. If you use a software configurable interrupt and only configure the ""Component tab"", you will get the following error:
Example for GTCIU2 setting:
To resolve this error, you must configure additional interrupt settings in the Interrupt tab.
As shown in the figure below, you need to select the interrupt from the corresponding interrupt vector group, INTA or INTB.
Please also refer to the ""User Manual: Hardware"" of each product to determine whether the interrupt belongs to INTA or INTB.
Suitable Products
RX Family

","['data/categories/rx_family/others/15b8c3770d2ad86ca65ea35992eef21e/images/41f4c059480f96c6a721c90f2f416caa.png', 'data/categories/rx_family/others/15b8c3770d2ad86ca65ea35992eef21e/images/3ceb03b38c7e310a9541757368c67e29.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'RX Family: How to configure the software configurable interrupt in the Smart Configurator?', 'url': 'https://en-support.renesas.com/knowledgeBase/21634939', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:12.081498'}","Question Enabling an interrupt (software configurable) on a peripheral results in an error in the smart configurator. How can I fix this issue? Answer Some RX MCU peripherals use only fixed interrupt vectors, while some others also use software configurable interrupt vectors. If you use a software configurable interrupt and only configure the ""Component tab"", you will get the following error Example for GTCIU2 setting To resolve this error, you must configure additional interrupt settings in the Interrupt tab. As shown in the figure below, you need to select the interrupt from the corresponding interrupt vector group, INTA or INTB. Please also refer to the ""User Manual Hardware"" of each product to determine whether the interrupt belongs to INTA or INTB. Suitable Products RX Family ",
94cc854ff3d461dcab0b65f54fb8e25f,"Question:
How to configure the CC-RX Optimizing Linkage Options through the project configuration in the e2studio IDE
Answer:
The CC-RX compiler offers Optimizing Linkage Editor (rlink) Options for users to determine how to link object module, link directive files, and library files and generates an object file executable in the target system. This article is meant for guiding fresh users to configure the CC-RX Compiler linker optimization through the e2 studio IDE. In addition, user can also refer to the CC-RX Compiler Users Manual for the detail descriptions of the supported Optimizing Linkage Editor Options after reading this article.
The first step for user is to open the Linker Optimization configuration through the e2 studio IDE. Please follow the instructions below to get ready for doing the further configuration.
Specify the RX project
Through the e2studio toolbar, click the Project and click the Properties
In the Properties window, navigate to C/C++ Build and expand it
Select the Settings to open the corresponding configuration in the left side pane of Properties window.
In the left side pane, navigate to the Tool Settings tab and expand the Linker item
Select the Optimization item within Linker settings
Now, users can proceed with the Optimization configuration based on your needs, and there are five major settings which are introduced below.
The Optimization Type (-optimize) configuration:
When Optimization type is configured as All, the -optimize without sub options, which executes all optimization, is used.
It is equivalent to -optimize=symbol_delete,same_code,short_format,branch.
User can specify the Minimum code size (-samesize) with a hexadecimal value from 8 to 7FFF for the optimization with the same_code unification. The default size is 0x1E (-samesize=1E).
When Optimization type is configured as No optimize, the -nooptimize option is specified, and optimization is not performed at linkage.
When Optimization type is configured as Speed-oriented optimization, the -optimize=speed option is used.
This configuration executes optimizations other than those reducing object speed.
This is equivalent to -optimize=symbol_delete,short_format,branch.
When Optimization type is configured as Safe optimization, the -optimize=safe option is used.
This configuration executes optimization other than those limited by variable or function attributes. This is equivalent to -optimize=short_format,branch.
When Optimization type is configured as Custom, the sub options will be incorporated based upon the following user configuration.
Deletes variables/functions that are not referenced (-optimize=symbol_delete)
Creates a subroutine for the same instruction sequence (-optimize=same_code)
When -optimize=same_code is specified, the -samesize will be included along with the option.
Replaces an instruction with a smaller-size instruction (-optimize=short_format)
Optimizes branch instruction size (optimize=branch)
For example, the Custom configuration incorporates the symbol_delete sub option usage.
Exclude the specified variable or function from the unreferenced symbol deletion optimization (-symbol_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration.
For an example as below, if I want to disable the optimization for an unreferenced variable (test_unreference_variable) in my program, the corresponding configuration is like below. This is equivalent to -symbol_forbid=_test_unreference_variable
Exclude the specified variable or function from the same-code unification optimization (-samecode_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration. When the function argument is void, specify as _<function name>().
For example, if I want to exclude the test_func() from the optimization in my program, the corresponding configuration is like below. Note that this is equivalent to -samecode_forbid=_test_func().
Exclude the specified from the optimization (-section_forbid)
In the e2studio properties window, user can go to Section (Linker/Section) and open the section viewer to add or check the section configuration.
For example, if I want to exclude the PFRAM section from the optimization in my program, the corresponding configuration is like below. This is equivalent to -section_forbid=(PFRAM)
Exclude a specified address range from the optimization (-absolute_forbid)
Disables optimization regarding the input address plus size specification.
For example:
Suitable Products
RX Family
How to configure the CC-RX Optimizing Linkage Options through the project configuration in the e2studio IDE
How to configure the CC-RX Optimizing Linkage Options through the project configuration in the e2studio IDE
Answer:
The CC-RX compiler offers Optimizing Linkage Editor (rlink) Options for users to determine how to link object module, link directive files, and library files and generates an object file executable in the target system. This article is meant for guiding fresh users to configure the CC-RX Compiler linker optimization through the e2 studio IDE. In addition, user can also refer to the CC-RX Compiler Users Manual for the detail descriptions of the supported Optimizing Linkage Editor Options after reading this article.
The first step for user is to open the Linker Optimization configuration through the e2 studio IDE. Please follow the instructions below to get ready for doing the further configuration.
Specify the RX project
Through the e2studio toolbar, click the Project and click the Properties
In the Properties window, navigate to C/C++ Build and expand it
Select the Settings to open the corresponding configuration in the left side pane of Properties window.
In the left side pane, navigate to the Tool Settings tab and expand the Linker item
Select the Optimization item within Linker settings
Now, users can proceed with the Optimization configuration based on your needs, and there are five major settings which are introduced below.
The Optimization Type (-optimize) configuration:
When Optimization type is configured as All, the -optimize without sub options, which executes all optimization, is used.
It is equivalent to -optimize=symbol_delete,same_code,short_format,branch.
User can specify the Minimum code size (-samesize) with a hexadecimal value from 8 to 7FFF for the optimization with the same_code unification. The default size is 0x1E (-samesize=1E).
When Optimization type is configured as No optimize, the -nooptimize option is specified, and optimization is not performed at linkage.
When Optimization type is configured as Speed-oriented optimization, the -optimize=speed option is used.
This configuration executes optimizations other than those reducing object speed.
This is equivalent to -optimize=symbol_delete,short_format,branch.
When Optimization type is configured as Safe optimization, the -optimize=safe option is used.
This configuration executes optimization other than those limited by variable or function attributes. This is equivalent to -optimize=short_format,branch.
When Optimization type is configured as Custom, the sub options will be incorporated based upon the following user configuration.
Deletes variables/functions that are not referenced (-optimize=symbol_delete)
Creates a subroutine for the same instruction sequence (-optimize=same_code)
When -optimize=same_code is specified, the -samesize will be included along with the option.
Replaces an instruction with a smaller-size instruction (-optimize=short_format)
Optimizes branch instruction size (optimize=branch)
For example, the Custom configuration incorporates the symbol_delete sub option usage.
Exclude the specified variable or function from the unreferenced symbol deletion optimization (-symbol_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration.
For an example as below, if I want to disable the optimization for an unreferenced variable (test_unreference_variable) in my program, the corresponding configuration is like below. This is equivalent to -symbol_forbid=_test_unreference_variable
Exclude the specified variable or function from the same-code unification optimization (-samecode_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration. When the function argument is void, specify as _<function name>().
For example, if I want to exclude the test_func() from the optimization in my program, the corresponding configuration is like below. Note that this is equivalent to -samecode_forbid=_test_func().
Exclude the specified from the optimization (-section_forbid)
In the e2studio properties window, user can go to Section (Linker/Section) and open the section viewer to add or check the section configuration.
For example, if I want to exclude the PFRAM section from the optimization in my program, the corresponding configuration is like below. This is equivalent to -section_forbid=(PFRAM)
Exclude a specified address range from the optimization (-absolute_forbid)
Disables optimization regarding the input address plus size specification.
For example:
Suitable Products
RX Family
The CC-RX compiler offers Optimizing Linkage Editor (rlink) Options for users to determine how to link object module, link directive files, and library files and generates an object file executable in the target system. This article is meant for guiding fresh users to configure the CC-RX Compiler linker optimization through the e2 studio IDE. In addition, user can also refer to the CC-RX Compiler Users Manual for the detail descriptions of the supported Optimizing Linkage Editor Options after reading this article.
The first step for user is to open the Linker Optimization configuration through the e2 studio IDE. Please follow the instructions below to get ready for doing the further configuration.
Specify the RX project
Through the e2studio toolbar, click the Project and click the Properties
In the Properties window, navigate to C/C++ Build and expand it
Select the Settings to open the corresponding configuration in the left side pane of Properties window.
In the left side pane, navigate to the Tool Settings tab and expand the Linker item
Select the Optimization item within Linker settings
Now, users can proceed with the Optimization configuration based on your needs, and there are five major settings which are introduced below.
The Optimization Type (-optimize) configuration:
When Optimization type is configured as All, the -optimize without sub options, which executes all optimization, is used.
It is equivalent to -optimize=symbol_delete,same_code,short_format,branch.
User can specify the Minimum code size (-samesize) with a hexadecimal value from 8 to 7FFF for the optimization with the same_code unification. The default size is 0x1E (-samesize=1E).
When Optimization type is configured as No optimize, the -nooptimize option is specified, and optimization is not performed at linkage.
When Optimization type is configured as Speed-oriented optimization, the -optimize=speed option is used.
This configuration executes optimizations other than those reducing object speed.
This is equivalent to -optimize=symbol_delete,short_format,branch.
When Optimization type is configured as Safe optimization, the -optimize=safe option is used.
This configuration executes optimization other than those limited by variable or function attributes. This is equivalent to -optimize=short_format,branch.
When Optimization type is configured as Custom, the sub options will be incorporated based upon the following user configuration.
Deletes variables/functions that are not referenced (-optimize=symbol_delete)
Creates a subroutine for the same instruction sequence (-optimize=same_code)
When -optimize=same_code is specified, the -samesize will be included along with the option.
Replaces an instruction with a smaller-size instruction (-optimize=short_format)
Optimizes branch instruction size (optimize=branch)
For example, the Custom configuration incorporates the symbol_delete sub option usage.
Exclude the specified variable or function from the unreferenced symbol deletion optimization (-symbol_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration.
For an example as below, if I want to disable the optimization for an unreferenced variable (test_unreference_variable) in my program, the corresponding configuration is like below. This is equivalent to -symbol_forbid=_test_unreference_variable
Exclude the specified variable or function from the same-code unification optimization (-samecode_forbid)
For a C/C++ variable or C function name, add an underscore (_) at the head of the definition name in the configuration. When the function argument is void, specify as _<function name>().
For example, if I want to exclude the test_func() from the optimization in my program, the corresponding configuration is like below. Note that this is equivalent to -samecode_forbid=_test_func().
Exclude the specified from the optimization (-section_forbid)
In the e2studio properties window, user can go to Section (Linker/Section) and open the section viewer to add or check the section configuration.
For example, if I want to exclude the PFRAM section from the optimization in my program, the corresponding configuration is like below. This is equivalent to -section_forbid=(PFRAM)
Exclude a specified address range from the optimization (-absolute_forbid)
Disables optimization regarding the input address plus size specification.
For example:
The CC-RX compiler offers Optimizing Linkage Editor (rlink) Options for users to determine how to link object module, link directive files, and library files and generates an object file executable in the target system. This article is meant for guiding fresh users to configure the CC-RX Compiler linker optimization through the e2 studio IDE. In addition, user can also refer to the CC-RX Compiler Users Manual for the detail descriptions of the supported Optimizing Linkage Editor Options after reading this article.
The first step for user is to open the Linker Optimization configuration through the e2 studio IDE. Please follow the instructions below to get ready for doing the further configuration.
Now, users can proceed with the Optimization configuration based on your needs, and there are five major settings which are introduced below.
Suitable Products
RX Family","['data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/5fb9db7af0c037fd31d168caaab5eb42.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/adac9960064a98a453f5e04c4794be38.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/999e1788be2278656c8f0361983dc09c.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/fc8ca249b46d51a86d368616d2eaee45.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/9ac8679252f3440a58b18aeded5a4bd4.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/3b4ce9eaf37b46cf549ce765850eb948.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/b39b1b862bebfd07a2c6c34503e4a081.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/83a1bfbe0c718f4eea4b41a7e69b01a4.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/7f3c4fd447588fee97bc7e7fa4adb1b8.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/633e4df4df0e971956873910ccbf7582.png', 'data/categories/rx_family/others/94cc854ff3d461dcab0b65f54fb8e25f/images/7d823e46016bcb87d7a11600b643c820.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'RX Family: How to configure the CC-RX Optimizing Linkage Options through the project configuration in the e2studio IDE', 'url': 'https://en-support.renesas.com/knowledgeBase/21727826', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:04.242757'}","Question How to configure the CC-RX Optimizing Linkage Options through the project configuration in the e2studio IDE Answer The CC-RX compiler offers Optimizing Linkage Editor (rlink) Options for users to determine how to link object module, link directive files, and library files and generates an object file executable in the target system. This article is meant for guiding fresh users to configure the CC-RX Compiler linker optimization through the e2 studio IDE. In addition, user can also refer to the CC-RX Compiler Users Manual for the detail descriptions of the supported Optimizing Linkage Editor Options after reading this article. The first step for user is to open the Linker Optimization configuration through the e2 studio IDE. Please follow the instructions below to get ready for doing the further configuration. Specify the RX project Through the e2studio toolbar, click the Project and click the Properties In the Properties window, navigate to C/C Build and expand it Select the Settings to open the corresponding configuration in the left side pane of Properties window. In the left side pane, navigate to the Tool Settings tab and expand the Linker item Select the Optimization item within Linker settings Now, users can proceed with the Optimization configuration based on your needs, and there are five major settings which are introduced below. The Optimization Type (-optimize) configuration When Optimization type is configured as All, the -optimize without sub options, which executes all optimization, is used. It is equivalent to -optimizesymboldelete,samecode,shortformat,branch. User can specify the Minimum code size (-samesize) with a hexadecimal value from 8 to 7FFF for the optimization with the samecode unification. The default size is 0x1E (-samesize1E). When Optimization type is configured as No optimize, the -nooptimize option is specified, and optimization is not performed at linkage. When Optimization type is configured as Speed-oriented optimization, the -optimizespeed option is used. This configuration executes optimizations other than those reducing object speed. This is equivalent to -optimizesymboldelete,shortformat,branch. When Optimization type is configured as Safe optimization, the -optimizesafe option is used. This configuration executes optimization other than those limited by variable or function attributes. This is equivalent to -optimizeshortformat,branch. When Optimization type is configured as Custom, the sub options will be incorporated based upon the following user configuration. Deletes variables/functions that are not referenced (-optimizesymboldelete) Creates a subroutine for the same instruction sequence (-optimizesamecode) When -optimizesamecode is specified, the -samesize will be included along with the option. Replaces an instruction with a smaller-size instruction (-optimizeshortformat) Optimizes branch instruction size (optimizebranch) For example, the Custom configuration incorporates the symboldelete sub option usage. Exclude the specified variable or function from the unreferenced symbol deletion optimization (-symbolforbid) For a C/C variable or C function name, add an underscore () at the head of the definition name in the configuration. For an example as below, if I want to disable the optimization for an unreferenced variable (testunreferencevariable) in my program, the corresponding configuration is like below. This is equivalent to -symbolforbidtestunreferencevariable Exclude the specified variable or function from the same-code unification optimization (-samecodeforbid) For a C/C variable or C function name, add an underscore () at the head of the definition name in the configuration. When the function argument is void, specify as function name(). For example, if I want to exclude the testfunc() from the optimization in my program, the corresponding configuration is like below. Note that this is equivalent to -samecodeforbidtestfunc(). Exclude the specified from the optimization (-sectionforbid) In the e2studio properties window, user can go to Section (Linker/Section) and open the section viewer to add or check the section configuration. For example, if I want to exclude the PFRAM section from the optimization in my program, the corresponding configuration is like below. This is equivalent to -sectionforbid(PFRAM) Exclude a specified address range from the optimization (-absoluteforbid) Disables optimization regarding the input address plus size specification. For example Suitable Products RX Family",
24ae2369724a839c71b001dfcb96c279,"Question:
I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations.
Answer:
Did you complete the pin settings?
If you select [Custom board] when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.
 Properties of each FIT module in the [Components] tab
Select the check boxes of the pins to be used.
 Peripherals in the [Pins] tab
For each pin, click [Pin Assignment], and then select the pin to be assigned.
 For GLCDC (r_glcdc_rx)
    Suitable Products
RX Family
  
Question:
I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations.
Answer:
Did you complete the pin settings?
If you select [Custom board] when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.
 Properties of each FIT module in the [Components] tab
Select the check boxes of the pins to be used.
 Peripherals in the [Pins] tab
For each pin, click [Pin Assignment], and then select the pin to be assigned.
 For GLCDC (r_glcdc_rx)
    Suitable Products
RX Family
I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations.
I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations.
Answer:
Did you complete the pin settings?
If you select [Custom board] when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.
 Properties of each FIT module in the [Components] tab
Select the check boxes of the pins to be used.
 Peripherals in the [Pins] tab
For each pin, click [Pin Assignment], and then select the pin to be assigned.
 For GLCDC (r_glcdc_rx)
    Suitable Products
RX Family
Did you complete the pin settings?
If you select [Custom board] when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.
 Properties of each FIT module in the [Components] tab
Select the check boxes of the pins to be used.
 Peripherals in the [Pins] tab
For each pin, click [Pin Assignment], and then select the pin to be assigned.
 For GLCDC (r_glcdc_rx)
Did you complete the pin settings?
If you select [Custom board] when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.
 Properties of each FIT module in the [Components] tab
Select the check boxes of the pins to be used.
 Peripherals in the [Pins] tab
For each pin, click [Pin Assignment], and then select the pin to be assigned.
 For GLCDC (r_glcdc_rx)
Suitable Products
RX Family

","['data/categories/rx_family/others/24ae2369724a839c71b001dfcb96c279/images/c2ef01d20c3a4384c8ea21660576743e.png', 'data/categories/rx_family/others/24ae2369724a839c71b001dfcb96c279/images/03bf9495f310eadc6f82d5469dc82805.png', 'data/categories/rx_family/others/24ae2369724a839c71b001dfcb96c279/images/2b6ce40dd1978753f5da261c4d7d4086.png', 'data/categories/rx_family/others/24ae2369724a839c71b001dfcb96c279/images/ce3c68f6064a9f48d481166a92659f42.png', 'data/categories/rx_family/others/24ae2369724a839c71b001dfcb96c279/images/7b1f4044af6c6c7c0d5c73f879cc29b2.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations.', 'url': 'https://en-support.renesas.com/knowledgeBase/20940281', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:23.782681'}","Question I am using a custom board and LCD. No window appears and the LCD does not respond to touch operations. Answer Did you complete the pin settings? If you select Custom board when creating a project, you must use the Smart Configurator to specify the settings for the pins that will be used for peripherals.  Properties of each FIT module in the Components tab Select the check boxes of the pins to be used.  Peripherals in the Pins tab For each pin, click Pin Assignment, and then select the pin to be assigned.  For GLCDC (rglcdcrx) Suitable Products RX Family  Suitable Products ",
7d965eee5b1ea2fae1923366dc6abb60,"Question:
A link error occurs due to insufficient internal RAM for some reason.
For example, in a use case where multiple windows are to be displayed on an on-board LCD by using the RX65N Envision Kit, I created the windows by using AppWizard (a GUI design tool for the emWin graphic middleware of Segger) and then built the windows by using e2 studio. At this time, a link error occurred. Why?
Answer:
This is probably due to RAM space being insufficient to allocate window data. 
If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. 
Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas.
Suitable Products
RX Family
  
Question:
A link error occurs due to insufficient internal RAM for some reason.
For example, in a use case where multiple windows are to be displayed on an on-board LCD by using the RX65N Envision Kit, I created the windows by using AppWizard (a GUI design tool for the emWin graphic middleware of Segger) and then built the windows by using e2 studio. At this time, a link error occurred. Why?
Answer:
This is probably due to RAM space being insufficient to allocate window data. 
If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. 
Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas.
Suitable Products
RX Family
A link error occurs due to insufficient internal RAM for some reason.
For example, in a use case where multiple windows are to be displayed on an on-board LCD by using the RX65N Envision Kit, I created the windows by using AppWizard (a GUI design tool for the emWin graphic middleware of Segger) and then built the windows by using e2 studio. At this time, a link error occurred. Why?
A link error occurs due to insufficient internal RAM for some reason.
For example, in a use case where multiple windows are to be displayed on an on-board LCD by using the RX65N Envision Kit, I created the windows by using AppWizard (a GUI design tool for the emWin graphic middleware of Segger) and then built the windows by using e2 studio. At this time, a link error occurred. Why?
Answer:
This is probably due to RAM space being insufficient to allocate window data. 
If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. 
Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas.
Suitable Products
RX Family
This is probably due to RAM space being insufficient to allocate window data. 
If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. 
Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas.
This is probably due to RAM space being insufficient to allocate window data. 
If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. 
Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas.
Suitable Products
RX Family

",['data/categories/rx_family/others/7d965eee5b1ea2fae1923366dc6abb60/images/bc0b61a5727812c674510d3fc75e9b79.png'],[],['|  |\n|  |\n| RX Family |'],"{'title': 'A link error occurs due to insufficient internal RAM for some reason.', 'url': 'https://en-support.renesas.com/knowledgeBase/20940271', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:59.104920'}","Question A link error occurs due to insufficient internal RAM for some reason. For example, in a use case where multiple windows are to be displayed on an on-board LCD by using the RX65N Envision Kit, I created the windows by using AppWizard (a GUI design tool for the emWin graphic middleware of Segger) and then built the windows by using e2 studio. At this time, a link error occurred. Why? Answer This is probably due to RAM space being insufficient to allocate window data. If an RX65N is used, the RAM space available is separated into two areas, Internal RAM (256 KB) and Extended Internal RAM (384 KB), and the addresses in these areas are not consecutive. Also, in use cases where windows are displayed on an LCD, a large amount of space is consumed for frame buffers. Therefore, in these cases, it is very important to manage RAM usage and section allocation. By specifying the section settings so that Extended Internal RAM is used, you become able to fully use the space of both the Internal RAM (256 KB) and Extended Internal RAM (384 KB) areas. Suitable Products RX Family  ",
85f2f3ea1400a595658872fdb8fe99d6,"Question:
How can I use a touch controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
  (2) In the qe_emwin_config.h file that is output, set the EMWIN_TOUCH_IF definition to TOUCH_IF_OTHER.
To use multi-touch operations, also set the EMWIN_USE_MULTITOUCH definition to 1.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the touch controller you use in the following two files:
 r_emwin_rx_pid_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\src
Overview of the program to be implemented:
Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the r_emwin_rx_pidconf_cb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically.
Notes on implementation:
The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop.
Hint:
Consult the implementations of r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c in the same directory.
 PIDConf.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config\PIDConf.c
Overview of the program to be implemented:
Implement the pidconf_cb_single function called from the r_emwin_rx_pidconf_cb function. (Lines 363 to 383)
The pidconf_cb_single function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUI_PID_STATE type (GUI_Type.h)). The function then sets the data in the GUI_TOUCH_StoreStateEx function so that the data is sent to emWin.
For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUI_MTOUCH_StoreEvent function is required, instead of GUI_TOUCH_StoreStateEx, for notification to emWin.
For an analog touch device, you need to implement measurement processing. (Lines 827 to 888)
GUI_TOUCH_X_ActivateX, GUI_TOUCH_X_MeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions.
And create a program in r_emwin_rx_pid_user_if.c to periodically execute GUI_TOUCH_Exec().
(For information on how to execute periodically, refer to r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c.)
Notes on implementation:
The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used.
Hint: 
 pidconf_cb_single, pidconf_cb_multi, and other functions in PIDConf.c
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details about the GUI_PID_STATE type, the GUI_TOUCH_StoreStateEx function, and the GUI_MTOUCH_StoreEvent function, see the emWin user's manual (UM03001_emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide & Reference Manual (segger.com)).
 Page related to touch operations
5.9.4.1 Generic touch screen API
(https://www.segger.com/doc/UM03001_emWin.html#Generic_touch_screen_API)
5.9.4.2.3.4 GUI_TOUCH_X_MeasureY()
(https://www.segger.com/doc/UM03001_emWin.html#GUI_TOUCH_X_MeasureY)
5.9.4.2 The analog touch screen driver
(https://www.segger.com/doc/UM03001_emWin.html#The_analog_touch_screen_driver)
For details about emWin, contact Segger(https://www.segger.com/) or it local agency. 
Suitable Products
RX Family
  
Question:
How can I use a touch controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
  (2) In the qe_emwin_config.h file that is output, set the EMWIN_TOUCH_IF definition to TOUCH_IF_OTHER.
To use multi-touch operations, also set the EMWIN_USE_MULTITOUCH definition to 1.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the touch controller you use in the following two files:
 r_emwin_rx_pid_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\src
Overview of the program to be implemented:
Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the r_emwin_rx_pidconf_cb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically.
Notes on implementation:
The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop.
Hint:
Consult the implementations of r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c in the same directory.
 PIDConf.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config\PIDConf.c
Overview of the program to be implemented:
Implement the pidconf_cb_single function called from the r_emwin_rx_pidconf_cb function. (Lines 363 to 383)
The pidconf_cb_single function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUI_PID_STATE type (GUI_Type.h)). The function then sets the data in the GUI_TOUCH_StoreStateEx function so that the data is sent to emWin.
For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUI_MTOUCH_StoreEvent function is required, instead of GUI_TOUCH_StoreStateEx, for notification to emWin.
For an analog touch device, you need to implement measurement processing. (Lines 827 to 888)
GUI_TOUCH_X_ActivateX, GUI_TOUCH_X_MeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions.
And create a program in r_emwin_rx_pid_user_if.c to periodically execute GUI_TOUCH_Exec().
(For information on how to execute periodically, refer to r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c.)
Notes on implementation:
The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used.
Hint: 
 pidconf_cb_single, pidconf_cb_multi, and other functions in PIDConf.c
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details about the GUI_PID_STATE type, the GUI_TOUCH_StoreStateEx function, and the GUI_MTOUCH_StoreEvent function, see the emWin user's manual (UM03001_emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide & Reference Manual (segger.com)).
 Page related to touch operations
5.9.4.1 Generic touch screen API
(https://www.segger.com/doc/UM03001_emWin.html#Generic_touch_screen_API)
5.9.4.2.3.4 GUI_TOUCH_X_MeasureY()
(https://www.segger.com/doc/UM03001_emWin.html#GUI_TOUCH_X_MeasureY)
5.9.4.2 The analog touch screen driver
(https://www.segger.com/doc/UM03001_emWin.html#The_analog_touch_screen_driver)
For details about emWin, contact Segger(https://www.segger.com/) or it local agency. 
Suitable Products
RX Family
How can I use a touch controller that is not supported by the emWin FIT module or QE for Display?
How can I use a touch controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
  (2) In the qe_emwin_config.h file that is output, set the EMWIN_TOUCH_IF definition to TOUCH_IF_OTHER.
To use multi-touch operations, also set the EMWIN_USE_MULTITOUCH definition to 1.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the touch controller you use in the following two files:
 r_emwin_rx_pid_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\src
Overview of the program to be implemented:
Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the r_emwin_rx_pidconf_cb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically.
Notes on implementation:
The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop.
Hint:
Consult the implementations of r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c in the same directory.
 PIDConf.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config\PIDConf.c
Overview of the program to be implemented:
Implement the pidconf_cb_single function called from the r_emwin_rx_pidconf_cb function. (Lines 363 to 383)
The pidconf_cb_single function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUI_PID_STATE type (GUI_Type.h)). The function then sets the data in the GUI_TOUCH_StoreStateEx function so that the data is sent to emWin.
For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUI_MTOUCH_StoreEvent function is required, instead of GUI_TOUCH_StoreStateEx, for notification to emWin.
For an analog touch device, you need to implement measurement processing. (Lines 827 to 888)
GUI_TOUCH_X_ActivateX, GUI_TOUCH_X_MeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions.
And create a program in r_emwin_rx_pid_user_if.c to periodically execute GUI_TOUCH_Exec().
(For information on how to execute periodically, refer to r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c.)
Notes on implementation:
The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used.
Hint: 
 pidconf_cb_single, pidconf_cb_multi, and other functions in PIDConf.c
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details about the GUI_PID_STATE type, the GUI_TOUCH_StoreStateEx function, and the GUI_MTOUCH_StoreEvent function, see the emWin user's manual (UM03001_emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide & Reference Manual (segger.com)).
 Page related to touch operations
5.9.4.1 Generic touch screen API
(https://www.segger.com/doc/UM03001_emWin.html#Generic_touch_screen_API)
5.9.4.2.3.4 GUI_TOUCH_X_MeasureY()
(https://www.segger.com/doc/UM03001_emWin.html#GUI_TOUCH_X_MeasureY)
5.9.4.2 The analog touch screen driver
(https://www.segger.com/doc/UM03001_emWin.html#The_analog_touch_screen_driver)
For details about emWin, contact Segger(https://www.segger.com/) or it local agency. 
Suitable Products
RX Family
With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
  (2) In the qe_emwin_config.h file that is output, set the EMWIN_TOUCH_IF definition to TOUCH_IF_OTHER.
To use multi-touch operations, also set the EMWIN_USE_MULTITOUCH definition to 1.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the touch controller you use in the following two files:
 r_emwin_rx_pid_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\src
Overview of the program to be implemented:
Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the r_emwin_rx_pidconf_cb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically.
Notes on implementation:
The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop.
Hint:
Consult the implementations of r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c in the same directory.
 PIDConf.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config\PIDConf.c
Overview of the program to be implemented:
Implement the pidconf_cb_single function called from the r_emwin_rx_pidconf_cb function. (Lines 363 to 383)
The pidconf_cb_single function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUI_PID_STATE type (GUI_Type.h)). The function then sets the data in the GUI_TOUCH_StoreStateEx function so that the data is sent to emWin.
For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUI_MTOUCH_StoreEvent function is required, instead of GUI_TOUCH_StoreStateEx, for notification to emWin.
For an analog touch device, you need to implement measurement processing. (Lines 827 to 888)
GUI_TOUCH_X_ActivateX, GUI_TOUCH_X_MeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions.
And create a program in r_emwin_rx_pid_user_if.c to periodically execute GUI_TOUCH_Exec().
(For information on how to execute periodically, refer to r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c.)
Notes on implementation:
The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used.
Hint: 
 pidconf_cb_single, pidconf_cb_multi, and other functions in PIDConf.c
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details about the GUI_PID_STATE type, the GUI_TOUCH_StoreStateEx function, and the GUI_MTOUCH_StoreEvent function, see the emWin user's manual (UM03001_emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide & Reference Manual (segger.com)).
 Page related to touch operations
5.9.4.1 Generic touch screen API
(https://www.segger.com/doc/UM03001_emWin.html#Generic_touch_screen_API)
5.9.4.2.3.4 GUI_TOUCH_X_MeasureY()
(https://www.segger.com/doc/UM03001_emWin.html#GUI_TOUCH_X_MeasureY)
5.9.4.2 The analog touch screen driver
(https://www.segger.com/doc/UM03001_emWin.html#The_analog_touch_screen_driver)
For details about emWin, contact Segger(https://www.segger.com/) or it local agency.
With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the qe_emwin_config.h file that is output, set the EMWIN_TOUCH_IF definition to TOUCH_IF_OTHER.
To use multi-touch operations, also set the EMWIN_USE_MULTITOUCH definition to 1.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the touch controller you use in the following two files:
 r_emwin_rx_pid_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\src
Overview of the program to be implemented:
Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the r_emwin_rx_pidconf_cb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically.
Notes on implementation:
The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop.
Hint:
Consult the implementations of r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c in the same directory.
 PIDConf.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config\PIDConf.c
Overview of the program to be implemented:
Implement the pidconf_cb_single function called from the r_emwin_rx_pidconf_cb function. (Lines 363 to 383)
The pidconf_cb_single function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUI_PID_STATE type (GUI_Type.h)). The function then sets the data in the GUI_TOUCH_StoreStateEx function so that the data is sent to emWin.
For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUI_MTOUCH_StoreEvent function is required, instead of GUI_TOUCH_StoreStateEx, for notification to emWin.
For an analog touch device, you need to implement measurement processing. (Lines 827 to 888)
GUI_TOUCH_X_ActivateX, GUI_TOUCH_X_MeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions.
And create a program in r_emwin_rx_pid_user_if.c to periodically execute GUI_TOUCH_Exec().
(For information on how to execute periodically, refer to r_emwin_rx_pid_iic_if.c and r_emwin_rx_pid_spi_if.c.)
Notes on implementation:
The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used.
Hint: 
 pidconf_cb_single, pidconf_cb_multi, and other functions in PIDConf.c
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details about the GUI_PID_STATE type, the GUI_TOUCH_StoreStateEx function, and the GUI_MTOUCH_StoreEvent function, see the emWin user's manual (UM03001_emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide & Reference Manual (segger.com)).
 Page related to touch operations
5.9.4.1 Generic touch screen API
(https://www.segger.com/doc/UM03001_emWin.html#Generic_touch_screen_API)
5.9.4.2.3.4 GUI_TOUCH_X_MeasureY()
(https://www.segger.com/doc/UM03001_emWin.html#GUI_TOUCH_X_MeasureY)
5.9.4.2 The analog touch screen driver
(https://www.segger.com/doc/UM03001_emWin.html#The_analog_touch_screen_driver)
For details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
RX Family

",['data/categories/rx_family/others/85f2f3ea1400a595658872fdb8fe99d6/images/1159e5a88de327f27e91e3d6feb5f337.png'],[],['|  |\n|  |\n| RX Family |'],"{'title': 'How can I use a touch controller that is not supported by the emWin FIT module or QE for Display?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940276', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:21.441307'}","Question How can I use a touch controller that is not supported by the emWin FIT module or QE for Display? Answer With a touch controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must implement a program that communicates with the touch controller by yourself. See the following procedure (1) Specify the settings to the extent possible, and then output the configuration file (qeemwinconfig.h). (2) In the qeemwinconfig.h file that is output, set the EMWINTOUCHIF definition to TOUCHIFOTHER. To use multi-touch operations, also set the EMWINUSEMULTITOUCH definition to 1. (Note that if you output the configuration file from QE again, the changes you made will be lost.) (3) Implement a program that communicates with the touch controller you use in the following two files  remwinrxpiduserif.c Directory project-namesrcsmcgenremwinrxsrc Overview of the program to be implemented Implement processing that obtains touch event data in accordance with the specifications and protocol of the controller to be used and then passes the data to the remwinrxpidconfcb function. Implement programs that initialize the peripherals that are used to obtain touch event data and set the interval at which to obtain the touch event data by using a timer so that the data is obtained periodically. Notes on implementation The implemented program will probably use interrupt processing to obtain data and send it to emWin. Therefore, make sure that the program does not include a wait loop. Hint Consult the implementations of remwinrxpidiicif.c and remwinrxpidspiif.c in the same directory.  PIDConf.c project-namesrcsmcgenremwinrxlibConfigPIDConf.c Implement the pidconfcbsingle function called from the remwinrxpidconfcb function. (Lines 363 to 383) The pidconfcbsingle function reformats the touch event data passed by an argument into a format that can be passed to emWin(GUIPIDSTATE type (GUIType.h)). The function then sets the data in the GUITOUCHStoreStateEx function so that the data is sent to emWin. For a touch controller that supports multi-touch operations, processing that recognizes multi-touch operations must be implemented and the GUIMTOUCHStoreEvent function is required, instead of GUITOUCHStoreStateEx, for notification to emWin. For an analog touch device, you need to implement measurement processing. (Lines 827 to 888) GUITOUCHXActivateX, GUITOUCHXMeasureX, and other unimplemented functions are provided. Implement analog value measurement programs for these functions. And create a program in remwinrxpiduserif.c to periodically execute GUITOUCHExec(). (For information on how to execute periodically, refer to remwinrxpidiicif.c and remwinrxpidspiif.c.) The origin coordinates (0,0) for touch operations might be different from the base point of the LCD. Therefore, coordinate conversion might be needed depending on the LCD to be used. Hint  pidconfcbsingle, pidconfcbmulti, and other functions in PIDConf.c Supplementary information You need to implement the programs in accordance with the emWin specifications. For details about the GUIPIDSTATE type, the GUITOUCHStoreStateEx function, and the GUIMTOUCHStoreEvent function, see the emWin user's manual (UM03001emWin.pdf) bundled with the emWin FIT module or the web manual provided by Segger, which developed emWin (emWin User Guide  Reference Manual (segger.com)).  Page related to touch operations 5.9.4.1 Generic touch screen API (https//www.segger.com/doc/UM03001emWin.htmlGenerictouchscreenAPI) 5.9.4.2.3.4 GUITOUCHXMeasureY() (https//www.segger.com/doc/UM03001emWin.htmlGUITOUCHXMeasureY) 5.9.4.2 The analog touch screen driver (https//www.segger.com/doc/UM03001emWin.htmlTheanalogtouchscreendriver) For details about emWin, contact Segger(https//www.segger.com/) or it local agency. Suitable Products RX Family  For details about emWin, contact Segger(https//www.segger.com/) or it local agency. (2) In the qeemwinconfig.h file that is output, set the EMWINTOUCHIF definition to TOUCHIFOTHER. ",
c436f6248565606875b83e7d27b76bc5,"Question:
I have a question in regard to an example shown in the RX113 Group User's Manual: Hardware Rev.1.20 (https://www.renesas.com/us/en/document/man/rx113-group-user-s-manual-hardware).
In the connection shown in the following figure, suppose that no power is supplied to the microcomputer. In this case, if a voltage of 5 V DC is supplied to VBUS from a device via the USB connector, isn't the pin (PC16 or PC4) to which USB0_VBUS is connected damaged?
Answer:
The PC16 is 5-volt tolerant even when power is off. Therefore, no problem occurs when VBUS is directly connected.
Because the PC4 is not 5-volt tolerant, lower the voltage to 3.3 V by using, for example, a resistive voltage divider.
Suitable Products
RX113
I have a question in regard to an example shown in the RX113 Group User's Manual: Hardware Rev.1.20 (https://www.renesas.com/us/en/document/man/rx113-group-user-s-manual-hardware).
In the connection shown in the following figure, suppose that no power is supplied to the microcomputer. In this case, if a voltage of 5 V DC is supplied to VBUS from a device via the USB connector, isn't the pin (PC16 or PC4) to which USB0_VBUS is connected damaged?
I have a question in regard to an example shown in the RX113 Group User's Manual: Hardware Rev.1.20 (https://www.renesas.com/us/en/document/man/rx113-group-user-s-manual-hardware).
In the connection shown in the following figure, suppose that no power is supplied to the microcomputer. In this case, if a voltage of 5 V DC is supplied to VBUS from a device via the USB connector, isn't the pin (PC16 or PC4) to which USB0_VBUS is connected damaged?
Answer:
The PC16 is 5-volt tolerant even when power is off. Therefore, no problem occurs when VBUS is directly connected.
Because the PC4 is not 5-volt tolerant, lower the voltage to 3.3 V by using, for example, a resistive voltage divider.
Suitable Products
RX113
The PC16 is 5-volt tolerant even when power is off. Therefore, no problem occurs when VBUS is directly connected.
Because the PC4 is not 5-volt tolerant, lower the voltage to 3.3 V by using, for example, a resistive voltage divider.
The PC16 is 5-volt tolerant even when power is off. Therefore, no problem occurs when VBUS is directly connected.
Because the PC4 is not 5-volt tolerant, lower the voltage to 3.3 V by using, for example, a resistive voltage divider.
Suitable Products
RX113

",['data/categories/rx_family/others/c436f6248565606875b83e7d27b76bc5/images/76e4362fcd0128981e3a583e5e6dcf9f.png'],[],['|  |\n|  |\n| RX113 |'],"{'title': 'A question in regard to the function connection example for a self-powered USB connector', 'url': 'https://en-support.renesas.com/knowledgeBase/21245144', 'last_updated': None, 'extracted_at': '2025-03-09T00:23:48.745923'}","Question I have a question in regard to an example shown in the RX113 Group User's Manual Hardware Rev.1.20 (https//www.renesas.com/us/en/document/man/rx113-group-user-s-manual-hardware). In the connection shown in the following figure, suppose that no power is supplied to the microcomputer. In this case, if a voltage of 5 V DC is supplied to VBUS from a device via the USB connector, isn't the pin (PC16 or PC4) to which USB0VBUS is connected damaged? Answer The PC16 is 5-volt tolerant even when power is off. Therefore, no problem occurs when VBUS is directly connected. Because the PC4 is not 5-volt tolerant, lower the voltage to 3.3 V by using, for example, a resistive voltage divider. Suitable Products RX113 ",
7cd7aedfbd9f831eb17a706ba700d0d1,"Question:
Is there a way in which I can use a debugger to check the data drawn in a frame buffer?
Answer:
If you are using e2 studio, you can check drawn data by using the [Memory] view.
Note: This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette.
1. From the menu bar, select [Window] > [Display View] > [Memory] to open the [Memory] view.
  2. In the [Memory] view, specify the settings so that the first address of a frame buffer is monitored.
  3. In the [New Rendering] tab, select [RAW Image], and then add a new rendering.
  4. Click the [Raw Image Format] button.
  5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click [OK].
  After a while, an image will appear.
The following example shows an image that appears when the display adjustment function is used in QE for Display.
Suitable Products
RX Family
  
Question:
Is there a way in which I can use a debugger to check the data drawn in a frame buffer?
Answer:
If you are using e2 studio, you can check drawn data by using the [Memory] view.
Note: This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette.
1. From the menu bar, select [Window] > [Display View] > [Memory] to open the [Memory] view.
  2. In the [Memory] view, specify the settings so that the first address of a frame buffer is monitored.
  3. In the [New Rendering] tab, select [RAW Image], and then add a new rendering.
  4. Click the [Raw Image Format] button.
  5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click [OK].
  After a while, an image will appear.
The following example shows an image that appears when the display adjustment function is used in QE for Display.
Suitable Products
RX Family
Is there a way in which I can use a debugger to check the data drawn in a frame buffer?
Is there a way in which I can use a debugger to check the data drawn in a frame buffer?
Answer:
If you are using e2 studio, you can check drawn data by using the [Memory] view.
Note: This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette.
1. From the menu bar, select [Window] > [Display View] > [Memory] to open the [Memory] view.
  2. In the [Memory] view, specify the settings so that the first address of a frame buffer is monitored.
  3. In the [New Rendering] tab, select [RAW Image], and then add a new rendering.
  4. Click the [Raw Image Format] button.
  5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click [OK].
  After a while, an image will appear.
The following example shows an image that appears when the display adjustment function is used in QE for Display.
Suitable Products
RX Family
If you are using e2 studio, you can check drawn data by using the [Memory] view.
Note: This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette.
1. From the menu bar, select [Window] > [Display View] > [Memory] to open the [Memory] view.
  2. In the [Memory] view, specify the settings so that the first address of a frame buffer is monitored.
  3. In the [New Rendering] tab, select [RAW Image], and then add a new rendering.
  4. Click the [Raw Image Format] button.
  5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click [OK].
  After a while, an image will appear.
The following example shows an image that appears when the display adjustment function is used in QE for Display.
If you are using e2 studio, you can check drawn data by using the [Memory] view.
Note: This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette.
1. From the menu bar, select [Window] > [Display View] > [Memory] to open the [Memory] view.
2. In the [Memory] view, specify the settings so that the first address of a frame buffer is monitored.
3. In the [New Rendering] tab, select [RAW Image], and then add a new rendering.
4. Click the [Raw Image Format] button.
5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click [OK].
After a while, an image will appear.
The following example shows an image that appears when the display adjustment function is used in QE for Display.
Suitable Products
RX Family

","['data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/687fedfcce2f9beebff26e8d68a77377.png', 'data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/3cd62b8ebfe450eca7b607238be800f5.png', 'data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/34f9039af9fe5c1a6aff18e6127ed7bf.png', 'data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/5a74f74e4d4f6e25e8ec31e6130b9e47.png', 'data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/0a843c77b4df91605afe3c023aeb7590.png', 'data/categories/rx_family/others/7cd7aedfbd9f831eb17a706ba700d0d1/images/6af1e09e718b5d1b4547830bd8c632be.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'Is there a way in which I can use a debugger to check the data drawn in a frame buffer?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940280', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:19.723975'}","Question Is there a way in which I can use a debugger to check the data drawn in a frame buffer? Answer If you are using e2 studio, you can check drawn data by using the Memory view. Note This method is unavailable for CLUT8, CLUT4, and other color depths that require a color palette. 1. From the menu bar, select Window  Display View  Memory to open the Memory view. 2. In the Memory view, specify the settings so that the first address of a frame buffer is monitored. 3. In the New Rendering tab, select RAW Image, and then add a new rendering. 4. Click the Raw Image Format button. 5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click OK. After a while, an image will appear. The following example shows an image that appears when the display adjustment function is used in QE for Display. Suitable Products RX Family  2. In the Memory view, specify the settings so that the first address of a frame buffer is monitored. 3. In the New Rendering tab, select RAW Image, and then add a new rendering. 4. Click the Raw Image Format button. 5. Specify the size and encoding of the image to be displayed (in this example, RGB565 is specified as the encoding), and then click OK. After a while, an image will appear. ",
66b8e403181e3afaf8bcbe519679c4f5,"Question:
When updating leaf devices with Azure RTOS ver. 6.2.1 or earlier, if one of the devices fails to update the firmware, consecutive updates on other devices are stopped.
In such a situation, how can I apply the firmware update to the following  leaf devices?
Answer:
On Azure RTOS ver. 6.2.1 or earlier, when OTA fails on one of the leaf devices, the updating process terminates at that point even if the next device is listed.
Renesas reported this issue to Microsoft issue and received a patch for the Azure RTOS ver.6.2.1.
This patch will allow the update process to continue by skipping the faulted device.
Figure 1. Overview of leaf device update
Figure 2. The process for  leaf device update before and after applying the patch.
Renesas can provide the patch on request, please contact your Renesas FAE or use our online support for further information.
This issue is fixed on Azure RTOS ver.6.3.0.
Please note, user can apply patch to Azure RTOS ver.6.2.1 or use the latest version for RX to overcome from such scenario.
More information about the Leaf Update (secondary OTA) can be found from the below link -
https://www.renesas.com/document/apn/rx-family-sample-code-secondary-ota-update-using-microsoft-azure-adu-rev100
Suitable Products
RX65N, RX
When updating leaf devices with Azure RTOS ver. 6.2.1 or earlier, if one of the devices fails to update the firmware, consecutive updates on other devices are stopped.
In such a situation, how can I apply the firmware update to the following  leaf devices?
When updating leaf devices with Azure RTOS ver. 6.2.1 or earlier, if one of the devices fails to update the firmware, consecutive updates on other devices are stopped.
In such a situation, how can I apply the firmware update to the following  leaf devices?
Answer:
On Azure RTOS ver. 6.2.1 or earlier, when OTA fails on one of the leaf devices, the updating process terminates at that point even if the next device is listed.
Renesas reported this issue to Microsoft issue and received a patch for the Azure RTOS ver.6.2.1.
This patch will allow the update process to continue by skipping the faulted device.
Figure 1. Overview of leaf device update
Figure 2. The process for  leaf device update before and after applying the patch.
Renesas can provide the patch on request, please contact your Renesas FAE or use our online support for further information.
This issue is fixed on Azure RTOS ver.6.3.0.
Please note, user can apply patch to Azure RTOS ver.6.2.1 or use the latest version for RX to overcome from such scenario.
More information about the Leaf Update (secondary OTA) can be found from the below link -
https://www.renesas.com/document/apn/rx-family-sample-code-secondary-ota-update-using-microsoft-azure-adu-rev100
Suitable Products
RX65N, RX
On Azure RTOS ver. 6.2.1 or earlier, when OTA fails on one of the leaf devices, the updating process terminates at that point even if the next device is listed.
Renesas reported this issue to Microsoft issue and received a patch for the Azure RTOS ver.6.2.1.
This patch will allow the update process to continue by skipping the faulted device.
Figure 1. Overview of leaf device update
Figure 2. The process for  leaf device update before and after applying the patch.
Renesas can provide the patch on request, please contact your Renesas FAE or use our online support for further information.
This issue is fixed on Azure RTOS ver.6.3.0.
Please note, user can apply patch to Azure RTOS ver.6.2.1 or use the latest version for RX to overcome from such scenario.
More information about the Leaf Update (secondary OTA) can be found from the below link -
https://www.renesas.com/document/apn/rx-family-sample-code-secondary-ota-update-using-microsoft-azure-adu-rev100
Suitable Products
On Azure RTOS ver. 6.2.1 or earlier, when OTA fails on one of the leaf devices, the updating process terminates at that point even if the next device is listed.
Renesas reported this issue to Microsoft issue and received a patch for the Azure RTOS ver.6.2.1.
This patch will allow the update process to continue by skipping the faulted device.
Figure 1. Overview of leaf device update
Figure 2. The process for  leaf device update before and after applying the patch.
Renesas can provide the patch on request, please contact your Renesas FAE or use our online support for further information.
This issue is fixed on Azure RTOS ver.6.3.0.
Please note, user can apply patch to Azure RTOS ver.6.2.1 or use the latest version for RX to overcome from such scenario.
More information about the Leaf Update (secondary OTA) can be found from the below link -
https://www.renesas.com/document/apn/rx-family-sample-code-secondary-ota-update-using-microsoft-azure-adu-rev100
Suitable Products
RX65N, RX

","['data/categories/rx_family/others/66b8e403181e3afaf8bcbe519679c4f5/images/52a7e611ce022a6c036d6eefa9a2ab19.png', 'data/categories/rx_family/others/66b8e403181e3afaf8bcbe519679c4f5/images/fbf53e7d6b39b2f5836299f3f26f667d.png']",[],"['|  |\n|  |\n| RX65N, RX |']","{'title': 'RX Family: Is it possible to skip the failed leaf device and continue updating the other leaf devices using Azure cloud?', 'url': 'https://en-support.renesas.com/knowledgeBase/21450120', 'last_updated': '2024-07-08', 'extracted_at': '2025-03-09T00:23:24.620802'}","Question When updating leaf devices with Azure RTOS ver. 6.2.1 or earlier, if one of the devices fails to update the firmware, consecutive updates on other devices are stopped. In such a situation, how can I apply the firmware update to the following leaf devices? Answer On Azure RTOS ver. 6.2.1 or earlier, when OTA fails on one of the leaf devices, the updating process terminates at that point even if the next device is listed. Renesas reported this issue to Microsoft issue and received a patch for the Azure RTOS ver.6.2.1. This patch will allow the update process to continue by skipping the faulted device. Figure 1. Overview of leaf device update Figure 2. The process for leaf device update before and after applying the patch. Renesas can provide the patch on request, please contact your Renesas FAE or use our online support for further information. This issue is fixed on Azure RTOS ver.6.3.0. Please note, user can apply patch to Azure RTOS ver.6.2.1 or use the latest version for RX to overcome from such scenario. More information about the Leaf Update (secondary OTA) can be found from the below link - https//www.renesas.com/document/apn/rx-family-sample-code-secondary-ota-update-using-microsoft-azure-adu-rev100 Suitable Products RX65N, RX ",
5bdb8b5e8105c2717a48a355c0c69f79,"Question:
How can I change the color format when emWin and QE for Display are used?
Answer:
Change the following settings.
The following is an example of changing the color format to CLUT8.
emWin Settings:
(1) Specify a color format that will be used for color depth per pixel (e.g., 8bit).
(2) For DRW2D, specify Do not use because it is unavailable with CLUT8 or lower.
(3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8).
(4) If an AppWizard project has not been generated yet, the project is generated according to the Color Depth per Pixel settings in emWin Settings.
If an AppWizard project has already been generated, specify the color format that you want to use (for example, 8 Bit, GUICC_8666) for Color format in the Edit project properties dialog box shown below.
  Suitable Products
RX Family
  
Question:
How can I change the color format when emWin and QE for Display are used?
Answer:
Change the following settings.
The following is an example of changing the color format to CLUT8.
emWin Settings:
(1) Specify a color format that will be used for color depth per pixel (e.g., 8bit).
(2) For DRW2D, specify Do not use because it is unavailable with CLUT8 or lower.
(3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8).
(4) If an AppWizard project has not been generated yet, the project is generated according to the Color Depth per Pixel settings in emWin Settings.
If an AppWizard project has already been generated, specify the color format that you want to use (for example, 8 Bit, GUICC_8666) for Color format in the Edit project properties dialog box shown below.
  Suitable Products
RX Family
How can I change the color format when emWin and QE for Display are used?
How can I change the color format when emWin and QE for Display are used?
Answer:
Change the following settings.
The following is an example of changing the color format to CLUT8.
emWin Settings:
(1) Specify a color format that will be used for color depth per pixel (e.g., 8bit).
(2) For DRW2D, specify Do not use because it is unavailable with CLUT8 or lower.
(3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8).
(4) If an AppWizard project has not been generated yet, the project is generated according to the Color Depth per Pixel settings in emWin Settings.
If an AppWizard project has already been generated, specify the color format that you want to use (for example, 8 Bit, GUICC_8666) for Color format in the Edit project properties dialog box shown below.
  Suitable Products
RX Family
Change the following settings.
The following is an example of changing the color format to CLUT8.
emWin Settings:
(1) Specify a color format that will be used for color depth per pixel (e.g., 8bit).
(2) For DRW2D, specify Do not use because it is unavailable with CLUT8 or lower.
(3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8).
(4) If an AppWizard project has not been generated yet, the project is generated according to the Color Depth per Pixel settings in emWin Settings.
If an AppWizard project has already been generated, specify the color format that you want to use (for example, 8 Bit, GUICC_8666) for Color format in the Edit project properties dialog box shown below.
Change the following settings.
The following is an example of changing the color format to CLUT8.
emWin Settings:
(1) Specify a color format that will be used for color depth per pixel (e.g., 8bit).
(2) For DRW2D, specify Do not use because it is unavailable with CLUT8 or lower.
(3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8).
(4) If an AppWizard project has not been generated yet, the project is generated according to the Color Depth per Pixel settings in emWin Settings.
If an AppWizard project has already been generated, specify the color format that you want to use (for example, 8 Bit, GUICC_8666) for Color format in the Edit project properties dialog box shown below.
Suitable Products
RX Family

","['data/categories/rx_family/others/5bdb8b5e8105c2717a48a355c0c69f79/images/5d2b4e96d697a8ab483bd22eea7e11f6.png', 'data/categories/rx_family/others/5bdb8b5e8105c2717a48a355c0c69f79/images/37ab2ddf7584e6559fd96290d29f67dc.png', 'data/categories/rx_family/others/5bdb8b5e8105c2717a48a355c0c69f79/images/8718f3ed4aced4f9637ddac4eda60cb1.png', 'data/categories/rx_family/others/5bdb8b5e8105c2717a48a355c0c69f79/images/f83b095b6d567f82483c5462fc408f5c.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'How can I change the color format when emWin and QE for Display are used?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940277', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:12.691023'}","Question How can I change the color format when emWin and QE for Display are used? Answer Change the following settings. The following is an example of changing the color format to CLUT8. emWin Settings (1) Specify a color format that will be used for color depth per pixel (e.g., 8bit). (2) For DRW2D, specify Do not use because it is unavailable with CLUT8 or lower. (3) For Graphic Layer 2 Output Data Format, specify the color format that you want to use (for example, CLUT8). (4) If an AppWizard project has not been generated yet, the project is generated according to the Color Depth per Pixel settings in emWin Settings. If an AppWizard project has already been generated, specify the color format that you want to use (for example, 8 Bit, GUICC8666) for Color format in the Edit project properties dialog box shown below. Suitable Products RX Family  Suitable Products ",
52bf941c703d009eb90dc54cddc8c1c6,"Question:
Is there a way to lower RAM consumption in emWin or GLCDC?
Answer:
For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM.
RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive.
Therefore, it is very important to manage RAM usage and section allocation.
If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take:
 Tune the stack size, heap size, and emWin work size.
You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application.
We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed.
See also the guideline values for memory usage in the emWin user's manual.
Stack size and heap size settings:
  emWin work size setting:
   Use a smaller data format (such as an 8-bit format).
For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows.
If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM + 512 KB Extended Internal RAM).
Suitable Products
RX Family
  
Question:
Is there a way to lower RAM consumption in emWin or GLCDC?
Answer:
For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM.
RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive.
Therefore, it is very important to manage RAM usage and section allocation.
If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take:
 Tune the stack size, heap size, and emWin work size.
You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application.
We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed.
See also the guideline values for memory usage in the emWin user's manual.
Stack size and heap size settings:
  emWin work size setting:
   Use a smaller data format (such as an 8-bit format).
For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows.
If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM + 512 KB Extended Internal RAM).
Suitable Products
RX Family
Is there a way to lower RAM consumption in emWin or GLCDC?
Is there a way to lower RAM consumption in emWin or GLCDC?
Answer:
For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM.
RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive.
Therefore, it is very important to manage RAM usage and section allocation.
If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take:
 Tune the stack size, heap size, and emWin work size.
You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application.
We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed.
See also the guideline values for memory usage in the emWin user's manual.
Stack size and heap size settings:
  emWin work size setting:
   Use a smaller data format (such as an 8-bit format).
For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows.
If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM + 512 KB Extended Internal RAM).
Suitable Products
RX Family
For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM.
RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive.
Therefore, it is very important to manage RAM usage and section allocation.
If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take:
 Tune the stack size, heap size, and emWin work size.
You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application.
We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed.
See also the guideline values for memory usage in the emWin user's manual.
Stack size and heap size settings:
  emWin work size setting:
   Use a smaller data format (such as an 8-bit format).
For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows.
If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM + 512 KB Extended Internal RAM).
For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM.
RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive.
Therefore, it is very important to manage RAM usage and section allocation.
If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take:
 Tune the stack size, heap size, and emWin work size.
You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application.
We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed.
See also the guideline values for memory usage in the emWin user's manual.
Stack size and heap size settings:
emWin work size setting:
 Use a smaller data format (such as an 8-bit format).
For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows.
If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM + 512 KB Extended Internal RAM).
Suitable Products
RX Family

","['data/categories/rx_family/others/52bf941c703d009eb90dc54cddc8c1c6/images/cf6deae293a960ae4fbbc29ef011b7cc.png', 'data/categories/rx_family/others/52bf941c703d009eb90dc54cddc8c1c6/images/f950f2012d8ba8fc1e8a365b5f386d1c.png', 'data/categories/rx_family/others/52bf941c703d009eb90dc54cddc8c1c6/images/594f012f40b3c5e173e4b67f445f3b37.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'Is there a way to lower RAM consumption in emWin or GLCDC?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940274', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:05.044056'}","Question Is there a way to lower RAM consumption in emWin or GLCDC? Answer For the RX72N or RX65N equipped with GLCDC, there are no areas available for only frame buffers. Therefore, you must secure such areas from the internal RAM. RAM is separated into two areas, Internal RAM and Extended Internal RAM, and the addresses in these areas are not consecutive. Therefore, it is very important to manage RAM usage and section allocation. If all RAM is consumed, you need to tune the RAM usage settings, such as reallocating sections to available areas. The following shows examples of measures you can take  Tune the stack size, heap size, and emWin work size. You can lower RAM consumption by tuning these settings, although the optimal values to be set depend on the user application. We do not recommend that you set too small values, as doing so will result in abnormal system behavior when a relatively large amount of RAM is consumed. See also the guideline values for memory usage in the emWin user's manual. Stack size and heap size settings emWin work size setting  Use a smaller data format (such as an 8-bit format). For example, changing the format from 16-bit to 8-bit will half the frame buffer size. Note, however, that this will narrow the range of colors representable on the LCD. Therefore, use this method only when the design allows. If RAM is still insufficient even after tuning the preceding settings, consider reducing the number of windows designed using AppWizard or GUI Builder. Alternatively, instead of using an RX65N, use an RX72N, RX66N, or RX72M in which more RAM is available (512 KB Internal RAM  512 KB Extended Internal RAM). Suitable Products RX Family  emWin work size setting  Use a smaller data format (such as an 8-bit format). ",
7f590ca5d35c0d379bfa7975f48ca7af,"Question:
How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller.
Display drivers and functions other than RGB connection (GUIDRV_Lin) and serial connection (GUIDRV_FlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger.
Note: GUIDRV_LIN and GUIDRV_FlexColor are display driver names defined by emWin. You must use a display driver that supports the LCD controller.
1. In the case of an LCD controller for RGB connection (GUIDRV_Lin)
If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings.
2. In the case of an LCD controller for serial connection (GUIDRV_FlexColor)
For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the qe_emwin_config.h file that is output, 
set the EMWIN_LCD_IF definition to LCD_IF_RSPI or LCD_IF_SCI_SPI, and then
set the EMWIN_LCD_DRIVER_IC definition to LCD_DRV_IC_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
Note: If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly.
(3) Implement a program that communicates with the LCD controller you use in the following two files:
 LCDConf_spi_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection  interface of the controller to be used, and then implement the functions that send data.
Hint:
The implementations in the same program source will become helpful.
Notes on implementation:
Note the following points when referring to the ST7715 configuration program (LCDConf_spi_if.c).
a. About the offset of write buffer memory
For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory.
If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below.
b. About the connection interface
For example, the ST7715 supports two types of 4-line 8-bit serial interfaces.
These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK.
These interfaces do not support read from the LCD controller. 
(The implemented read8_a1 and readm8_a1 functions are dummy functions.)
3. In the case of an LCD controller that is neither for RGB connection (GUIDRV_Lin) nor for serial connection (GUIDRV_FlexColor)
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the qe_emwin_config.h file that is output,
Set the EMWIN_LCD_IF definition to LCD_IF_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the LCD controller you use in the following files:
 LCDConf_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data.
Hint:
The implementations of LCDConf_glcdc_if.c or LCDConf_spi_if.c will become helpful.
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details, see the emWin user's manual bundled with the emWin FIT module (UM03001_emWin.pdf) or the web manual (emWin User Guide & Reference Manual (segger.com)) provided by Segger that developed emWin.
emWin User Guide & Reference Manual (segger.com)
You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol.
See also the following documentation, which is bundled with the emWin FIT module:
 Documentation for the emWin FIT module
 Read the notes in Chapter 6.
For other details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
RX Family
  
Question:
How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller.
Display drivers and functions other than RGB connection (GUIDRV_Lin) and serial connection (GUIDRV_FlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger.
Note: GUIDRV_LIN and GUIDRV_FlexColor are display driver names defined by emWin. You must use a display driver that supports the LCD controller.
1. In the case of an LCD controller for RGB connection (GUIDRV_Lin)
If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings.
2. In the case of an LCD controller for serial connection (GUIDRV_FlexColor)
For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the qe_emwin_config.h file that is output, 
set the EMWIN_LCD_IF definition to LCD_IF_RSPI or LCD_IF_SCI_SPI, and then
set the EMWIN_LCD_DRIVER_IC definition to LCD_DRV_IC_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
Note: If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly.
(3) Implement a program that communicates with the LCD controller you use in the following two files:
 LCDConf_spi_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection  interface of the controller to be used, and then implement the functions that send data.
Hint:
The implementations in the same program source will become helpful.
Notes on implementation:
Note the following points when referring to the ST7715 configuration program (LCDConf_spi_if.c).
a. About the offset of write buffer memory
For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory.
If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below.
b. About the connection interface
For example, the ST7715 supports two types of 4-line 8-bit serial interfaces.
These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK.
These interfaces do not support read from the LCD controller. 
(The implemented read8_a1 and readm8_a1 functions are dummy functions.)
3. In the case of an LCD controller that is neither for RGB connection (GUIDRV_Lin) nor for serial connection (GUIDRV_FlexColor)
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the qe_emwin_config.h file that is output,
Set the EMWIN_LCD_IF definition to LCD_IF_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the LCD controller you use in the following files:
 LCDConf_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data.
Hint:
The implementations of LCDConf_glcdc_if.c or LCDConf_spi_if.c will become helpful.
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details, see the emWin user's manual bundled with the emWin FIT module (UM03001_emWin.pdf) or the web manual (emWin User Guide & Reference Manual (segger.com)) provided by Segger that developed emWin.
emWin User Guide & Reference Manual (segger.com)
You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol.
See also the following documentation, which is bundled with the emWin FIT module:
 Documentation for the emWin FIT module
 Read the notes in Chapter 6.
For other details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
RX Family
How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display?
How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display?
Answer:
With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller.
Display drivers and functions other than RGB connection (GUIDRV_Lin) and serial connection (GUIDRV_FlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger.
Note: GUIDRV_LIN and GUIDRV_FlexColor are display driver names defined by emWin. You must use a display driver that supports the LCD controller.
1. In the case of an LCD controller for RGB connection (GUIDRV_Lin)
If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings.
2. In the case of an LCD controller for serial connection (GUIDRV_FlexColor)
For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the qe_emwin_config.h file that is output, 
set the EMWIN_LCD_IF definition to LCD_IF_RSPI or LCD_IF_SCI_SPI, and then
set the EMWIN_LCD_DRIVER_IC definition to LCD_DRV_IC_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
Note: If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly.
(3) Implement a program that communicates with the LCD controller you use in the following two files:
 LCDConf_spi_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection  interface of the controller to be used, and then implement the functions that send data.
Hint:
The implementations in the same program source will become helpful.
Notes on implementation:
Note the following points when referring to the ST7715 configuration program (LCDConf_spi_if.c).
a. About the offset of write buffer memory
For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory.
If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below.
b. About the connection interface
For example, the ST7715 supports two types of 4-line 8-bit serial interfaces.
These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK.
These interfaces do not support read from the LCD controller. 
(The implemented read8_a1 and readm8_a1 functions are dummy functions.)
3. In the case of an LCD controller that is neither for RGB connection (GUIDRV_Lin) nor for serial connection (GUIDRV_FlexColor)
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the qe_emwin_config.h file that is output,
Set the EMWIN_LCD_IF definition to LCD_IF_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the LCD controller you use in the following files:
 LCDConf_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data.
Hint:
The implementations of LCDConf_glcdc_if.c or LCDConf_spi_if.c will become helpful.
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details, see the emWin user's manual bundled with the emWin FIT module (UM03001_emWin.pdf) or the web manual (emWin User Guide & Reference Manual (segger.com)) provided by Segger that developed emWin.
emWin User Guide & Reference Manual (segger.com)
You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol.
See also the following documentation, which is bundled with the emWin FIT module:
 Documentation for the emWin FIT module
 Read the notes in Chapter 6.
For other details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
RX Family
With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller.
Display drivers and functions other than RGB connection (GUIDRV_Lin) and serial connection (GUIDRV_FlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger.
Note: GUIDRV_LIN and GUIDRV_FlexColor are display driver names defined by emWin. You must use a display driver that supports the LCD controller.
1. In the case of an LCD controller for RGB connection (GUIDRV_Lin)
If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings.
2. In the case of an LCD controller for serial connection (GUIDRV_FlexColor)
For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the qe_emwin_config.h file that is output, 
set the EMWIN_LCD_IF definition to LCD_IF_RSPI or LCD_IF_SCI_SPI, and then
set the EMWIN_LCD_DRIVER_IC definition to LCD_DRV_IC_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
Note: If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly.
(3) Implement a program that communicates with the LCD controller you use in the following two files:
 LCDConf_spi_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection  interface of the controller to be used, and then implement the functions that send data.
Hint:
The implementations in the same program source will become helpful.
Notes on implementation:
Note the following points when referring to the ST7715 configuration program (LCDConf_spi_if.c).
a. About the offset of write buffer memory
For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory.
If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below.
b. About the connection interface
For example, the ST7715 supports two types of 4-line 8-bit serial interfaces.
These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK.
These interfaces do not support read from the LCD controller. 
(The implemented read8_a1 and readm8_a1 functions are dummy functions.)
3. In the case of an LCD controller that is neither for RGB connection (GUIDRV_Lin) nor for serial connection (GUIDRV_FlexColor)
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the qe_emwin_config.h file that is output,
Set the EMWIN_LCD_IF definition to LCD_IF_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the LCD controller you use in the following files:
 LCDConf_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data.
Hint:
The implementations of LCDConf_glcdc_if.c or LCDConf_spi_if.c will become helpful.
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details, see the emWin user's manual bundled with the emWin FIT module (UM03001_emWin.pdf) or the web manual (emWin User Guide & Reference Manual (segger.com)) provided by Segger that developed emWin.
emWin User Guide & Reference Manual (segger.com)
You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol.
See also the following documentation, which is bundled with the emWin FIT module:
 Documentation for the emWin FIT module
 Read the notes in Chapter 6.
For other details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller.
Display drivers and functions other than RGB connection (GUIDRV_Lin) and serial connection (GUIDRV_FlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger.
Note: GUIDRV_LIN and GUIDRV_FlexColor are display driver names defined by emWin. You must use a display driver that supports the LCD controller.
1. In the case of an LCD controller for RGB connection (GUIDRV_Lin)
If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings.
2. In the case of an LCD controller for serial connection (GUIDRV_FlexColor)
For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module.
See the following procedure:
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the qe_emwin_config.h file that is output, 
set the EMWIN_LCD_IF definition to LCD_IF_RSPI or LCD_IF_SCI_SPI, and then
set the EMWIN_LCD_DRIVER_IC definition to LCD_DRV_IC_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
Note: If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly.
(3) Implement a program that communicates with the LCD controller you use in the following two files:
 LCDConf_spi_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection  interface of the controller to be used, and then implement the functions that send data.
Hint:
The implementations in the same program source will become helpful.
Notes on implementation:
Note the following points when referring to the ST7715 configuration program (LCDConf_spi_if.c).
a. About the offset of write buffer memory
For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory.
If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below.
b. About the connection interface
For example, the ST7715 supports two types of 4-line 8-bit serial interfaces.
These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK.
These interfaces do not support read from the LCD controller. 
(The implemented read8_a1 and readm8_a1 functions are dummy functions.)
3. In the case of an LCD controller that is neither for RGB connection (GUIDRV_Lin) nor for serial connection (GUIDRV_FlexColor)
(1) Specify the settings to the extent possible, and then output the configuration file (qe_emwin_config.h).
(2) In the qe_emwin_config.h file that is output,
Set the EMWIN_LCD_IF definition to LCD_IF_OTHER.
(Note that if you output the configuration file from QE again, the changes you made will be lost.)
(3) Implement a program that communicates with the LCD controller you use in the following files:
 LCDConf_user_if.c
Directory:
<project-name>\src\smc_gen\r_emwin_rx\lib\Config
Overview of the program to be implemented:
Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data.
Hint:
The implementations of LCDConf_glcdc_if.c or LCDConf_spi_if.c will become helpful.
Supplementary information:
You need to implement the programs in accordance with the emWin specifications.
For details, see the emWin user's manual bundled with the emWin FIT module (UM03001_emWin.pdf) or the web manual (emWin User Guide & Reference Manual (segger.com)) provided by Segger that developed emWin.
emWin User Guide & Reference Manual (segger.com)
You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol.
See also the following documentation, which is bundled with the emWin FIT module:
 Documentation for the emWin FIT module
 Read the notes in Chapter 6.
For other details about emWin, contact Segger(https://www.segger.com/) or it local agency.
Suitable Products
RX Family

","['data/categories/rx_family/others/7f590ca5d35c0d379bfa7975f48ca7af/images/d15b5e080a69ec5e9ce5aba37a36a1aa.png', 'data/categories/rx_family/others/7f590ca5d35c0d379bfa7975f48ca7af/images/f9cefd22d409322ff89c745b6b88d941.png', 'data/categories/rx_family/others/7f590ca5d35c0d379bfa7975f48ca7af/images/1302202bc17536b8af00e9f665cd05a5.png', 'data/categories/rx_family/others/7f590ca5d35c0d379bfa7975f48ca7af/images/5c44d7ba6c635a045e005e037ecd515f.png']",[],['|  |\n|  |\n| RX Family |'],"{'title': 'How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display?', 'url': 'https://en-support.renesas.com/knowledgeBase/20940275', 'last_updated': None, 'extracted_at': '2025-03-09T00:24:08.932759'}","Question How can I use an LCD controller that is not supported by the emWin FIT module or QE for Display? Answer With an LCD controller that is not supported by the emWin FIT module, you cannot specify settings from QE. In this case, you must yourself implement a program that communicates with the LCD controller. Display drivers and functions other than RGB connection (GUIDRVLin) and serial connection (GUIDRVFlexColor) are not supported by emWin FIT module. If you want to use it, you need a license agreement with Segger. Note GUIDRVLIN and GUIDRVFlexColor are display driver names defined by emWin. You must use a display driver that supports the LCD controller. 1. In the case of an LCD controller for RGB connection (GUIDRVLin) If the LCD controller (source driver) supports RGB connection, it can likely be used with an emWin FT module and QE for Display. Use QE for Display to specify the GLCDC settings. 2. In the case of an LCD controller for serial connection (GUIDRVFlexColor) For the LCD controllers that support FlexColor drivers that can be used with the latest version of the emWin FIT module, see the documentation for the emWin FIT module. See the following procedure (1) Specify the settings to the extent possible, and then output the configuration file (qeemwinconfig.h). (2) In the qeemwinconfig.h file that is output, set the EMWINLCDIF definition to LCDIFRSPI or LCDIFSCISPI, and then set the EMWINLCDDRIVERIC definition to LCDDRVICOTHER. (Note that if you output the configuration file from QE again, the changes you made will be lost.) Note If a custom board and custom display are selected, the preceding settings might be specified during setup. In such a case, you do not need to edit the file directly. (3) Implement a program that communicates with the LCD controller you use in the following two files  LCDConfspiif.c Directory project-namesrcsmcgenremwinrxlibConfig Overview of the program to be implemented Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and connection interface of the controller to be used, and then implement the functions that send data. Hint The implementations in the same program source will become helpful. Notes on implementation Note the following points when referring to the ST7715 configuration program (LCDConfspiif.c). a. About the offset of write buffer memory For the Pmod-connected LCD that comes with the RSK, the resolution has been narrowed from the maximum resolution (132x132) of ST7715 to 127x127. Therefore, an offset shown below has been set for the controller memory. If the resolution has not been changed from the controller's maximum resolution for the LCD you are using, set 0 for the settings shown below. b. About the connection interface For example, the ST7715 supports two types of 4-line 8-bit serial interfaces. These two interfaces are programmed assuming the 0110 settings according to the Pmode-connected LCD that comes with the RSK. These interfaces do not support read from the LCD controller. (The implemented read8a1 and readm8a1 functions are dummy functions.) 3. In the case of an LCD controller that is neither for RGB connection (GUIDRVLin) nor for serial connection (GUIDRVFlexColor) (2) In the qeemwinconfig.h file that is output, Set the EMWINLCDIF definition to LCDIFOTHER. (3) Implement a program that communicates with the LCD controller you use in the following files  LCDConfuserif.c Initialize emWin, the peripherals to be used, and the LCD controller according to the specifications and protocol of the controller to be used, and then implement the functions that send data. The implementations of LCDConfglcdcif.c or LCDConfspiif.c will become helpful. Supplementary information You need to implement the programs in accordance with the emWin specifications. For details, see the emWin user's manual bundled with the emWin FIT module (UM03001emWin.pdf) or the web manual (emWin User Guide  Reference Manual (segger.com)) provided by Segger that developed emWin. emWin User Guide  Reference Manual (segger.com) You will be able to see the information about the sections to be configured by performing searches by the controller model name or communication protocol. See also the following documentation, which is bundled with the emWin FIT module  Documentation for the emWin FIT module Read the notes in Chapter 6. For other details about emWin, contact Segger(https//www.segger.com/) or it local agency. Suitable Products RX Family  ",
90834a1150d409d7f533f8079d32c364,"Question:
If the port is pulled up externally, to which power supply should it be connected?
Answer:
A pull-up to the port's power supply is required. The power supply of the port can be checked with VIH or VIL listed in the electrical characteristics in the user's manual of the product used, as shown below. For example, the power supply of the port in the case where 0.8 x VCC is written is VCC, so the pull-up resistor should be connected to VCC. If 0.8 x AVCC1 is written, the pull-up resistor should be connected to AVCC1. If VCC and AVCC1 are at the same potential, the pull-up resistor may be connected to either VCC or AVCC1.
(RX66T Group User's Manual Excerpt)
Suitable Products
RX Family
If the port is pulled up externally, to which power supply should it be connected?
If the port is pulled up externally, to which power supply should it be connected?
Answer:
A pull-up to the port's power supply is required. The power supply of the port can be checked with VIH or VIL listed in the electrical characteristics in the user's manual of the product used, as shown below. For example, the power supply of the port in the case where 0.8 x VCC is written is VCC, so the pull-up resistor should be connected to VCC. If 0.8 x AVCC1 is written, the pull-up resistor should be connected to AVCC1. If VCC and AVCC1 are at the same potential, the pull-up resistor may be connected to either VCC or AVCC1.
(RX66T Group User's Manual Excerpt)
Suitable Products
RX Family
A pull-up to the port's power supply is required. The power supply of the port can be checked with VIH or VIL listed in the electrical characteristics in the user's manual of the product used, as shown below. For example, the power supply of the port in the case where 0.8 x VCC is written is VCC, so the pull-up resistor should be connected to VCC. If 0.8 x AVCC1 is written, the pull-up resistor should be connected to AVCC1. If VCC and AVCC1 are at the same potential, the pull-up resistor may be connected to either VCC or AVCC1.
(RX66T Group User's Manual Excerpt)
A pull-up to the port's power supply is required. The power supply of the port can be checked with VIH or VIL listed in the electrical characteristics in the user's manual of the product used, as shown below. For example, the power supply of the port in the case where 0.8 x VCC is written is VCC, so the pull-up resistor should be connected to VCC. If 0.8 x AVCC1 is written, the pull-up resistor should be connected to AVCC1. If VCC and AVCC1 are at the same potential, the pull-up resistor may be connected to either VCC or AVCC1.
(RX66T Group User's Manual Excerpt)
Suitable Products
RX Family
Japanese
Japanese",['data/categories/rx_family/io_port/90834a1150d409d7f533f8079d32c364/images/0c1bcbdeb149d08f0271ec257953a5b9.png'],[],['|  |\n|  |\n| RX Family |'],"{'title': 'RX Family: Power supply to pull up port', 'url': 'https://en-support.renesas.com/knowledgeBase/21810951', 'last_updated': None, 'extracted_at': '2025-03-09T00:16:22.294320'}","Question If the port is pulled up externally, to which power supply should it be connected? Answer A pull-up to the port's power supply is required. The power supply of the port can be checked with VIH or VIL listed in the electrical characteristics in the user's manual of the product used, as shown below. For example, the power supply of the port in the case where 0.8 x VCC is written is VCC, so the pull-up resistor should be connected to VCC. If 0.8 x AVCC1 is written, the pull-up resistor should be connected to AVCC1. If VCC and AVCC1 are at the same potential, the pull-up resistor may be connected to either VCC or AVCC1. (RX66T Group User's Manual Excerpt) Suitable Products RX Family Japanese",
74d72c28a7ebe8fcb75352ee5454f6f7,"Question:
How to configure correctly  a custom project, in order to use MC-COM Port with Renesas Motor Workbench (RMW)?
Answer:
In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication.
MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu.
  By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project:
  1)he user  should include the the necessary ICS2 library files on his project. The files that he will need is the ICS_RXxxT.h header file and ICS2_RXxxT.lib or ICS2_RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder.
  For the .lib or .obj files, the user should got to Project properties -> Linker -> Input and add the library:
        2)he next step is to prepare the project, in order to generate the map file, that includes all the projects variables and will be uploaded on the RMW tool. To do this check the screenshot below:
        3) he next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added:
      4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose.  0x00000000 of RAM is used:
      5)he next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added:
    n r_app_rmw_interrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2_init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate).
    6) The final function that should be used is the ics2_watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called.
For more information, about ics2_init and ics2_watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide:
RMW_Quick_Start_Guide
  After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel.
  Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project:
            Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application.
    Suitable Products
RX-T
  ??? ??
Question:
How to configure correctly  a custom project, in order to use MC-COM Port with Renesas Motor Workbench (RMW)?
Answer:
In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication.
MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu.
  By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project:
  1)he user  should include the the necessary ICS2 library files on his project. The files that he will need is the ICS_RXxxT.h header file and ICS2_RXxxT.lib or ICS2_RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder.
  For the .lib or .obj files, the user should got to Project properties -> Linker -> Input and add the library:
        2)he next step is to prepare the project, in order to generate the map file, that includes all the projects variables and will be uploaded on the RMW tool. To do this check the screenshot below:
        3) he next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added:
      4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose.  0x00000000 of RAM is used:
      5)he next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added:
    n r_app_rmw_interrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2_init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate).
    6) The final function that should be used is the ics2_watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called.
For more information, about ics2_init and ics2_watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide:
RMW_Quick_Start_Guide
  After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel.
  Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project:
            Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application.
    Suitable Products
RX-T
How to configure correctly  a custom project, in order to use MC-COM Port with Renesas Motor Workbench (RMW)?
How to configure correctly  a custom project, in order to use MC-COM Port with Renesas Motor Workbench (RMW)?
Answer:
In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication.
MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu.
  By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project:
  1)he user  should include the the necessary ICS2 library files on his project. The files that he will need is the ICS_RXxxT.h header file and ICS2_RXxxT.lib or ICS2_RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder.
  For the .lib or .obj files, the user should got to Project properties -> Linker -> Input and add the library:
        2)he next step is to prepare the project, in order to generate the map file, that includes all the projects variables and will be uploaded on the RMW tool. To do this check the screenshot below:
        3) he next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added:
      4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose.  0x00000000 of RAM is used:
      5)he next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added:
    n r_app_rmw_interrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2_init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate).
    6) The final function that should be used is the ics2_watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called.
For more information, about ics2_init and ics2_watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide:
RMW_Quick_Start_Guide
  After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel.
  Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project:
            Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application.
    Suitable Products
RX-T
In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication.
MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu.
  By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project:
  1)he user  should include the the necessary ICS2 library files on his project. The files that he will need is the ICS_RXxxT.h header file and ICS2_RXxxT.lib or ICS2_RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder.
  For the .lib or .obj files, the user should got to Project properties -> Linker -> Input and add the library:
        2)he next step is to prepare the project, in order to generate the map file, that includes all the projects variables and will be uploaded on the RMW tool. To do this check the screenshot below:
        3) he next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added:
      4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose.  0x00000000 of RAM is used:
      5)he next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added:
    n r_app_rmw_interrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2_init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate).
    6) The final function that should be used is the ics2_watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called.
For more information, about ics2_init and ics2_watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide:
RMW_Quick_Start_Guide
  After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel.
  Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project:
            Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application.
In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication.
MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu.
By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project:
1)he user  should include the the necessary ICS2 library files on his project. The files that he will need is the ICS_RXxxT.h header file and ICS2_RXxxT.lib or ICS2_RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder.
For the .lib or .obj files, the user should got to Project properties -> Linker -> Input and add the library:
2)he next step is to prepare the project, in order to generate the map file, that includes all the projects variables and will be uploaded on the RMW tool. To do this check the screenshot below:
3) he next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added:
4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose.  0x00000000 of RAM is used:
5)he next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added:
n r_app_rmw_interrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2_init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate).
6) The final function that should be used is the ics2_watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called.
For more information, about ics2_init and ics2_watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide:
RMW_Quick_Start_Guide
After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel.
Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project:
Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application.
Suitable Products
RX-T
??? ??
???
??","['data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/3c0c377540971b9e0b9dd32af515aec3.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/cdf8cc3c97eaf8b4aaeac0d760ba84f7.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/531c5a249d158d95d59b78fc4e29643b.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/92e57beb7c926a61c45078799116feec.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/6f0724da2f9d3872d56694e1bbffe9df.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/15d9685135a97e232c6b112eed860205.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/ceeaa92caf5f9f4810437de400641eb4.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/b8491061cac70a3506aaa2df321c4413.png', 'data/categories/rx_family/rx-t/74d72c28a7ebe8fcb75352ee5454f6f7/images/ee0c525a2f357ae97f8c005c076750c2.png']",[],['|  |\n|  |\n| RX-T |'],"{'title': 'Configuration of communication between Renesas Motor Workbench (RMW) and PC device on a custom RX-T project', 'url': 'https://en-support.renesas.com/knowledgeBase/21656980', 'last_updated': None, 'extracted_at': '2025-03-09T00:06:16.399871'}","Question How to configure correctly a custom project, in order to use MC-COM Port with Renesas Motor Workbench (RMW)? Answer In general, using MC-COM, it is not difficult to implement the communication library ( ICS LIBRARY) to any customized board that uses RX-T MCUs. The only hardware requirement is the use of specific SCI channel for the communication between the RX-T mcu and the MC-COM board. For example, for RX23-T the SCI1 or SCI5 channel can be used for the communication. MC-COM includes the RMW command processing and analyzer processing, without needing to configure a lot of things on the RX-T mcu. By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project 1)he user should include the the necessary ICS2 library files on his project. The files that he will need is the ICSRXxxT.h header file and ICS2RXxxT.lib or ICS2RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder. For the .lib or .obj files, the user should got to Project properties - Linker - Input and add the library 2)he next step is to prepare the project, in order to generate the map file, that includes all the projects variables and will be uploaded on the RMW tool. To do this check the screenshot below 3) he next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added 4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose. 0x00000000 of RAM is used 5)he next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added n rapprmwinterrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate). 6) The final function that should be used is the ics2watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called. For more information, about ics2init and ics2watcpoint(), the customer can study Chapter 4.3 of RMW quick start guide RMWQuickStartGuide After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel. Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application. Suitable Products RX-T ??? ?? By following the necessary steps below, the user will be able to watch on the scope the global variables that he will define on his project 1)he user should include the the necessary ICS2 library files on his project. The files that he will need is the ICSRXxxT.h header file and ICS2RXxxT.lib or ICS2RXxxT.obj. These files can be easily found on any motor sample project that exists on Renesas official website. The header files needs a simple addition on the project folder. For the .lib or .obj files, the user should got to Project properties - Linker - Input and add the library 2)he next step is to prepare the project, in order to generate the map file, that includes all the projects variables and will be uploaded on the RMW tool. To do this check the screenshot below 3) he next step is to define some RAM area on the project for the DTC table that will be used for the communication. On the main file, the lines below have been added 4)The RX memory sections should be defined on an appropriate way, in order to say to the compiler that the user wants to use a specific area called DTCTBL for his purpose. 0x00000000 of RAM is used 5)he next step is how the customer should use the functions provided from ICS2 library, in order to setup the communication between the MC-COM and the RX-T mcu. For this reason, the folder rmw that includes some definitions and apis has been added n rapprmwinterrupt.c file, the interrupt routines have been specified for the communication and the parameters of the ics2init(), which is responsible for the initialization of the communication. The parameters of this function define the mode of the SCI communication ( for example the baud rate). 6) The final function that should be used is the ics2watcpoint() function. This function can be called inside a routine, that the user will know that will called periodically on some specific us time interval. For that reason, CMT Timer that triggers a event every 100usec is used and the function inside this callback is called. After all the steps above, the user will be able to watch any global variable on the RMW. On the attached project, two variables that called variable and analog have been defined. The variable is increased when CMT event is triggered, while analog is a variable from an ADC channel input and if the user check the attached screenshot, he will be able to see a sine signal that be measured using the adc peripheral of RX26-T channel. Finally, on the RMW tool, the customer should load the map file that can be found on the HardwareDebug file inside the project Also, find attached a RX26-T project that have been configured using the steps above and it is ready to be use for any custom application. Suitable Products ??? ?? ??? ??",
50f645c4fbf9c072a2663f78c6fa169c,"Question:
What are the differences within the RX23E-B group?
Answer:
The RX23E-B are 32-bit microcontrollers with built-in high-speed, high-precision 24-bit -A/D converters, and the data rate and analog input voltage range of the 24-bit -A/D converters differ depending on the part number. Refer to the table below for details.
  Suitable Products
RX23E-B
What are the differences within the RX23E-B group?
What are the differences within the RX23E-B group?
Answer:
The RX23E-B are 32-bit microcontrollers with built-in high-speed, high-precision 24-bit -A/D converters, and the data rate and analog input voltage range of the 24-bit -A/D converters differ depending on the part number. Refer to the table below for details.
  Suitable Products
RX23E-B
The RX23E-B are 32-bit microcontrollers with built-in high-speed, high-precision 24-bit -A/D converters, and the data rate and analog input voltage range of the 24-bit -A/D converters differ depending on the part number. Refer to the table below for details.
The RX23E-B are 32-bit microcontrollers with built-in high-speed, high-precision 24-bit -A/D converters, and the data rate and analog input voltage range of the 24-bit -A/D converters differ depending on the part number. Refer to the table below for details.
Suitable Products
RX23E-B
 

",['data/categories/rx_family/rx23e-b/50f645c4fbf9c072a2663f78c6fa169c/images/a2be97e31fafcbaa6af81b108eae8786.png'],[],['|  |\n|  |\n| RX23E-B |'],"{'title': 'Differences within the RX23E-B group', 'url': 'https://en-support.renesas.com/knowledgeBase/21106543', 'last_updated': None, 'extracted_at': '2025-03-09T00:04:36.965732'}","Question What are the differences within the RX23E-B group? Answer The RX23E-B are 32-bit microcontrollers with built-in high-speed, high-precision 24-bit -A/D converters, and the data rate and analog input voltage range of the 24-bit -A/D converters differ depending on the part number. Refer to the table below for details. Suitable Products RX23E-B Suitable Products    ",
b373bb4b6a72b3206cd5572f6b4a8cb4,"Question:
What are the differences between the RX23E-B and RX23E-A?
Answer:
The data rate and noise performance of the 24-bit -A/D converters and the number of them built in differ between the RX23E-B and RX23E-A. The -A/D converters of the RX23E-B have the high speed performance and noise performance enhanced from those of the RX23E-A. The -A/D converters of the RX23E-B support a maximum of 125 kSPS, which is eight times faster than that of the RX23E-A.. The RMS noise performance is also reduced from that of the RX23E-A to about a 1/3. Other differences are that a 16-bit D/A converter and +/-10 V analog input are newly incorporated from the RX23E-B.
Also refer to the table below for details.
Suitable Products
RX23E-B
What are the differences between the RX23E-B and RX23E-A?
What are the differences between the RX23E-B and RX23E-A?
Answer:
The data rate and noise performance of the 24-bit -A/D converters and the number of them built in differ between the RX23E-B and RX23E-A. The -A/D converters of the RX23E-B have the high speed performance and noise performance enhanced from those of the RX23E-A. The -A/D converters of the RX23E-B support a maximum of 125 kSPS, which is eight times faster than that of the RX23E-A.. The RMS noise performance is also reduced from that of the RX23E-A to about a 1/3. Other differences are that a 16-bit D/A converter and +/-10 V analog input are newly incorporated from the RX23E-B.
Also refer to the table below for details.
Suitable Products
RX23E-B
The data rate and noise performance of the 24-bit -A/D converters and the number of them built in differ between the RX23E-B and RX23E-A. The -A/D converters of the RX23E-B have the high speed performance and noise performance enhanced from those of the RX23E-A. The -A/D converters of the RX23E-B support a maximum of 125 kSPS, which is eight times faster than that of the RX23E-A.. The RMS noise performance is also reduced from that of the RX23E-A to about a 1/3. Other differences are that a 16-bit D/A converter and +/-10 V analog input are newly incorporated from the RX23E-B.
Also refer to the table below for details.
Suitable Products
RX23E-B
 

",['data/categories/rx_family/rx23e-b/b373bb4b6a72b3206cd5572f6b4a8cb4/images/5b5aeefbea0f8d40e47d3d76a3f967b0.png'],[],['|  |\n|  |\n| RX23E-B |'],"{'title': 'Differences within the RX23E series', 'url': 'https://en-support.renesas.com/knowledgeBase/21106546', 'last_updated': None, 'extracted_at': '2025-03-09T00:04:39.619815'}","Question What are the differences between the RX23E-B and RX23E-A? Answer The data rate and noise performance of the 24-bit -A/D converters and the number of them built in differ between the RX23E-B and RX23E-A. The -A/D converters of the RX23E-B have the high speed performance and noise performance enhanced from those of the RX23E-A. The -A/D converters of the RX23E-B support a maximum of 125 kSPS, which is eight times faster than that of the RX23E-A.. The RMS noise performance is also reduced from that of the RX23E-A to about a 1/3. Other differences are that a 16-bit D/A converter and /-10 V analog input are newly incorporated from the RX23E-B. Also refer to the table below for details. Suitable Products RX23E-B    ",
96c5bd114fd602960522608adb7f0495,"Question:
During normal read operation on a separate bus, why is one cycle of the CS signal negation period inserted even though the insertion of read recovery cycles is disabled?
Answer:
During normal read operation on a separate bus, if CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted even if no read recovery cycle is inserted.
This is because when CSnWCR2.CSROFF[2:0] = 000b, the next bus access can start one cycle after Tend in the diagram below.
The following explains the operation using the example of ""Figure 16.19 Bus Timing (Normal-Read Operation)"" in the ""RX64M Group User's Manual: Hardware"" as an example.
[CSnWCR2.CSROFF[2:0] setting and next bus access start timing]
Note 1 in the diagram shows that when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend"" in the diagram.
Furthermore, when CSnWCR2.CSROFF[2:0] = 001b, ""Tn1"" is inserted in the diagram, the next bus access can begin.
In other words, if CSnWCR2.CSROFF[2:0] = 000b or CSnWCR2.CSROFF[2:0] = 001b, in both cases the next bus access can start one cycle after ""Tend"".
[Regarding Separate Bus Read Recovery Cycle when CSnWCR2.CSROFF[2:0]=000b]
When not inserting Separate Bus Read Recovery Cycle
As explained above, when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend."" When inserting N cycles (1 or more) of Separate Bus Read Recovery Cycle
When CSnWCR2.CSROFF[2:0] = 000b, the bus access disable period of 1 cycle according to Note 1 in the above figure is ensured by the N cycles set for the read recovery cycle, so an N-cycle CS negate period is inserted.
[Separate Bus Read Recovery Cycle for when CSnWCR2.CSROFF[2:0] >= 001b]
If CSnWCR2.CSROFF[2:0] >= 001b, a read recovery cycle is inserted starting with the next cycle from Tn1 to Tnm.
Suitable Products
RX Family
During normal read operation on a separate bus, why is one cycle of the CS signal negation period inserted even though the insertion of read recovery cycles is disabled?
During normal read operation on a separate bus, why is one cycle of the CS signal negation period inserted even though the insertion of read recovery cycles is disabled?
Answer:
During normal read operation on a separate bus, if CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted even if no read recovery cycle is inserted.
This is because when CSnWCR2.CSROFF[2:0] = 000b, the next bus access can start one cycle after Tend in the diagram below.
The following explains the operation using the example of ""Figure 16.19 Bus Timing (Normal-Read Operation)"" in the ""RX64M Group User's Manual: Hardware"" as an example.
[CSnWCR2.CSROFF[2:0] setting and next bus access start timing]
Note 1 in the diagram shows that when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend"" in the diagram.
Furthermore, when CSnWCR2.CSROFF[2:0] = 001b, ""Tn1"" is inserted in the diagram, the next bus access can begin.
In other words, if CSnWCR2.CSROFF[2:0] = 000b or CSnWCR2.CSROFF[2:0] = 001b, in both cases the next bus access can start one cycle after ""Tend"".
[Regarding Separate Bus Read Recovery Cycle when CSnWCR2.CSROFF[2:0]=000b]
When not inserting Separate Bus Read Recovery Cycle
As explained above, when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend."" When inserting N cycles (1 or more) of Separate Bus Read Recovery Cycle
When CSnWCR2.CSROFF[2:0] = 000b, the bus access disable period of 1 cycle according to Note 1 in the above figure is ensured by the N cycles set for the read recovery cycle, so an N-cycle CS negate period is inserted.
[Separate Bus Read Recovery Cycle for when CSnWCR2.CSROFF[2:0] >= 001b]
If CSnWCR2.CSROFF[2:0] >= 001b, a read recovery cycle is inserted starting with the next cycle from Tn1 to Tnm.
Suitable Products
RX Family
During normal read operation on a separate bus, if CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted even if no read recovery cycle is inserted.
This is because when CSnWCR2.CSROFF[2:0] = 000b, the next bus access can start one cycle after Tend in the diagram below.
The following explains the operation using the example of ""Figure 16.19 Bus Timing (Normal-Read Operation)"" in the ""RX64M Group User's Manual: Hardware"" as an example.
[CSnWCR2.CSROFF[2:0] setting and next bus access start timing]
Note 1 in the diagram shows that when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend"" in the diagram.
Furthermore, when CSnWCR2.CSROFF[2:0] = 001b, ""Tn1"" is inserted in the diagram, the next bus access can begin.
In other words, if CSnWCR2.CSROFF[2:0] = 000b or CSnWCR2.CSROFF[2:0] = 001b, in both cases the next bus access can start one cycle after ""Tend"".
[Regarding Separate Bus Read Recovery Cycle when CSnWCR2.CSROFF[2:0]=000b]
When not inserting Separate Bus Read Recovery Cycle
As explained above, when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend."" When inserting N cycles (1 or more) of Separate Bus Read Recovery Cycle
When CSnWCR2.CSROFF[2:0] = 000b, the bus access disable period of 1 cycle according to Note 1 in the above figure is ensured by the N cycles set for the read recovery cycle, so an N-cycle CS negate period is inserted.
[Separate Bus Read Recovery Cycle for when CSnWCR2.CSROFF[2:0] >= 001b]
If CSnWCR2.CSROFF[2:0] >= 001b, a read recovery cycle is inserted starting with the next cycle from Tn1 to Tnm.
During normal read operation on a separate bus, if CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted even if no read recovery cycle is inserted.
This is because when CSnWCR2.CSROFF[2:0] = 000b, the next bus access can start one cycle after Tend in the diagram below.
The following explains the operation using the example of ""Figure 16.19 Bus Timing (Normal-Read Operation)"" in the ""RX64M Group User's Manual: Hardware"" as an example.
[CSnWCR2.CSROFF[2:0] setting and next bus access start timing]
Note 1 in the diagram shows that when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend"" in the diagram.
Furthermore, when CSnWCR2.CSROFF[2:0] = 001b, ""Tn1"" is inserted in the diagram, the next bus access can begin.
In other words, if CSnWCR2.CSROFF[2:0] = 000b or CSnWCR2.CSROFF[2:0] = 001b, in both cases the next bus access can start one cycle after ""Tend"".
[Regarding Separate Bus Read Recovery Cycle when CSnWCR2.CSROFF[2:0]=000b]
When not inserting Separate Bus Read Recovery Cycle
As explained above, when CSnWCR2.CSROFF[2:0] = 000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend."" When inserting N cycles (1 or more) of Separate Bus Read Recovery Cycle
When CSnWCR2.CSROFF[2:0] = 000b, the bus access disable period of 1 cycle according to Note 1 in the above figure is ensured by the N cycles set for the read recovery cycle, so an N-cycle CS negate period is inserted.
[Separate Bus Read Recovery Cycle for when CSnWCR2.CSROFF[2:0] >= 001b]
If CSnWCR2.CSROFF[2:0] >= 001b, a read recovery cycle is inserted starting with the next cycle from Tn1 to Tnm.
Suitable Products
RX Family
Japanese
Japanese",['data/categories/rx_family/external_bus/96c5bd114fd602960522608adb7f0495/images/74f890308b8213a5e46e8fb52f29d0c9.png'],[],['|  |\n|  |\n| RX Family |'],"{'title': 'RX Family: Why is one cycle of the CS signal negation period inserted even though the insertion of read recovery is disabled?', 'url': 'https://en-support.renesas.com/knowledgeBase/21810950', 'last_updated': None, 'extracted_at': '2025-03-09T00:13:40.609559'}","Question During normal read operation on a separate bus, why is one cycle of the CS signal negation period inserted even though the insertion of read recovery cycles is disabled? Answer During normal read operation on a separate bus, if CSnWCR2.CSROFF20  000b, a one-cycle bus access disable period (CS negation period) is inserted even if no read recovery cycle is inserted. This is because when CSnWCR2.CSROFF20  000b, the next bus access can start one cycle after Tend in the diagram below. The following explains the operation using the example of ""Figure 16.19 Bus Timing (Normal-Read Operation)"" in the ""RX64M Group User's Manual Hardware"" as an example. CSnWCR2.CSROFF20 setting and next bus access start timing Note 1 in the diagram shows that when CSnWCR2.CSROFF20  000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend"" in the diagram. Furthermore, when CSnWCR2.CSROFF20  001b, ""Tn1"" is inserted in the diagram, the next bus access can begin. In other words, if CSnWCR2.CSROFF20  000b or CSnWCR2.CSROFF20  001b, in both cases the next bus access can start one cycle after ""Tend"". Regarding Separate Bus Read Recovery Cycle when CSnWCR2.CSROFF20000b When not inserting Separate Bus Read Recovery Cycle As explained above, when CSnWCR2.CSROFF20  000b, a one-cycle bus access disable period (CS negation period) is inserted after ""Tend."" When inserting N cycles (1 or more) of Separate Bus Read Recovery Cycle When CSnWCR2.CSROFF20  000b, the bus access disable period of 1 cycle according to Note 1 in the above figure is ensured by the N cycles set for the read recovery cycle, so an N-cycle CS negate period is inserted. Separate Bus Read Recovery Cycle for when CSnWCR2.CSROFF20  001b If CSnWCR2.CSROFF20  001b, a read recovery cycle is inserted starting with the next cycle from Tn1 to Tnm. Suitable Products RX Family Japanese",
f667dac2f8827a3fd660628fb62d3413,"Question:
What is the difference between RX26T products with 64 Kbytes of RAM and those with 48 Kbyte of RAM?
Answer:
The RX26T comes with either 48 Kbytes or 64 Kbytes of RAM. 
Refer to the following for details on the differences between each product. 
For detailed specifications, please refer to the RX26T Group User's Manual: Hardware.
*Mass production of the 48-Kbyte RAM products is scheduled to start in the second half of 2023.
Suitable Products
RX26T
What is the difference between RX26T products with 64 Kbytes of RAM and those with 48 Kbyte of RAM?
What is the difference between RX26T products with 64 Kbytes of RAM and those with 48 Kbyte of RAM?
Answer:
The RX26T comes with either 48 Kbytes or 64 Kbytes of RAM. 
Refer to the following for details on the differences between each product. 
For detailed specifications, please refer to the RX26T Group User's Manual: Hardware.
*Mass production of the 48-Kbyte RAM products is scheduled to start in the second half of 2023.
Suitable Products
RX26T
The RX26T comes with either 48 Kbytes or 64 Kbytes of RAM. 
Refer to the following for details on the differences between each product. 
For detailed specifications, please refer to the RX26T Group User's Manual: Hardware.
*Mass production of the 48-Kbyte RAM products is scheduled to start in the second half of 2023.
The RX26T comes with either 48 Kbytes or 64 Kbytes of RAM. 
Refer to the following for details on the differences between each product.
For detailed specifications, please refer to the RX26T Group User's Manual: Hardware.
*Mass production of the 48-Kbyte RAM products is scheduled to start in the second half of 2023.
Suitable Products
RX26T
 

",['data/categories/rx_family/rx26t/f667dac2f8827a3fd660628fb62d3413/images/713f32e6f49f3b394e37e279da8dec8e.png'],[],['|  |\n|  |\n| RX26T |'],"{'title': 'Differences within the RX26T group', 'url': 'https://en-support.renesas.com/knowledgeBase/20938978', 'last_updated': None, 'extracted_at': '2025-03-09T00:06:01.625506'}","Question What is the difference between RX26T products with 64 Kbytes of RAM and those with 48 Kbyte of RAM? Answer The RX26T comes with either 48 Kbytes or 64 Kbytes of RAM. Refer to the following for details on the differences between each product. For detailed specifications, please refer to the RX26T Group User's Manual Hardware. Mass production of the 48-Kbyte RAM products is scheduled to start in the second half of 2023. Suitable Products RX26T Refer to the following for details on the differences between each product.    ",
8348c3c45c5165c7e201d965cc7d5f69,"Question:
How do I configure the IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board.
Answer:
The Fast Prototyping board has the onboard JLINK so you will have to use the Segger JLINK GDB Server to this setup.
Configuration options in IAR Embedded Work Bench
    The entry for the TCP/IP Address or hostname[.port] is different that what you expect this entry is using the localhost,port (using a comma to separate the two.)
    Launch the Segger Jlink GDB Server and configure as shown below
Once configured make sure the board is connected to your computer and launch the application by clicking OK.
This Dialog box should appear.  You can select the option to stay on top if you want but it is not needed.
  Suitable Products
R9A02G021
How do I configure the IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board.
How do I configure the IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board.
How do I configure the IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board.
Answer:
The Fast Prototyping board has the onboard JLINK so you will have to use the Segger JLINK GDB Server to this setup.
Configuration options in IAR Embedded Work Bench
    The entry for the TCP/IP Address or hostname[.port] is different that what you expect this entry is using the localhost,port (using a comma to separate the two.)
    Launch the Segger Jlink GDB Server and configure as shown below
Once configured make sure the board is connected to your computer and launch the application by clicking OK.
This Dialog box should appear.  You can select the option to stay on top if you want but it is not needed.
  Suitable Products
R9A02G021
The Fast Prototyping board has the onboard JLINK so you will have to use the Segger JLINK GDB Server to this setup.
Configuration options in IAR Embedded Work Bench
    The entry for the TCP/IP Address or hostname[.port] is different that what you expect this entry is using the localhost,port (using a comma to separate the two.)
    Launch the Segger Jlink GDB Server and configure as shown below
Once configured make sure the board is connected to your computer and launch the application by clicking OK.
This Dialog box should appear.  You can select the option to stay on top if you want but it is not needed.
The Fast Prototyping board has the onboard JLINK so you will have to use the Segger JLINK GDB Server to this setup.
Configuration options in IAR Embedded Work Bench
The entry for the TCP/IP Address or hostname[.port] is different that what you expect this entry is using the localhost,port (using a comma to separate the two.)
localhost,port
Launch the Segger Jlink GDB Server and configure as shown below
Once configured make sure the board is connected to your computer and launch the application by clicking OK.
This Dialog box should appear.  You can select the option to stay on top if you want but it is not needed.
Suitable Products
R9A02G021
R9A02G021
??? ??
???
??","['data/categories/risc-v/kit/8348c3c45c5165c7e201d965cc7d5f69/images/d72ba0492484bb30df711d27bd8d49e8.png', 'data/categories/risc-v/kit/8348c3c45c5165c7e201d965cc7d5f69/images/e3f015e8a2eff7728aad666b59482550.png', 'data/categories/risc-v/kit/8348c3c45c5165c7e201d965cc7d5f69/images/6a74d6cb21fca802623285b86e9ad2d3.png']",[],['|  |\n|  |\n| R9A02G021 |'],"{'title': 'Using IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board', 'url': 'https://en-support.renesas.com/knowledgeBase/21584038', 'last_updated': None, 'extracted_at': '2025-03-09T00:25:10.431117'}","Question How do I configure the IAR RISC-V tools to work with the Renesas R9A02G021 Fast Prototyping Board. Answer The Fast Prototyping board has the onboard JLINK so you will have to use the Segger JLINK GDB Server to this setup. Configuration options in IAR Embedded Work Bench The entry for the TCP/IP Address or hostname.port is different that what you expect this entry is using the localhost,port (using a comma to separate the two.) Launch the Segger Jlink GDB Server and configure as shown below Once configured make sure the board is connected to your computer and launch the application by clicking OK. This Dialog box should appear. You can select the option to stay on top if you want but it is not needed. Suitable Products R9A02G021 The entry for the TCP/IP Address or hostname.port is different that what you expect this entry is using the localhost,port (using a comma to separate the two.) localhost,port Launch the Segger Jlink GDB Server and configure as shown below Suitable Products ??? ?? ??? ??",
61beafa427d1d4732b828ea8be2281c6,"Question:
What is the notes on RZ/A1H and RZ/A1M from a software perspective?
Answer:
Since RZ/A1H and RZ/A1M are pin-compatible, Renesas only provides evaluation board and software packages for RZ/A1H and not provides RZ/A1M's one.If you consider RZ/A1M, please use RZ/A1H's one.
(The built-in memory size is different between RZ/A1H and RZ/A1M: RZ/A1H: 10MB, RZ/A1M: 5MB)
However, when using the RZ/A1H software package to evaluate RZ/A1M, please note the following point.
Target RZ/A1H software package: RZ/A1H FreeRTOS Software Package
The above RZ/A1H software uses the red frame in the table below as the memory area. 
On the other hand, RZ/A1M can not use the reserved area in the blue frame in the table below.
When using the above software on RZ/A1M, it is possible to use the software as it is by arranging memory that does not use the reserved area in the blue frame above.
Suitable Products
RZ/A1M
What is the notes on RZ/A1H and RZ/A1M from a software perspective?
What is the notes on RZ/A1H and RZ/A1M from a software perspective?
Answer:
Since RZ/A1H and RZ/A1M are pin-compatible, Renesas only provides evaluation board and software packages for RZ/A1H and not provides RZ/A1M's one.If you consider RZ/A1M, please use RZ/A1H's one.
(The built-in memory size is different between RZ/A1H and RZ/A1M: RZ/A1H: 10MB, RZ/A1M: 5MB)
However, when using the RZ/A1H software package to evaluate RZ/A1M, please note the following point.
Target RZ/A1H software package: RZ/A1H FreeRTOS Software Package
The above RZ/A1H software uses the red frame in the table below as the memory area. 
On the other hand, RZ/A1M can not use the reserved area in the blue frame in the table below.
When using the above software on RZ/A1M, it is possible to use the software as it is by arranging memory that does not use the reserved area in the blue frame above.
Suitable Products
RZ/A1M
Since RZ/A1H and RZ/A1M are pin-compatible, Renesas only provides evaluation board and software packages for RZ/A1H and not provides RZ/A1M's one.If you consider RZ/A1M, please use RZ/A1H's one.
(The built-in memory size is different between RZ/A1H and RZ/A1M: RZ/A1H: 10MB, RZ/A1M: 5MB)
However, when using the RZ/A1H software package to evaluate RZ/A1M, please note the following point.
Target RZ/A1H software package: RZ/A1H FreeRTOS Software Package
The above RZ/A1H software uses the red frame in the table below as the memory area. 
On the other hand, RZ/A1M can not use the reserved area in the blue frame in the table below.
When using the above software on RZ/A1M, it is possible to use the software as it is by arranging memory that does not use the reserved area in the blue frame above.
Since RZ/A1H and RZ/A1M are pin-compatible, Renesas only provides evaluation board and software packages for RZ/A1H and not provides RZ/A1M's one.If you consider RZ/A1M, please use RZ/A1H's one.
(The built-in memory size is different between RZ/A1H and RZ/A1M: RZ/A1H: 10MB, RZ/A1M: 5MB)
However, when using the RZ/A1H software package to evaluate RZ/A1M, please note the following point.
Target RZ/A1H software package: RZ/A1H FreeRTOS Software Package
The above RZ/A1H software uses the red frame in the table below as the memory area. 
On the other hand, RZ/A1M can not use the reserved area in the blue frame in the table below.
When using the above software on RZ/A1M, it is possible to use the software as it is by arranging memory that does not use the reserved area in the blue frame above.
Suitable Products
RZ/A1M
 

",['data/categories/rz_family/rza/61beafa427d1d4732b828ea8be2281c6/images/1b07bf68123dc56b75639427bd9967b8.png'],[],['|  |\n|  |\n| RZ/A1M |'],"{'title': 'RZ/A1M: Notes on RZ/A1H and RZ/A1M from a software perspective', 'url': 'https://en-support.renesas.com/knowledgeBase/21276790', 'last_updated': None, 'extracted_at': '2025-03-08T23:43:04.810110'}","Question What is the notes on RZ/A1H and RZ/A1M from a software perspective? Answer Since RZ/A1H and RZ/A1M are pin-compatible, Renesas only provides evaluation board and software packages for RZ/A1H and not provides RZ/A1M's one.If you consider RZ/A1M, please use RZ/A1H's one. (The built-in memory size is different between RZ/A1H and RZ/A1M RZ/A1H 10MB, RZ/A1M 5MB) However, when using the RZ/A1H software package to evaluate RZ/A1M, please note the following point. Target RZ/A1H software package RZ/A1H FreeRTOS Software Package The above RZ/A1H software uses the red frame in the table below as the memory area. On the other hand, RZ/A1M can not use the reserved area in the blue frame in the table below. When using the above software on RZ/A1M, it is possible to use the software as it is by arranging memory that does not use the reserved area in the blue frame above. Suitable Products RZ/A1M    ",
3dbde11d28df31639bc8a09f88b73fa3,"Question:
In what combinations can the three Ethernet ports of the RZ/N2L be used?
Answer:
The assignments of the Ethernet/EtherCAT communication ports for the RZ/N2L can be selected in the MODCTRL register. 
The following figure shows the available combinations.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode
26.2.2 MODCTRL: Mode Control Register in RZ/N2L Group Users Manual: Hardware (r01uh0955ej0110-rzn2l)
Suitable Products
RZ/N2L
In what combinations can the three Ethernet ports of the RZ/N2L be used?
In what combinations can the three Ethernet ports of the RZ/N2L be used?
Answer:
The assignments of the Ethernet/EtherCAT communication ports for the RZ/N2L can be selected in the MODCTRL register. 
The following figure shows the available combinations.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode
26.2.2 MODCTRL: Mode Control Register in RZ/N2L Group Users Manual: Hardware (r01uh0955ej0110-rzn2l)
Suitable Products
RZ/N2L
The assignments of the Ethernet/EtherCAT communication ports for the RZ/N2L can be selected in the MODCTRL register. 
The following figure shows the available combinations.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode
26.2.2 MODCTRL: Mode Control Register in RZ/N2L Group Users Manual: Hardware (r01uh0955ej0110-rzn2l)
The assignments of the Ethernet/EtherCAT communication ports for the RZ/N2L can be selected in the MODCTRL register. 
The following figure shows the available combinations.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode
26.2.2 MODCTRL: Mode Control Register in RZ/N2L Group Users Manual: Hardware (r01uh0955ej0110-rzn2l)
Suitable Products
RZ/N2L
Go to Japanese Go to Chinese
Go to Japanese
Go to Chinese",['data/categories/rz_family/rzn2l/3dbde11d28df31639bc8a09f88b73fa3/images/008031755259d543c144b56c9b0ceb79.png'],[],['|  |\n|  |\n| RZ/N2L |'],"{'title': 'In what combinations can the three Ethernet ports of the RZ/N2L be used?', 'url': 'https://en-support.renesas.com/knowledgeBase/20612313', 'last_updated': '2022-09-08', 'extracted_at': '2025-03-08T23:46:50.122557'}","Question In what combinations can the three Ethernet ports of the RZ/N2L be used? Answer The assignments of the Ethernet/EtherCAT communication ports for the RZ/N2L can be selected in the MODCTRL register. The following figure shows the available combinations. For details, refer to the following items. Table 26.4 MAC-PHY interface mode 26.2.2 MODCTRL Mode Control Register in RZ/N2L Group Users Manual Hardware (r01uh0955ej0110-rzn2l) Suitable Products RZ/N2L Go to Japanese Go to Chinese Go to Japanese Go to Chinese",
5b422b7a44c7f9eed559902955806842,"Question:
How do I boot from NOR flash?
Answer:
RZ/T2H and RZ/N2H devices are not capable of booting from NOR flash.
Supported boot modes and mode setting pins (MDx) configurations are described below.
Suitable Products
RZ/T2H, RZ/N2H
How do I boot from NOR flash?
How do I boot from NOR flash?
Answer:
RZ/T2H and RZ/N2H devices are not capable of booting from NOR flash.
Supported boot modes and mode setting pins (MDx) configurations are described below.
Suitable Products
RZ/T2H, RZ/N2H
RZ/T2H and RZ/N2H devices are not capable of booting from NOR flash.
Supported boot modes and mode setting pins (MDx) configurations are described below.
RZ/T2H and RZ/N2H devices are not capable of booting from NOR flash.
Supported boot modes and mode setting pins (MDx) configurations are described below.
Suitable Products
RZ/T2H, RZ/N2H
 

",['data/categories/rz_family/rzt2h_rzn2h/5b422b7a44c7f9eed559902955806842/images/9564c55e674ccfa7e25eae893f81e756.png'],[],"['|  |\n|  |\n| RZ/T2H, RZ/N2H |']","{'title': 'RZ/T2H, RZ/N2H: Booting from NOR flash', 'url': 'https://en-support.renesas.com/knowledgeBase/21681478', 'last_updated': '2025-07-02', 'extracted_at': '2025-03-08T23:49:22.219240'}","Question How do I boot from NOR flash? Answer RZ/T2H and RZ/N2H devices are not capable of booting from NOR flash. Supported boot modes and mode setting pins (MDx) configurations are described below. Suitable Products RZ/T2H, RZ/N2H    ",
811c1c2702f2b6c084ff503d3efa38ed,"Question:
How do I use a PCIe card on the RZT2H-EVB.
Answer:
Using a 5Gbps PCIe NIC (Gen3 1-lane) as an example to explain the procedure, follow the below steps:
Step1: Modify the dts file (r9a09g077m44-dev.dts) to enable PCIe I/F as the root complex port.
Change SEL_ETHSS_PCIE from 1 (ETHSS/default) to 0 (PCIE) and compile the dts file.
Step2: Compile the in-box or out-of-box driver.
For in-box driver, reconfigure Linux kernel to enable it.
Eg. MACHINE=rzt2h-dev bitbake linux-renesas -c menuconfig
For out-of-box driver, use T2H Yocto SDK as the build env. to compile device driver module (*.ko) of the specific PCIe card.
Setup Yocto SDK env: source /opt/poky/3.1.21/environment-setup-aarch64-poky-linux
Modify the macro in Makefile of PCIe card device driver
Eg. BASEDIR, KERNELDIR, DRIVERDIR and etc
Step3: Change the SW setting on T2H-EVB to enable PCIe I/F.
For PCIe RC Configuration (2-port & 1-lane)
Set SW2-8 (OFF) and SW15-1 (ON), SW15-2 (ON), SW15-5~8 (ON)
Step4: Insert PCIe card and power on T2H-EVB.
Step5: Power on T2H-EVB and use lspci to check information about PCI buses in the system and devices connected to them.
lspci output is as following

If lspci utility is not available, check whether PCIe adaptor can be found under /sys/bus/pci/devices (or /sys/bus/pci-express/devices) directory

Step6: Install the PCIe card device driver (*.ko) by insmod command.
Eg. insmod r8126.ko
Now the 5Gbps PCIe NIC is working on T2H-EVB and can be configured by Linux ifconfig command. Utilities (ethtool and iperf3) can be used to set ethernet band (eg. 2.5GBaseT, 5GBaseT and etc) and performance/throughput.
Suitable Products
RZ/T2H
How do I use a PCIe card on the RZT2H-EVB.
How do I use a PCIe card on the RZT2H-EVB.
Answer:
Using a 5Gbps PCIe NIC (Gen3 1-lane) as an example to explain the procedure, follow the below steps:
Step1: Modify the dts file (r9a09g077m44-dev.dts) to enable PCIe I/F as the root complex port.
Change SEL_ETHSS_PCIE from 1 (ETHSS/default) to 0 (PCIE) and compile the dts file.
Step2: Compile the in-box or out-of-box driver.
For in-box driver, reconfigure Linux kernel to enable it.
Eg. MACHINE=rzt2h-dev bitbake linux-renesas -c menuconfig
For out-of-box driver, use T2H Yocto SDK as the build env. to compile device driver module (*.ko) of the specific PCIe card.
Setup Yocto SDK env: source /opt/poky/3.1.21/environment-setup-aarch64-poky-linux
Modify the macro in Makefile of PCIe card device driver
Eg. BASEDIR, KERNELDIR, DRIVERDIR and etc
Step3: Change the SW setting on T2H-EVB to enable PCIe I/F.
For PCIe RC Configuration (2-port & 1-lane)
Set SW2-8 (OFF) and SW15-1 (ON), SW15-2 (ON), SW15-5~8 (ON)
Step4: Insert PCIe card and power on T2H-EVB.
Step5: Power on T2H-EVB and use lspci to check information about PCI buses in the system and devices connected to them.
lspci output is as following

If lspci utility is not available, check whether PCIe adaptor can be found under /sys/bus/pci/devices (or /sys/bus/pci-express/devices) directory

Step6: Install the PCIe card device driver (*.ko) by insmod command.
Eg. insmod r8126.ko
Now the 5Gbps PCIe NIC is working on T2H-EVB and can be configured by Linux ifconfig command. Utilities (ethtool and iperf3) can be used to set ethernet band (eg. 2.5GBaseT, 5GBaseT and etc) and performance/throughput.
Suitable Products
RZ/T2H
Using a 5Gbps PCIe NIC (Gen3 1-lane) as an example to explain the procedure, follow the below steps:
Step1: Modify the dts file (r9a09g077m44-dev.dts) to enable PCIe I/F as the root complex port.
Change SEL_ETHSS_PCIE from 1 (ETHSS/default) to 0 (PCIE) and compile the dts file.
Step2: Compile the in-box or out-of-box driver.
For in-box driver, reconfigure Linux kernel to enable it.
Eg. MACHINE=rzt2h-dev bitbake linux-renesas -c menuconfig
For out-of-box driver, use T2H Yocto SDK as the build env. to compile device driver module (*.ko) of the specific PCIe card.
Setup Yocto SDK env: source /opt/poky/3.1.21/environment-setup-aarch64-poky-linux
Modify the macro in Makefile of PCIe card device driver
Eg. BASEDIR, KERNELDIR, DRIVERDIR and etc
Step3: Change the SW setting on T2H-EVB to enable PCIe I/F.
For PCIe RC Configuration (2-port & 1-lane)
Set SW2-8 (OFF) and SW15-1 (ON), SW15-2 (ON), SW15-5~8 (ON)
Step4: Insert PCIe card and power on T2H-EVB.
Step5: Power on T2H-EVB and use lspci to check information about PCI buses in the system and devices connected to them.
lspci output is as following

If lspci utility is not available, check whether PCIe adaptor can be found under /sys/bus/pci/devices (or /sys/bus/pci-express/devices) directory

Step6: Install the PCIe card device driver (*.ko) by insmod command.
Eg. insmod r8126.ko
Now the 5Gbps PCIe NIC is working on T2H-EVB and can be configured by Linux ifconfig command. Utilities (ethtool and iperf3) can be used to set ethernet band (eg. 2.5GBaseT, 5GBaseT and etc) and performance/throughput.
Using a 5Gbps PCIe NIC (Gen3 1-lane) as an example to explain the procedure, follow the below steps:
Step1: Modify the dts file (r9a09g077m44-dev.dts) to enable PCIe I/F as the root complex port.
Step2: Compile the in-box or out-of-box driver.
Step3: Change the SW setting on T2H-EVB to enable PCIe I/F.
Step4: Insert PCIe card and power on T2H-EVB.
Step5: Power on T2H-EVB and use lspci to check information about PCI buses in the system and devices connected to them.
Step6: Install the PCIe card device driver (*.ko) by insmod command.
Now the 5Gbps PCIe NIC is working on T2H-EVB and can be configured by Linux ifconfig command. Utilities (ethtool and iperf3) can be used to set ethernet band (eg. 2.5GBaseT, 5GBaseT and etc) and performance/throughput.
Suitable Products
RZ/T2H","['data/categories/rz_family/rzt2h_rzn2h/811c1c2702f2b6c084ff503d3efa38ed/images/3aa085b30caeeebb546f8cc3778ca28d.png', 'data/categories/rz_family/rzt2h_rzn2h/811c1c2702f2b6c084ff503d3efa38ed/images/93e8d38e4eca3761adec36088f2fcc3f.png', 'data/categories/rz_family/rzt2h_rzn2h/811c1c2702f2b6c084ff503d3efa38ed/images/4ba37b2b80ff69cd55ee3a80de8ab5bb.png']",[],['|  |\n|  |\n| RZ/T2H |'],"{'title': 'How to Use a PCIe card on the RZT2H-EVB', 'url': 'https://en-support.renesas.com/knowledgeBase/21727836', 'last_updated': None, 'extracted_at': '2025-03-08T23:49:40.104072'}","Question How do I use a PCIe card on the RZT2H-EVB. Answer Using a 5Gbps PCIe NIC (Gen3 1-lane) as an example to explain the procedure, follow the below steps Step1 Modify the dts file (r9a09g077m44-dev.dts) to enable PCIe I/F as the root complex port. Change SELETHSSPCIE from 1 (ETHSS/default) to 0 (PCIE) and compile the dts file. Step2 Compile the in-box or out-of-box driver. For in-box driver, reconfigure Linux kernel to enable it. Eg. MACHINErzt2h-dev bitbake linux-renesas -c menuconfig For out-of-box driver, use T2H Yocto SDK as the build env. to compile device driver module (.ko) of the specific PCIe card. Setup Yocto SDK env source /opt/poky/3.1.21/environment-setup-aarch64-poky-linux Modify the macro in Makefile of PCIe card device driver Eg. BASEDIR, KERNELDIR, DRIVERDIR and etc Step3 Change the SW setting on T2H-EVB to enable PCIe I/F. For PCIe RC Configuration (2-port  1-lane) Set SW2-8 (OFF) and SW15-1 (ON), SW15-2 (ON), SW15-58 (ON) Step4 Insert PCIe card and power on T2H-EVB. Step5 Power on T2H-EVB and use lspci to check information about PCI buses in the system and devices connected to them. lspci output is as following If lspci utility is not available, check whether PCIe adaptor can be found under /sys/bus/pci/devices (or /sys/bus/pci-express/devices) directory Step6 Install the PCIe card device driver (.ko) by insmod command. Eg. insmod r8126.ko Now the 5Gbps PCIe NIC is working on T2H-EVB and can be configured by Linux ifconfig command. Utilities (ethtool and iperf3) can be used to set ethernet band (eg. 2.5GBaseT, 5GBaseT and etc) and performance/throughput. Suitable Products RZ/T2H",
5048b566c97e05a4aea81eda6f5acb7e,"Question:
What should I do with pins I don't use?
Answer:
Refer to the following chapter in the Users Manual: Hardware to address unused pins. Note that measures differ depending on the pin.
17.6 Handling of Unused Pins
Suitable Products
RZ/T2H, RZ/N2H
What should I do with pins I don't use?
What should I do with pins I don't use?
Answer:
Refer to the following chapter in the Users Manual: Hardware to address unused pins. Note that measures differ depending on the pin.
17.6 Handling of Unused Pins
Suitable Products
RZ/T2H, RZ/N2H
Refer to the following chapter in the Users Manual: Hardware to address unused pins. Note that measures differ depending on the pin.
17.6 Handling of Unused Pins
Refer to the following chapter in the Users Manual: Hardware to address unused pins. Note that measures differ depending on the pin.
17.6 Handling of Unused Pins
Suitable Products
RZ/T2H, RZ/N2H
 

",['data/categories/rz_family/rzt2h_rzn2h/5048b566c97e05a4aea81eda6f5acb7e/images/bfaf8a7d7dc7f14cc870c51726af24d2.png'],[],"['|  |\n|  |\n| RZ/T2H, RZ/N2H |']","{'title': 'RZ/T2H, RZ/N2H: Handling of unused pins', 'url': 'https://en-support.renesas.com/knowledgeBase/21557040', 'last_updated': '2025-07-02', 'extracted_at': '2025-03-08T23:49:19.318848'}","Question What should I do with pins I don't use? Answer Refer to the following chapter in the Users Manual Hardware to address unused pins. Note that measures differ depending on the pin. 17.6 Handling of Unused Pins Suitable Products RZ/T2H, RZ/N2H    ",
bda26d0e54eb84cd230f57eead9420df,"Question:
 How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK?
Answer:
To use the USB Ethernet Adapter that works as a CDC-ECM, configure the USB Host CDC and application program by following the steps below.
Step1: Choose the Configuration (by bConfigurationValue) contained the interface class (2: USB_CLASS_COMMUNICATIONS) and subclass (6: USB_CDC_ECM_SUBCLASS). The below log is an example produced by the lsusb utility. The bConfigurationValue is 3 in this example.
Step2: Choose the CDC Communication (2: USB_CLASS_COMMUNICATIONS) and Data (10: USB_CLASS_CDC_DATA) interfaces (by bInterfaceNumber and bAlternateSetting) contained the endpoints for the transaction of BULK-IN/OUT and INTR-IN. The below log is an example produced by lsusb utility. In this case, the bInterfaceNumber & bAlternateSetting are 0 & 0 and 1 & 1 for CDC Comm. and Data interfaces respectively.
Step3: Set no packet filter (0x43: SET_ETHERNET_PACKET_FILTER) to 0x1F.
The filter values are as the following
USB_CDC_PACKET_TYPE_PROMISCUOUS          0x01
USB_CDC_PACKET_TYPE_ALL_MULTICAST       0x02
USB_CDC_PACKET_TYPE_DIRECTED                  0x04
USB_CDC_PACKET_TYPE_BROADCAST               0x08
USB_CDC_PACKET_TYPE_MULTICAST               0x10
Step4: Get the notification of network connection and disconnection through CDC Communication Interface (INTR-IN EP).
USB_CDC_NETWORK_CONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x01, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
USB_CDC_NETWORK_DISCONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x00, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
Step5: Transmit and receive ethernet packets through CDC Data Interface (BULK-IN/OUT EPs).
Besides the above steps, there are several more points to be checked. The 1st one is to allocate USB buffer in non-cache area and the 2nd one is to check USB device enumeration process. Will it just use configuration 0 as default? Or it will check available configurations and choose the proper one. The last one is to make sure with different buffer location for INTR-IN and BULK-IN/OUT EPs. Finally, there are two CDC-ECM dongles (RTL8153 and AX88179A) with verified functionalities on T2M-RSK with FreeRTOS+TCP stack.
Suitable Products
RZ/T2M
How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK?
How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK?
Answer:
To use the USB Ethernet Adapter that works as a CDC-ECM, configure the USB Host CDC and application program by following the steps below.
Step1: Choose the Configuration (by bConfigurationValue) contained the interface class (2: USB_CLASS_COMMUNICATIONS) and subclass (6: USB_CDC_ECM_SUBCLASS). The below log is an example produced by the lsusb utility. The bConfigurationValue is 3 in this example.
Step2: Choose the CDC Communication (2: USB_CLASS_COMMUNICATIONS) and Data (10: USB_CLASS_CDC_DATA) interfaces (by bInterfaceNumber and bAlternateSetting) contained the endpoints for the transaction of BULK-IN/OUT and INTR-IN. The below log is an example produced by lsusb utility. In this case, the bInterfaceNumber & bAlternateSetting are 0 & 0 and 1 & 1 for CDC Comm. and Data interfaces respectively.
Step3: Set no packet filter (0x43: SET_ETHERNET_PACKET_FILTER) to 0x1F.
The filter values are as the following
USB_CDC_PACKET_TYPE_PROMISCUOUS          0x01
USB_CDC_PACKET_TYPE_ALL_MULTICAST       0x02
USB_CDC_PACKET_TYPE_DIRECTED                  0x04
USB_CDC_PACKET_TYPE_BROADCAST               0x08
USB_CDC_PACKET_TYPE_MULTICAST               0x10
Step4: Get the notification of network connection and disconnection through CDC Communication Interface (INTR-IN EP).
USB_CDC_NETWORK_CONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x01, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
USB_CDC_NETWORK_DISCONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x00, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
Step5: Transmit and receive ethernet packets through CDC Data Interface (BULK-IN/OUT EPs).
Besides the above steps, there are several more points to be checked. The 1st one is to allocate USB buffer in non-cache area and the 2nd one is to check USB device enumeration process. Will it just use configuration 0 as default? Or it will check available configurations and choose the proper one. The last one is to make sure with different buffer location for INTR-IN and BULK-IN/OUT EPs. Finally, there are two CDC-ECM dongles (RTL8153 and AX88179A) with verified functionalities on T2M-RSK with FreeRTOS+TCP stack.
Suitable Products
RZ/T2M
To use the USB Ethernet Adapter that works as a CDC-ECM, configure the USB Host CDC and application program by following the steps below.
Step1: Choose the Configuration (by bConfigurationValue) contained the interface class (2: USB_CLASS_COMMUNICATIONS) and subclass (6: USB_CDC_ECM_SUBCLASS). The below log is an example produced by the lsusb utility. The bConfigurationValue is 3 in this example.
Step2: Choose the CDC Communication (2: USB_CLASS_COMMUNICATIONS) and Data (10: USB_CLASS_CDC_DATA) interfaces (by bInterfaceNumber and bAlternateSetting) contained the endpoints for the transaction of BULK-IN/OUT and INTR-IN. The below log is an example produced by lsusb utility. In this case, the bInterfaceNumber & bAlternateSetting are 0 & 0 and 1 & 1 for CDC Comm. and Data interfaces respectively.
Step3: Set no packet filter (0x43: SET_ETHERNET_PACKET_FILTER) to 0x1F.
The filter values are as the following
USB_CDC_PACKET_TYPE_PROMISCUOUS          0x01
USB_CDC_PACKET_TYPE_ALL_MULTICAST       0x02
USB_CDC_PACKET_TYPE_DIRECTED                  0x04
USB_CDC_PACKET_TYPE_BROADCAST               0x08
USB_CDC_PACKET_TYPE_MULTICAST               0x10
Step4: Get the notification of network connection and disconnection through CDC Communication Interface (INTR-IN EP).
USB_CDC_NETWORK_CONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x01, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
USB_CDC_NETWORK_DISCONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x00, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
Step5: Transmit and receive ethernet packets through CDC Data Interface (BULK-IN/OUT EPs).
Besides the above steps, there are several more points to be checked. The 1st one is to allocate USB buffer in non-cache area and the 2nd one is to check USB device enumeration process. Will it just use configuration 0 as default? Or it will check available configurations and choose the proper one. The last one is to make sure with different buffer location for INTR-IN and BULK-IN/OUT EPs. Finally, there are two CDC-ECM dongles (RTL8153 and AX88179A) with verified functionalities on T2M-RSK with FreeRTOS+TCP stack.
To use the USB Ethernet Adapter that works as a CDC-ECM, configure the USB Host CDC and application program by following the steps below.
Step1: Choose the Configuration (by bConfigurationValue) contained the interface class (2: USB_CLASS_COMMUNICATIONS) and subclass (6: USB_CDC_ECM_SUBCLASS). The below log is an example produced by the lsusb utility. The bConfigurationValue is 3 in this example.
Step2: Choose the CDC Communication (2: USB_CLASS_COMMUNICATIONS) and Data (10: USB_CLASS_CDC_DATA) interfaces (by bInterfaceNumber and bAlternateSetting) contained the endpoints for the transaction of BULK-IN/OUT and INTR-IN. The below log is an example produced by lsusb utility. In this case, the bInterfaceNumber & bAlternateSetting are 0 & 0 and 1 & 1 for CDC Comm. and Data interfaces respectively.
Step3: Set no packet filter (0x43: SET_ETHERNET_PACKET_FILTER) to 0x1F.
The filter values are as the following
USB_CDC_PACKET_TYPE_PROMISCUOUS          0x01
USB_CDC_PACKET_TYPE_ALL_MULTICAST       0x02
USB_CDC_PACKET_TYPE_DIRECTED                  0x04
USB_CDC_PACKET_TYPE_BROADCAST               0x08
USB_CDC_PACKET_TYPE_MULTICAST               0x10
Step4: Get the notification of network connection and disconnection through CDC Communication Interface (INTR-IN EP).
USB_CDC_NETWORK_CONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x01, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
USB_CDC_NETWORK_DISCONNECT packet
{
0xA1, /* bmRequestType */
0x00, /* bRequest */
0x00, /* wValue (lo) */
0x00, /* wValue (hi) */
0x01, /* wIndex (lo) */
0x00, /* wIndex (hi) */
0x00, /* wLength (lo) */
0x00 /* wLength (hi) */
}
Step5: Transmit and receive ethernet packets through CDC Data Interface (BULK-IN/OUT EPs).
Besides the above steps, there are several more points to be checked. The 1st one is to allocate USB buffer in non-cache area and the 2nd one is to check USB device enumeration process. Will it just use configuration 0 as default? Or it will check available configurations and choose the proper one. The last one is to make sure with different buffer location for INTR-IN and BULK-IN/OUT EPs. Finally, there are two CDC-ECM dongles (RTL8153 and AX88179A) with verified functionalities on T2M-RSK with FreeRTOS+TCP stack.
Suitable Products
RZ/T2M","['data/categories/rz_family/rzt2m/bda26d0e54eb84cd230f57eead9420df/images/3f8722265fad494f2ea9904ae91b8c90.png', 'data/categories/rz_family/rzt2m/bda26d0e54eb84cd230f57eead9420df/images/3e6d5c5000679bc2e60128a650ae91dd.png']",[],['|  |\n|  |\n| RZ/T2M |'],"{'title': 'RZ Family: How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK?', 'url': 'https://en-support.renesas.com/knowledgeBase/21698326', 'last_updated': None, 'extracted_at': '2025-03-08T23:50:23.316645'}","Question How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK? Answer To use the USB Ethernet Adapter that works as a CDC-ECM, configure the USB Host CDC and application program by following the steps below. Step1 Choose the Configuration (by bConfigurationValue) contained the interface class (2 USBCLASSCOMMUNICATIONS) and subclass (6 USBCDCECMSUBCLASS). The below log is an example produced by the lsusb utility. The bConfigurationValue is 3 in this example. Step2 Choose the CDC Communication (2 USBCLASSCOMMUNICATIONS) and Data (10 USBCLASSCDCDATA) interfaces (by bInterfaceNumber and bAlternateSetting) contained the endpoints for the transaction of BULK-IN/OUT and INTR-IN. The below log is an example produced by lsusb utility. In this case, the bInterfaceNumber  bAlternateSetting are 0  0 and 1  1 for CDC Comm. and Data interfaces respectively. Step3 Set no packet filter (0x43 SETETHERNETPACKETFILTER) to 0x1F. The filter values are as the following USBCDCPACKETTYPEPROMISCUOUS 0x01 USBCDCPACKETTYPEALLMULTICAST 0x02 USBCDCPACKETTYPEDIRECTED 0x04 USBCDCPACKETTYPEBROADCAST 0x08 USBCDCPACKETTYPEMULTICAST 0x10 Step4 Get the notification of network connection and disconnection through CDC Communication Interface (INTR-IN EP). USBCDCNETWORKCONNECT packet  0xA1, / bmRequestType / 0x00, / bRequest / 0x01, / wValue (lo) / 0x00, / wValue (hi) / 0x01, / wIndex (lo) / 0x00, / wIndex (hi) / 0x00, / wLength (lo) / 0x00 / wLength (hi) /  USBCDCNETWORKDISCONNECT packet 0x00, / wValue (lo) / Step5 Transmit and receive ethernet packets through CDC Data Interface (BULK-IN/OUT EPs). Besides the above steps, there are several more points to be checked. The 1st one is to allocate USB buffer in non-cache area and the 2nd one is to check USB device enumeration process. Will it just use configuration 0 as default? Or it will check available configurations and choose the proper one. The last one is to make sure with different buffer location for INTR-IN and BULK-IN/OUT EPs. Finally, there are two CDC-ECM dongles (RTL8153 and AX88179A) with verified functionalities on T2M-RSK with FreeRTOSTCP stack. Suitable Products RZ/T2M How to use USB Ethernet Adaptor supports CDC-ECM on RZT2M-RSK?",
521cb8e6ba2a9fb702fbedc441c0ab26,"Question:
How should I handle unused pins?
Answer:
Be careful because the handling differs depending on the pin. 
Handle the unused pins in reference to the following table.
16.5 Handling of Unused Pins
Suitable Products
RZ/T2M
How should I handle unused pins?
How should I handle unused pins?
Answer:
Be careful because the handling differs depending on the pin. 
Handle the unused pins in reference to the following table.
16.5 Handling of Unused Pins
Suitable Products
RZ/T2M
Be careful because the handling differs depending on the pin. 
Handle the unused pins in reference to the following table.
16.5 Handling of Unused Pins
Be careful because the handling differs depending on the pin. 
Handle the unused pins in reference to the following table.
16.5 Handling of Unused Pins
Suitable Products
RZ/T2M
Go to Japanese Go to Chinese
Go to Japanese
Go to Chinese",['data/categories/rz_family/rzt2m/521cb8e6ba2a9fb702fbedc441c0ab26/images/cd54bce4709dfd7821d675d5ca7cb0ae.png'],[],['|  |\n|  |\n| RZ/T2M |'],"{'title': 'RZ/T2M: How should I handle unused pins?', 'url': 'https://en-support.renesas.com/knowledgeBase/20483526', 'last_updated': '2022-07-06', 'extracted_at': '2025-03-08T23:50:07.115956'}",Question How should I handle unused pins? Answer Be careful because the handling differs depending on the pin. Handle the unused pins in reference to the following table. 16.5 Handling of Unused Pins Suitable Products RZ/T2M Go to Japanese Go to Chinese Go to Japanese Go to Chinese,
820abc84ea260a975d04191cca4b267e,"Question:
What power supply configuration is recommended for the RZ/T2M?
Answer:
Refer to the power supply combination of the following winning combo. 
JP191 Motor Control System with Industrial Network and FuSa
Suitable Products
RZ/T2M
What power supply configuration is recommended for the RZ/T2M?
What power supply configuration is recommended for the RZ/T2M?
Answer:
Refer to the power supply combination of the following winning combo. 
JP191 Motor Control System with Industrial Network and FuSa
Suitable Products
RZ/T2M
Refer to the power supply combination of the following winning combo. 
JP191 Motor Control System with Industrial Network and FuSa
Refer to the power supply combination of the following winning combo.
JP191 Motor Control System with Industrial Network and FuSa
Suitable Products
RZ/T2M
Go to Japanese Go to Chinese
Go to Japanese
Go to Chinese",['data/categories/rz_family/rzt2m/820abc84ea260a975d04191cca4b267e/images/69703acb22128bbcce4619f779e25c3d.png'],[],['|  |\n|  |\n| RZ/T2M |'],"{'title': 'What power supply configuration is recommended for the RZ/T2M?', 'url': 'https://en-support.renesas.com/knowledgeBase/20483524', 'last_updated': '2022-07-06', 'extracted_at': '2025-03-08T23:50:14.798348'}",Question What power supply configuration is recommended for the RZ/T2M? Answer Refer to the power supply combination of the following winning combo. JP191 Motor Control System with Industrial Network and FuSa Suitable Products RZ/T2M Refer to the power supply combination of the following winning combo. Go to Japanese Go to Chinese Go to Japanese Go to Chinese,
da220d6b1410aa9a27624de30338af16,"Question:
Please tell me about the types of reset of the RZ/T2M, and their initialization targets.
Answer:
The RZ/T2M has the five types of reset shown in Table 5.1.
For the initialization targets of each reset, refer to Table 5.2.
Suitable Products
RZ/T2M
Please tell me about the types of reset of the RZ/T2M, and their initialization targets.
Please tell me about the types of reset of the RZ/T2M, and their initialization targets.
Answer:
The RZ/T2M has the five types of reset shown in Table 5.1.
For the initialization targets of each reset, refer to Table 5.2.
Suitable Products
RZ/T2M
The RZ/T2M has the five types of reset shown in Table 5.1.
For the initialization targets of each reset, refer to Table 5.2.
The RZ/T2M has the five types of reset shown in Table 5.1.
For the initialization targets of each reset, refer to Table 5.2.
Suitable Products
RZ/T2M
Go to Japanese Go to Chinese
Go to Japanese
Go to Chinese","['data/categories/rz_family/rzt2m/da220d6b1410aa9a27624de30338af16/images/4a2f9e3f6d7eac9bb05c33a4c21c1c96.png', 'data/categories/rz_family/rzt2m/da220d6b1410aa9a27624de30338af16/images/414993a67cb1a819ee5acb69422a4196.png']",[],['|  |\n|  |\n| RZ/T2M |'],"{'title': 'Please tell me about the types of reset of the RZ/T2M, and their initialization targets.', 'url': 'https://en-support.renesas.com/knowledgeBase/20483528', 'last_updated': '2022-07-06', 'extracted_at': '2025-03-08T23:50:20.282789'}","Question Please tell me about the types of reset of the RZ/T2M, and their initialization targets. Answer The RZ/T2M has the five types of reset shown in Table 5.1. For the initialization targets of each reset, refer to Table 5.2. Suitable Products RZ/T2M Go to Japanese Go to Chinese Go to Japanese Go to Chinese",
d4aab005aea43af76373abe7c614208e,"Question:
What combinations can be used simultaneously with Ethernet/EtherCAT communication of the RZ/T2M?
Answer:
The combinations that can be used simultaneously with the Ethernet/EtherCAT communication port of the RZ/T2M can be selected in MDOCTRL. 
The combinations that can be set are as shown in the following figure.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode and 26.2.2 MODCTRL: Mode Control Register in RZ/T2M Group Users Manual: Hardware (r01uh0916ej0080-rzt2m)
Suitable Products
RZ/T2M
What combinations can be used simultaneously with Ethernet/EtherCAT communication of the RZ/T2M?
What combinations can be used simultaneously with Ethernet/EtherCAT communication of the RZ/T2M?
Answer:
The combinations that can be used simultaneously with the Ethernet/EtherCAT communication port of the RZ/T2M can be selected in MDOCTRL. 
The combinations that can be set are as shown in the following figure.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode and 26.2.2 MODCTRL: Mode Control Register in RZ/T2M Group Users Manual: Hardware (r01uh0916ej0080-rzt2m)
Suitable Products
RZ/T2M
The combinations that can be used simultaneously with the Ethernet/EtherCAT communication port of the RZ/T2M can be selected in MDOCTRL. 
The combinations that can be set are as shown in the following figure.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode and 26.2.2 MODCTRL: Mode Control Register in RZ/T2M Group Users Manual: Hardware (r01uh0916ej0080-rzt2m)
The combinations that can be used simultaneously with the Ethernet/EtherCAT communication port of the RZ/T2M can be selected in MDOCTRL. 
The combinations that can be set are as shown in the following figure.
For details, refer to the following items. 
Table 26.4 MAC-PHY interface mode and 26.2.2 MODCTRL: Mode Control Register in RZ/T2M Group Users Manual: Hardware (r01uh0916ej0080-rzt2m)
Suitable Products
RZ/T2M
Go to Japanese Go to Chinese
Go to Japanese
Go to Chinese",['data/categories/rz_family/rzt2m/d4aab005aea43af76373abe7c614208e/images/2e81d73589f7604fd234a1e565b04c51.png'],[],['|  |\n|  |\n| RZ/T2M |'],"{'title': 'What combinations can be used simultaneously with Ethernet/EtherCAT communication of the RZ/T2M?', 'url': 'https://en-support.renesas.com/knowledgeBase/20483523', 'last_updated': '2022-07-06', 'extracted_at': '2025-03-08T23:50:12.097934'}","Question What combinations can be used simultaneously with Ethernet/EtherCAT communication of the RZ/T2M? Answer The combinations that can be used simultaneously with the Ethernet/EtherCAT communication port of the RZ/T2M can be selected in MDOCTRL. The combinations that can be set are as shown in the following figure. For details, refer to the following items. Table 26.4 MAC-PHY interface mode and 26.2.2 MODCTRL Mode Control Register in RZ/T2M Group Users Manual Hardware (r01uh0916ej0080-rzt2m) Suitable Products RZ/T2M Go to Japanese Go to Chinese Go to Japanese Go to Chinese",
752b5f2bc6e3c76bc4cdaf68e35306ee,"Question:
RZ/V2H EVK - How to boot up from eMMC ?
Answer:
Hardware : RZ/V2H EVK
Software : AI SDK ver 5.00 (Release note)
Steps to boot up from eMMC :
Adjust the DIP switch on the CPU board to SCI download mode.

SW1(ON) : 1, 3, 5
SW2(ON) : 1, 2, 4

Download the flash writer (Flash_Writer_SCIF_RZV2H_DEV_INTERNAL_MEMORY.mot) to RZ/V2H, then program Arm trusted firmware (bl2_bp_emmc-rzv2h-evk-alpha.srec) via USB-CDC.

Sector number : 1
Program start address : 0x8101E00



Use theSUP command to change uart baurate to 921.6Kbps, then programming b31 firmware + uboot (fip-rzv2h-evk-alpha.srec) via USB-CDC.

Sector number : 0x300
Program start address : 0x44000000



Use theEM_SECSD command to set CSD attributes

Deploy the SD card using Ubuntu bmaptool. Adjust the SD device (e.g., sda, sdb) based on your Linux machine.

sudo bmaptool copy --bmap core-image-weston-rzv2h-evk-alpha.wic.bmap core-image-weston-rzv2h-evk-alpha.wic.gz /dev/sda

Power off RZ/V2H, then adjust the DIP switch on the CPU board to boot from eMMC.

SW1(ON) : 1, 3, 4, 5
SW2(ON) : 1, 2, 4

mmcblk1 is for SD card.



/ mount at SD card



Use ""fdisk"" to partition the eMMC into two partitions, then deploy rootfs to eMMC.

Power off RZ/V2H, Remove SD card, then set U-boot for eMMC boot.

Now / mount at eMMC.

No SD card is mounted.



Suitable Products
RZ/V2H
RZ/V2H EVK - How to boot up from eMMC ?
Answer:
Hardware : RZ/V2H EVK
Software : AI SDK ver 5.00 (Release note)
Steps to boot up from eMMC :
Adjust the DIP switch on the CPU board to SCI download mode.

SW1(ON) : 1, 3, 5
SW2(ON) : 1, 2, 4

Download the flash writer (Flash_Writer_SCIF_RZV2H_DEV_INTERNAL_MEMORY.mot) to RZ/V2H, then program Arm trusted firmware (bl2_bp_emmc-rzv2h-evk-alpha.srec) via USB-CDC.

Sector number : 1
Program start address : 0x8101E00



Use theSUP command to change uart baurate to 921.6Kbps, then programming b31 firmware + uboot (fip-rzv2h-evk-alpha.srec) via USB-CDC.

Sector number : 0x300
Program start address : 0x44000000



Use theEM_SECSD command to set CSD attributes

Deploy the SD card using Ubuntu bmaptool. Adjust the SD device (e.g., sda, sdb) based on your Linux machine.

sudo bmaptool copy --bmap core-image-weston-rzv2h-evk-alpha.wic.bmap core-image-weston-rzv2h-evk-alpha.wic.gz /dev/sda

Power off RZ/V2H, then adjust the DIP switch on the CPU board to boot from eMMC.

SW1(ON) : 1, 3, 4, 5
SW2(ON) : 1, 2, 4

mmcblk1 is for SD card.



/ mount at SD card



Use ""fdisk"" to partition the eMMC into two partitions, then deploy rootfs to eMMC.

Power off RZ/V2H, Remove SD card, then set U-boot for eMMC boot.

Now / mount at eMMC.

No SD card is mounted.



Suitable Products
RZ/V2H
Hardware : RZ/V2H EVK
Software : AI SDK ver 5.00 (Release note)
Steps to boot up from eMMC :
1
0x8101E00
0x300
0x44000000
sudo bmaptool copy --bmap core-image-weston-rzv2h-evk-alpha.wic.bmap core-image-weston-rzv2h-evk-alpha.wic.gz /dev/sda
4
Suitable Products
RZ/V2H","['data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/8eec000bcbe2091cfc8c04653d5e9d78.png', 'data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/e7783038faecfc033f17ad1ec58d5118.png', 'data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/5a439f27b1fe1342ce6f05d5791e402d.png', 'data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/2ceb717ff94f9f2ae4da02528a6e982a.png', 'data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/48977d68d10456bdb52a476b0fc9450d.png', 'data/categories/rz_family/rzv/752b5f2bc6e3c76bc4cdaf68e35306ee/images/15cdfd9ebbae9de0b5d39f6bbe34f228.png']",[],['|  |\n|  |\n| RZ/V2H |'],"{'title': 'RZ/V2H EVK - How to boot up from eMMC', 'url': 'https://en-support.renesas.com/knowledgeBase/21727835', 'last_updated': None, 'extracted_at': '2025-03-08T23:51:38.757080'}","Question RZ/V2H EVK - How to boot up from eMMC ? Answer Hardware  RZ/V2H EVK Software  AI SDK ver 5.00 (Release note) Steps to boot up from eMMC  Adjust the DIP switch on the CPU board to SCI download mode. SW1(ON)  1, 3, 5 SW2(ON)  1, 2, 4 Download the flash writer (FlashWriterSCIFRZV2HDEVINTERNALMEMORY.mot) to RZ/V2H, then program Arm trusted firmware (bl2bpemmc-rzv2h-evk-alpha.srec) via USB-CDC. Sector number  1 Program start address  0x8101E00 Use theSUP command to change uart baurate to 921.6Kbps, then programming b31 firmware  uboot (fip-rzv2h-evk-alpha.srec) via USB-CDC. Sector number  0x300 Program start address  0x44000000 Use theEMSECSD command to set CSD attributes Deploy the SD card using Ubuntu bmaptool. Adjust the SD device (e.g., sda, sdb) based on your Linux machine. sudo bmaptool copy --bmap core-image-weston-rzv2h-evk-alpha.wic.bmap core-image-weston-rzv2h-evk-alpha.wic.gz /dev/sda Power off RZ/V2H, then adjust the DIP switch on the CPU board to boot from eMMC. SW1(ON)  1, 3, 4, 5 mmcblk1 is for SD card. / mount at SD card Use ""fdisk"" to partition the eMMC into two partitions, then deploy rootfs to eMMC. Power off RZ/V2H, Remove SD card, then set U-boot for eMMC boot. Now / mount at eMMC. No SD card is mounted. Suitable Products RZ/V2H 1 0x8101E00 0x300 0x44000000 4",
d59bb9588a3224079421a4b9283844f3,"Question:
I get the error shown in the figure below when building a project created using RZ/T FSP v2.2.0. What does this look like?
e studio
EWARM
Answer:
It is a configurator error. This occurs when a section placement is changed to a different area from the area generated by the code generation in the linker script of RZ/T FSP v2.2.0 and RZ/N FSP v2.1.0 or later. (e.g. from ATCM to System RAM)
If this error occurs, it will not be possible to create a secondary project for multi-core operation with that project as the primary project because .sbd file generated after the build will not be generated correctly.
As a countermeasure, the following changes suppress the occurrence of errors, so you can create a secondary project, but please evaluate it thoroughly in your environment because it may not work properly.
e studioRemove __ddsc_xxxx_END described at the end of linker script file in {project name}/script
EWARM{project name}/rzt/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
{project name}/rzn/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
 Remove __ddsc_xxxx_END around #L756 (in the case of RZ/T FSP v2.2.0, RZ/N FSP v2.1.0)
(xxxx is the name of the memory area displayed in error.)
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
I get the error shown in the figure below when building a project created using RZ/T FSP v2.2.0. What does this look like?
e studio
EWARM
I get the error shown in the figure below when building a project created using RZ/T FSP v2.2.0. What does this look like?
e studio
EWARM
Answer:
It is a configurator error. This occurs when a section placement is changed to a different area from the area generated by the code generation in the linker script of RZ/T FSP v2.2.0 and RZ/N FSP v2.1.0 or later. (e.g. from ATCM to System RAM)
If this error occurs, it will not be possible to create a secondary project for multi-core operation with that project as the primary project because .sbd file generated after the build will not be generated correctly.
As a countermeasure, the following changes suppress the occurrence of errors, so you can create a secondary project, but please evaluate it thoroughly in your environment because it may not work properly.
e studioRemove __ddsc_xxxx_END described at the end of linker script file in {project name}/script
EWARM{project name}/rzt/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
{project name}/rzn/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
 Remove __ddsc_xxxx_END around #L756 (in the case of RZ/T FSP v2.2.0, RZ/N FSP v2.1.0)
(xxxx is the name of the memory area displayed in error.)
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
It is a configurator error. This occurs when a section placement is changed to a different area from the area generated by the code generation in the linker script of RZ/T FSP v2.2.0 and RZ/N FSP v2.1.0 or later. (e.g. from ATCM to System RAM)
If this error occurs, it will not be possible to create a secondary project for multi-core operation with that project as the primary project because .sbd file generated after the build will not be generated correctly.
As a countermeasure, the following changes suppress the occurrence of errors, so you can create a secondary project, but please evaluate it thoroughly in your environment because it may not work properly.
e studioRemove __ddsc_xxxx_END described at the end of linker script file in {project name}/script
EWARM{project name}/rzt/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
{project name}/rzn/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
 Remove __ddsc_xxxx_END around #L756 (in the case of RZ/T FSP v2.2.0, RZ/N FSP v2.1.0)
(xxxx is the name of the memory area displayed in error.)
It is a configurator error. This occurs when a section placement is changed to a different area from the area generated by the code generation in the linker script of RZ/T FSP v2.2.0 and RZ/N FSP v2.1.0 or later. (e.g. from ATCM to System RAM)
If this error occurs, it will not be possible to create a secondary project for multi-core operation with that project as the primary project because .sbd file generated after the build will not be generated correctly.
As a countermeasure, the following changes suppress the occurrence of errors, so you can create a secondary project, but please evaluate it thoroughly in your environment because it may not work properly.
e studioRemove __ddsc_xxxx_END described at the end of linker script file in {project name}/script
EWARM{project name}/rzt/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
{project name}/rzn/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c
 Remove __ddsc_xxxx_END around #L756 (in the case of RZ/T FSP v2.2.0, RZ/N FSP v2.1.0)
(xxxx is the name of the memory area displayed in error.)
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L

","['data/categories/rz_family/rzt2_rzn2_fsp/d59bb9588a3224079421a4b9283844f3/images/e081400097b52db48df817eb23bef824.png', 'data/categories/rz_family/rzt2_rzn2_fsp/d59bb9588a3224079421a4b9283844f3/images/87535df5e0568510ef8d96c2a9748f71.png', 'data/categories/rz_family/rzt2_rzn2_fsp/d59bb9588a3224079421a4b9283844f3/images/3114f01a3552653f639d3c5fbb158c83.png', 'data/categories/rz_family/rzt2_rzn2_fsp/d59bb9588a3224079421a4b9283844f3/images/99af35b8101980996357e21d818aff0f.png']",[],"['|  |\n|  |\n| RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L |']","{'title': 'RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L: Error regarding smart bundle occurs when building the project', 'url': 'https://en-support.renesas.com/knowledgeBase/21733883', 'last_updated': None, 'extracted_at': '2025-03-08T23:52:25.674120'}","Question I get the error shown in the figure below when building a project created using RZ/T FSP v2.2.0. What does this look like? e studio EWARM Answer It is a configurator error. This occurs when a section placement is changed to a different area from the area generated by the code generation in the linker script of RZ/T FSP v2.2.0 and RZ/N FSP v2.1.0 or later. (e.g. from ATCM to System RAM) If this error occurs, it will not be possible to create a secondary project for multi-core operation with that project as the primary project because .sbd file generated after the build will not be generated correctly. As a countermeasure, the following changes suppress the occurrence of errors, so you can create a secondary project, but please evaluate it thoroughly in your environment because it may not work properly. e studioRemove ddscxxxxEND described at the end of linker script file in project name/script EWARMproject name/rzt/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c project name/rzn/fsp/src/bsp/cmsis/Device/RENESAS/Source/system.c Remove ddscxxxxEND around L756 (in the case of RZ/T FSP v2.2.0, RZ/N FSP v2.1.0) (xxxx is the name of the memory area displayed in error.) Suitable Products RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L ",
88e6db58570d269662afcaa0397a468c,"Question:
Please tell me how to check the memory usage of RZ/T, RZ/N FSP project in e2 studio.
Answer:
The memory usage can be checked at Smart Bundle view.
It appears when you double-click on the bundle file({project name}/Debug/{project name}.sbd), which is created when you build the project.
Open the Memories tab of Smart Bundle view to see the memory placement and size for each core.
Sections that do not exist in FSP GCC linker script({project name}/script/fsp_XXXX.ld) will not be displayed. To add a new section, add the definition of ddsc symbols(__ddsc*_START and __ddsc*_END) to linker script.
Implementation ExampleAdd xSPI0_CS0 section
SECTIONS
{
    ...Omission of intermediate part...
    .xspi : AT (xSPI0_CS0_SPACE_PRV_START)
    {
        xspi_start = .;
        KEEP(*(.xspi))
        xspi_end = .;
    } > xSPI0_CS0_SPACE
}
    ...Omission of intermediate part...
__ddsc_xSPI0_CS0_SPACE_START = ORIGIN(xSPI0_CS0_SPACE);
__ddsc_xSPI0_CS0_SPACE_END = xspi_end;
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
Please tell me how to check the memory usage of RZ/T, RZ/N FSP project in e2 studio.
Please tell me how to check the memory usage of RZ/T, RZ/N FSP project in e2 studio.
Answer:
The memory usage can be checked at Smart Bundle view.
It appears when you double-click on the bundle file({project name}/Debug/{project name}.sbd), which is created when you build the project.
Open the Memories tab of Smart Bundle view to see the memory placement and size for each core.
Sections that do not exist in FSP GCC linker script({project name}/script/fsp_XXXX.ld) will not be displayed. To add a new section, add the definition of ddsc symbols(__ddsc*_START and __ddsc*_END) to linker script.
Implementation ExampleAdd xSPI0_CS0 section
SECTIONS
{
    ...Omission of intermediate part...
    .xspi : AT (xSPI0_CS0_SPACE_PRV_START)
    {
        xspi_start = .;
        KEEP(*(.xspi))
        xspi_end = .;
    } > xSPI0_CS0_SPACE
}
    ...Omission of intermediate part...
__ddsc_xSPI0_CS0_SPACE_START = ORIGIN(xSPI0_CS0_SPACE);
__ddsc_xSPI0_CS0_SPACE_END = xspi_end;
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
The memory usage can be checked at Smart Bundle view.
It appears when you double-click on the bundle file({project name}/Debug/{project name}.sbd), which is created when you build the project.
Open the Memories tab of Smart Bundle view to see the memory placement and size for each core.
Sections that do not exist in FSP GCC linker script({project name}/script/fsp_XXXX.ld) will not be displayed. To add a new section, add the definition of ddsc symbols(__ddsc*_START and __ddsc*_END) to linker script.
Implementation ExampleAdd xSPI0_CS0 section
SECTIONS
{
    ...Omission of intermediate part...
    .xspi : AT (xSPI0_CS0_SPACE_PRV_START)
    {
        xspi_start = .;
        KEEP(*(.xspi))
        xspi_end = .;
    } > xSPI0_CS0_SPACE
}
    ...Omission of intermediate part...
__ddsc_xSPI0_CS0_SPACE_START = ORIGIN(xSPI0_CS0_SPACE);
__ddsc_xSPI0_CS0_SPACE_END = xspi_end;
The memory usage can be checked at Smart Bundle view.
It appears when you double-click on the bundle file({project name}/Debug/{project name}.sbd), which is created when you build the project.
Open the Memories tab of Smart Bundle view to see the memory placement and size for each core.
Sections that do not exist in FSP GCC linker script({project name}/script/fsp_XXXX.ld) will not be displayed. To add a new section, add the definition of ddsc symbols(__ddsc*_START and __ddsc*_END) to linker script.
Implementation ExampleAdd xSPI0_CS0 section
SECTIONS
{
    ...Omission of intermediate part...
    .xspi : AT (xSPI0_CS0_SPACE_PRV_START)
    {
        xspi_start = .;
        KEEP(*(.xspi))
        xspi_end = .;
    } > xSPI0_CS0_SPACE
}
    ...Omission of intermediate part...
__ddsc_xSPI0_CS0_SPACE_START = ORIGIN(xSPI0_CS0_SPACE);
__ddsc_xSPI0_CS0_SPACE_END = xspi_end;
.xspi : AT (xSPI0_CS0_SPACE_PRV_START)
{
xspi_start = .;
KEEP(*(.xspi))
xspi_end = .;
} > xSPI0_CS0_SPACE
__ddsc_xSPI0_CS0_SPACE_START = ORIGIN(xSPI0_CS0_SPACE);
__ddsc_xSPI0_CS0_SPACE_END = xspi_end;
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L

","['data/categories/rz_family/rzt2_rzn2_fsp/88e6db58570d269662afcaa0397a468c/images/e78d60a443ff4ae54ccd889f90529a85.png', 'data/categories/rz_family/rzt2_rzn2_fsp/88e6db58570d269662afcaa0397a468c/images/0678de88cbeb0a31325be1dcbf94ef04.png']",[],"['|  |\n|  |\n| RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L |']","{'title': 'Display of memory usage for RZ/T, RZ/N FSP project', 'url': 'https://en-support.renesas.com/knowledgeBase/21733881', 'last_updated': None, 'extracted_at': '2025-03-08T23:52:34.541431'}","Question Please tell me how to check the memory usage of RZ/T, RZ/N FSP project in e2 studio. Answer The memory usage can be checked at Smart Bundle view. It appears when you double-click on the bundle file(project name/Debug/project name.sbd), which is created when you build the project. Open the Memories tab of Smart Bundle view to see the memory placement and size for each core. Sections that do not exist in FSP GCC linker script(project name/script/fspXXXX.ld) will not be displayed. To add a new section, add the definition of ddsc symbols(ddscSTART and ddscEND) to linker script. Implementation ExampleAdd xSPI0CS0 section SECTIONS  ...Omission of intermediate part... .xspi  AT (xSPI0CS0SPACEPRVSTART)  xspistart  .; KEEP((.xspi)) xspiend  .;   xSPI0CS0SPACE  ddscxSPI0CS0SPACESTART  ORIGIN(xSPI0CS0SPACE); ddscxSPI0CS0SPACEEND  xspiend; Suitable Products RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L .xspi  AT (xSPI0CS0SPACEPRVSTART) xspistart  .; KEEP((.xspi)) xspiend  .;   xSPI0CS0SPACE ",
153f60c2408d5bf988a443daf4a23364,"Question:
For multicore processing using RZ/T2M device, I create projects and build them in e2 studio with reference to RZ/T2,RZ/N2 Getting Started with Flexible Software Package. 
When I try to connect to the debugger in the secondary project with the debugger connected in the primary project, the following error occurs and the debugger does not start. What is the cause?
(The error message is ""Command ... is timed out"". Which command times out depends on the situation.)
Answer:
If the download does not finish within the GDB command timeout period, the startup may fail.
Please refer to the related FAQ: e studio debugger failed with timeout error to extend the timeout period.
Suitable Products
RZ/T2M, RZ/T2ME, RZ/T2H
For multicore processing using RZ/T2M device, I create projects and build them in e2 studio with reference to RZ/T2,RZ/N2 Getting Started with Flexible Software Package. 
When I try to connect to the debugger in the secondary project with the debugger connected in the primary project, the following error occurs and the debugger does not start. What is the cause?
(The error message is ""Command ... is timed out"". Which command times out depends on the situation.)
For multicore processing using RZ/T2M device, I create projects and build them in e2 studio with reference to RZ/T2,RZ/N2 Getting Started with Flexible Software Package. 
When I try to connect to the debugger in the secondary project with the debugger connected in the primary project, the following error occurs and the debugger does not start. What is the cause?
(The error message is ""Command ... is timed out"". Which command times out depends on the situation.)
Answer:
If the download does not finish within the GDB command timeout period, the startup may fail.
Please refer to the related FAQ: e studio debugger failed with timeout error to extend the timeout period.
Suitable Products
RZ/T2M, RZ/T2ME, RZ/T2H
If the download does not finish within the GDB command timeout period, the startup may fail.
Please refer to the related FAQ: e studio debugger failed with timeout error to extend the timeout period.
If the download does not finish within the GDB command timeout period, the startup may fail.
Please refer to the related FAQ: e studio debugger failed with timeout error to extend the timeout period.
Suitable Products
RZ/T2M, RZ/T2ME, RZ/T2H

",['data/categories/rz_family/rzt2_rzn2_fsp/153f60c2408d5bf988a443daf4a23364/images/a3c76ad5aabee3a6e24636c6b898d6d7.png'],[],"['|  |\n|  |\n| RZ/T2M, RZ/T2ME, RZ/T2H |']","{'title': 'RZ/T2M: Cannot debug a secondary project for multicore processing with flash boot mode in e studio.', 'url': 'https://en-support.renesas.com/knowledgeBase/21733880', 'last_updated': None, 'extracted_at': '2025-03-08T23:52:28.383648'}","Question For multicore processing using RZ/T2M device, I create projects and build them in e2 studio with reference to RZ/T2,RZ/N2 Getting Started with Flexible Software Package. When I try to connect to the debugger in the secondary project with the debugger connected in the primary project, the following error occurs and the debugger does not start. What is the cause? (The error message is ""Command ... is timed out"". Which command times out depends on the situation.) Answer If the download does not finish within the GDB command timeout period, the startup may fail. Please refer to the related FAQ e studio debugger failed with timeout error to extend the timeout period. Suitable Products RZ/T2M, RZ/T2ME, RZ/T2H ",
9cd77df4afd29800aac5905a344d1bfb,"Question:
Do I need any settings to use J-Link RTT with RZ/T2 and RZ/N2 (Cortex-R52) devices?
Answer:
RTT (Real time transfer) communication is performed by placing a SEGGER RTT Control Block and a buffer for reading/writing data in the memory.(https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/)
In case RZ/T2 devices, these data are placed in the SystemRAM area without cache for the following reasons.
 - The assigned addresses on each memory mapping of the CPU and AXI-AP is the same memory area. (e.g. ATCM cannot be used because the assigned addresses are different between the CPU and CoreSight (AXI-AP).)
 - No-cache areas are recommended because they are accessed by multiple bus masters.
To use J-Link RTT with Cortex-R52 core of RZ/T2 and RZ/N2 devices, make the following changes.
File to be changed
linker script(.ld) in {project name}/script
Chnages
Add the section definition for RTT to the .data_noncache section (SystemRAM area without cache) of the GCC linker script. Also, move the .data_noncache section before the .bss section, since the section for RTT is defined in the .bss section if it is after .bss.
1. Move .data_noncache section to the previous of .bss section(to avoid .data_noncache section being defined in .bss)
2. Add the following definitions in .data_noncache section.

    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
In the case of RZ/T FSP v2.2.0

.data_noncache DATA_NONCACHE_START : AT (DATA_NONCACHE_INIT_START)
{
    . = ((0 == HAS_SYSTEM_RAM_MIRROR) && (DEFINED(CR52_0) || DEFINED(CR52_1))) ? ALIGN(64) : ALIGN(8);
    _data_noncache_start = .;
    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
    KEEP(*(.data_noncache*))
    _data_noncache_end = .;
} > NONCACHE
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
Do I need any settings to use J-Link RTT with RZ/T2 and RZ/N2 (Cortex-R52) devices?
Do I need any settings to use J-Link RTT with RZ/T2 and RZ/N2 (Cortex-R52) devices?
Answer:
RTT (Real time transfer) communication is performed by placing a SEGGER RTT Control Block and a buffer for reading/writing data in the memory.(https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/)
In case RZ/T2 devices, these data are placed in the SystemRAM area without cache for the following reasons.
 - The assigned addresses on each memory mapping of the CPU and AXI-AP is the same memory area. (e.g. ATCM cannot be used because the assigned addresses are different between the CPU and CoreSight (AXI-AP).)
 - No-cache areas are recommended because they are accessed by multiple bus masters.
To use J-Link RTT with Cortex-R52 core of RZ/T2 and RZ/N2 devices, make the following changes.
File to be changed
linker script(.ld) in {project name}/script
Chnages
Add the section definition for RTT to the .data_noncache section (SystemRAM area without cache) of the GCC linker script. Also, move the .data_noncache section before the .bss section, since the section for RTT is defined in the .bss section if it is after .bss.
1. Move .data_noncache section to the previous of .bss section(to avoid .data_noncache section being defined in .bss)
2. Add the following definitions in .data_noncache section.

    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
In the case of RZ/T FSP v2.2.0

.data_noncache DATA_NONCACHE_START : AT (DATA_NONCACHE_INIT_START)
{
    . = ((0 == HAS_SYSTEM_RAM_MIRROR) && (DEFINED(CR52_0) || DEFINED(CR52_1))) ? ALIGN(64) : ALIGN(8);
    _data_noncache_start = .;
    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
    KEEP(*(.data_noncache*))
    _data_noncache_end = .;
} > NONCACHE
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L
RTT (Real time transfer) communication is performed by placing a SEGGER RTT Control Block and a buffer for reading/writing data in the memory.(https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/)
In case RZ/T2 devices, these data are placed in the SystemRAM area without cache for the following reasons.
 - The assigned addresses on each memory mapping of the CPU and AXI-AP is the same memory area. (e.g. ATCM cannot be used because the assigned addresses are different between the CPU and CoreSight (AXI-AP).)
 - No-cache areas are recommended because they are accessed by multiple bus masters.
To use J-Link RTT with Cortex-R52 core of RZ/T2 and RZ/N2 devices, make the following changes.
File to be changed
linker script(.ld) in {project name}/script
Chnages
Add the section definition for RTT to the .data_noncache section (SystemRAM area without cache) of the GCC linker script. Also, move the .data_noncache section before the .bss section, since the section for RTT is defined in the .bss section if it is after .bss.
1. Move .data_noncache section to the previous of .bss section(to avoid .data_noncache section being defined in .bss)
2. Add the following definitions in .data_noncache section.

    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
In the case of RZ/T FSP v2.2.0

.data_noncache DATA_NONCACHE_START : AT (DATA_NONCACHE_INIT_START)
{
    . = ((0 == HAS_SYSTEM_RAM_MIRROR) && (DEFINED(CR52_0) || DEFINED(CR52_1))) ? ALIGN(64) : ALIGN(8);
    _data_noncache_start = .;
    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
    KEEP(*(.data_noncache*))
    _data_noncache_end = .;
} > NONCACHE
RTT (Real time transfer) communication is performed by placing a SEGGER RTT Control Block and a buffer for reading/writing data in the memory.(https://www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/)
In case RZ/T2 devices, these data are placed in the SystemRAM area without cache for the following reasons.
 - The assigned addresses on each memory mapping of the CPU and AXI-AP is the same memory area. (e.g. ATCM cannot be used because the assigned addresses are different between the CPU and CoreSight (AXI-AP).)
 - No-cache areas are recommended because they are accessed by multiple bus masters.
To use J-Link RTT with Cortex-R52 core of RZ/T2 and RZ/N2 devices, make the following changes.
File to be changed
linker script(.ld) in {project name}/script
Chnages
Add the section definition for RTT to the .data_noncache section (SystemRAM area without cache) of the GCC linker script. Also, move the .data_noncache section before the .bss section, since the section for RTT is defined in the .bss section if it is after .bss.
1. Move .data_noncache section to the previous of .bss section(to avoid .data_noncache section being defined in .bss)
2. Add the following definitions in .data_noncache section.

    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
*(.bss._SEGGER_RTT)
*(.bss._acDownBuffer)
*(.bss._acUpBuffer)
In the case of RZ/T FSP v2.2.0

.data_noncache DATA_NONCACHE_START : AT (DATA_NONCACHE_INIT_START)
{
    . = ((0 == HAS_SYSTEM_RAM_MIRROR) && (DEFINED(CR52_0) || DEFINED(CR52_1))) ? ALIGN(64) : ALIGN(8);
    _data_noncache_start = .;
    *(.bss._SEGGER_RTT)
    *(.bss._acDownBuffer)
    *(.bss._acUpBuffer)
    KEEP(*(.data_noncache*))
    _data_noncache_end = .;
} > NONCACHE
*(.bss._SEGGER_RTT)
*(.bss._acDownBuffer)
*(.bss._acUpBuffer)
Suitable Products
RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L

",['data/categories/rz_family/rzt2_rzn2_fsp/9cd77df4afd29800aac5905a344d1bfb/images/71aab7ea9fd7135b3b2e4aab9120bf8b.png'],[],"['|  |\n|  |\n| RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L |']","{'title': 'How to use J-Link RTT with RZ/T2 and RZ/N2 (Cortex-R52) devices', 'url': 'https://en-support.renesas.com/knowledgeBase/21733882', 'last_updated': None, 'extracted_at': '2025-03-08T23:52:31.342371'}","Question Do I need any settings to use J-Link RTT with RZ/T2 and RZ/N2 (Cortex-R52) devices? Answer RTT (Real time transfer) communication is performed by placing a SEGGER RTT Control Block and a buffer for reading/writing data in the memory.(https//www.segger.com/products/debug-probes/j-link/technology/about-real-time-transfer/) In case RZ/T2 devices, these data are placed in the SystemRAM area without cache for the following reasons. - The assigned addresses on each memory mapping of the CPU and AXI-AP is the same memory area. (e.g. ATCM cannot be used because the assigned addresses are different between the CPU and CoreSight (AXI-AP).) - No-cache areas are recommended because they are accessed by multiple bus masters. To use J-Link RTT with Cortex-R52 core of RZ/T2 and RZ/N2 devices, make the following changes. File to be changed linker script(.ld) in project name/script Chnages Add the section definition for RTT to the .datanoncache section (SystemRAM area without cache) of the GCC linker script. Also, move the .datanoncache section before the .bss section, since the section for RTT is defined in the .bss section if it is after .bss. 1. Move .datanoncache section to the previous of .bss section(to avoid .datanoncache section being defined in .bss) 2. Add the following definitions in .datanoncache section. (.bss.SEGGERRTT) (.bss.acDownBuffer) (.bss.acUpBuffer) In the case of RZ/T FSP v2.2.0 .datanoncache DATANONCACHESTART  AT (DATANONCACHEINITSTART)  .  ((0  HASSYSTEMRAMMIRROR)  (DEFINED(CR520)  DEFINED(CR521))) ? ALIGN(64)  ALIGN(8); datanoncachestart  .; KEEP((.datanoncache)) datanoncacheend  .;   NONCACHE Suitable Products RZ/T2M, RZ/T2L, RZ/T2ME, RZ/T2H, RZ/N2L (.bss.SEGGERRTT) (.bss.acDownBuffer) (.bss.acUpBuffer) ",
1e7a6124b197aac1b88db40dfb0d8be2,"Question:
What are RL78 Family microcontrollers with minimal power consumption?
Answer:
The RL78/G22.
Power consumption is among the lowest in the industry at 37.5 A in CPU RUN mode and 0.20 A in STOP mode.
  Suitable Products
RL78/G22
What are RL78 Family microcontrollers with minimal power consumption?
What are RL78 Family microcontrollers with minimal power consumption?
Answer:
The RL78/G22.
Power consumption is among the lowest in the industry at 37.5 A in CPU RUN mode and 0.20 A in STOP mode.
  Suitable Products
RL78/G22
The RL78/G22.
Power consumption is among the lowest in the industry at 37.5 A in CPU RUN mode and 0.20 A in STOP mode.
  Suitable Products
The RL78/G22.
Power consumption is among the lowest in the industry at 37.5 A in CPU RUN mode and 0.20 A in STOP mode.
Suitable Products
RL78/G22
 

",['data/categories/rl78_family/rl78g22/1e7a6124b197aac1b88db40dfb0d8be2/images/3a08ea13a8a3ef188c0538de5c9d16a4.png'],[],['|  |\n|  |\n| RL78/G22 |'],"{'title': 'RL78 Family microcontrollers with minimal power consumption', 'url': 'https://en-support.renesas.com/knowledgeBase/20788289', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:46.029267'}",Question What are RL78 Family microcontrollers with minimal power consumption? Answer The RL78/G22. Power consumption is among the lowest in the industry at 37.5 A in CPU RUN mode and 0.20 A in STOP mode. Suitable Products RL78/G22 Suitable Products    ,
536e04c610491bde7f77847a05f6effb,"Question:
How much current is consumed when measuring capacitive touch?
Answer:
SNOOZE mode sequencer (SMS) and multi-electrode connection function (MEC) reduce current consumption.
The average current consumption measured with a capacitive touch cycle of 100 ms is 9.7 A (reference value for the RL78/G22).
  Figure 1: Current consumption results(Touch measurement using SMS/MEC function)
Please refer to this document for details.
RL78/G22 Capacitive Touch Low Power Guide (SMS / MEC function) (R01AN6847)
Suitable Products
RL78/G22
How much current is consumed when measuring capacitive touch?
How much current is consumed when measuring capacitive touch?
Answer:
SNOOZE mode sequencer (SMS) and multi-electrode connection function (MEC) reduce current consumption.
The average current consumption measured with a capacitive touch cycle of 100 ms is 9.7 A (reference value for the RL78/G22).
  Figure 1: Current consumption results(Touch measurement using SMS/MEC function)
Please refer to this document for details.
RL78/G22 Capacitive Touch Low Power Guide (SMS / MEC function) (R01AN6847)
Suitable Products
RL78/G22
SNOOZE mode sequencer (SMS) and multi-electrode connection function (MEC) reduce current consumption.
The average current consumption measured with a capacitive touch cycle of 100 ms is 9.7 A (reference value for the RL78/G22).
  Figure 1: Current consumption results(Touch measurement using SMS/MEC function)
Please refer to this document for details.
RL78/G22 Capacitive Touch Low Power Guide (SMS / MEC function) (R01AN6847)
Suitable Products
SNOOZE mode sequencer (SMS) and multi-electrode connection function (MEC) reduce current consumption.
The average current consumption measured with a capacitive touch cycle of 100 ms is 9.7 A (reference value for the RL78/G22).
Figure 1: Current consumption results(Touch measurement using SMS/MEC function)
Please refer to this document for details.
RL78/G22 Capacitive Touch Low Power Guide (SMS / MEC function) (R01AN6847)
Suitable Products
RL78/G22
 

",['data/categories/rl78_family/rl78g22/536e04c610491bde7f77847a05f6effb/images/6d889e5372360438633f9310ffc53244.png'],[],['|  |\n|  |\n| RL78/G22 |'],"{'title': 'RL78/G22: Current consumption when measuring capacitive touch', 'url': 'https://en-support.renesas.com/knowledgeBase/20982731', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:43.322021'}",Question How much current is consumed when measuring capacitive touch? Answer SNOOZE mode sequencer (SMS) and multi-electrode connection function (MEC) reduce current consumption. The average current consumption measured with a capacitive touch cycle of 100 ms is 9.7 A (reference value for the RL78/G22). Figure 1 Current consumption results(Touch measurement using SMS/MEC function) Please refer to this document for details. RL78/G22 Capacitive Touch Low Power Guide (SMS / MEC function) (R01AN6847) Suitable Products RL78/G22 Figure 1 Current consumption results(Touch measurement using SMS/MEC function)    ,
1060b2aeacfc0b9c8616c6e2db45ff35,"Question:
How does the internal touch functionality of the RL78/G22 differ from that of the RL78/G23?
Answer:
Multiple electrode connection (MEC) functionality has been added to the CTSU2La featured on the RL78/G22.
Multiple touch channels can be connected to a single channel inside the MCU, and touch detection performed.
Figure 1: The CTSU2L (without MEC) and CTSU2La (with MEC)
Using MEC has the following benefits.
The unit can return from standby mode even when any of the touch channels have been touched.
Can be used as a single large proximity (contactless) sensor.
Touch channel measurement completes with a single scan, reducing power consumption compared to scanning a single channel at a time.
Figure 2: Comparison between measurement times for the RL78/G23 (without MEC) and the RL78/G22 (when using MEC)
Suitable Products
RL78/G22
How does the internal touch functionality of the RL78/G22 differ from that of the RL78/G23?
How does the internal touch functionality of the RL78/G22 differ from that of the RL78/G23?
Answer:
Multiple electrode connection (MEC) functionality has been added to the CTSU2La featured on the RL78/G22.
Multiple touch channels can be connected to a single channel inside the MCU, and touch detection performed.
Figure 1: The CTSU2L (without MEC) and CTSU2La (with MEC)
Using MEC has the following benefits.
The unit can return from standby mode even when any of the touch channels have been touched.
Can be used as a single large proximity (contactless) sensor.
Touch channel measurement completes with a single scan, reducing power consumption compared to scanning a single channel at a time.
Figure 2: Comparison between measurement times for the RL78/G23 (without MEC) and the RL78/G22 (when using MEC)
Suitable Products
RL78/G22
Multiple electrode connection (MEC) functionality has been added to the CTSU2La featured on the RL78/G22.
Multiple touch channels can be connected to a single channel inside the MCU, and touch detection performed.
Figure 1: The CTSU2L (without MEC) and CTSU2La (with MEC)
Using MEC has the following benefits.
The unit can return from standby mode even when any of the touch channels have been touched.
Can be used as a single large proximity (contactless) sensor.
Touch channel measurement completes with a single scan, reducing power consumption compared to scanning a single channel at a time.
Figure 2: Comparison between measurement times for the RL78/G23 (without MEC) and the RL78/G22 (when using MEC)
Suitable Products
Multiple electrode connection (MEC) functionality has been added to the CTSU2La featured on the RL78/G22.
Multiple touch channels can be connected to a single channel inside the MCU, and touch detection performed.
Figure 1: The CTSU2L (without MEC) and CTSU2La (with MEC)
Using MEC has the following benefits.
Figure 2: Comparison between measurement times for the RL78/G23 (without MEC) and the RL78/G22 (when using MEC)
Suitable Products
RL78/G22
 

","['data/categories/rl78_family/rl78g22/1060b2aeacfc0b9c8616c6e2db45ff35/images/1b8fd22a17c2d1a537d0ab637d719628.png', 'data/categories/rl78_family/rl78g22/1060b2aeacfc0b9c8616c6e2db45ff35/images/3fe68907e911fbeffd7b22a77748ba54.png']",[],['|  |\n|  |\n| RL78/G22 |'],"{'title': 'Differences between the touch functionality of the RL78/G22 and RL78/G23', 'url': 'https://en-support.renesas.com/knowledgeBase/20824901', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:48.910151'}","Question How does the internal touch functionality of the RL78/G22 differ from that of the RL78/G23? Answer Multiple electrode connection (MEC) functionality has been added to the CTSU2La featured on the RL78/G22. Multiple touch channels can be connected to a single channel inside the MCU, and touch detection performed. Figure 1 The CTSU2L (without MEC) and CTSU2La (with MEC) Using MEC has the following benefits. The unit can return from standby mode even when any of the touch channels have been touched. Can be used as a single large proximity (contactless) sensor. Touch channel measurement completes with a single scan, reducing power consumption compared to scanning a single channel at a time. Figure 2 Comparison between measurement times for the RL78/G23 (without MEC) and the RL78/G22 (when using MEC) Suitable Products RL78/G22    ",
779ed323d666d0c8134a0a37e52e5d91,"Question:
When using the Serial Array Unit (SAU) to perform UART communication, how are start bit detection and data detection conducted?
Answer:
UART communication uses a start bit to determine the timing of data detection. 
  Start bit detection
To detect the start bit, the receive signal must be sampled, and the start bit detected. This sampling uses the SAU operating clock (fMCK) which generates the baud rate. There may be a delay of one cycle of the sampling clock when taking in the received signal into the SAU. If the sampling result is at a low level, it proceeds to the next step in the process.
When a low level is detected in the received signal, the counter of the baud rate generator begins operation. The detection of the start bit is performed at a position that is half the width of one bit as determined by the baud rate setting, near the center of one bit width. If the sampling result is at a low level, it is determined to be a start bit, and data detection is carried out.
The sampling result is judged as noise if it is at a high level, and the process of detection of the start bit is started again.
  Data detection
Data detection uses sampling which  is conducted at intervals of one bit each, as determined by the baud rate setting, starting from the detection point of the start bit, which is near the middle of a 1-bit width.
Remark
fCLK :     CPU/peripheral hardware clock frequency
fMCK :     Sampling clock
fTCLK :    Transfer clock used in shift register
Suitable Products
RL78 Family
When using the Serial Array Unit (SAU) to perform UART communication, how are start bit detection and data detection conducted?
When using the Serial Array Unit (SAU) to perform UART communication, how are start bit detection and data detection conducted?
Answer:
UART communication uses a start bit to determine the timing of data detection. 
  Start bit detection
To detect the start bit, the receive signal must be sampled, and the start bit detected. This sampling uses the SAU operating clock (fMCK) which generates the baud rate. There may be a delay of one cycle of the sampling clock when taking in the received signal into the SAU. If the sampling result is at a low level, it proceeds to the next step in the process.
When a low level is detected in the received signal, the counter of the baud rate generator begins operation. The detection of the start bit is performed at a position that is half the width of one bit as determined by the baud rate setting, near the center of one bit width. If the sampling result is at a low level, it is determined to be a start bit, and data detection is carried out.
The sampling result is judged as noise if it is at a high level, and the process of detection of the start bit is started again.
  Data detection
Data detection uses sampling which  is conducted at intervals of one bit each, as determined by the baud rate setting, starting from the detection point of the start bit, which is near the middle of a 1-bit width.
Remark
fCLK :     CPU/peripheral hardware clock frequency
fMCK :     Sampling clock
fTCLK :    Transfer clock used in shift register
Suitable Products
RL78 Family
UART communication uses a start bit to determine the timing of data detection. 
  Start bit detection
To detect the start bit, the receive signal must be sampled, and the start bit detected. This sampling uses the SAU operating clock (fMCK) which generates the baud rate. There may be a delay of one cycle of the sampling clock when taking in the received signal into the SAU. If the sampling result is at a low level, it proceeds to the next step in the process.
When a low level is detected in the received signal, the counter of the baud rate generator begins operation. The detection of the start bit is performed at a position that is half the width of one bit as determined by the baud rate setting, near the center of one bit width. If the sampling result is at a low level, it is determined to be a start bit, and data detection is carried out.
The sampling result is judged as noise if it is at a high level, and the process of detection of the start bit is started again.
  Data detection
Data detection uses sampling which  is conducted at intervals of one bit each, as determined by the baud rate setting, starting from the detection point of the start bit, which is near the middle of a 1-bit width.
Remark
fCLK :     CPU/peripheral hardware clock frequency
fMCK :     Sampling clock
fTCLK :    Transfer clock used in shift register
UART communication uses a start bit to determine the timing of data detection.
Start bit detection
To detect the start bit, the receive signal must be sampled, and the start bit detected. This sampling uses the SAU operating clock (fMCK) which generates the baud rate. There may be a delay of one cycle of the sampling clock when taking in the received signal into the SAU. If the sampling result is at a low level, it proceeds to the next step in the process.
When a low level is detected in the received signal, the counter of the baud rate generator begins operation. The detection of the start bit is performed at a position that is half the width of one bit as determined by the baud rate setting, near the center of one bit width. If the sampling result is at a low level, it is determined to be a start bit, and data detection is carried out.
The sampling result is judged as noise if it is at a high level, and the process of detection of the start bit is started again.
Data detection
Data detection uses sampling which  is conducted at intervals of one bit each, as determined by the baud rate setting, starting from the detection point of the start bit, which is near the middle of a 1-bit width.
Remark
fCLK :     CPU/peripheral hardware clock frequency
fMCK :     Sampling clock
fTCLK :    Transfer clock used in shift register
Suitable Products
RL78 Family

","['data/categories/rl78_family/communication_function/779ed323d666d0c8134a0a37e52e5d91/images/56f4fdda5157f926ed2ef6296aa3a952.png', 'data/categories/rl78_family/communication_function/779ed323d666d0c8134a0a37e52e5d91/images/3d232ebfcb80d615fadd3cdc4d169a11.png', 'data/categories/rl78_family/communication_function/779ed323d666d0c8134a0a37e52e5d91/images/d9362f4f7f703945cef78526fe060c61.png', 'data/categories/rl78_family/communication_function/779ed323d666d0c8134a0a37e52e5d91/images/a6802f75612c47fec22614d5280b16d2.png']",[],['|  |\n|  |\n| RL78 Family |'],"{'title': 'UART Reception Timing when using Serial Array Unit', 'url': 'https://en-support.renesas.com/knowledgeBase/21373720', 'last_updated': None, 'extracted_at': '2025-03-08T23:57:30.144946'}","Question When using the Serial Array Unit (SAU) to perform UART communication, how are start bit detection and data detection conducted? Answer UART communication uses a start bit to determine the timing of data detection. Start bit detection To detect the start bit, the receive signal must be sampled, and the start bit detected. This sampling uses the SAU operating clock (fMCK) which generates the baud rate. There may be a delay of one cycle of the sampling clock when taking in the received signal into the SAU. If the sampling result is at a low level, it proceeds to the next step in the process. When a low level is detected in the received signal, the counter of the baud rate generator begins operation. The detection of the start bit is performed at a position that is half the width of one bit as determined by the baud rate setting, near the center of one bit width. If the sampling result is at a low level, it is determined to be a start bit, and data detection is carried out. The sampling result is judged as noise if it is at a high level, and the process of detection of the start bit is started again. Data detection Data detection uses sampling which is conducted at intervals of one bit each, as determined by the baud rate setting, starting from the detection point of the start bit, which is near the middle of a 1-bit width. Remark fCLK  CPU/peripheral hardware clock frequency fMCK  Sampling clock fTCLK  Transfer clock used in shift register Suitable Products RL78 Family UART communication uses a start bit to determine the timing of data detection. Start bit detection Data detection ",
354d396c714dcc1ee28a203db036a75f,"Last updated: 01 Nov 2024
Why do I get 'Section .bss cannot be placed on the TRACERAM area' error when trying to build the project ?
The .bss area overlaps with the trace RAM area which on R7F100GxN is F4300H to F46FFH.
The trace RAM area is an area in RAM which is used for the trace function of the debugger.
You can disable the trace function and the problem should be gone. Otherwise you need to reserve this space for trace RAM only
Alternatively, you can modify the start address of .bss section on linker settings to F4700H (right after the trace RAM area ends).
Suitable Products",['data/categories/rl78_family/rl78g23/354d396c714dcc1ee28a203db036a75f/images/c096aea49792f1b9c5e24c23ed0e23cd.png'],[],"['|  |\n|  |\n| RL78/G2x, RL78/F2x |']","{'title': 'Trace RAM area error', 'url': 'https://en-support.renesas.com/knowledgeBase/21662907', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:18.968576'}","Last updated 01 Nov 2024 Why do I get 'Section .bss cannot be placed on the TRACERAM area' error when trying to build the project ? The .bss area overlaps with the trace RAM area which on R7F100GxN is F4300H to F46FFH. The trace RAM area is an area in RAM which is used for the trace function of the debugger. You can disable the trace function and the problem should be gone. Otherwise you need to reserve this space for trace RAM only Alternatively, you can modify the start address of .bss section on linker settings to F4700H (right after the trace RAM area ends). Suitable Products",
ef3b2c005ab3fb7f98bc38d5711a77d2,"Question:
What are the differences between the RL78/G23, RL78/G22, and RL78/G13?
Answer:
Differences in functions and lineups are shown in the figure below. The RL78/G23 and RL78/G22 are new generation series in the RL78 Family and utilize new development processes to achieve low power consumption. In addition, they are equipped with new functions such as capacitive touch sensors and Event Link Controllers. The RL78/G22 features many touch channels, and has the lowest power consumption of any product in the RL78 Family.
Additionally, the RL78 Family lineup has been expanded with the RL78/G23, which is offered with a large-capacity ROM package of up to 768 KB, and the RL78/G22, which is available with a minimum 16-pin package.
Figure 1: Function comparison table
Figure 2: Lineup comparison table
Suitable Products
RL78/G22, RL78/G23, RL78/G13
What are the differences between the RL78/G23, RL78/G22, and RL78/G13?
What are the differences between the RL78/G23, RL78/G22, and RL78/G13?
Answer:
Differences in functions and lineups are shown in the figure below. The RL78/G23 and RL78/G22 are new generation series in the RL78 Family and utilize new development processes to achieve low power consumption. In addition, they are equipped with new functions such as capacitive touch sensors and Event Link Controllers. The RL78/G22 features many touch channels, and has the lowest power consumption of any product in the RL78 Family.
Additionally, the RL78 Family lineup has been expanded with the RL78/G23, which is offered with a large-capacity ROM package of up to 768 KB, and the RL78/G22, which is available with a minimum 16-pin package.
Figure 1: Function comparison table
Figure 2: Lineup comparison table
Suitable Products
RL78/G22, RL78/G23, RL78/G13
Differences in functions and lineups are shown in the figure below. The RL78/G23 and RL78/G22 are new generation series in the RL78 Family and utilize new development processes to achieve low power consumption. In addition, they are equipped with new functions such as capacitive touch sensors and Event Link Controllers. The RL78/G22 features many touch channels, and has the lowest power consumption of any product in the RL78 Family.
Additionally, the RL78 Family lineup has been expanded with the RL78/G23, which is offered with a large-capacity ROM package of up to 768 KB, and the RL78/G22, which is available with a minimum 16-pin package.
Figure 1: Function comparison table
Figure 2: Lineup comparison table
Differences in functions and lineups are shown in the figure below. The RL78/G23 and RL78/G22 are new generation series in the RL78 Family and utilize new development processes to achieve low power consumption. In addition, they are equipped with new functions such as capacitive touch sensors and Event Link Controllers. The RL78/G22 features many touch channels, and has the lowest power consumption of any product in the RL78 Family.
Additionally, the RL78 Family lineup has been expanded with the RL78/G23, which is offered with a large-capacity ROM package of up to 768 KB, and the RL78/G22, which is available with a minimum 16-pin package.
Figure 1: Function comparison table
Figure 2: Lineup comparison table
Suitable Products
RL78/G22, RL78/G23, RL78/G13
 

","['data/categories/rl78_family/rl78g23/ef3b2c005ab3fb7f98bc38d5711a77d2/images/56f5968fd6a5e60c1aeccec79a8123af.png', 'data/categories/rl78_family/rl78g23/ef3b2c005ab3fb7f98bc38d5711a77d2/images/08b19e328398d685a16c3c67fe507025.png']",[],"['|  |\n|  |\n| RL78/G22, RL78/G23, RL78/G13 |']","{'title': 'Differences between the RL78/G23, RL78/G22, and RL78/G13', 'url': 'https://en-support.renesas.com/knowledgeBase/20824905', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:26.646466'}","Question What are the differences between the RL78/G23, RL78/G22, and RL78/G13? Answer Differences in functions and lineups are shown in the figure below. The RL78/G23 and RL78/G22 are new generation series in the RL78 Family and utilize new development processes to achieve low power consumption. In addition, they are equipped with new functions such as capacitive touch sensors and Event Link Controllers. The RL78/G22 features many touch channels, and has the lowest power consumption of any product in the RL78 Family. Additionally, the RL78 Family lineup has been expanded with the RL78/G23, which is offered with a large-capacity ROM package of up to 768 KB, and the RL78/G22, which is available with a minimum 16-pin package. Figure 1 Function comparison table Figure 2 Lineup comparison table Suitable Products RL78/G22, RL78/G23, RL78/G13    ",
7ff8ed6086d6386b20ac5bce6acbabe9,"Question:
How much current is consumed when measuring capacitive touch? Is there any reference information available?
Answer:
The average current consumption measured with a capacitive touch cycle of 100 ms is 15.8 A (reference value for the RL78/G23).
Figure 1: Current consumption results
Current consumption can be reduced further when using the SNOOZE Mode Sequencer (SMS).
The average current consumption measured with a capacitive touch cycle of 100 ms and using SMS is 10.8 A (reference value for the RL78/G23).
Figure 2: Current consumption results (touch measurement using SMS)
For details on measurement conditions, etc., please refer to this document.
https://www.renesas.com/document/apn/rl78g23-group-rl78g23-capacitive-touch-low-power-guide-sms-function-rev100?r=1496636
Suitable Products
RL78/G23
How much current is consumed when measuring capacitive touch? Is there any reference information available?
How much current is consumed when measuring capacitive touch? Is there any reference information available?
Answer:
The average current consumption measured with a capacitive touch cycle of 100 ms is 15.8 A (reference value for the RL78/G23).
Figure 1: Current consumption results
Current consumption can be reduced further when using the SNOOZE Mode Sequencer (SMS).
The average current consumption measured with a capacitive touch cycle of 100 ms and using SMS is 10.8 A (reference value for the RL78/G23).
Figure 2: Current consumption results (touch measurement using SMS)
For details on measurement conditions, etc., please refer to this document.
https://www.renesas.com/document/apn/rl78g23-group-rl78g23-capacitive-touch-low-power-guide-sms-function-rev100?r=1496636
Suitable Products
RL78/G23
The average current consumption measured with a capacitive touch cycle of 100 ms is 15.8 A (reference value for the RL78/G23).
Figure 1: Current consumption results
Current consumption can be reduced further when using the SNOOZE Mode Sequencer (SMS).
The average current consumption measured with a capacitive touch cycle of 100 ms and using SMS is 10.8 A (reference value for the RL78/G23).
Figure 2: Current consumption results (touch measurement using SMS)
For details on measurement conditions, etc., please refer to this document.
https://www.renesas.com/document/apn/rl78g23-group-rl78g23-capacitive-touch-low-power-guide-sms-function-rev100?r=1496636
Suitable Products
The average current consumption measured with a capacitive touch cycle of 100 ms is 15.8 A (reference value for the RL78/G23).
Figure 1: Current consumption results
Current consumption can be reduced further when using the SNOOZE Mode Sequencer (SMS).
The average current consumption measured with a capacitive touch cycle of 100 ms and using SMS is 10.8 A (reference value for the RL78/G23).
Figure 2: Current consumption results (touch measurement using SMS)
For details on measurement conditions, etc., please refer to this document.
https://www.renesas.com/document/apn/rl78g23-group-rl78g23-capacitive-touch-low-power-guide-sms-function-rev100?r=1496636
Suitable Products
RL78/G23
 

","['data/categories/rl78_family/rl78g23/7ff8ed6086d6386b20ac5bce6acbabe9/images/d1c1623c64cc65ed0adcf0bf6fd93eb1.png', 'data/categories/rl78_family/rl78g23/7ff8ed6086d6386b20ac5bce6acbabe9/images/9c7d202b0fd04b654c8f8fc9cfd484d8.png']",[],['|  |\n|  |\n| RL78/G23 |'],"{'title': 'RL78/G23: Current consumption when measuring capacitive touch', 'url': 'https://en-support.renesas.com/knowledgeBase/20824903', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:10.929337'}","Question How much current is consumed when measuring capacitive touch? Is there any reference information available? Answer The average current consumption measured with a capacitive touch cycle of 100 ms is 15.8 A (reference value for the RL78/G23). Figure 1 Current consumption results Current consumption can be reduced further when using the SNOOZE Mode Sequencer (SMS). The average current consumption measured with a capacitive touch cycle of 100 ms and using SMS is 10.8 A (reference value for the RL78/G23). Figure 2 Current consumption results (touch measurement using SMS) For details on measurement conditions, etc., please refer to this document. https//www.renesas.com/document/apn/rl78g23-group-rl78g23-capacitive-touch-low-power-guide-sms-function-rev100?r1496636 Suitable Products RL78/G23    ",
03331522dd20eff998b20d765a566138,"Question:
How to create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices ?
  Answer:
How to create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices ?
How to create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices ?
Answer:
To create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices, do the following steps:
1) Add the r_rfd_rl78_t01_dataflash and r_rfd_rl78_t01_common components on the Smart Configurator:
2) Set the following option to enable the data flash access:
3) Add the following sections in ROM and RAM memory which will be used by the Renesas Flash Driver RL78 Type 01.
4) Add the following -rom option for RFD_DATA_n section which will be copied into RAM.
5) Refer to the attached project for RL78/G23 FPB 64-pin board on how to add code to initialize the flash library and perform the basic data flash operations (blank check/erase/write).
You can find all information for the Renesas Flash Driver RL78 Type 01 User's Manual for RL78/G2x on the user's manual:
https://www.renesas.com/en/document/man/renesas-flash-driver-rl78-type-01-users-manual-rl78g23
Suitable Products
RL78/G23
RL78/G23","['data/categories/rl78_family/rl78g23/03331522dd20eff998b20d765a566138/images/4db65c38cf33c645f83de180a80b6f68.png', 'data/categories/rl78_family/rl78g23/03331522dd20eff998b20d765a566138/images/b681e3b990a3229d9da87b1e55c3e3ad.png', 'data/categories/rl78_family/rl78g23/03331522dd20eff998b20d765a566138/images/3494f51a5c7fb14e874b6f956a4af8f7.png', 'data/categories/rl78_family/rl78g23/03331522dd20eff998b20d765a566138/images/0f07395cc8db5f719f760ab76668e528.png']",[],[],"{'title': 'How to create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21757166', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:16.252267'}","Question How to create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices ? Answer Answer To create a project from scratch to use the Renesas Flash Driver RL78 Type 01 on RL78/G2x devices, do the following steps 1) Add the rrfdrl78t01dataflash and rrfdrl78t01common components on the Smart Configurator 2) Set the following option to enable the data flash access 3) Add the following sections in ROM and RAM memory which will be used by the Renesas Flash Driver RL78 Type 01. 4) Add the following -rom option for RFDDATAn section which will be copied into RAM. 5) Refer to the attached project for RL78/G23 FPB 64-pin board on how to add code to initialize the flash library and perform the basic data flash operations (blank check/erase/write). You can find all information for the Renesas Flash Driver RL78 Type 01 User's Manual for RL78/G2x on the user's manual https//www.renesas.com/en/document/man/renesas-flash-driver-rl78-type-01-users-manual-rl78g23 Suitable Products RL78/G23",
96412b0e4b5dfee9d8c0b8096b03c211,"Question:
How to enable real time refresh of variables during debugging with RL78/G15
Answer:
To enable real time refresh of variables, it is required to enable the Pseudo-RRM/DMM function setting and to allocate 4 bytes of memory in RAM.
Pre-requisite of IDE and compiler for RL78/G15
IDE:
e2studio: 2023-01 (23.1.0) or later
CS+: CC V8.09.00 or later.

Compiler:
CC-RL V1.12.00 or later.
Configuration setting for pseudo-RRM/DMM function and allocation of 4 bytes of memory in RAM -
Using e2studio:
Enable the Real-time Refresh on specified variable.


Select Pseudo-RRM/DMM function setting.


Provide the address for 4 bytes of RAM memory required for the RRM/DMM function.


Using CS+:
Enable Access by stopping execution option in the Debug Tool Settings.


Enable Set debug monitor area, Reserve working memory for RRM/DMM function and Start address of working memory for RRM/DMM function.


Note: Allocate the 4 bytes memory on top of RAM to allow maximum RAM available to the user application.
Suitable Products
RL78/G15
How to enable real time refresh of variables during debugging with RL78/G15
Answer:
To enable real time refresh of variables, it is required to enable the Pseudo-RRM/DMM function setting and to allocate 4 bytes of memory in RAM.
Pre-requisite of IDE and compiler for RL78/G15
IDE:
e2studio: 2023-01 (23.1.0) or later
CS+: CC V8.09.00 or later.

Compiler:
CC-RL V1.12.00 or later.
Configuration setting for pseudo-RRM/DMM function and allocation of 4 bytes of memory in RAM -
Using e2studio:
Enable the Real-time Refresh on specified variable.


Select Pseudo-RRM/DMM function setting.


Provide the address for 4 bytes of RAM memory required for the RRM/DMM function.


Using CS+:
Enable Access by stopping execution option in the Debug Tool Settings.


Enable Set debug monitor area, Reserve working memory for RRM/DMM function and Start address of working memory for RRM/DMM function.


Note: Allocate the 4 bytes memory on top of RAM to allow maximum RAM available to the user application.
Suitable Products
RL78/G15
To enable real time refresh of variables, it is required to enable the Pseudo-RRM/DMM function setting and to allocate 4 bytes of memory in RAM.
Pre-requisite of IDE and compiler for RL78/G15
Configuration setting for pseudo-RRM/DMM function and allocation of 4 bytes of memory in RAM -
Note: Allocate the 4 bytes memory on top of RAM to allow maximum RAM available to the user application.
Suitable Products
RL78/G15","['data/categories/rl78_family/rl78g15/96412b0e4b5dfee9d8c0b8096b03c211/images/fa8ae2c72a11f0ec5b08f14f2e906934.png', 'data/categories/rl78_family/rl78g15/96412b0e4b5dfee9d8c0b8096b03c211/images/b544d48adf95d4160b12d6a066e08974.png', 'data/categories/rl78_family/rl78g15/96412b0e4b5dfee9d8c0b8096b03c211/images/edf2b5ed67775f78e4a4af06a5b273da.png', 'data/categories/rl78_family/rl78g15/96412b0e4b5dfee9d8c0b8096b03c211/images/54f4969681c7ba3cf2fc498aa088b53b.png', 'data/categories/rl78_family/rl78g15/96412b0e4b5dfee9d8c0b8096b03c211/images/b52c4928746de361cc48e5dfeffc5279.png']",[],['|  |\n|  |\n| RL78/G15 |'],"{'title': 'How to enable real time refresh of variables during debugging with RL78/G15', 'url': 'https://en-support.renesas.com/knowledgeBase/21056458', 'last_updated': None, 'extracted_at': '2025-03-08T23:54:09.332088'}","Question How to enable real time refresh of variables during debugging with RL78/G15 Answer To enable real time refresh of variables, it is required to enable the Pseudo-RRM/DMM function setting and to allocate 4 bytes of memory in RAM. Pre-requisite of IDE and compiler for RL78/G15 IDE e2studio 2023-01 (23.1.0) or later CS CC V8.09.00 or later. Compiler CC-RL V1.12.00 or later. Configuration setting for pseudo-RRM/DMM function and allocation of 4 bytes of memory in RAM - Using e2studio Enable the Real-time Refresh on specified variable. Select Pseudo-RRM/DMM function setting. Provide the address for 4 bytes of RAM memory required for the RRM/DMM function. Using CS Enable Access by stopping execution option in the Debug Tool Settings. Enable Set debug monitor area, Reserve working memory for RRM/DMM function and Start address of working memory for RRM/DMM function. Note Allocate the 4 bytes memory on top of RAM to allow maximum RAM available to the user application. Suitable Products RL78/G15",
f640e0c1852d1e90ce56c400fc4f1d44,"Last updated: 10/10/2023
How to setup a FDL T04 project on a RL78/x1x device ?
The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on: 
https://www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120 
  This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided. 
  Download Data Flash Library T04 for RL78 family from: https://www.renesas.com/us/en/software-tool/data-flash-libraries 
    Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL): 
        Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section: 
      Import the library files into the project. The project should now have the following files: 
pfdl_types.h  
pfdl.h  
pfdl.inc 
pfdl.lib 
    Go to Linker -> Settings and open the Section Viewer after disabling the automatic section layout: 
  On e2studio: 
    On CS+: 
    If the section PFDL_COD does not already exist as a section already, create a new section with this name: 
  PFDL_COD contains the code of data flash library functions. It can be placed to ROM or RAM. 
    Import the pfdl.lib library file that already exists in the project folder from linkers input settings: 
On e2studio: 
          On CS+: 
        The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker. 
  Locate your device in self-RAM list document: 
https://www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305 
  If your device has no dedicated area for FDL T04 library (for example R5F100xA), no action is required, and you can proceed to the next step. 
  If your device requires a dedicated area to be allocated (for example R5F100xE), you need to make sure no other data is placed in this area. There are 2 ways to do this:  
  Go to Linker -> Device and select the self-RAM area option. 
  On e2studio: 
    On CS+: 
    This option will reserve the needed self-RAM area, but it will by default allocate the maximum self-RAM area of all flash libraries which is 1Kbytes (FSL T01 self-RAM size). 
  To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to None. 
On e2studio: 
        On CS+: 
      Next, add these lines in your source code: 
  #pragma address self_ram_area = <starting address of self-RAM area for FDL T04> 
volatile char self_ram_area[136] 
  For example, for R5F100xE device: 
  #pragma address self_ram_area = 0xFEF00  
volatile char self_ram_area[136] 
      In the attached example project all 5 data flash library commands are implemented. The example project is targeted for a device with dedicated self-RAM area.
Open -> Erase -> Blank check -> Write -> Internal verification -> Read -> Close
The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on: 
https://www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120 
  This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided. 
  Download Data Flash Library T04 for RL78 family from: https://www.renesas.com/us/en/software-tool/data-flash-libraries
The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on:
The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on:
https://www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120
https://www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120
This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided.
This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided.
Download Data Flash Library T04 for RL78 family from: https://www.renesas.com/us/en/software-tool/data-flash-libraries
Download Data Flash Library T04 for RL78 family from: https://www.renesas.com/us/en/software-tool/data-flash-libraries
Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL):
Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL):
Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL):
Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section: 
      Import the library files into the project. The project should now have the following files: 
pfdl_types.h  
pfdl.h
Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section:
Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section:
Import the library files into the project. The project should now have the following files:
Import the library files into the project. The project should now have the following files:
pfdl_types.h
pfdl_types.h
pfdl.h
pfdl.h
pfdl.inc 
pfdl.lib 
    Go to Linker -> Settings and open the Section Viewer after disabling the automatic section layout:
pfdl.inc
pfdl.inc
pfdl.lib
pfdl.lib
Go to Linker -> Settings and open the Section Viewer after disabling the automatic section layout:
Go to Linker -> Settings and open the Section Viewer after disabling the automatic section layout:
On e2studio:
On e2studio:
On CS+:
On CS+:
If the section PFDL_COD does not already exist as a section already, create a new section with this name:
If the section PFDL_COD does not already exist as a section already, create a new section with this name:
PFDL_COD contains the code of data flash library functions. It can be placed to ROM or RAM.
PFDL_COD contains the code of data flash library functions. It can be placed to ROM or RAM.
Import the pfdl.lib library file that already exists in the project folder from linkers input settings: 
On e2studio:
Import the pfdl.lib library file that already exists in the project folder from linkers input settings:
Import the pfdl.lib library file that already exists in the project folder from linkers input settings:
On e2studio:
On e2studio:
On CS+:
On CS+:
The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker. 
  Locate your device in self-RAM list document: 
https://www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305
The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker.
The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker.
Locate your device in self-RAM list document:
Locate your device in self-RAM list document:
https://www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305
https://www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305
If your device has no dedicated area for FDL T04 library (for example R5F100xA), no action is required, and you can proceed to the next step.
If your device has no dedicated area for FDL T04 library (for example R5F100xA), no action is required, and you can proceed to the next step.
If your device requires a dedicated area to be allocated (for example R5F100xE), you need to make sure no other data is placed in this area. There are 2 ways to do this:
If your device requires a dedicated area to be allocated (for example R5F100xE), you need to make sure no other data is placed in this area. There are 2 ways to do this:
Go to Linker -> Device and select the self-RAM area option. 
  On e2studio:
Go to Linker -> Device and select the self-RAM area option.
Go to Linker -> Device and select the self-RAM area option.
On e2studio:
On e2studio:
On CS+:
On CS+:
This option will reserve the needed self-RAM area, but it will by default allocate the maximum self-RAM area of all flash libraries which is 1Kbytes (FSL T01 self-RAM size).
This option will reserve the needed self-RAM area, but it will by default allocate the maximum self-RAM area of all flash libraries which is 1Kbytes (FSL T01 self-RAM size).
To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to None. 
On e2studio:
To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to None.
To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to None.
On e2studio:
On e2studio:
On CS+:
On CS+:
Next, add these lines in your source code:
Next, add these lines in your source code:
#pragma address self_ram_area = <starting address of self-RAM area for FDL T04> 
volatile char self_ram_area[136]
#pragma address self_ram_area = <starting address of self-RAM area for FDL T04> 
volatile char self_ram_area[136]
For example, for R5F100xE device:
For example, for R5F100xE device:
#pragma address self_ram_area = 0xFEF00  
volatile char self_ram_area[136]
#pragma address self_ram_area = 0xFEF00  
volatile char self_ram_area[136]
In the attached example project all 5 data flash library commands are implemented. The example project is targeted for a device with dedicated self-RAM area.
In the attached example project all 5 data flash library commands are implemented. The example project is targeted for a device with dedicated self-RAM area.
Open -> Erase -> Blank check -> Write -> Internal verification -> Read -> Close
Open -> Erase -> Blank check -> Write -> Internal verification -> Read -> Close","['data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/d6931ddceac57defd1f2f6074f115784.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/3c5a851ab4989520d023c4ccdb6c0881.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/008468b2d7a09dd842259ef244135988.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/9b7ce4c34545f10a1f8a7f53e176c454.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/8fa4a41ef08f4b333df6de4c0d51ceab.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/0cbcef07d871a63b8fa31f916836208a.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/5a03c6e97ece70e4374467d52847a7ac.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/35c0277498d1c446d9e46bc79f62482a.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/b8baf077a35a3fcf56c9cf883042aff2.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/c2068acb584a81fec2bf953627d74af1.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/8e6c5b485d1cf029a9c2655d881cfc9e.png', 'data/categories/rl78_family/memory/f640e0c1852d1e90ce56c400fc4f1d44/images/6ad7d654f237aff173f34da69368081d.png']",[],[],"{'title': 'How to setup a FDL T04 project on a RL78/x1x device ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21092507', 'last_updated': None, 'extracted_at': '2025-03-08T23:59:53.261431'}","Last updated 10/10/2023 How to setup a FDL T04 project on a RL78/x1x device ? The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on https//www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120 This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided. Download Data Flash Library T04 for RL78 family from https//www.renesas.com/us/en/software-tool/data-flash-libraries Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL) Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section Import the library files into the project. The project should now have the following files pfdltypes.h pfdl.h pfdl.inc pfdl.lib Go to Linker - Settings and open the Section Viewer after disabling the automatic section layout On e2studio On CS If the section PFDLCOD does not already exist as a section already, create a new section with this name PFDLCOD contains the code of data flash library functions. It can be placed to ROM or RAM. Import the pfdl.lib library file that already exists in the project folder from linkers input settings On e2studio On CS The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker. Locate your device in self-RAM list document https//www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305 If your device has no dedicated area for FDL T04 library (for example R5F100xA), no action is required, and you can proceed to the next step. If your device requires a dedicated area to be allocated (for example R5F100xE), you need to make sure no other data is placed in this area. There are 2 ways to do this Go to Linker - Device and select the self-RAM area option. This option will reserve the needed self-RAM area, but it will by default allocate the maximum self-RAM area of all flash libraries which is 1Kbytes (FSL T01 self-RAM size). To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to None. On CS Next, add these lines in your source code pragma address selframarea  starting address of self-RAM area for FDL T04 volatile char selframarea136 For example, for R5F100xE device pragma address selframarea  0xFEF00 In the attached example project all 5 data flash library commands are implemented. The example project is targeted for a device with dedicated self-RAM area. Open - Erase - Blank check - Write - Internal verification - Read - Close Download Data Flash Library T04 for RL78 family from https//www.renesas.com/us/en/software-tool/data-flash-libraries The Data Flash Library T04 is a software library to perform operations on the data flash memory of the RL78 microcontroller. All information about the FDL T04 library can be found on https//www.renesas.com/us/en/document/mat/data-flash-access-library-type-t04-pico-european-release-rev120 This guide walks the user through all the necessary steps to set up an RL78 project to access data flash using FDL T04 library. The example code for implementation of all available data flash operations is also provided. Download Data Flash Library T04 for RL78 family from https//www.renesas.com/us/en/software-tool/data-flash-libraries Unzip the .zip file and install the library files. During installation process select your compiler (for example CC-RL) Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section pfdl.h Create a new project for your RL78 device and set the following settings on Code Generator under Clock Generator section Import the library files into the project. The project should now have the following files pfdltypes.h Go to Linker - Settings and open the Section Viewer after disabling the automatic section layout pfdl.inc pfdl.lib Go to Linker - Settings and open the Section Viewer after disabling the automatic section layout On e2studio On CS If the section PFDLCOD does not already exist as a section already, create a new section with this name PFDLCOD contains the code of data flash library functions. It can be placed to ROM or RAM. Import the pfdl.lib library file that already exists in the project folder from linkers input settings Import the pfdl.lib library file that already exists in the project folder from linkers input settings The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker. https//www.renesas.com/us/en/document/mat/rl78-family-self-ram-list-flash-self-programming-library-rev305 The data flash library requires some space in RAM which is called self-RAM area. Depending on the device this area can be either in a specific address range or placed anywhere by the linker. Locate your device in self-RAM list document If your device has no dedicated area for FDL T04 library (for example R5F100xA), no action is required, and you can proceed to the next step. If your device requires a dedicated area to be allocated (for example R5F100xE), you need to make sure no other data is placed in this area. There are 2 ways to do this Go to Linker - Device and select the self-RAM area option. On e2studio Go to Linker - Device and select the self-RAM area option. This option will reserve the needed self-RAM area, but it will by default allocate the maximum self-RAM area of all flash libraries which is 1Kbytes (FSL T01 self-RAM size). To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to None. To allocate only the 136 bytes which are needed by FDL T04, the self-RAM area option should be set to None. Next, add these lines in your source code pragma address selframarea  starting address of self-RAM area for FDL T04 volatile char selframarea136 For example, for R5F100xE device pragma address selframarea  0xFEF00 In the attached example project all 5 data flash library commands are implemented. The example project is targeted for a device with dedicated self-RAM area.",
9fdab48172f9db4b11a4bd41ad5838e4,"Last updated: 19/07/2024
How to initialize RAM to avoid RAM parity errors  ?
During startup some parts of RAM (.bss, .dataR , stack sections) are initialized but others do not. As a result there are uninitialized parts in RAM that can cause RAM parity errors.
To avoid these errors, RAM must be initialized manually during initialization. To do this, the cstart.asm file should be modified as per the following example:
The RAM start address and size are according to below address range so please modify according to your device.","['data/categories/rl78_family/memory/9fdab48172f9db4b11a4bd41ad5838e4/images/13627864c40b6c1d0d1209898dd2cfba.png', 'data/categories/rl78_family/memory/9fdab48172f9db4b11a4bd41ad5838e4/images/3b710b79de43fabc87a0fa2e89451b59.png']",[],[],"{'title': '[RL78] How to initialize RAM to avoid RAM parity errors ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21483964', 'last_updated': None, 'extracted_at': '2025-03-09T00:00:00.766864'}","Last updated 19/07/2024 How to initialize RAM to avoid RAM parity errors ? During startup some parts of RAM (.bss, .dataR , stack sections) are initialized but others do not. As a result there are uninitialized parts in RAM that can cause RAM parity errors. To avoid these errors, RAM must be initialized manually during initialization. To do this, the cstart.asm file should be modified as per the following example The RAM start address and size are according to below address range so please modify according to your device.",
ba1d37fb897f8aab88b9201ad7cf4b25,"Last updated: 18/01/2024
How can I read the flash contents of a RL78 device ?
The RL78 programming interface does not permit reading flash memory at all.
The RL78 debugging interface does under the following conditions:
1. The debugging is enabled on the device.
2. The debug monitor area (small piece of code installed to the flash memory downloaded when debugging the device) is installed on the device.
3. Both points above are not typical of released devices - only the user can answer whether they have devices in this state.
4. The user will need to ensure they have matching security ID's (if the user has changed it at all, again he will need to know this in advance).
The above points can be summarized with the question: With the binary the device was flashed with, was debugging enabled?
If it was, the subsequent information is relevant.. If it was not, there is no retrieving program data without corruption of flash.
Assuming debugging was enabled on the binary the following can be done:
1. Create an empty project for a device which they would like to communicate.
2. Disable flash erase in the debug tool settings.
3.Then also uncheck the program binary in ""Load image and symbols"":
4. Then launch a debug session connecting to your device.
5. You will be presented with something like this i.e., no source or symbols (because you have no program data or symbols):
6.From here you can use the memory view:
7. Then use the ""export tool"" (circled in red in top right of first image below) to export the entire flash memory range for your device (I am using the rl78/g22 (R7F102GxE) with 64k code flash as an example):
This will output the program binary in S3 SREC format, fixed 32bit width for the entire code flash - but again please specify the code flash memory range for your device.
If you do not have debugging enabled on the device already, the only way to connect to the device would be the corrupt the code flash by re-writing it with debugging code, which will make the output useless.
This is the best we can do - but it's worth noting that if the device is in the right state for connection and the result is to get the binary output  this won't give any code symbols, it's just post-compilation binary data, with which the user will not be able to reverse compile the project to get the code back.","['data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/03f040f6bfef2e5b153ea94d113980e9.png', 'data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/c08c7f283e01c4b5806a6eddb61e8550.png', 'data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/bc0b20170dcf6248c5fbc47517743868.png', 'data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/53810cec90a6abaedc8b88f973d62b9e.png', 'data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/573b90bfd5e4297d2127e7a69c466133.png', 'data/categories/rl78_family/memory/ba1d37fb897f8aab88b9201ad7cf4b25/images/ff4e7ed59a434105231ea05a9aac3fa4.png']",[],[],"{'title': 'How can I read the flash contents of a RL78 device ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21204937', 'last_updated': None, 'extracted_at': '2025-03-08T23:59:57.857640'}","Last updated 18/01/2024 How can I read the flash contents of a RL78 device ? The RL78 programming interface does not permit reading flash memory at all. The RL78 debugging interface does under the following conditions 1. The debugging is enabled on the device. 2. The debug monitor area (small piece of code installed to the flash memory downloaded when debugging the device) is installed on the device. 3. Both points above are not typical of released devices - only the user can answer whether they have devices in this state. 4. The user will need to ensure they have matching security ID's (if the user has changed it at all, again he will need to know this in advance). The above points can be summarized with the question With the binary the device was flashed with, was debugging enabled? If it was, the subsequent information is relevant.. If it was not, there is no retrieving program data without corruption of flash. Assuming debugging was enabled on the binary the following can be done 1. Create an empty project for a device which they would like to communicate. 2. Disable flash erase in the debug tool settings. 3.Then also uncheck the program binary in ""Load image and symbols"" 4. Then launch a debug session connecting to your device. 5. You will be presented with something like this i.e., no source or symbols (because you have no program data or symbols) 6.From here you can use the memory view 7. Then use the ""export tool"" (circled in red in top right of first image below) to export the entire flash memory range for your device (I am using the rl78/g22 (R7F102GxE) with 64k code flash as an example) This will output the program binary in S3 SREC format, fixed 32bit width for the entire code flash - but again please specify the code flash memory range for your device. If you do not have debugging enabled on the device already, the only way to connect to the device would be the corrupt the code flash by re-writing it with debugging code, which will make the output useless. This is the best we can do - but it's worth noting that if the device is in the right state for connection and the result is to get the binary output  this won't give any code symbols, it's just post-compilation binary data, with which the user will not be able to reverse compile the project to get the code back.",
e68d4fcf20d6e7d5f0002ab23d3bd1bc,"Last updated: 17 Oct 2024
How can I issue a software reset on a RL78 device ?
Most RL78 devices do not have a software reset as reset source. The reset sources are usually as following:
The user can take advantage of the internal reset due to execution of illegal instruction and use it as 'software' reset.
This is what R_RFD_ForceReset function of the code flash programming library also does:
For example the .DB 255 command on CC-RL will reset the device due to illegal instruction but it can be used as a forced software reset too.
Note: The illegal instruction is generated when instruction code FFH is executed.
Reset by the illegal instruction execution not issued by emulation with the in-circuit emulator or on-chip debug emulator.
Suitable Products","['data/categories/rl78_family/reset/e68d4fcf20d6e7d5f0002ab23d3bd1bc/images/85abc75a10d450c71021c9a8b8eb6ac2.png', 'data/categories/rl78_family/reset/e68d4fcf20d6e7d5f0002ab23d3bd1bc/images/f8235e0cc36bb2b99c79bbd1bf502875.png']",[],['|  |\n|  |\n| RL78 |'],"{'title': '[RL78] How can I issue a software reset on a RL78 device ?', 'url': 'https://en-support.renesas.com/knowledgeBase/21633589', 'last_updated': None, 'extracted_at': '2025-03-09T00:00:43.339593'}",Last updated 17 Oct 2024 How can I issue a software reset on a RL78 device ? Most RL78 devices do not have a software reset as reset source. The reset sources are usually as following The user can take advantage of the internal reset due to execution of illegal instruction and use it as 'software' reset. This is what RRFDForceReset function of the code flash programming library also does For example the .DB 255 command on CC-RL will reset the device due to illegal instruction but it can be used as a forced software reset too. Note The illegal instruction is generated when instruction code FFH is executed. Reset by the illegal instruction execution not issued by emulation with the in-circuit emulator or on-chip debug emulator. Suitable Products,
77f89a4d1ced35ba59e117d120fe08a8,"Question:
Please tell me the points to be aware of when using the RL78 Code Generator with the WDT.
Answer:
In the RL78 Code Generator, the Watchdog Timer (WDT) is set to 'Enabled' by default, as shown in the diagram below. To avoid unintended resets by the WDT, please either select 'Disabled' for the 'Watchdog Timer Operation Setting' or add a program to clear the Watchdog Timer counter.
Suitable Products
RL78/D1A, RL78/F12, RL78/F13, RL78/F14, RL78/F15, RL78/G10, RL78/G11, RL78/G12, RL78/G13, RL78/G13A, RL78/G14, RL78/G1A, RL78/G1C, RL78/G1D, RL78/G1E, RL78/G1F, RL78/G1G, RL78/G1H, RL78/H1D, RL78/I1A, RL78/I1B, RL78/I1C, RL78/I1D, RL78/I1E, RL78/L12, RL78/L13, RL78/L1A, RL78/L1C
Please tell me the points to be aware of when using the RL78 Code Generator with the WDT.
Please tell me the points to be aware of when using the RL78 Code Generator with the WDT.
Answer:
In the RL78 Code Generator, the Watchdog Timer (WDT) is set to 'Enabled' by default, as shown in the diagram below. To avoid unintended resets by the WDT, please either select 'Disabled' for the 'Watchdog Timer Operation Setting' or add a program to clear the Watchdog Timer counter.
Suitable Products
RL78/D1A, RL78/F12, RL78/F13, RL78/F14, RL78/F15, RL78/G10, RL78/G11, RL78/G12, RL78/G13, RL78/G13A, RL78/G14, RL78/G1A, RL78/G1C, RL78/G1D, RL78/G1E, RL78/G1F, RL78/G1G, RL78/G1H, RL78/H1D, RL78/I1A, RL78/I1B, RL78/I1C, RL78/I1D, RL78/I1E, RL78/L12, RL78/L13, RL78/L1A, RL78/L1C
In the RL78 Code Generator, the Watchdog Timer (WDT) is set to 'Enabled' by default, as shown in the diagram below. To avoid unintended resets by the WDT, please either select 'Disabled' for the 'Watchdog Timer Operation Setting' or add a program to clear the Watchdog Timer counter.
In the RL78 Code Generator, the Watchdog Timer (WDT) is set to 'Enabled' by default, as shown in the diagram below. To avoid unintended resets by the WDT, please either select 'Disabled' for the 'Watchdog Timer Operation Setting' or add a program to clear the Watchdog Timer counter.
Suitable Products
RL78/D1A, RL78/F12, RL78/F13, RL78/F14, RL78/F15, RL78/G10, RL78/G11, RL78/G12, RL78/G13, RL78/G13A, RL78/G14, RL78/G1A, RL78/G1C, RL78/G1D, RL78/G1E, RL78/G1F, RL78/G1G, RL78/G1H, RL78/H1D, RL78/I1A, RL78/I1B, RL78/I1C, RL78/I1D, RL78/I1E, RL78/L12, RL78/L13, RL78/L1A, RL78/L1C

",['data/categories/rl78_family/others/77f89a4d1ced35ba59e117d120fe08a8/images/215e8b1e35b939dad9757ca246bd5d18.png'],[],"['|  |\n|  |\n| RL78/D1A, RL78/F12, RL78/F13, RL78/F14, RL78/F15, RL78/G10, RL78/G11, RL78/G12, RL78/G13, RL78/G13A, RL78/G14, RL78/G1A, RL78/G1C, RL78/G1D, RL78/G1E, RL78/G1F, RL78/G1G, RL78/G1H, RL78/H1D, RL78/I1A, RL78/I1B, RL78/I1C, RL78/I1D, RL78/I1E, RL78/L12, RL78/L13, RL78/L1A, RL78/L1C |']","{'title': 'Tell me the points to be aware of when using the RL78 Code Generator with the WDT.', 'url': 'https://en-support.renesas.com/knowledgeBase/21715566', 'last_updated': '2024-10-12', 'extracted_at': '2025-03-09T00:01:25.089871'}","Question Please tell me the points to be aware of when using the RL78 Code Generator with the WDT. Answer In the RL78 Code Generator, the Watchdog Timer (WDT) is set to 'Enabled' by default, as shown in the diagram below. To avoid unintended resets by the WDT, please either select 'Disabled' for the 'Watchdog Timer Operation Setting' or add a program to clear the Watchdog Timer counter. Suitable Products RL78/D1A, RL78/F12, RL78/F13, RL78/F14, RL78/F15, RL78/G10, RL78/G11, RL78/G12, RL78/G13, RL78/G13A, RL78/G14, RL78/G1A, RL78/G1C, RL78/G1D, RL78/G1E, RL78/G1F, RL78/G1G, RL78/G1H, RL78/H1D, RL78/I1A, RL78/I1B, RL78/I1C, RL78/I1D, RL78/I1E, RL78/L12, RL78/L13, RL78/L1A, RL78/L1C ",
5730b1afab0205f7a297ca241eae09f1,"Question:
What are the concerns with inserting a resistor between the REGC pin and the capacitor?
Answer:
The voltage applied to the REGC pin is crucial for the internal circuits of RL78 products. 
We would like to inform you that inserting a resistor between the REGC pin and the capacitor can cause the voltage supplied to the internal circuit of the RL78 product to become unstable, potentially impacting the device's performance. Therefore, we do not recommend inserting a resistor for stable operation of RL78 products.
However, if you require resistor insertion for some reason, please ensure that the following criteria are met and assess whether resistor insertion is acceptable or not.
Select a resistor with a resistance value of 50  or less, and as small a value as possible.
Voltage fluctuations on the REGC pin should always be within  0.1 V.
Caution:
The voltage applied to the REGC pin (regulator output voltage) varies depending on the RL78 microcontroller and flash operation mode.
For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
RL78/G13
LS (Low-speed main) mode, LV (Low-voltage main) mode: 1.8V
HS (high speed main) mode: 2.1V
RL78/G23
1.5V
Remark:
To prevent noise from affecting the internal circuits of RL78 products through the capacitor connected to the REGC pin, it is recommended to strengthen the power supply by adding bypass capacitors near the device. 
If noise is applied to the GND side, it may be transmitted to the internal circuits, so taking these measures can be effective in reducing its impact.
Suitable Products
RL78 Family
What are the concerns with inserting a resistor between the REGC pin and the capacitor?
What are the concerns with inserting a resistor between the REGC pin and the capacitor?
Answer:
The voltage applied to the REGC pin is crucial for the internal circuits of RL78 products. 
We would like to inform you that inserting a resistor between the REGC pin and the capacitor can cause the voltage supplied to the internal circuit of the RL78 product to become unstable, potentially impacting the device's performance. Therefore, we do not recommend inserting a resistor for stable operation of RL78 products.
However, if you require resistor insertion for some reason, please ensure that the following criteria are met and assess whether resistor insertion is acceptable or not.
Select a resistor with a resistance value of 50  or less, and as small a value as possible.
Voltage fluctuations on the REGC pin should always be within  0.1 V.
Caution:
The voltage applied to the REGC pin (regulator output voltage) varies depending on the RL78 microcontroller and flash operation mode.
For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
RL78/G13
LS (Low-speed main) mode, LV (Low-voltage main) mode: 1.8V
HS (high speed main) mode: 2.1V
RL78/G23
1.5V
Remark:
To prevent noise from affecting the internal circuits of RL78 products through the capacitor connected to the REGC pin, it is recommended to strengthen the power supply by adding bypass capacitors near the device. 
If noise is applied to the GND side, it may be transmitted to the internal circuits, so taking these measures can be effective in reducing its impact.
Suitable Products
RL78 Family
The voltage applied to the REGC pin is crucial for the internal circuits of RL78 products. 
We would like to inform you that inserting a resistor between the REGC pin and the capacitor can cause the voltage supplied to the internal circuit of the RL78 product to become unstable, potentially impacting the device's performance. Therefore, we do not recommend inserting a resistor for stable operation of RL78 products.
However, if you require resistor insertion for some reason, please ensure that the following criteria are met and assess whether resistor insertion is acceptable or not.
Select a resistor with a resistance value of 50  or less, and as small a value as possible.
Voltage fluctuations on the REGC pin should always be within  0.1 V.
Caution:
The voltage applied to the REGC pin (regulator output voltage) varies depending on the RL78 microcontroller and flash operation mode.
For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
RL78/G13
LS (Low-speed main) mode, LV (Low-voltage main) mode: 1.8V
HS (high speed main) mode: 2.1V
RL78/G23
1.5V
Remark:
To prevent noise from affecting the internal circuits of RL78 products through the capacitor connected to the REGC pin, it is recommended to strengthen the power supply by adding bypass capacitors near the device. 
If noise is applied to the GND side, it may be transmitted to the internal circuits, so taking these measures can be effective in reducing its impact.
The voltage applied to the REGC pin is crucial for the internal circuits of RL78 products. 
We would like to inform you that inserting a resistor between the REGC pin and the capacitor can cause the voltage supplied to the internal circuit of the RL78 product to become unstable, potentially impacting the device's performance. Therefore, we do not recommend inserting a resistor for stable operation of RL78 products.
However, if you require resistor insertion for some reason, please ensure that the following criteria are met and assess whether resistor insertion is acceptable or not.
Caution:
The voltage applied to the REGC pin (regulator output voltage) varies depending on the RL78 microcontroller and flash operation mode.
For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
Remark:
To prevent noise from affecting the internal circuits of RL78 products through the capacitor connected to the REGC pin, it is recommended to strengthen the power supply by adding bypass capacitors near the device. 
If noise is applied to the GND side, it may be transmitted to the internal circuits, so taking these measures can be effective in reducing its impact.
Suitable Products
RL78 Family

",['data/categories/rl78_family/others/5730b1afab0205f7a297ca241eae09f1/images/cbd80ea6cb946652c96b61d100d15ca1.png'],[],['|  |\n|  |\n| RL78 Family |'],"{'title': 'Noise countermeasures to the REGC pin', 'url': 'https://en-support.renesas.com/knowledgeBase/20916011', 'last_updated': '2023-11-05', 'extracted_at': '2025-03-09T00:01:32.575371'}","Question What are the concerns with inserting a resistor between the REGC pin and the capacitor? Answer The voltage applied to the REGC pin is crucial for the internal circuits of RL78 products. We would like to inform you that inserting a resistor between the REGC pin and the capacitor can cause the voltage supplied to the internal circuit of the RL78 product to become unstable, potentially impacting the device's performance. Therefore, we do not recommend inserting a resistor for stable operation of RL78 products. However, if you require resistor insertion for some reason, please ensure that the following criteria are met and assess whether resistor insertion is acceptable or not. Select a resistor with a resistance value of 50  or less, and as small a value as possible. Voltage fluctuations on the REGC pin should always be within  0.1 V. Caution The voltage applied to the REGC pin (regulator output voltage) varies depending on the RL78 microcontroller and flash operation mode. For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product. Example of regulator output voltage RL78/G13 LS (Low-speed main) mode, LV (Low-voltage main) mode 1.8V HS (high speed main) mode 2.1V RL78/G23 1.5V Remark To prevent noise from affecting the internal circuits of RL78 products through the capacitor connected to the REGC pin, it is recommended to strengthen the power supply by adding bypass capacitors near the device. If noise is applied to the GND side, it may be transmitted to the internal circuits, so taking these measures can be effective in reducing its impact. Suitable Products RL78 Family ",
07ef99b5d7a7eaabf982c5966ea3dade,"Question:
I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is +-3% for the grade K (up to 125C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator.
Answer:
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
This is available on the document section of the product landing page.
  This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
Suitable Products
RL78
Question:
I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is +-3% for the grade K (up to 125C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator.
Answer:
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
This is available on the document section of the product landing page.
  This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
Suitable Products
RL78
I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is +-3% for the grade K (up to 125C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator.
I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is +-3% for the grade K (up to 125C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator.
I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is +-3% for the grade K (up to 125C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator.
Answer:
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
This is available on the document section of the product landing page.
  This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
Suitable Products
RL78
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
This is available on the document section of the product landing page.
  This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
Please check the following application: [RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer | Renesas|https://www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer].
This is available on the document section of the product landing page.
This is available on the document section of the product landing page.
This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
This should show the variation across the temperature range.
These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.
Suitable Products
RL78",['data/categories/rl78_family/electrical_characteristics/07ef99b5d7a7eaabf982c5966ea3dade/images/6b82dcbba8fc503dfae2e2b7964c843e.png'],[],['|  |\n|  |\n| RL78 |'],"{'title': 'RL78 F13/14/15 electrical characteristics', 'url': 'https://en-support.renesas.com/knowledgeBase/21671335', 'last_updated': None, 'extracted_at': '2025-03-08T23:58:33.182333'}","Question I am using RL78 F13 family device I would like to ask about the high-speed on-chip oscillator accuracy. The datasheet value is -3 for the grade K (up to 125C). I would like to know a graph with the dependence of the temperature and accuracy of the oscillator. Answer Please check the following application RL78/F13/F14/F15 Electrical Characteristics Reference Value Quick Viewer  Renesashttps//www.renesas.com/us/en/document/oth/rl78f13f14f15-electrical-characteristics-reference-value-quick-viewer. This is available on the document section of the product landing page. This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached. Suitable Products RL78 This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached. This should show the variation across the temperature range. These are typical values and all the samples are not guaranteed to be in the range in the graph. Additionally as this is typical temperature behavior, max limit the datasheet values should be used for design even if the limits will normally not be reached.",
99247d54bf98c2ad7d8d7c4620385a29,"Question:
Is there any characteristics about power supply voltage rising slope?
Is there any characteristics about power supply voltage rising slope?
Answer:
Please refer to the ""Power supply voltage rising slope characteristics"" section in the ""ELECTRICAL SPECIFICATIONS"" section of the RL78 User's Manual Hardware of each product.
The RL78 family has a built-in regulator for operating the device with a constant voltage. To obtain a stable regulator output voltage, power supply voltage rising slope spec of MAX. 54 V/ms is specified.
If the spec of power supply voltage rising slope is satisfied, there will be no negative effect on the device even if the supply voltage rises slowly. However, please maintain the reset state by using a voltage detector or external reset until VDD reaches within the operating voltage range shown in the ""AC Characteristics"" chapter of the ""ELECTRICAL SPECIFICATIONS"" section.
If the spec of power supply voltage rising slope is not satisfied, it may cause device malfunction or degradation. However, the slope until the VDD becomes the specified regulator output voltage at power-on does not matter. If the supply voltage meets the spec of power supply voltage rising slope when above the specified regulator output voltage, there will be no negative effect on the device.
Note: The regulator output voltage varies depending on the RL78 microcontroller and flash operation mode.
           For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
RL78/G13
LS (Low-speed main) mode, LV (Low-voltage main) mode: 1.8V
HS (high speed main) mode: 2.1V
RL78/G23
1.5V
Suitable Products
RL78 Family
Please refer to the ""Power supply voltage rising slope characteristics"" section in the ""ELECTRICAL SPECIFICATIONS"" section of the RL78 User's Manual Hardware of each product.
The RL78 family has a built-in regulator for operating the device with a constant voltage. To obtain a stable regulator output voltage, power supply voltage rising slope spec of MAX. 54 V/ms is specified.
If the spec of power supply voltage rising slope is satisfied, there will be no negative effect on the device even if the supply voltage rises slowly. However, please maintain the reset state by using a voltage detector or external reset until VDD reaches within the operating voltage range shown in the ""AC Characteristics"" chapter of the ""ELECTRICAL SPECIFICATIONS"" section.
If the spec of power supply voltage rising slope is not satisfied, it may cause device malfunction or degradation. However, the slope until the VDD becomes the specified regulator output voltage at power-on does not matter. If the supply voltage meets the spec of power supply voltage rising slope when above the specified regulator output voltage, there will be no negative effect on the device.
Note: The regulator output voltage varies depending on the RL78 microcontroller and flash operation mode.
           For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
RL78/G13
LS (Low-speed main) mode, LV (Low-voltage main) mode: 1.8V
HS (high speed main) mode: 2.1V
RL78/G23
1.5V
Please refer to the ""Power supply voltage rising slope characteristics"" section in the ""ELECTRICAL SPECIFICATIONS"" section of the RL78 User's Manual Hardware of each product.
The RL78 family has a built-in regulator for operating the device with a constant voltage. To obtain a stable regulator output voltage, power supply voltage rising slope spec of MAX. 54 V/ms is specified.
If the spec of power supply voltage rising slope is satisfied, there will be no negative effect on the device even if the supply voltage rises slowly. However, please maintain the reset state by using a voltage detector or external reset until VDD reaches within the operating voltage range shown in the ""AC Characteristics"" chapter of the ""ELECTRICAL SPECIFICATIONS"" section.
If the spec of power supply voltage rising slope is not satisfied, it may cause device malfunction or degradation. However, the slope until the VDD becomes the specified regulator output voltage at power-on does not matter. If the supply voltage meets the spec of power supply voltage rising slope when above the specified regulator output voltage, there will be no negative effect on the device.
Note: The regulator output voltage varies depending on the RL78 microcontroller and flash operation mode.
           For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product.
Example of regulator output voltage:
Suitable Products
RL78 Family
Go to Japanese
Go to Japanese",['data/categories/rl78_family/electrical_characteristics/99247d54bf98c2ad7d8d7c4620385a29/images/621e0782d187d26c9ad1abfd5f0b406d.png'],[],['|  |\n|  |\n| RL78 Family |'],"{'title': 'About power supply voltage rising slope', 'url': 'https://en-support.renesas.com/knowledgeBase/20282330', 'last_updated': '2023-11-05', 'extracted_at': '2025-03-08T23:58:36.166277'}","Question Is there any characteristics about power supply voltage rising slope? Answer Please refer to the ""Power supply voltage rising slope characteristics"" section in the ""ELECTRICAL SPECIFICATIONS"" section of the RL78 User's Manual Hardware of each product. The RL78 family has a built-in regulator for operating the device with a constant voltage. To obtain a stable regulator output voltage, power supply voltage rising slope spec of MAX. 54 V/ms is specified. If the spec of power supply voltage rising slope is satisfied, there will be no negative effect on the device even if the supply voltage rises slowly. However, please maintain the reset state by using a voltage detector or external reset until VDD reaches within the operating voltage range shown in the ""AC Characteristics"" chapter of the ""ELECTRICAL SPECIFICATIONS"" section. If the spec of power supply voltage rising slope is not satisfied, it may cause device malfunction or degradation. However, the slope until the VDD becomes the specified regulator output voltage at power-on does not matter. If the supply voltage meets the spec of power supply voltage rising slope when above the specified regulator output voltage, there will be no negative effect on the device. Note The regulator output voltage varies depending on the RL78 microcontroller and flash operation mode. For the regulator output voltage, please refer to the ""Regulator"" section of the RL78 User's Manual Hardware of each product. Example of regulator output voltage RL78/G13 LS (Low-speed main) mode, LV (Low-voltage main) mode 1.8V HS (high speed main) mode 2.1V RL78/G23 1.5V Suitable Products RL78 Family Go to Japanese",
e33237919facfaf9a388fa69e3bb087a,"Question:
How is touch development performed with the RL78 microcontroller?
Also, please tell me about tuning and parameter adjustment.
Answer:
We offer QE for Capacitive Touch as a touch development support tool.
QE for Capacitive Touch can be used to perform the initial setting and sensitivity adjustment of the touch interface required for touch development.
QE for Capacitive Touch is available as a plug-in used in the e2 studio integrated development environment and as a standalone version that operates independently. It can be used in the e2 studio Renesas Electronics development environment or in CS+.
Figure: QE for Capacitive Touch development screen
When using e2 studio for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-qe-and-sis-develop-capacitive-touch-applications?r=1170071
The above setting methods are also explained in a video.
https://www.renesas.com/video/qe-capacitive-touch-tutorial-settings-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-tuning-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-serial-monitoring-rl78
When using CS+ for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-standalone-version-qe-develop-capacitive-touch-applications-rev100?r=1170071
Refer to the following application note for information on parameters used when monitoring touch functionality in QE for Capacitive Touch.
https://www.renesas.com/document/apn/rl78-family-touch-module-software-integration-system?r=1521766
Click here to install e2 studio:
https://www.renesas.com/software-tool/e2studio-information-rl78-family
Click here to install CS+:
https://www.renesas.com/software-tool/cs
*When using CS+, please also install Smart Configurator:
https://www.renesas.com/software-tool/rl78-smart-configurator#overview
Click here to install QE for Capacitive Touch:
https://www.renesas.com/software-tool/qe-capacitive-touch-development-assistance-tool-capacitive-touch-sensors#download
Suitable Products
RL78/G22, RL78/G23
How is touch development performed with the RL78 microcontroller?
Also, please tell me about tuning and parameter adjustment.
How is touch development performed with the RL78 microcontroller?
Also, please tell me about tuning and parameter adjustment.
Answer:
We offer QE for Capacitive Touch as a touch development support tool.
QE for Capacitive Touch can be used to perform the initial setting and sensitivity adjustment of the touch interface required for touch development.
QE for Capacitive Touch is available as a plug-in used in the e2 studio integrated development environment and as a standalone version that operates independently. It can be used in the e2 studio Renesas Electronics development environment or in CS+.
Figure: QE for Capacitive Touch development screen
When using e2 studio for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-qe-and-sis-develop-capacitive-touch-applications?r=1170071
The above setting methods are also explained in a video.
https://www.renesas.com/video/qe-capacitive-touch-tutorial-settings-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-tuning-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-serial-monitoring-rl78
When using CS+ for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-standalone-version-qe-develop-capacitive-touch-applications-rev100?r=1170071
Refer to the following application note for information on parameters used when monitoring touch functionality in QE for Capacitive Touch.
https://www.renesas.com/document/apn/rl78-family-touch-module-software-integration-system?r=1521766
Click here to install e2 studio:
https://www.renesas.com/software-tool/e2studio-information-rl78-family
Click here to install CS+:
https://www.renesas.com/software-tool/cs
*When using CS+, please also install Smart Configurator:
https://www.renesas.com/software-tool/rl78-smart-configurator#overview
Click here to install QE for Capacitive Touch:
https://www.renesas.com/software-tool/qe-capacitive-touch-development-assistance-tool-capacitive-touch-sensors#download
Suitable Products
RL78/G22, RL78/G23
We offer QE for Capacitive Touch as a touch development support tool.
QE for Capacitive Touch can be used to perform the initial setting and sensitivity adjustment of the touch interface required for touch development.
QE for Capacitive Touch is available as a plug-in used in the e2 studio integrated development environment and as a standalone version that operates independently. It can be used in the e2 studio Renesas Electronics development environment or in CS+.
Figure: QE for Capacitive Touch development screen
When using e2 studio for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-qe-and-sis-develop-capacitive-touch-applications?r=1170071
The above setting methods are also explained in a video.
https://www.renesas.com/video/qe-capacitive-touch-tutorial-settings-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-tuning-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-serial-monitoring-rl78
When using CS+ for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-standalone-version-qe-develop-capacitive-touch-applications-rev100?r=1170071
Refer to the following application note for information on parameters used when monitoring touch functionality in QE for Capacitive Touch.
https://www.renesas.com/document/apn/rl78-family-touch-module-software-integration-system?r=1521766
Click here to install e2 studio:
https://www.renesas.com/software-tool/e2studio-information-rl78-family
Click here to install CS+:
https://www.renesas.com/software-tool/cs
*When using CS+, please also install Smart Configurator:
https://www.renesas.com/software-tool/rl78-smart-configurator#overview
Click here to install QE for Capacitive Touch:
https://www.renesas.com/software-tool/qe-capacitive-touch-development-assistance-tool-capacitive-touch-sensors#download
We offer QE for Capacitive Touch as a touch development support tool.
QE for Capacitive Touch can be used to perform the initial setting and sensitivity adjustment of the touch interface required for touch development.
QE for Capacitive Touch is available as a plug-in used in the e2 studio integrated development environment and as a standalone version that operates independently. It can be used in the e2 studio Renesas Electronics development environment or in CS+.
Figure: QE for Capacitive Touch development screen
When using e2 studio for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-qe-and-sis-develop-capacitive-touch-applications?r=1170071
The above setting methods are also explained in a video.
https://www.renesas.com/video/qe-capacitive-touch-tutorial-settings-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-tuning-rl78
https://www.renesas.com/video/qe-capacitive-touch-tutorial-serial-monitoring-rl78
When using CS+ for development, please refer to this document.
https://www.renesas.com/document/apn/rl78-family-using-standalone-version-qe-develop-capacitive-touch-applications-rev100?r=1170071
Refer to the following application note for information on parameters used when monitoring touch functionality in QE for Capacitive Touch.
https://www.renesas.com/document/apn/rl78-family-touch-module-software-integration-system?r=1521766
Click here to install e2 studio:
https://www.renesas.com/software-tool/e2studio-information-rl78-family
Click here to install CS+:
https://www.renesas.com/software-tool/cs
*When using CS+, please also install Smart Configurator:
https://www.renesas.com/software-tool/rl78-smart-configurator#overview
Click here to install QE for Capacitive Touch:
https://www.renesas.com/software-tool/qe-capacitive-touch-development-assistance-tool-capacitive-touch-sensors#download
Suitable Products
RL78/G22, RL78/G23
 

","['data/categories/rl78_family/capacitive_touch/e33237919facfaf9a388fa69e3bb087a/images/c635af90f3a2a9ef29a16d1c45b5b9b4.png', 'data/categories/rl78_family/capacitive_touch/e33237919facfaf9a388fa69e3bb087a/images/8487d97fd42112e2f1e8e27800637883.png']",[],"['|  |\n|  |\n| RL78/G22, RL78/G23 |']","{'title': 'Touch development with the RL78 microcontroller', 'url': 'https://en-support.renesas.com/knowledgeBase/20824902', 'last_updated': None, 'extracted_at': '2025-03-08T23:57:07.644181'}","Question How is touch development performed with the RL78 microcontroller? Also, please tell me about tuning and parameter adjustment. Answer We offer QE for Capacitive Touch as a touch development support tool. QE for Capacitive Touch can be used to perform the initial setting and sensitivity adjustment of the touch interface required for touch development. QE for Capacitive Touch is available as a plug-in used in the e2 studio integrated development environment and as a standalone version that operates independently. It can be used in the e2 studio Renesas Electronics development environment or in CS. Figure QE for Capacitive Touch development screen When using e2 studio for development, please refer to this document. https//www.renesas.com/document/apn/rl78-family-using-qe-and-sis-develop-capacitive-touch-applications?r1170071 The above setting methods are also explained in a video. https//www.renesas.com/video/qe-capacitive-touch-tutorial-settings-rl78 https//www.renesas.com/video/qe-capacitive-touch-tutorial-tuning-rl78 https//www.renesas.com/video/qe-capacitive-touch-tutorial-serial-monitoring-rl78 When using CS for development, please refer to this document. https//www.renesas.com/document/apn/rl78-family-using-standalone-version-qe-develop-capacitive-touch-applications-rev100?r1170071 Refer to the following application note for information on parameters used when monitoring touch functionality in QE for Capacitive Touch. https//www.renesas.com/document/apn/rl78-family-touch-module-software-integration-system?r1521766 Click here to install e2 studio https//www.renesas.com/software-tool/e2studio-information-rl78-family Click here to install CS https//www.renesas.com/software-tool/cs When using CS, please also install Smart Configurator https//www.renesas.com/software-tool/rl78-smart-configuratoroverview Click here to install QE for Capacitive Touch https//www.renesas.com/software-tool/qe-capacitive-touch-development-assistance-tool-capacitive-touch-sensorsdownload Suitable Products RL78/G22, RL78/G23    ",
33114193511a8fc78428a290c4a4e122,"Question:
How can we adjust the sensitivity?
Answer:
Button sensitivity adjustment uses QE for Capacitive Touch. The sensitivity adjustment method is as follows.
The method using monitoring function of QE for Capacitive Touch
Follow the tutorial from the ""CapTouch Workflow (QE)"" of QE for Capacitive Touch.

Real-time change method using monitoring function of QE for Capacitive Touch
Display the Cap Touch parameter list of QE for Capacitive Touch and adjust it by the following steps.

Select the touch I/F corresponding to the button you want to adjust.
Click [Enable Monitoring] icon to start monitoring. When monitoring is enabled, the CapTouch parameter item is displayed.
Click [Write Value to the Target Board] to enable.
Change the value of [Touch Threshold].
Repeat steps 4 to adjust the sensitivity. After completing the sensitivity adjustment, reflect the adjustment result in the source code by the following steps.
Click [Output Parameter Files] to generate the parameter file.
Build the project using the IDE (e2 studio as an example).
Write the program to the MCU using the IDE (e2 studio as an example).

How to view the CapTouch Parameter List screen is as follows.
How to change the code manually
It can be adjusted by changing member variables of structure variable g_qe_touch_button_cfg_config01 to 03. The variables to change are:
 threshold : Touch detection threshold
Reference Application Notes:
RL78/G22 Capacitive Touch Evaluation System Sample Code (R01AN6803)
RL78 Family Using QE and SIS to Develop Capacitive Touch Applications (R01AN5512)
Suitable Products
RL78/G23, RL78/G22, RL78/G16
How can we adjust the sensitivity?
Answer:
Button sensitivity adjustment uses QE for Capacitive Touch. The sensitivity adjustment method is as follows.
The method using monitoring function of QE for Capacitive Touch
Follow the tutorial from the ""CapTouch Workflow (QE)"" of QE for Capacitive Touch.

Real-time change method using monitoring function of QE for Capacitive Touch
Display the Cap Touch parameter list of QE for Capacitive Touch and adjust it by the following steps.

Select the touch I/F corresponding to the button you want to adjust.
Click [Enable Monitoring] icon to start monitoring. When monitoring is enabled, the CapTouch parameter item is displayed.
Click [Write Value to the Target Board] to enable.
Change the value of [Touch Threshold].
Repeat steps 4 to adjust the sensitivity. After completing the sensitivity adjustment, reflect the adjustment result in the source code by the following steps.
Click [Output Parameter Files] to generate the parameter file.
Build the project using the IDE (e2 studio as an example).
Write the program to the MCU using the IDE (e2 studio as an example).

How to view the CapTouch Parameter List screen is as follows.
How to change the code manually
It can be adjusted by changing member variables of structure variable g_qe_touch_button_cfg_config01 to 03. The variables to change are:
 threshold : Touch detection threshold
Reference Application Notes:
RL78/G22 Capacitive Touch Evaluation System Sample Code (R01AN6803)
RL78 Family Using QE and SIS to Develop Capacitive Touch Applications (R01AN5512)
Suitable Products
RL78/G23, RL78/G22, RL78/G16
Button sensitivity adjustment uses QE for Capacitive Touch. The sensitivity adjustment method is as follows.
The method using monitoring function of QE for Capacitive Touch
Follow the tutorial from the ""CapTouch Workflow (QE)"" of QE for Capacitive Touch.

Real-time change method using monitoring function of QE for Capacitive Touch
Display the Cap Touch parameter list of QE for Capacitive Touch and adjust it by the following steps.

Select the touch I/F corresponding to the button you want to adjust.
Click [Enable Monitoring] icon to start monitoring. When monitoring is enabled, the CapTouch parameter item is displayed.
Click [Write Value to the Target Board] to enable.
Change the value of [Touch Threshold].
Repeat steps 4 to adjust the sensitivity. After completing the sensitivity adjustment, reflect the adjustment result in the source code by the following steps.
Click [Output Parameter Files] to generate the parameter file.
Build the project using the IDE (e2 studio as an example).
Write the program to the MCU using the IDE (e2 studio as an example).

How to view the CapTouch Parameter List screen is as follows.
How to change the code manually
It can be adjusted by changing member variables of structure variable g_qe_touch_button_cfg_config01 to 03. The variables to change are:
 threshold : Touch detection threshold
Reference Application Notes:
RL78/G22 Capacitive Touch Evaluation System Sample Code (R01AN6803)
RL78 Family Using QE and SIS to Develop Capacitive Touch Applications (R01AN5512)
Button sensitivity adjustment uses QE for Capacitive Touch. The sensitivity adjustment method is as follows.
Reference Application Notes:
RL78/G22 Capacitive Touch Evaluation System Sample Code (R01AN6803)
RL78 Family Using QE and SIS to Develop Capacitive Touch Applications (R01AN5512)
Suitable Products
RL78/G23, RL78/G22, RL78/G16
 

","['data/categories/rl78_family/capacitive_touch/33114193511a8fc78428a290c4a4e122/images/51cb533a6c1eb00f1d5c0c94dcdb85f9.png', 'data/categories/rl78_family/capacitive_touch/33114193511a8fc78428a290c4a4e122/images/1a10bc17fd6835bb8ad19243096badd6.png']",[],"['|  |\n|  |\n| RL78/G23, RL78/G22, RL78/G16 |']","{'title': 'How to adjust sensitivity', 'url': 'https://en-support.renesas.com/knowledgeBase/20977341', 'last_updated': None, 'extracted_at': '2025-03-08T23:56:53.027692'}","Question How can we adjust the sensitivity? Answer Button sensitivity adjustment uses QE for Capacitive Touch. The sensitivity adjustment method is as follows. The method using monitoring function of QE for Capacitive Touch Follow the tutorial from the ""CapTouch Workflow (QE)"" of QE for Capacitive Touch. Real-time change method using monitoring function of QE for Capacitive Touch Display the Cap Touch parameter list of QE for Capacitive Touch and adjust it by the following steps. Select the touch I/F corresponding to the button you want to adjust. Click Enable Monitoring icon to start monitoring. When monitoring is enabled, the CapTouch parameter item is displayed. Click Write Value to the Target Board to enable. Change the value of Touch Threshold. Repeat steps 4 to adjust the sensitivity. After completing the sensitivity adjustment, reflect the adjustment result in the source code by the following steps. Click Output Parameter Files to generate the parameter file. Build the project using the IDE (e2 studio as an example). Write the program to the MCU using the IDE (e2 studio as an example). How to view the CapTouch Parameter List screen is as follows. How to change the code manually It can be adjusted by changing member variables of structure variable gqetouchbuttoncfgconfig01 to 03. The variables to change are  threshold  Touch detection threshold Reference Application Notes RL78/G22 Capacitive Touch Evaluation System Sample Code (R01AN6803) RL78 Family Using QE and SIS to Develop Capacitive Touch Applications (R01AN5512) Suitable Products RL78/G23, RL78/G22, RL78/G16    ",
29966c0f65f5233670864e6f7df25742,"Question:
Which RL78 MCUs have touch functionality?
Answer:
RL78/G23, RL78/G22, and RL78/G16 have.
Please refer to the figure below regarding the lineup by memory and pin count.
Figure 1: RL78 Touch MCU Lineup
Also, please refer to the table below for the differences in each touch function.
Figure 2: Comparison between RL78/G23, RL78/G22 and RL78/G16
Suitable Products
RL78/G23, RL78/G22, RL78/G16
Which RL78 MCUs have touch functionality?
Which RL78 MCUs have touch functionality?
Answer:
RL78/G23, RL78/G22, and RL78/G16 have.
Please refer to the figure below regarding the lineup by memory and pin count.
Figure 1: RL78 Touch MCU Lineup
Also, please refer to the table below for the differences in each touch function.
Figure 2: Comparison between RL78/G23, RL78/G22 and RL78/G16
Suitable Products
RL78/G23, RL78/G22, RL78/G16
RL78/G23, RL78/G22, and RL78/G16 have.
Please refer to the figure below regarding the lineup by memory and pin count.
Figure 1: RL78 Touch MCU Lineup
Also, please refer to the table below for the differences in each touch function.
Figure 2: Comparison between RL78/G23, RL78/G22 and RL78/G16
RL78/G23, RL78/G22, and RL78/G16 have.
Please refer to the figure below regarding the lineup by memory and pin count.
Figure 1: RL78 Touch MCU Lineup
Also, please refer to the table below for the differences in each touch function.
Figure 2: Comparison between RL78/G23, RL78/G22 and RL78/G16
Suitable Products
RL78/G23, RL78/G22, RL78/G16
 

","['data/categories/rl78_family/capacitive_touch/29966c0f65f5233670864e6f7df25742/images/4034592102df7fcef09a958280e20553.png', 'data/categories/rl78_family/capacitive_touch/29966c0f65f5233670864e6f7df25742/images/99a2f01850a46470647e4e3a0246ce4b.png']",[],"['|  |\n|  |\n| RL78/G23, RL78/G22, RL78/G16 |']","{'title': 'RL78 Touch MCU', 'url': 'https://en-support.renesas.com/knowledgeBase/20977336', 'last_updated': None, 'extracted_at': '2025-03-08T23:56:58.837534'}","Question Which RL78 MCUs have touch functionality? Answer RL78/G23, RL78/G22, and RL78/G16 have. Please refer to the figure below regarding the lineup by memory and pin count. Figure 1 RL78 Touch MCU Lineup Also, please refer to the table below for the differences in each touch function. Figure 2 Comparison between RL78/G23, RL78/G22 and RL78/G16 Suitable Products RL78/G23, RL78/G22, RL78/G16    ",
d3418a81006d6c7b069e207077ce3cda,"Question:
Are there any precautions when using the CC-RL free evaluation version (V1.12.00 or later) for touch development?
Answer:
Serial tuning cannot be performed if you are using RL78 family and CC-RL compiler (V1.12.00 or later) and the optimization level of CC-RL compiler is set to ""-Olite"".
To perform serial tuning, set the CC-RL compiler optimization level to ""-Onothing"".
For details, please refer to the following document on p. 38.
RL78 Family Using QE (standalone ver.) to Develop Touch Applications for FPB board
Please refer to the following guide for the details specifications of the optimization level option of the CC-RL free evaluation version (V1.12.00).
[Notification] C Compiler Package for RL78 Family (CC-RL) Changes in Specifications of Free Evaluation Edition
Suitable Products
RL78/G23, RL78/G22, RL78/G16
Are there any precautions when using the CC-RL free evaluation version (V1.12.00 or later) for touch development?
Are there any precautions when using the CC-RL free evaluation version (V1.12.00 or later) for touch development?
Answer:
Serial tuning cannot be performed if you are using RL78 family and CC-RL compiler (V1.12.00 or later) and the optimization level of CC-RL compiler is set to ""-Olite"".
To perform serial tuning, set the CC-RL compiler optimization level to ""-Onothing"".
For details, please refer to the following document on p. 38.
RL78 Family Using QE (standalone ver.) to Develop Touch Applications for FPB board
Please refer to the following guide for the details specifications of the optimization level option of the CC-RL free evaluation version (V1.12.00).
[Notification] C Compiler Package for RL78 Family (CC-RL) Changes in Specifications of Free Evaluation Edition
Suitable Products
RL78/G23, RL78/G22, RL78/G16
Serial tuning cannot be performed if you are using RL78 family and CC-RL compiler (V1.12.00 or later) and the optimization level of CC-RL compiler is set to ""-Olite"".
To perform serial tuning, set the CC-RL compiler optimization level to ""-Onothing"".
For details, please refer to the following document on p. 38.
RL78 Family Using QE (standalone ver.) to Develop Touch Applications for FPB board
Please refer to the following guide for the details specifications of the optimization level option of the CC-RL free evaluation version (V1.12.00).
[Notification] C Compiler Package for RL78 Family (CC-RL) Changes in Specifications of Free Evaluation Edition
Serial tuning cannot be performed if you are using RL78 family and CC-RL compiler (V1.12.00 or later) and the optimization level of CC-RL compiler is set to ""-Olite"".
To perform serial tuning, set the CC-RL compiler optimization level to ""-Onothing"".
For details, please refer to the following document on p. 38.
RL78 Family Using QE (standalone ver.) to Develop Touch Applications for FPB board
Please refer to the following guide for the details specifications of the optimization level option of the CC-RL free evaluation version (V1.12.00).
[Notification] C Compiler Package for RL78 Family (CC-RL) Changes in Specifications of Free Evaluation Edition
Suitable Products
RL78/G23, RL78/G22, RL78/G16
 

",['data/categories/rl78_family/capacitive_touch/d3418a81006d6c7b069e207077ce3cda/images/74bdbb7fce363641e345f41c2241f84c.png'],[],"['|  |\n|  |\n| RL78/G23, RL78/G22, RL78/G16 |']","{'title': 'Notes for touch development using CC-RL free evaluation version (V1.12.00 or later) (Optimization option)', 'url': 'https://en-support.renesas.com/knowledgeBase/20977340', 'last_updated': None, 'extracted_at': '2025-03-08T23:56:55.835312'}","Question Are there any precautions when using the CC-RL free evaluation version (V1.12.00 or later) for touch development? Answer Serial tuning cannot be performed if you are using RL78 family and CC-RL compiler (V1.12.00 or later) and the optimization level of CC-RL compiler is set to ""-Olite"". To perform serial tuning, set the CC-RL compiler optimization level to ""-Onothing"". For details, please refer to the following document on p. 38. RL78 Family Using QE (standalone ver.) to Develop Touch Applications for FPB board Please refer to the following guide for the details specifications of the optimization level option of the CC-RL free evaluation version (V1.12.00). Notification C Compiler Package for RL78 Family (CC-RL) Changes in Specifications of Free Evaluation Edition Suitable Products RL78/G23, RL78/G22, RL78/G16    ",
0c38fc0eac324c42940a0c8505a84755,"Question:
How can I download a SIS module from the Renesas website (not from e studio or CS+) and use it?
Answer:
See the List of SIS Modules and download the module you need from Renesas Web site.
Unzip the downloaded file (*.zip), and then copy the contents (*.xml, *.zip, and *.mdf, if any) to the SIS module download folder.
The following are the default download folders.
e studio :  %USERPROFILE%\.eclipse\com.renesas.platform_download\RL78_Modules\GenericModules
CS+ : %USERPROFILE%\.eclipse\com.renesas.smc.rcp.product_download\RL78_Modules\GenericModules
Copying and pasting the strings to the Windows File Explorer address bar will open the folder.
  If the folder cannot be found or has been moved, find the folder as follows.
e studio :
    Select [Window], [Preferences], [Renesas], and then check [Module Download].
CS+ :
    Start Smart Configurator, select [Window], [Preferences], and then check [Module Download].

Note: The [GenericModules] folder is created when the first Smart Configurator project is made. If the [GenericModules] folder does not exist, create the folder, and then copy the files to it.
E.g., e studio [Preferences]:

Example: e studio [GenericModules] folder with copied files. (There might be no [Downloaded] folder, but this is not a problem. The contents are very similar in CS+.)

After placing the files in the destination folder, start Smart Configurator, and then click the [Add component] button as shown below.


Make sure that the added SIS module is available in the dialog box below.

  Suitable Products
RL78/G23, RL78/G22, RL78/G16
How can I download a SIS module from the Renesas website (not from e studio or CS+) and use it?
How can I download a SIS module from the Renesas website (not from e studio or CS+) and use it?
Answer:
See the List of SIS Modules and download the module you need from Renesas Web site.
Unzip the downloaded file (*.zip), and then copy the contents (*.xml, *.zip, and *.mdf, if any) to the SIS module download folder.
The following are the default download folders.
e studio :  %USERPROFILE%\.eclipse\com.renesas.platform_download\RL78_Modules\GenericModules
CS+ : %USERPROFILE%\.eclipse\com.renesas.smc.rcp.product_download\RL78_Modules\GenericModules
Copying and pasting the strings to the Windows File Explorer address bar will open the folder.
  If the folder cannot be found or has been moved, find the folder as follows.
e studio :
    Select [Window], [Preferences], [Renesas], and then check [Module Download].
CS+ :
    Start Smart Configurator, select [Window], [Preferences], and then check [Module Download].

Note: The [GenericModules] folder is created when the first Smart Configurator project is made. If the [GenericModules] folder does not exist, create the folder, and then copy the files to it.
E.g., e studio [Preferences]:

Example: e studio [GenericModules] folder with copied files. (There might be no [Downloaded] folder, but this is not a problem. The contents are very similar in CS+.)

After placing the files in the destination folder, start Smart Configurator, and then click the [Add component] button as shown below.


Make sure that the added SIS module is available in the dialog box below.

  Suitable Products
RL78/G23, RL78/G22, RL78/G16
See the List of SIS Modules and download the module you need from Renesas Web site.
Unzip the downloaded file (*.zip), and then copy the contents (*.xml, *.zip, and *.mdf, if any) to the SIS module download folder.
The following are the default download folders.
e studio :  %USERPROFILE%\.eclipse\com.renesas.platform_download\RL78_Modules\GenericModules
CS+ : %USERPROFILE%\.eclipse\com.renesas.smc.rcp.product_download\RL78_Modules\GenericModules
Copying and pasting the strings to the Windows File Explorer address bar will open the folder.
  If the folder cannot be found or has been moved, find the folder as follows.
e studio :
    Select [Window], [Preferences], [Renesas], and then check [Module Download].
CS+ :
    Start Smart Configurator, select [Window], [Preferences], and then check [Module Download].

Note: The [GenericModules] folder is created when the first Smart Configurator project is made. If the [GenericModules] folder does not exist, create the folder, and then copy the files to it.
E.g., e studio [Preferences]:

Example: e studio [GenericModules] folder with copied files. (There might be no [Downloaded] folder, but this is not a problem. The contents are very similar in CS+.)

After placing the files in the destination folder, start Smart Configurator, and then click the [Add component] button as shown below.


Make sure that the added SIS module is available in the dialog box below.
See the List of SIS Modules and download the module you need from Renesas Web site.
Unzip the downloaded file (*.zip), and then copy the contents (*.xml, *.zip, and *.mdf, if any) to the SIS module download folder.
The following are the default download folders.
e studio :  %USERPROFILE%\.eclipse\com.renesas.platform_download\RL78_Modules\GenericModules
CS+ : %USERPROFILE%\.eclipse\com.renesas.smc.rcp.product_download\RL78_Modules\GenericModules
Copying and pasting the strings to the Windows File Explorer address bar will open the folder.
If the folder cannot be found or has been moved, find the folder as follows.
e studio :
    Select [Window], [Preferences], [Renesas], and then check [Module Download].
CS+ :
    Start Smart Configurator, select [Window], [Preferences], and then check [Module Download].

Note: The [GenericModules] folder is created when the first Smart Configurator project is made. If the [GenericModules] folder does not exist, create the folder, and then copy the files to it.
E.g., e studio [Preferences]:
Example: e studio [GenericModules] folder with copied files. (There might be no [Downloaded] folder, but this is not a problem. The contents are very similar in CS+.)
After placing the files in the destination folder, start Smart Configurator, and then click the [Add component] button as shown below.
Make sure that the added SIS module is available in the dialog box below.
Suitable Products
RL78/G23, RL78/G22, RL78/G16
 

","['data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/5657ae0054503aae3352121bd6b666bd.png', 'data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/0ae2664d95b166195254ef5b709124f2.png', 'data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/75786d68092a2d551305023268937fc9.png', 'data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/830cc14e0f626c3ca818209cd6ae8455.png', 'data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/d8decd5ad5818eda4000213005fdbe70.png', 'data/categories/rl78_family/capacitive_touch/0c38fc0eac324c42940a0c8505a84755/images/f93c5286147373bc2c5cae866054994a.png']",[],"['|  |\n|  |\n| RL78/G23, RL78/G22, RL78/G16 |']","{'title': 'How to Download and Use a SIS Modules', 'url': 'https://en-support.renesas.com/knowledgeBase/20977342', 'last_updated': None, 'extracted_at': '2025-03-08T23:56:50.034556'}","Question How can I download a SIS module from the Renesas website (not from e studio or CS) and use it? Answer See the List of SIS Modules and download the module you need from Renesas Web site. Unzip the downloaded file (.zip), and then copy the contents (.xml, .zip, and .mdf, if any) to the SIS module download folder. The following are the default download folders. e studio  USERPROFILE.eclipsecom.renesas.platformdownloadRL78ModulesGenericModules CS  USERPROFILE.eclipsecom.renesas.smc.rcp.productdownloadRL78ModulesGenericModules Copying and pasting the strings to the Windows File Explorer address bar will open the folder. If the folder cannot be found or has been moved, find the folder as follows. e studio  Select Window, Preferences, Renesas, and then check Module Download. CS  Start Smart Configurator, select Window, Preferences, and then check Module Download. Note The GenericModules folder is created when the first Smart Configurator project is made. If the GenericModules folder does not exist, create the folder, and then copy the files to it. E.g., e studio Preferences Example e studio GenericModules folder with copied files. (There might be no Downloaded folder, but this is not a problem. The contents are very similar in CS.) After placing the files in the destination folder, start Smart Configurator, and then click the Add component button as shown below. Make sure that the added SIS module is available in the dialog box below. Suitable Products RL78/G23, RL78/G22, RL78/G16 If the folder cannot be found or has been moved, find the folder as follows. Suitable Products    ",
15e47175b2c701227c8e774332360856,"Question:
What is the difference between the RL78/G16 and other RL78 MCUs such as RL78/G15?
Answer:
RL78/G16 is RL78/G15 + capacitive touch sensor and safety functions with larger memory and pin package lineup. Also, it has pin-compatible with the RL78/G15 and RL78/G12 (20pin).
Furthermore, as well as RL78/G15, RL78/G16 supports an operating ambient temperature of up to 125C. Therefore, RL78/G16 is designed to be stable even in high-temperature environments.
Figure 1: The RL78/G16 position in RL78 Family
Figure 2: Specification comparison between RL78/G16 and existing products
Figure 3: RL78/G16 and RL78/G15 Package Lineup
The RL78/G16 has the following four major features.
RL78/G16 is optimized for 8-bit MCU applications as well as G15. Including capacitive touch sensor and safety functions make it suitable for a wide range of applications, including home appliances.
Smallest-pin package touch MCU, realizing touch functions in a small space.
Application notes and sample codes to support the acquisition of functional safety IEC60730 certification, which is mandatory for home appliances.
Enhanced built-in peripheral functions to reduce overall device cost.
Wide operating ambient temperature range to simplify the thermal design.
Figure 4: 4 Key Features of RL78/G16 MCU
Suitable Products
RL78/G16
What is the difference between the RL78/G16 and other RL78 MCUs such as RL78/G15?
What is the difference between the RL78/G16 and other RL78 MCUs such as RL78/G15?
Answer:
RL78/G16 is RL78/G15 + capacitive touch sensor and safety functions with larger memory and pin package lineup. Also, it has pin-compatible with the RL78/G15 and RL78/G12 (20pin).
Furthermore, as well as RL78/G15, RL78/G16 supports an operating ambient temperature of up to 125C. Therefore, RL78/G16 is designed to be stable even in high-temperature environments.
Figure 1: The RL78/G16 position in RL78 Family
Figure 2: Specification comparison between RL78/G16 and existing products
Figure 3: RL78/G16 and RL78/G15 Package Lineup
The RL78/G16 has the following four major features.
RL78/G16 is optimized for 8-bit MCU applications as well as G15. Including capacitive touch sensor and safety functions make it suitable for a wide range of applications, including home appliances.
Smallest-pin package touch MCU, realizing touch functions in a small space.
Application notes and sample codes to support the acquisition of functional safety IEC60730 certification, which is mandatory for home appliances.
Enhanced built-in peripheral functions to reduce overall device cost.
Wide operating ambient temperature range to simplify the thermal design.
Figure 4: 4 Key Features of RL78/G16 MCU
Suitable Products
RL78/G16
RL78/G16 is RL78/G15 + capacitive touch sensor and safety functions with larger memory and pin package lineup. Also, it has pin-compatible with the RL78/G15 and RL78/G12 (20pin).
Furthermore, as well as RL78/G15, RL78/G16 supports an operating ambient temperature of up to 125C. Therefore, RL78/G16 is designed to be stable even in high-temperature environments.
Figure 1: The RL78/G16 position in RL78 Family
Figure 2: Specification comparison between RL78/G16 and existing products
Figure 3: RL78/G16 and RL78/G15 Package Lineup
The RL78/G16 has the following four major features.
RL78/G16 is optimized for 8-bit MCU applications as well as G15. Including capacitive touch sensor and safety functions make it suitable for a wide range of applications, including home appliances.
Smallest-pin package touch MCU, realizing touch functions in a small space.
Application notes and sample codes to support the acquisition of functional safety IEC60730 certification, which is mandatory for home appliances.
Enhanced built-in peripheral functions to reduce overall device cost.
Wide operating ambient temperature range to simplify the thermal design.
Figure 4: 4 Key Features of RL78/G16 MCU
RL78/G16 is RL78/G15 + capacitive touch sensor and safety functions with larger memory and pin package lineup. Also, it has pin-compatible with the RL78/G15 and RL78/G12 (20pin).
Furthermore, as well as RL78/G15, RL78/G16 supports an operating ambient temperature of up to 125C. Therefore, RL78/G16 is designed to be stable even in high-temperature environments.
Figure 1: The RL78/G16 position in RL78 Family
Figure 2: Specification comparison between RL78/G16 and existing products
Figure 3: RL78/G16 and RL78/G15 Package Lineup
The RL78/G16 has the following four major features.
RL78/G16 is optimized for 8-bit MCU applications as well as G15. Including capacitive touch sensor and safety functions make it suitable for a wide range of applications, including home appliances.
Figure 4: 4 Key Features of RL78/G16 MCU
Suitable Products
RL78/G16
 

","['data/categories/rl78_family/rl78g16/15e47175b2c701227c8e774332360856/images/54e60126b54074c9030a138b26622f10.png', 'data/categories/rl78_family/rl78g16/15e47175b2c701227c8e774332360856/images/e1f90bcc8144750bd91e01d8c0288b83.png', 'data/categories/rl78_family/rl78g16/15e47175b2c701227c8e774332360856/images/16f27c8b1230f2183be3d4de01b6e73c.png', 'data/categories/rl78_family/rl78g16/15e47175b2c701227c8e774332360856/images/6957f4b26b7950b7c5f9e34a0dbdab0b.png']",[],['|  |\n|  |\n| RL78/G16 |'],"{'title': 'The RL78/G16 position in the RL78 family', 'url': 'https://en-support.renesas.com/knowledgeBase/20919983', 'last_updated': None, 'extracted_at': '2025-03-08T23:53:57.469859'}","Question What is the difference between the RL78/G16 and other RL78 MCUs such as RL78/G15? Answer RL78/G16 is RL78/G15  capacitive touch sensor and safety functions with larger memory and pin package lineup. Also, it has pin-compatible with the RL78/G15 and RL78/G12 (20pin). Furthermore, as well as RL78/G15, RL78/G16 supports an operating ambient temperature of up to 125C. Therefore, RL78/G16 is designed to be stable even in high-temperature environments. Figure 1 The RL78/G16 position in RL78 Family Figure 2 Specification comparison between RL78/G16 and existing products Figure 3 RL78/G16 and RL78/G15 Package Lineup The RL78/G16 has the following four major features. RL78/G16 is optimized for 8-bit MCU applications as well as G15. Including capacitive touch sensor and safety functions make it suitable for a wide range of applications, including home appliances. Smallest-pin package touch MCU, realizing touch functions in a small space. Application notes and sample codes to support the acquisition of functional safety IEC60730 certification, which is mandatory for home appliances. Enhanced built-in peripheral functions to reduce overall device cost. Wide operating ambient temperature range to simplify the thermal design. Figure 4 4 Key Features of RL78/G16 MCU Suitable Products RL78/G16    ",
c16698da0408a214bcadc398c7d4e79f,"Question:
Are there any precautions when developing touch functions on the RL78/G16?
Answer:
Tuning and monitoring functions by QE for Capacitive Touch must be executed using serial communication (UART). (They cannot be executed via the E2/E2 Lite emulator.)
Also, monitoring via serial communication (UART) cannot be executed with variable values registered in IDE functions (e2 studio: Expression View, CS+: watch-expression).
Please also refer to the table below.
  Suitable Products
RL78/G16
Are there any precautions when developing touch functions on the RL78/G16?
Are there any precautions when developing touch functions on the RL78/G16?
Answer:
Tuning and monitoring functions by QE for Capacitive Touch must be executed using serial communication (UART). (They cannot be executed via the E2/E2 Lite emulator.)
Also, monitoring via serial communication (UART) cannot be executed with variable values registered in IDE functions (e2 studio: Expression View, CS+: watch-expression).
Please also refer to the table below.
  Suitable Products
RL78/G16
Tuning and monitoring functions by QE for Capacitive Touch must be executed using serial communication (UART). (They cannot be executed via the E2/E2 Lite emulator.)
Also, monitoring via serial communication (UART) cannot be executed with variable values registered in IDE functions (e2 studio: Expression View, CS+: watch-expression).
Please also refer to the table below.
Tuning and monitoring functions by QE for Capacitive Touch must be executed using serial communication (UART). (They cannot be executed via the E2/E2 Lite emulator.)
Also, monitoring via serial communication (UART) cannot be executed with variable values registered in IDE functions (e2 studio: Expression View, CS+: watch-expression).
Please also refer to the table below.
Suitable Products
RL78/G16
 

",['data/categories/rl78_family/rl78g16/c16698da0408a214bcadc398c7d4e79f/images/6df500e8e194807dee4b1120e8ec4eeb.png'],[],['|  |\n|  |\n| RL78/G16 |'],"{'title': 'Precautions when Developing Touch Functions with the RL78/G16', 'url': 'https://en-support.renesas.com/knowledgeBase/20977337', 'last_updated': None, 'extracted_at': '2025-03-08T23:54:00.310568'}","Question Are there any precautions when developing touch functions on the RL78/G16? Answer Tuning and monitoring functions by QE for Capacitive Touch must be executed using serial communication (UART). (They cannot be executed via the E2/E2 Lite emulator.) Also, monitoring via serial communication (UART) cannot be executed with variable values registered in IDE functions (e2 studio Expression View, CS watch-expression). Please also refer to the table below. Suitable Products RL78/G16 Suitable Products    ",
d28a079bd8b7b0321819324bbe19d5ac,"Question:
I need more information about ADC module in C R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ?
CPU and peripheral clock is 24MH.
Answer:
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. 
   Figure 1: Conversion time electrical specs
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
Figure 2: Conversion clock electrical spec
  A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
Suitable Products
RL78
Question:
I need more information about ADC module in C R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ?
CPU and peripheral clock is 24MH.
Answer:
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. 
   Figure 1: Conversion time electrical specs
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
Figure 2: Conversion clock electrical spec
  A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
Suitable Products
RL78
I need more information about ADC module in C R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ?
CPU and peripheral clock is 24MH.
I need more information about ADC module in C R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ?
I need more information about ADC module in C
R5F10BGGCKFB.
Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ?
CPU and peripheral clock is 24MH.
CPU and peripheral clock is 24MH.
Answer:
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. 
   Figure 1: Conversion time electrical specs
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
Figure 2: Conversion clock electrical spec
  A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
Suitable Products
RL78
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. 
   Figure 1: Conversion time electrical specs
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
Figure 2: Conversion clock electrical spec
  A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs.
The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs.
Figure 1: Conversion time electrical specs
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz.
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. 
For 24MHz the min sample time will be a round 3us
Figure 2: Conversion clock electrical spec
A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.
Suitable Products
RL78","['data/categories/rl78_family/ad_converter/d28a079bd8b7b0321819324bbe19d5ac/images/11238e947e14beea8eeb87e2ce670825.png', 'data/categories/rl78_family/ad_converter/d28a079bd8b7b0321819324bbe19d5ac/images/7d4903223de989d3f9130dc9bd73ccaf.png']",[],['|  |\n|  |\n| RL78 |'],"{'title': 'RL78 ADC Sampling time', 'url': 'https://en-support.renesas.com/knowledgeBase/21205011', 'last_updated': None, 'extracted_at': '2025-03-08T23:56:13.605929'}","Question I need more information about ADC module in C R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ? CPU and peripheral clock is 24MH. Answer The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. Figure 1 Conversion time electrical specs Min. conversion time is given with 2.125us which results in a max sample rate of about 470KHz. But the sample rate depends also on the possible ADM0 (FR and LV bits) settings. It is not completely free configurable. For 24MHz the min sample time will be a round 3us Figure 2 Conversion clock electrical spec A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle. Suitable Products RL78 I need more information about ADC module in C R5F10BGGCKFB. Can I achieve maximum sample rate of 470MHz. What is the channel to channel delay time ? The sampling rate (min conversion time) is selectable with the ADM0 register. But there are limits which are given in the electrical specs. Figure 1 Conversion time electrical specs A channel-to-channel delay time is not existing. If a new conversion is started, a possibly running conversion is cancelled an the new one is directly started. In scan mode and sequential conversion, the next the channel is switched in next clock cycle.",
